      PROGRAM MAIN
C
C  MAIN IS THE MAIN PROGRAM FOR TCELL.
C
C  DISCUSSION:
C
C    TCELL SOLVES THE STEADY INCOMPRESSIBLE NAVIER-STOKES EQUATIONS
C    IN A 2D "T"-SHAPED REGION.
C
C    THE FLUID FLOW PROBLEM IS FORMULATED IN TERMS OF
C    PRIMITIVE VARIABLES-U,V,AND P.
C
C    U_T-LAPLACIAN U+(U.GRAD)U+GRAD P=F
C                                DIV U=0
C
C    BOUNDARY CONDITIONS:  (U,V)=(0,0) ON TOP
C                          (U,V)=0 ON LEFT,RIGHT AND BOTTOM
C
C    THIS VERSION USES FINITE ELEMENT TECHNIQUES
C    WITH PIECEWISE LINEAR FUNCTIONS ON TRIANGLES TO APPROXIMATE
C    THE PRESSURE AND QUADRATICS ON TRIANGLES FOR THE VELOCITY
C    (TAYLOR-HOOD ELEMENT),ISOPARAMETRIC ELEMENT
C
C  INPUT FILES:
C
C    FUINI.TXT CONTAINS THE INITIAL VALUES OF THE SOLUTION COEFFICIENTS.
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE,
C    DEPARTMENT OF MATHEMATICS,
C    AJOU UNIVERSITY,KOREA
C
C  LOCAL PARAMETERS:
C
C    BC_TYPE SELECTS THE BOUNDARY CONDITIONS,BY CONTROLLING THE VALUE OF ALPHA.
C    1,FOR A STEP FUNCTION,
C    2,FOR A "HAT" FUNCTION,
C    3,FOR A SINUSOID.
C
C    FILENAME IS THE NAME TO BE USED FOR THE FIRST OUTPUT FILE.
C    EACH SUBSEQUENT OUTPUT FILE CREATED BY THE PROGRAM WILL HAVE AN
C    INCREMENTED NAME.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER(NX=41)
      PARAMETER(NY=41)
      PARAMETER(MX=2*NX-1)
      PARAMETER(MY=2*NY-1)
      PARAMETER(MAXEL=2*(NX-1)*(NY-1))
      PARAMETER(MAXND=MX*MY)
      PARAMETER(MAXUN=2*MX*MY+NX*NY)
      PARAMETER(MINUN=27*NY)
      CHARACTER*20 FILENAME
      DIMENSION INDX(MAXND,2),INSC(MAXND),IPIVOT(MAXUN),NODE(MAXEL,6),
     &A(MINUN,MAXUN),AREA(MAXEL),F(MAXUN),G(MAXUN),GG(MAXUN),GP(MAXUN),
     &UOLD(MAXUN),XC(MAXND),XM(MAXEL,3),YC(MAXND),YM(MAXEL,3)
      WRITE(*,'(A)')'TCELL:'
      WRITE(*,'(A)')'FORTRAN77 VERSION'
      WRITE(*,'(A)')'SOLVE THE NAVIER STOKES FLUID FLOW'
      WRITE(*,'(A)')'EQUATIONS IN A TCELL REGION,'
      WRITE(*,'(A)')'USING FINITE ELEMENTS.'
      WRITE(*,'(A,I6)')'MAXIMUM NUMBER OF NODES=   ',MAXND
      WRITE(*,'(A,I6)')'MAXIMUM NUMBER OF ELEMENTS=',MAXEL
      IBC_TYPE=1
      FILENAME='UP000.TXT'
C
C  SET FUNCTIONS FOR THE INPUT PROFILE.
C
      IWRITE=0
C
C   INPUT
C
      XLNGTH=1.0D0
      YLNGTH=1.0D0
      REYNLD=1.0D0
      MROW1=MINUN
      NSIM=3
      NSTEPS=10
      TOLNS=1.0D-6
      TOLOPT=1.0D-06
      PI=4.0D0*DATAN(1.0D0)
C
C  2.  SETGRD CONSTRUCTS GRID,NUMBERS UNKNOWNS,CALCULATES AREAS,
C      AND POINTS FOR MIDPOINT QUADRATURE RULE
C      SETGRD SETS BANDWIDTH AND NEQN1
C
      CALL SETGRD(XC,YC,AREA,XM,YM,XLNGTH,YLNGTH,
     &    NODE,INDX,INSC,NLBAND,NBAND,
     &    NX,NY,NELEMN,NP,NNODES,NUK,NQUAD,NEQN1,
     &    IWRITE,MAXND,MAXEL)
      WRITE(*,'(A,I6)')'NUMBER OF NODES=   ',NP
      WRITE(*,'(A,I6)')'NUMBER OF ELEMENTS=',NELEMN
      WRITE(*,'(A,I6)')'LOWER BANDWIDTH=   ',NLBAND
      WRITE(*,'(A,I6)')'TOTAL BANDWIDTH=   ',NBAND
      OPEN(1,FILE='tcell.2dv',STATUS='UNKNOWN')
      WRITE(1,*)NP
      DO I=1,NP
        WRITE(1,*)XC(I),YC(I)
      ENDDO
      WRITE(1,*)NELEMN
      DO I=1,NELEMN
        WRITE(1,'(3I6)')(NODE(I,J),J=1,3)
      ENDDO
      CLOSE(1)
      NUBAND=NLBAND
      NROW1=NLBAND+NLBAND+NUBAND+1
      NCOL1=NEQN1
      NY2=NY+NY-1
      DELTAT=0.0002D0
      RDEL=1.0D0/DELTAT
      DO I=1,NEQN1
        F(I)=0.0D0
      ENDDO
C
C  INITIALIZE THE SOLUTION.
C
      CALL SOLUTION_INIT(NEQN1,UOLD)
C
C  CARRY OUT THE TIME ITERATION.
C
      NITER=10
      DO ITER=1,NITER
        IF(IBC_TYPE.EQ.1)THEN
          IF(ITER.LE.250)THEN
            ALPHA=5.0D0
          ELSE
            ALPHA=1.0D0
          ENDIF
        ELSE IF(IBC_TYPE.EQ.2)THEN
          IF(ITER.LE.250)THEN
            ALPHA=80.0D0*DBLE(ITER)*DELTAT+1.0D0
          ELSE
            ALPHA=-80.0D0*DBLE(ITER)*DELTAT+9.0D0
          ENDIF
        ELSE IF(IBC_TYPE.EQ.3)THEN
          ALPHA=2.0D0*SIN(DBLE(ITER)*0.01D0*PI)
        ENDIF
        DO I=1,NEQN1
          G(I)=F(I)
        ENDDO
        DO I=1,NEQN1
          F(I)=0.0D0
        ENDDO
        CALL NSTOKE(XC,YC,AREA,XM,YM,
     &     A,F,G,UOLD,REYNLD,TOLNS,XLNGTH,YLNGTH,
     &     NODE,INDX,INSC,IPIVOT,MROW1,
     &     NLBAND,NUBAND,NBAND,NROW1,NCOL1,
     &     NELEMN,NP,NNODES,NUK,NQUAD,NEQN1,
     &     NSTEPS,NSIM,IWRITE,MAXND,MAXEL,RDEL,ALPHA)
        DO I=1,NEQN1
          UOLD(I)=F(I)
        ENDDO
        WRITE(*,*)ITER,' OF ',NITER
      ENDDO
      OPEN(1,FILE='tcell.v2d',STATUS='UNKNOWN')
      OPEN(2,FILE='tcell.plt',STATUS='UNKNOWN')
      WRITE(2,1000)
 1000 FORMAT('TITLE="T-CELL"')
      WRITE(2,1001)
 1001 FORMAT('VARIABLES="X" "Y" "P" "U" "V"')
      WRITE(2,1002)NP,NELEMN
 1002 FORMAT('ZONE T="RESULTS" N=',I4,', E=',I4,
     &', F=FEPOINT, ET=TRIANGLE'/
     &'DT=(DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE)')
      DO IC=1,NP
        IUKU=INDX(IC,1)
        IUKV=INDX(IC,2)
        IUKP=INSC(IC)
        IF(IUKU.EQ.0)THEN
          GX=0.0D0
        ELSE IF(IUKU.EQ.-1)THEN
          GX=ALPHA*UBDRY(1,IC,XC,YC)
        ELSE
          GX=F(IUKU)
        ENDIF
        IF(IUKV.LE.0)THEN
          GY=0.0D0
        ELSE
          GY=F(IUKV)
        ENDIF
        IF(IUKP.EQ.0)THEN
          PP=0.0D0
        ELSE
          PP=F(IUKP)
        ENDIF
        G(IC)=GX
        GG(IC)=GY
        GP(IC)=PP
        WRITE(1,'(4E13.5)')XC(IC),YC(IC),GX,GY
        WRITE(2,'(5E13.5)')XC(IC),YC(IC),PP,GX,GY
      ENDDO
      CLOSE(1)
      DO I=1,NELEMN
        WRITE(2,'(3I6)')(NODE(I,J),J=1,3)
      ENDDO
      CLOSE(2)
      STOP
      END
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
C
C  DAXPY ADDS A MULTIPLE OF ONE VECTOR TO ANOTHER.
C
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA,LINPACK,3/11/78.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION DX(1),DY(1),DA
      IF(N.LE.0)RETURN
      IF(DA.EQ.0.0D0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GOTO 20
C
C    CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C    NOT EQUAL TO 1
C
      IX=1
      IY=1
      IF(INCX.LT.0)IX=(-N+1)*INCX+1
      IF(INCY.LT.0)IY=(-N+1)*INCY+1
      DO 10 I=1,N
        DY(IY)=DY(IY)+DA*DX(IX)
        IX=IX+INCX
        IY=IY+INCY
   10 CONTINUE
      RETURN
C
C   CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C   CLEAN-UP LOOP
C
   20 M=MOD(N,4)
      IF(M.EQ.0)GOTO 40
      DO 30 I=1,M
        DY(I)=DY(I)+DA*DX(I)
   30 CONTINUE
      IF(N.LT.4)RETURN
   40 MP1=M+1
      DO I=MP1,N,4
        DY(I)=DY(I)+DA*DX(I)
        DY(I+1)=DY(I+1)+DA*DX(I+1)
        DY(I+2)=DY(I+2)+DA*DX(I+2)
        DY(I+3)=DY(I+3)+DA*DX(I+3)
      ENDDO
      RETURN
      END
      DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
C
C  DDOT FORMS THE DOT PRODUCT OF TWO VECTORS.
C
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA,LINPACK,3/11/78.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(1),DY(1)
      DDOT=0.0D0
      DTEMP=0.0D0
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GOTO 20
C
C    CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C    NOT EQUAL TO 1
C
      IX=1
      IY=1
      IF(INCX.LT.0)IX=(-N+1)*INCX+1
      IF(INCY.LT.0)IY=(-N+1)*INCY+1
      DO 10 I=1,N
        DTEMP=DTEMP+DX(IX)*DY(IY)
        IX=IX+INCX
        IY=IY+INCY
   10 CONTINUE
      DDOT=DTEMP
      RETURN
C
C    CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C    CLEAN-UP LOOP
C
   20 M=MOD(N,5)
      IF(M.EQ.0)GOTO 40
      DO 30 I=1,M
        DTEMP=DTEMP+DX(I)*DY(I)
   30 CONTINUE
      IF(N.LT.5)GOTO 60
   40 MP1=M+1
      DO 50 I=MP1,N,5
      DTEMP=DTEMP+DX(I)*DY(I)+DX(I+1)*DY(I+1) +
     &  DX(I+2)*DY(I+2)+DX(I+3)*DY(I+3)+DX(I+4)*DY(I+4)
   50 CONTINUE
   60 DDOT=DTEMP
      RETURN
      END
      SUBROUTINE DGBFA(ABD,LDA,N,ML,MU,IPVT,INFO)
C
C  DGBFA FACTORS A DOUBLE PRECISION BAND MATRIX BY ELIMINATION.
C
C     DGBFA IS USUALLY CALLED BY DGBCO,BUT IT CAN BE CALLED
C     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA,N)
C                CONTAINS THE MATRIX IN BAND STORAGE.  THE COLUMNS
C                OF THE MATRIX ARE STORED IN THE COLUMNS OF  ABD  AND
C                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS
C                ML+1 THROUGH 2*ML+MU+1 OF  ABD .
C                SEE THE COMMENTS BELOW FOR DETAILS.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C                LDA MUST BE .GE. 2*ML+MU+1 .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C                0.LE.ML .LT. N .
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C                0.LE.MU .LT. N .
C                MORE EFFICIENT IF  ML.LE.MU .
C     ON RETURN
C
C        ABD     AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND
C                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A=L*U  WHERE
C                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C
C        INFO    INTEGER
C               =0  NORMAL VALUE.
C               =K  IF  U(K,K).EQ.0.0 .  THIS IS NOT AN ERROR
C                     CONDITION FOR THIS SUBROUTINE,BUT IT DOES
C                     INDICATE THAT DGBSL WILL DIVIDE BY ZERO IF
C                     CALLED.  USE  RCOND  IN DGBCO FOR A RELIABLE
C                     INDICATION OF SINGULARITY.
C
C     BAND STORAGE
C
C           IF  A  IS A BAND MATRIX,THE FOLLOWING PROGRAM SEGMENT
C           WILL SET UP THE INPUT.
C
C                   ML=(BAND WIDTH BELOW THE DIAGONAL)
C                   MU=(BAND WIDTH ABOVE THE DIAGONAL)
C                   M=ML+MU+1
C                   DO 20 J=1,N
C                      I1=MAX0(1,J-MU)
C                      I2=MIN0(N,J+ML)
C                      DO 10 I=I1,I2
C                         K=I-J+M
C                         ABD(K,J)=A(I,J)
C                10    CONTINUE
C                20 CONTINUE
C
C           THIS USES ROWS  ML+1  THROUGH  2*ML+MU+1  OF  ABD .
C           IN ADDITION,THE FIRST  ML  ROWS IN  ABD  ARE USED FOR
C           ELEMENTS GENERATED DURING THE TRIANGULARIZATION.
C           THE TOTAL NUMBER OF ROWS NEEDED IN  ABD  IS  2*ML+MU+1 .
C           THE  ML+MU BY ML+MU  UPPER LEFT TRIANGLE AND THE
C           ML BY ML  LOWER RIGHT TRIANGLE ARE NOT REFERENCED.
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER,UNIVERSITY OF NEW MEXICO,ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DSCAL,IDAMAX
C     FORTRAN MAX0,MIN0
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION IPVT(1),ABD(LDA,1)
      M=ML+MU+1
      INFO=0
C
C     ZERO INITIAL FILL-IN COLUMNS
C
      J0=MU+2
      J1=MIN0(N,M)-1
      IF(J1.LT.J0)GOTO 30
      DO 20 JZ=J0,J1
         I0=M+1-JZ
         DO 10 I=I0,ML
            ABD(I,JZ)=0.0D0
   10    CONTINUE
   20 CONTINUE
   30 CONTINUE
      JZ=J1
      JU=0
C
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
C
      NM1=N-1
      IF(NM1.LT.1)GOTO 130
      DO 120 K=1,NM1
         KP1=K+1
C
C        ZERO NEXT FILL-IN COLUMN
C
         JZ=JZ+1
         IF(JZ.GT.N)GOTO 50
         IF(ML.LT.1)GOTO 50
            DO 40 I=1,ML
               ABD(I,JZ)=0.0D0
   40       CONTINUE
   50    CONTINUE
C
C        FIND L=PIVOT INDEX
C
         LM=MIN0(ML,N-K)
         L=IDAMAX(LM+1,ABD(M,K),1)+M-1
         IPVT(K)=L+K-M
C
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
C
         IF(ABD(L,K).EQ.0.0D0)GOTO 100
C
C           INTERCHANGE IF NECESSARY
C
            IF(L.EQ.M)GOTO 60
               T=ABD(L,K)
               ABD(L,K)=ABD(M,K)
               ABD(M,K)=T
   60       CONTINUE
C
C           COMPUTE MULTIPLIERS
C
            T=-1.0D0/ABD(M,K)
            CALL DSCAL(LM,T,ABD(M+1,K),1)
C
C           ROW ELIMINATION WITH COLUMN INDEXING
C
            JU=MIN0(MAX0(JU,MU+IPVT(K)),N)
            MM=M
            IF(JU.LT.KP1)GOTO 90
            DO 80 J=KP1,JU
               L=L-1
               MM=MM-1
               T=ABD(L,J)
               IF(L.EQ.MM)GOTO 70
                  ABD(L,J)=ABD(MM,J)
                  ABD(MM,J)=T
   70          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,ABD(MM+1,J),1)
   80       CONTINUE
   90       CONTINUE
         GOTO 110
  100    CONTINUE
            INFO=K
  110    CONTINUE
  120 CONTINUE
  130 CONTINUE
      IPVT(N)=N
      IF(ABD(M,N).EQ.0.0D0)INFO=N
      RETURN
      END
      SUBROUTINE DGBSL(ABD,LDA,N,ML,MU,IPVT,B,JOB)
C
C  DGBSL SOLVES A DOUBLE PRECISION BAND LINEAR SYSTEM.
C
C    THE LINEAR SYSTEM HAS THE FORM
C
C     A*X=B  OR  TRANS(A)*X=B
C
C     THE MATRIX HAS BEEN FACTORED BY DGBCO OR DGBFA.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA,N)
C                THE OUTPUT FROM DGBCO OR DGBFA.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C
C        IPVT    INTEGER(N)
C                THE PIVOT VECTOR FROM DGBCO OR DGBFA.
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C        JOB     INTEGER
C               =0         TO SOLVE  A*X=B ,
C               =NONZERO   TO SOLVE  TRANS(A)*X=B ,WHERE
C                            TRANS(A)  IS THE TRANSPOSE.
C
C     ON RETURN
C
C        B       THE SOLUTION VECTOR  X .
C
C     ERROR CONDITION
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
C        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
C        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
C        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
C        CALLED CORRECTLY AND IF DGBCO HAS SET RCOND.GT.0.0
C        OR DGBFA HAS SET INFO.EQ.0 .
C
C     TO COMPUTE  INVERSE(A)*C  WHERE  C  IS A MATRIX
C     WITH  P  COLUMNS
C           CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z)
C           IF(RCOND IS TOO SMALL)GOTO ...
C           DO 10 J=1,P
C              CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0)
C        10 CONTINUE
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER,UNIVERSITY OF NEW MEXICO,ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DDOT
C     FORTRAN MIN0
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION IPVT(1),ABD(LDA,1),B(1)
      M=MU+ML+1
      NM1=N-1
      IF(JOB.NE.0)GOTO 50
C
C        JOB=0 ,SOLVE  A*X=B
C        FIRST SOLVE L*Y=B
C
         IF(ML.EQ.0)GOTO 30
         IF(NM1.LT.1)GOTO 30
            DO 20 K=1,NM1
               LM=MIN0(ML,N-K)
               L=IPVT(K)
               T=B(L)
               IF(L.EQ.K)GOTO 10
                  B(L)=B(K)
                  B(K)=T
   10          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,B(K+1),1)
   20       CONTINUE
   30    CONTINUE
C
C        NOW SOLVE  U*X=Y
C
         DO 40 KB=1,N
            K=N+1-KB
            B(K)=B(K)/ABD(M,K)
            LM=MIN0(K,M)-1
            LA=M-LM
            LB=K-LM
            T=-B(K)
            CALL DAXPY(LM,T,ABD(LA,K),1,B(LB),1)
   40    CONTINUE
      GOTO 100
   50 CONTINUE
C
C        JOB=NONZERO,SOLVE  TRANS(A)*X=B
C        FIRST SOLVE  TRANS(U)*Y=B
C
         DO 60 K=1,N
            LM=MIN0(K,M)-1
            LA=M-LM
            LB=K-LM
            T=DDOT(LM,ABD(LA,K),1,B(LB),1)
            B(K)=(B(K)-T)/ABD(M,K)
   60    CONTINUE
C
C        NOW SOLVE TRANS(L)*X=Y
C
         IF(ML.EQ.0)GOTO 90
         IF(NM1.LT.1)GOTO 90
            DO 80 KB=1,NM1
               K=N-KB
               LM=MIN0(ML,N-K)
               B(K)=B(K)+DDOT(LM,ABD(M+1,K),1,B(K+1),1)
               L=IPVT(K)
               IF(L.EQ.K)GOTO 70
                  T=B(L)
                  B(L)=B(K)
                  B(K)=T
   70          CONTINUE
   80       CONTINUE
   90    CONTINUE
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DSCAL(N,DA,DX,INCX)
C
C  DSCAL SCALES A VECTOR BY A CONSTANT.
C
C     USES UNROLLED LOOPS FOR INCREMENT EQUAL TO ONE.
C     JACK DONGARRA,LINPACK,3/11/78.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(1)
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1)GOTO 20
C
C   CODE FOR INCREMENT NOT EQUAL TO 1
C
      NINCX=N*INCX
      DO 10 I=1,NINCX,INCX
      DX(I)=DA*DX(I)
   10 CONTINUE
      RETURN
C
C   CODE FOR INCREMENT EQUAL TO 1
C
C
C   CLEAN-UP LOOP
C
   20 M=MOD(N,5)
      IF(M.EQ.0)GOTO 40
      DO 30 I=1,M
        DX(I)=DA*DX(I)
   30 CONTINUE
      IF(N.LT.5)RETURN
   40 MP1=M+1
      DO 50 I=MP1,N,5
        DX(I)=DA*DX(I)
        DX(I+1)=DA*DX(I+1)
        DX(I+2)=DA*DX(I+2)
        DX(I+3)=DA*DX(I+3)
        DX(I+4)=DA*DX(I+4)
   50 CONTINUE
      RETURN
      END
      FUNCTION IDAMAX(N,DX,INCX)
C
C  IDAMAX FINDS THE VECTOR ELEMENT OF LARGEST MAGNITUDE.
C
C     JACK DONGARRA,LINPACK,3/11/78.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(1)
      IDAMAX=0
      IF(N.LT.1)RETURN
      IDAMAX=1
      IF(N.EQ.1)RETURN
      IF(INCX.EQ.1)GOTO 20
C
C   CODE FOR INCREMENT NOT EQUAL TO 1
C
      IX=1
      DMAX=DABS(DX(1))
      IX=IX+INCX
      DO 10 I=2,N
       IF(DABS(DX(IX)).LE.DMAX)GOTO 5
        IDAMAX=I
        DMAX=DABS(DX(IX))
    5   IX=IX+INCX
   10 CONTINUE
      RETURN
C
C   CODE FOR INCREMENT EQUAL TO 1
C
   20 DMAX=DABS(DX(1))
      DO 30 I=2,N
        IF(DABS(DX(I)).LE.DMAX)GOTO 30
        IDAMAX=I
        DMAX=DABS(DX(I))
   30 CONTINUE
      RETURN
      END
      SUBROUTINE NSTOKE(XC,YC,AREA,XM,YM,
     &  A,F,G,UOLD,REYNLD,TOLNS,XLNGTH,YLNGTH,
     &  NODE,INDX,INSC,IPIVOT,MROW1,
     &  NLBAND,NUBAND,NBAND,NROW1,NCOL1,
     &  NELEMN,NP,NNODES,NUK,NQUAD,NEQN1,
     &  NSTEPS,NSIM,IWRITE,MAXND,MAXEL,RDEL,ALPHA)
C
C  NSTOKE SOLVES THE NAVIER-STOKES EQUATIONS USING TAYLOR-HOOD ELEMENTS.
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE,
C    DEPARTMENT OF MATHEMATICS,
C    AJOU UNIVERSITY,KOREA
C
C  PARAMETERS:
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(MROW1,*),AREA(*),F(*),G(*),INDX(MAXND,*),INSC(*),
     &IPIVOT(*),NODE(MAXEL,*),UN(2),UNX(2),UNY(2),UOLD(*),XC(*),
     &XM(MAXEL,*),YC(*),YM(MAXEL,*)
C
C  ZERO ARRAYS
C  G ARRAY CONTAINS THE PREVIOUS ITERATE
C  F ARRAY CONTAINS THE RIGHT HAND SIDE INITIALLY AND THEN THE CURRENT
C  ITERATE IS OVERWRITTEN ON F
C
      VISC=1.0D0/REYNLD
C
C  MATRIX ASSEMBLY TRIANGLE BY TRIANGLE
C  NSIM IS THE NUMBER OF SIMPLE ITERATIONS PERFORMED
C
      DO ITER=1,NSTEPS
        IF(ITER.LE.NSIM)THEN
          CSIM=0.0D0
        ELSE
          CSIM=1.0D0
        ENDIF
        DO I=1,NROW1
          DO J=1,NCOL1
            A(I,J)=0.0D0
          ENDDO
        ENDDO
        DO IT=1,NELEMN
          ARR=AREA(IT)/3.0D0
          DO IQUAD=1,NQUAD
            Y=YM(IT,IQUAD)
            X=XM(IT,IQUAD)
            CALL TRANS(IT,X,Y,DET,XIX,XIY,ETAX,ETAY,XC,YC,NODE,MAXEL)
            AR=ARR*DET
            DO KK=1,2
              UN(KK) =0.0D0
              UNY(KK)=0.0D0
              UNX(KK)=0.0D0
            ENDDO
            UOLD_QP=0.0D0
            VOLD_QP=0.0D0
            DO IQ=1,NNODES
              CALL REFQBF(X,Y,IQ,BB,TBX,TBY)
              BX=TBX*XIX+TBY*ETAX
              BY=TBX*XIY+TBY*ETAY
              IP=NODE(IT,IQ)
              DO IUK=1,2
                IUN=INDX(IP,IUK)
                IF(0.LT.IUN)THEN
                  UN(IUK) =UN(IUK) +BB*G(IUN)
                  UNX(IUK)=UNX(IUK)+BX*G(IUN)
                  UNY(IUK)=UNY(IUK)+BY*G(IUN)
                  IF(IUK.EQ.1)THEN
                    UOLD_QP=UOLD_QP+BB*UOLD(IUN)
                  ELSE IF(IUK.EQ.2)THEN
                    VOLD_QP=VOLD_QP+BB*UOLD(IUN)
                  ENDIF
                ELSE IF(IUN.LT.0)THEN
                  UBC=ALPHA*UBDRY(IUK,IP,XC,YC)
                  UN(IUK) =UN(IUK) +BB*UBC
                  UNX(IUK)=UNX(IUK)+BX*UBC
                  UNY(IUK)=UNY(IUK)+BY*UBC
                  IF(IUK.EQ.1)THEN
                    UOLD_QP=UOLD_QP+BB*UBC
                  ELSE IF(IUK.EQ.2)THEN
                    VOLD_QP=VOLD_QP+BB*UBC
                  ENDIF
                ENDIF
              ENDDO
            ENDDO
            DO IQ=1,NNODES
              IP=NODE(IT,IQ)
              CALL REFQBF(X,Y,IQ,BB,TBX,TBY)
              BX=TBX*XIX+TBY*ETAX
              BY=TBX*XIY+TBY*ETAY
              BBL=REFBSP(X,Y,IQ)
              DO 210 IUK=1,NUK
                IF(IUK.EQ.3)THEN
                  I=INSC(IP)
                ELSE
                  I=INDX(IP,IUK)
                ENDIF
                IF(I.LE.0)GOTO 210
                IF(IUK.EQ.1)THEN
                  F(I)=F(I)
     &               +CSIM *( (UN(1)*UNX(1)+UN(2)*UNY(1))*BB)*AR
     &               +RDEL*UOLD_QP*BB*AR
                ELSE IF(IUK.EQ.2)THEN
                  F(I)=F(I)
     &              +CSIM *( (UN(1)*UNX(2)+UN(2)*UNY(2))*BB)*AR
     &              +RDEL*VOLD_QP*BB*AR
                ENDIF
                DO IQQ=1,NNODES
                  IPP=NODE(IT,IQQ)
                  CALL REFQBF(X,Y,IQQ,BBB,TBBX,TBBY)
                  BBX=TBBX*XIX+TBBY*ETAX
                  BBY=TBBX*XIY+TBBY*ETAY
                  BBBL=REFBSP(X,Y,IQQ)
                  DO 190 IUKK=1,NUK
                    IF(IUKK.LT.3)THEN
                      J=INDX(IPP,IUKK)
                    ELSE
                      J=INSC(IPP)
                    ENDIF
                    IF(J.EQ.0)GOTO 190
                    AIJ=0.0D0
                    IF(I.EQ.NEQN1)GOTO 190
                    IF(IUK.EQ.1)THEN
                      IF(IUKK.EQ.1)THEN
                        AIJ=VISC*(BY*BBY+BX*BBX)
     &                    +(BBB*UNX(1)*BB)*CSIM
     &                    +BB*BBX*UN(1)
     &                    +BB*BBY*UN(2)+RDEL*(BB*BBB)
                      ELSE IF(IUKK.EQ.2)THEN
                        AIJ=CSIM*BB*BBB*UNY(1)
                      ELSE IF(IUKK.EQ.3)THEN
                        AIJ=-BX*BBBL
                      ENDIF
                    ELSE IF(IUK.EQ.2)THEN
                      IF(IUKK.EQ.1)THEN
                        AIJ=CSIM*BB*BBB*UNX(2)
                      ELSE IF(IUKK.EQ.2)THEN
                        AIJ=(VISC*(BY*BBY+BX*BBX)
     &                    +(BB*BBB*UNY(2))*CSIM
     &                    +BB*BBY*UN(2)
     &                    +BB*BBX*UN(1))+RDEL*BB*BBB
                      ELSE IF(IUKK.EQ.3)THEN
                        AIJ=-BY*BBBL
                      ENDIF
                    ELSE IF(IUK.EQ.3)THEN
                      IF(IUKK.EQ.1)THEN
                        AIJ=BBX*BBL
                      ELSE IF(IUKK.EQ.2)THEN
                        AIJ=BBY*BBL
                      ENDIF
                    ENDIF
C
C  AN INHOMOGENEOUS BOUNDARY CONDITION RESULTS IN A TERM ADDED
C  TO THE RIGHT HAND SIDE.
C
                    IF(J.LT.0)THEN
                      UBC=ALPHA*UBDRY(IUKK,IPP,XC,YC)
                      F(I)=F(I)-AR*AIJ*UBC
                    ELSE
                      IUSE=I-J+NBAND
                      A(IUSE,J)=A(IUSE,J)+AR*AIJ
                    ENDIF
 190              CONTINUE
                ENDDO
 210          CONTINUE
            ENDDO
          ENDDO
        ENDDO
C
C  REPLACE THE LAST EQUATION BY AN EQUATION THAT FORCES THE PRESSURE TO BE ZERO
C  AT THE LAST PRESSURE NODE.
C
        F(NEQN1)=0.0D0
        DO J=NEQN1-NLBAND,NEQN1-1
          I=NEQN1-J+NBAND
          A(I,J)=0.0D0
        ENDDO
        A(NBAND,NEQN1)=1.0D0
C
C  FACTOR THE MATRIX.
C
        CALL DGBFA(A,MROW1,NEQN1,NLBAND,NUBAND,IPIVOT,INFO)
        IF(INFO .NE. 0)THEN
          WRITE(*,*)'NSTOKE-FATAL ERROR!'
          WRITE(*,*)'DGBFA RETURNED INFO=',INFO
          STOP
        ENDIF
C
C  SOLVE THE SYSTEM.
C
        JOB=0
        CALL DGBSL(A,MROW1,NEQN1,NLBAND,NUBAND,IPIVOT,F,JOB)
C
C  CHECK FOR CONVERGENCE
C
        DIFF=0.0D0
        DO I=1,NEQN1
          DIFF=DIFF +(G(I)-F(I))**2
        ENDDO
        DIFF=SQRT(DIFF)
        WRITE(6,1045) ITER,DIFF
        IF(DIFF.LE.TOLNS)THEN
          GOTO 750
        ENDIF
        DO I=1,NEQN1
          G(I)=F(I)
          F(I)=0.0D0
        ENDDO
      ENDDO
750    CONTINUE
1045  FORMAT('FOR ITERATION NO.',I3,'DIFFERENCE IN ITERATES IS '
     &      ,2D14.8)
      RETURN
      END
      FUNCTION REFBSP(X,Y,IQ)
C
C  REFBSP EVALUATES A LINEAR BASIS FUNCTION ON THE REFERENCE TRIANGLE.
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE,
C    DEPARTMENT OF MATHEMATICS,
C    AJOU UNIVERSITY,KOREA
C
C  PARAMETERS:
C
C    INPUT,DOUBLE PRECISION X,Y,THE COORDINATES OF THE POINT.
C
C    INPUT,INTEGER IQ,THE INDEX OF THE BASIS FUNCTION.
C    1 <= IQ <= 3.
C
C    OUTPUT,DOUBLE PRECISION VALUE,THE VALUE OF THE IQ-TH BASIS
C    FUNCTION AT (X,Y).
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      IF(IQ.EQ.1)THEN
        REFBSP=1.0D0-X-Y
      ELSE IF(IQ.EQ.2)THEN
        REFBSP=X
      ELSE IF(IQ.EQ.3)THEN
        REFBSP=Y
      ELSE
        REFBSP=0.0D0
      ENDIF
      RETURN
      END
      SUBROUTINE REFQBF(X,Y,IN,BB,BX,BY)
C
C  REFQBF EVALUATES A QUADRATIC BASIS FUNCTION ON THE REFERENCE TRIANGLE.
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE,
C    DEPARTMENT OF MATHEMATICS,
C    AJOU UNIVERSITY,KOREA
C
C  PARAMETERS:
C
C    INPUT,DOUBLE PRECISION X,Y,COORDINATES IN THE REFERENCE TRIANGLE
C    OF THE POINT WHERE THE BASIS FUNCTION IS TO BE EVALUATED.
C
C    INPUT,INTEGER IN,THE INDEX OF THE BASIS FUNCTION.
C
C    OUTPUT,DOUBLE PRECISION BB,BX,BY,THE VALUE OF THE BASIS FUNCTION,
C    AND ITS X AND Y DERIVATIVES,AT THE GIVEN POINT.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      IF(IN.EQ.1)THEN
        BB=(1.0D0-X-Y)*(1.0D0-2.0D0*X-2.0D0*Y)
        BX=-3.0D0+4.0D0*X+4.0D0*Y
        BY=-3.0D0+4.0D0*X+4.0D0*Y
      ELSE IF(IN.EQ.2)THEN
        BB=X*(2.0D0*X-1.0D0)
        BX=4.0D0*X-1.0D0
        BY=0.0D0
      ELSE IF(IN.EQ.3)THEN
        BB=Y*(2.0D0*Y-1.0D0)
        BX=0.0D0
        BY=4.0D0*Y-1.0D0
      ELSE IF(IN.EQ.4)THEN
        BB=4.0D0*X*(1.0D0-X-Y)
        BX=4.0D0*(1.0D0-2.0D0*X-Y)
        BY=-4.0D0*X
      ELSE IF(IN.EQ.5)THEN
        BB=4.0D0*X*Y
        BX=4.0D0*Y
        BY=4.0D0*X
      ELSE IF(IN.EQ.6)THEN
        BB=4.0D0*Y *(1.0D0-X-Y)
        BX=-4.0D0*Y
        BY=4.0D0*(1.0D0-X-2.0D0*Y)
      ELSE
        BB=0.0D0
        BX=0.0D0
        BY=0.0D0
      ENDIF
      RETURN
      END
      SUBROUTINE SETGRD(XC,YC,AREA,XM,YM,XLNGTH,YLNGTH,
     &   NODE,INDX,INSC,NLBAND,NBAND,NX,NY,NELEMN,NP,
     &   NNODES,NUK,NQUAD,NEQN1,IWRITE,MAXND,MAXEL)
C
C  SETGRD SETS UP THE GRID FOR THE PROBLEM.
C
C  DISCUSSION:
C
C    WE ARE USING QUADRATICS FOR THE VELOCITY AND LINEARS FOR THE
C    PRESSURE
C
C    INPUT NEEDED IS NX,NY,XLNGTH,YLNGTH,WRITE
C    COMPUTES ARRAYS NODE,AREA,XC,YC,XM,YM,INDEX,INSC
C    COMPUTES NEQN1,BANDWIDTH INFORMATION
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE,
C    DEPARTMENT OF MATHEMATICS,
C    AJOU UNIVERSITY,KOREA
C
C  PARAMETERS:
C
C    OUTPUT,DOUBLE PRECISION XC(NP),YC(NP),THE COORDINATES OF THE NODES.
C
C    OUTPUT,DOUBLE PRECISION AREA(NELEMN),THE AREA OF EACH ELEMENT.
C
C    OUTPUT,DOUBLE PRECISION XM(MAXEL,3),YM(MAXEL,3),THE COORDINATES
C    OF QUADRATURE POINTS IN EACH ELEMENT.
C
C    INPUT,DOUBLE PRECISION XLNGTH,YLNGTH,THE TOTAL WIDTH AND HEIGHT
C    OF THE REGION.
C
C    OUTPUT,INTEGER NODE(MAXEL,6),THE NODES THAT MAKE UP EACH ELEMENT.
C
C    OUTPUT,INTEGER INDX(MAXND,3),LISTS THE INDICES OF THE U,V,AND P
C    VARIABLES ASSOCIATED WITH THE NODE.
C
C    OUTPUT,INTEGER INSC(NP),IS ZERO IF A NODE IS NOT A PRESSURE NODE.
C    OTHERWISE,IT IS THE INDEX OF THE UNKNOWN PRESSURE ASSOCIATED WITH THE NODE.
C
C    OUTPUT,INTEGER NLBAND,THE HALF BANDWIDTH FOR THE FINITE ELEMENT MATRIX.
C    OUTPUT,INTEGER NBAND,THE BANDWIDTH FOR THE FINITE ELEMENT MATRIX.
C
C    INPUT,INTEGER NX,NY,SPECIFIES THE DENSITY OF ELEMENTS IN
C    THE X AND Y DIRECTIONS.
C
C    OUTPUT,INTEGER NELEMN,THE NUMBER OF ELEMENTS.
C    OUTPUT,INTEGER NP,THE NUMBER OF NODES.
C    OUTPUT,INTEGER NNODES,THE NUMBER OF NODES PER ELEMENT.
C    OUTPUT,INTEGER NUK,THE MAXIMUM NUMBER OF UNKNOWNS ASSOCIATED WITH ONE NODE.
C    OUTPUT,INTEGER NQUAD,THE NUMBER OF QUADRATURE POINTS.
C    OUTPUT,INTEGER NEQN1,THE TOTAL NUMBER OF UNKNOWNS.
C    INPUT,INTEGER IWRITE,AN OUTPUT UNIT FOR DEBUGGING INFORMATION.
C    INPUT,INTEGER MAXND,THE MAXIMUM NUMBER OF NODES.
C    INPUT,INTEGER MAXEL,THE MAXIMUM NUMBER OF ELEMENTS.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION AREA(*),INDX(MAXND,*),INSC(*),NODE(MAXEL,*),XC(NP),
     &XM(MAXEL,*),YC(NP),YM(MAXEL,*)
C
C  SET PARAMETERS FOR THE TAYLOR-HOOD ELEMENT.
C
      NNODES=6
      NUK=3
C
C  CONSTRUCT THE GRID COORDINATES AND ORDERING OF UNKNOWNS
C
      NYM1=NY-1
      NXM1=NX-1
      NROW=NX+NXM1
      NCOL=NY+NYM1
      HX=XLNGTH/DBLE(NXM1)
      HX1=HX/2.0D0
      HY=YLNGTH/DBLE(NYM1)
      HY1=HY/2.0D0
      I=0
      IP=0
      IT1=-1
      XX=0.0D0-HX1
      IQUATER1=(NROW-1)/4-2
      IQUATER2=( 3 *(NROW- 1))/4
      DO IC=1,IQUATER1
        XX=XX+HX1
        ICNT=MOD(IC,2)
        DO JC=1,NY
          JCNT=MOD(JC,2)
          YY=0.5D0+HY1*DBLE(JC-1)
          IP=IP+1
          XC(IP)=XX
          YC(IP)=YY
          IF(ICNT.EQ.1.AND.JCNT.EQ.1.AND.JC.LT.NY)THEN
            IT1=IT1+2
            NELEMN=IT1+1
            IP1=IP+NY
            IP2=IP+NY+NY
            NODE(IT1,1)=IP
            NODE(IT1,2)=IP2+2
            NODE(IT1,3)=IP2
            NODE(IT1,4)=IP1+1
            NODE(IT1,5)=IP2+1
            NODE(IT1,6)=IP1
            NODE(NELEMN,1)=IP
            NODE(NELEMN,2)=IP2+2
            NODE(NELEMN,3)=IP+2
            NODE(NELEMN,4)=IP1+1
            NODE(NELEMN,5)=IP1+2
            NODE(NELEMN,6)=IP+1
          ENDIF
C
C  INDEX FOR DIRICHLET B.C.
C
          IF(JC.NE.1.AND.JC.NE.NY.AND.IC.NE.1)THEN
            I=I+2
            INDX(IP,1)=I-1
            INDX(IP,2)=I
          ELSE
            INDX(IP,1)=-1
            INDX(IP,2)=-1
          ENDIF
          IF(JCNT.EQ.1.AND.ICNT.EQ.1)THEN
            I=I+1
            INSC(IP)=I
          ELSE
            INSC(IP)=0
          ENDIF
        ENDDO
      ENDDO
      DO 140 IC=IQUATER1+1,IQUATER1+2
        XX=XX+HX1
        ICNT=MOD(IC,2)
        DO 135 JC=1,NY
          JCNT=MOD(JC,2)
          YY=0.5D0+HY1*DBLE(JC-1)
          IP=IP+1
          XC(IP)=XX
          YC(IP)=YY
          IF(ICNT.EQ.1.AND.JCNT.EQ.1)GOTO 15
          GOTO 110
   15     IF(JC.EQ.NY)GOTO 110
          IT1=IT1+2
          NELEMN=IT1+1
          IP1=IP+NY
          IP2=IP+NY+NCOL
          NODE(IT1,1)=IP
          NODE(IT1,2)=IP2+2
          NODE(IT1,3)=IP2
          NODE(IT1,4)=IP1+1
          NODE(IT1,5)=IP2+1
          NODE(IT1,6)=IP1
          NODE(NELEMN,1)=IP
          NODE(NELEMN,2)=IP2+2
          NODE(NELEMN,3)=IP+2
          NODE(NELEMN,4)=IP1+1
          NODE(NELEMN,5)=IP1+2
          NODE(NELEMN,6)=IP+1
  110     CONTINUE
C
C INDEX FOR DIRICHLET B.C.
C
        IF(JC.EQ.1.OR.JC.EQ.NY)GOTO 120
        I=I+2
          INDX(IP,1)=I-1
          INDX(IP,2)=I
          GOTO 129
  120     CONTINUE
          INDX(IP,1)=-1
          INDX(IP,2)=-1
  129     CONTINUE
          IF(JCNT.EQ.0.OR.ICNT.EQ.0)GOTO 130
          I=I+1
          INSC(IP)=I
          GOTO 135
  130     INSC(IP)=0
  135   CONTINUE
  140 CONTINUE
      DO 240 IC=IQUATER1+3,IQUATER2
        XX=XX+HX1
        ICNT=MOD(IC,2)
        DO 235 JC=1,NCOL
          JCNT=MOD(JC,2)
          YY=HY1*DBLE(JC-1)
          IP=IP+1
          XC(IP)=XX
          YC(IP)=YY
          IF(ICNT.EQ.1.AND.JCNT.EQ.1)GOTO 25
          GOTO 210
   25     IF(JC.EQ.NCOL)GOTO 210
          IT1=IT1+2
          NELEMN=IT1+1
          IP1=IP+NCOL
          IP2=IP+NCOL+NCOL
          NODE(IT1,1)=IP
          NODE(IT1,2)=IP2+2
          NODE(IT1,3)=IP2
          NODE(IT1,4)=IP1+1
          NODE(IT1,5)=IP2+1
          NODE(IT1,6)=IP1
          NODE(NELEMN,1)=IP
          NODE(NELEMN,2)=IP2+2
          NODE(NELEMN,3)=IP+2
          NODE(NELEMN,4)=IP1+1
          NODE(NELEMN,5)=IP1+2
          NODE(NELEMN,6)=IP+1
  210     CONTINUE
C
C INDEX FOR DIRICHLET B.C.
C
        IF(JC.EQ.1.OR.JC.EQ.NCOL)GOTO 220
        IF(IC.EQ.IQUATER1+3.AND.JC.LE.NY)GOTO 220
        I=I+2
          INDX(IP,1)=I-1
          INDX(IP,2)=I
          GOTO 229
  220     CONTINUE
          INDX(IP,1)=-1
          INDX(IP,2)=-1
  229     CONTINUE
          IF(JCNT.EQ.0.OR.ICNT.EQ.0)GOTO 230
          I=I+1
          INSC(IP)=I
          GOTO 235
  230     INSC(IP)=0
  235   CONTINUE
  240 CONTINUE
        XX=XX+HX1
        ICNT=MOD(IQUATER2+1,2)
        DO 255 JC=1,NY-1
          JCNT=MOD(JC,2)
          YY=HY1*DBLE(JC-1)
          IP=IP+1
          XC(IP)=XX
          YC(IP)=YY
          INDX(IP,1)=-1
          INDX(IP,2)=-1
          IF(JCNT.EQ.0.OR.ICNT.EQ.0)GOTO 930
          I=I+1
          INSC(IP)=I
          GOTO 255
  930     INSC(IP)=0
  255   CONTINUE
       XX=XX-HX1
      DO 340 IC=IQUATER2+1,NROW
        XX=XX+HX1
        ICNT=MOD(IC,2)
        DO 335 JC=1,NY
          JCNT=MOD(JC,2)
          YY=0.5D0+HY1*DBLE(JC-1)
          IP=IP+1
          XC(IP)=XX
          YC(IP)=YY
          IF(ICNT.EQ.1.AND.JCNT.EQ.1)GOTO 435
          GOTO 310
  435     IF(IC.EQ.NROW.OR.JC.EQ.NY)GOTO 310
          IT1=IT1+2
          NELEMN=IT1+1
          IP1=IP+NY
          IP2=IP+NY+NY
          NODE(IT1,1)=IP
          NODE(IT1,2)=IP2+2
          NODE(IT1,3)=IP2
          NODE(IT1,4)=IP1+1
          NODE(IT1,5)=IP2+1
          NODE(IT1,6)=IP1
          NODE(NELEMN,1)=IP
          NODE(NELEMN,2)=IP2+2
          NODE(NELEMN,3)=IP+2
          NODE(NELEMN,4)=IP1+1
          NODE(NELEMN,5)=IP1+2
          NODE(NELEMN,6)=IP+1
  310     CONTINUE
C
C  INDEX FOR DIRICHLET BOUNDARY CONDITION.
C
        IF(JC.EQ.1.OR.JC.EQ.NY)GOTO 320
          I=I+2
          INDX(IP,1)=I-1
          INDX(IP,2)=I
          GOTO 329
  320     CONTINUE
          INDX(IP,1)=-1
          INDX(IP,2)=-1
  329     CONTINUE
          IF(JCNT.EQ.0.OR.ICNT.EQ.0)GOTO 330
          I=I+1
          INSC(IP)=I
          GOTO 335
  330     INSC(IP)=0
  335   CONTINUE
  340 CONTINUE
      NP=IP
      NEQN1=I
      IF(.FALSE.)THEN
        WRITE(*,'(I5,2F12.5,3I5)') (I,XC(I),YC(I),INDX(I,1),
     &                  INDX(I,2),INSC(I),I=1,NP)
        WRITE(*,'(7I6)') (IT,(NODE(IT,I),I=1,6),IT=1,NELEMN)
      ENDIF
C
C  SET THE QUADRATURE INFORMATION
C  QUADRATURE RULE IS MIDPOINT
C  COORDINATES AND WEIGHTS ARE SET BY ROUTINE QD7PT
C
      NQUAD=3
      DO IT=1,NELEMN
        XM(IT,1)=0.5D0
        XM(IT,2)=0.5D0
        XM(IT,3)=0.0D0
        YM(IT,1)=0.0D0
        YM(IT,2)=0.5D0
        YM(IT,3)=0.5D0
        AREA(IT)=0.5D0
      ENDDO
C
C  HALF BAND WIDTH
C
      NLBAND=0
      DO IT=1,NELEMN
        DO IQ=1,NNODES
          IP=NODE(IT,IQ)
          DO IUK=1,NUK
            IF(IUK.EQ.3)THEN
              I=INSC(IP)
            ELSE
              I=INDX(IP,IUK)
            ENDIF
            IF(0.LT.I)THEN
              DO IQQ=1,NNODES
                IPP=NODE(IT,IQQ)
                DO IUKK=1,NUK
                  IF(IUKK.EQ.NUK)THEN
                    J=INSC(IPP)
                  ELSE
                    J=INDX(IPP,IUKK)
                  ENDIF
                  IF(I.LE.J)THEN
                    IJ=J-I
                    IF(IJ.GT.NLBAND)THEN
                      NLBAND=IJ
                    ENDIF
                  ENDIF
                ENDDO
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      NBAND=NLBAND+NLBAND+1
      RETURN
      END
      SUBROUTINE SOLUTION_INIT(NEQN1,UOLD)
C
C  SOLUTION_INIT RETURNS AN INITIAL VALUE FOR THE SOLUTION COEFFICIENT VECTOR.
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE
C
C  PARAMETERS:
C
C    INPUT,INTEGER NEQN1,THE NUMBER OF COEFFICIENTS.
C
C    OUTPUT,DOUBLE PRECISION UOLD(NEQN1),THE INITIAL VALUE FOR THE
C    SOLUTION COEFFICIENTS.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION UOLD(NEQN1)
      DO I=1,NEQN1
        UOLD(I)=0.5D0
      ENDDO
      RETURN
      END
      SUBROUTINE TRANS(IT,XQ,YQ,DET,PJ11,PJ21,PJ12,PJ22,
     &  XC,YC,NODE,MAXEL)
C
C  TRANS TRANSFORMS DATA BETWEEN THE REFERENCE AND PHYSICAL ELEMENTS.
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE,
C    DEPARTMENT OF MATHEMATICS,
C    AJOU UNIVERSITY,KOREA
C
C  PARAMETERS:
C
C    INPUT,INTEGER IT,THE ELEMENT NUMBER.
C
C    INPUT,DOUBLE PRECISION X,Y,THE COORDINATES OF A POINT.
C
C    OUTPUT,DOUBLE PRECISION DET,THE DETERMINANT OF JACOBIAN OF THE
C    TRANSFORMATION AT (X,Y).
C
C    OUTPUT,DOUBLE PRECISION PJ11,PJ21,PJ12,PJ22,THE ELEMENTS OF THE
C    INVERSE OF THE JACOBIAN AT (X,Y).
C
C    INPUT,DOUBLE PRECISION XC(*),YC(*),THE COORDINATES OF ALL THE NODES.
C
C    INPUT,INTEGER NODE(MAXEL,6),THE NODES THAT MAKE UP EACH ELEMENT.
C
C    INPUT,INTEGER MAXEL,THE MAXIMUM NUMBER OF ELEMENTS.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION NODE(MAXEL,*),XC(*),YC(*)
      I1=NODE(IT,1)
      I2=NODE(IT,2)
      I3=NODE(IT,3)
      I4=NODE(IT,4)
      I5=NODE(IT,5)
      I6=NODE(IT,6)
      X1=XC(I1)
      Y1=YC(I1)
      X2=XC(I2)
      Y2=YC(I2)
      X3=XC(I3)
      Y3=YC(I3)
      X4=XC(I4)
      Y4=YC(I4)
      X5=XC(I5)
      Y5=YC(I5)
      X6=XC(I6)
      Y6=YC(I6)
C
C  COMPUTE PARTIAL DERIVATIVES AT POINT (XQ,YQ)
C
      F1X=X1*(-3.D0+4.D0*XQ+4.D0*YQ)
     &       +X2*(4.D0*XQ-1.D0)
     &       +X4*4.D0*(1.D0-2.D0*XQ-YQ)
     &       +X5*4.D0*YQ+X6*4.D0*(-YQ)
      F1Y=X1*(-3.D0+4.D0*XQ+4.D0*YQ)
     &       +X3*(4.D0*YQ-1.D0)
     &       +X4*4.D0*(-XQ)+X5*4.D0*XQ
     &       +X6*4.D0*(1.D0-XQ-2.D0*YQ)
      F2X=Y1*(-3.D0+4.D0*XQ+4.D0*YQ)
     &       +Y2*(4.D0*XQ-1.D0)
     &       +Y4*4.D0*(1.D0-2.D0*XQ-YQ)
     &       +Y5*4.D0*YQ+Y6*4.D0*(-YQ)
      F2Y=Y1*(-3.D0+4.D0*XQ+4.D0*YQ)
     &       +Y3*(4.D0*YQ-1.D0)
     &       +Y4*4.D0*(-XQ)+Y5*4.D0*XQ
     &       +Y6*4.D0*(1.D0-XQ-2.D0*YQ)
C
C  COMPUTE DETERMINANT OF TRANSFORMATION EVALUATED AT POINT (XQ,YQ).
C
      DET=F1X*F2Y-F1Y*F2X
C
C  COMPUTE J11,J22,J21,J22.
C
      PJ11= F2Y/DET
      PJ12=-F2X/DET
      PJ21=-F1Y/DET
      PJ22= F1X/DET
      DET=DABS(DET)
      RETURN
      END
      FUNCTION UBDRY(IUK,IP,XC,YC)
C
C  UBDRY EVALUATES THE BOUNDARY CONDITIONS.
C
C  LICENSING:
C
C    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
C
C  AUTHOR:
C
C    HYUNG-CHUN LEE,
C    DEPARTMENT OF MATHEMATICS,
C    AJOU UNIVERSITY,KOREA
C
C  PARAMETERS:
C
C    INPUT,INTEGER IUK,INDICATES THE TYPE OF THE UNKNOWN.
C    1,HORIZONTAL VELOCITY.
C    2,VERTICAL VELOCITY.
C    3,PRESSURE.
C
C    INPUT,INTEGER IP,THE INDEX OF THE NODE.
C
C    INPUT,DOUBLE PRECISION XC(*),YC(*),THE NODE COORDINATES.
C
C    OUTPUT,DOUBLE PRECISION UBDRY,THE VALUE OF THE BOUNDARY CONDITION
C    APPLIED AT THIS NODE,IF ANY.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION XC(*),YC(*)
      X=XC(IP)
      Y=YC(IP)
      IF(X.EQ.0.0)THEN
        IF(IUK.EQ.1)THEN
          UBDRY=16.0D0 *(Y-0.5D0) *(1.0D0-Y)
        ELSE IF(IUK.EQ.2)THEN
          UBDRY=0.0D0
        ELSE
          UBDRY=0.0D0
        ENDIF
      ELSE
        UBDRY=0.0D0
      ENDIF
      RETURN
      END
