      PROGRAM ISAAC
C     Integrated Solution Algorithm for Arbitrary Configurations
C     Author:  Joseph H. Morrison
C
C     Original code developed under contract to the NASA Langley Research Center
C     while the author worked for:
C       Analytical Services and Materials, Inc.
C       107 Research Drive
C       Hampton, Virginia 23666
C
C Portions Copyright (C) 2001 Joseph H. Morrison
C
C This program is distributed under the terms of the ISAAC Public Source
C License. This program is distributed WITHOUT ANY WARRANTY; without
C even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
C PURPOSE.
C
C     A FEW MODIFICATIONS BY DJB TO RUN ON WINDOWS/INTEL
C
C     Revision 4.6  2001/06/22 03:47:28  jhmorr
C     Add output of function name file. Modify contact information
C
C     Revision 4.5  2001/06/20 03:28:43  jhmorr
C     Added test for STOP file to stop a run.
C
C     Revision 4.4  2001/06/18 03:36:04  jhmorr
C     Added calculation of computational time.
C
C     Revision 4.3  2001/06/08 06:25:36  jhmorr
C     Fixed error in BCPRSB where S, PROPS are dimensioned but not passed
C
C     Revision 4.2  2001/06/08 04:56:15  jhmorr
C     Added notice
C
C     Revision 4.1  1998/04/14 20:33:16  jhmorr
C     Alpha 4.1.
C
C Parameter statements setting up the maximum storage
C MXBLKS :  maximum number of blocks
C MXLVLS :  maximum number of grid levels
C MXCFS  :  maximum number of coarse to fine sequences
C MXBCS  :  maximum number of boundary conditions per block
C MXCUTS :  maximum number of cuts
C MXPRT  :  maximum number of print statements per block
C MXPTS  :  maximum number of grid points
C           = summation of (JDIM+3)*(KDIM+3)*(IDIM+3) over all blocks
C MXPPTS :  maximum number of points to store PROPERTIES at
C           =  1     for inviscid calculation
C           =  MXPTS for viscous calculation
C MXQNPT :  maximum number of points to store additional TIME levels at
C           =  1     for steady   calculation
C           =  MXPTS for unsteady calculation
C           QN(1:NTIME)        stores Q^(n), Q^(n-1), ...
C           QN(NTIME+1:NTMLVL) stores Q^(m), ...
C MXRKPT :  maximum number of points required for Runge-Kutta algorithm
C           =  1     if not using Runge-Kutta or doing turb. model conversion
C           =  MXPTS if     using Runge-Kutta or doing turb. model conversion
C MXNODE :  maximum number of grid nodes over entire field
C           = summation of (JDIM+2)*(KDIM+2)*(IDIM+2) over all blocks
C MXBCPT :  maximum number of boundary condition points to be
C           stored in the QBC array (for the PROFILE bc type)
C MXPROF :  maximum number of profile boundary condition segments in QBC array
C MAXQ   :  maximum number of variables to store
C           =  5 for perfect gas
C           =  7 for perfect gas with 2 equation turbulence model
C           = 12 for perfect gas with Reynolds stress turbulence
C MAXF   :  maximum number of fluxes and residuals to store
C           =  5 for perfect gas
C           =  7 for perfect gas with 2 equation turbulence model
C           = 12 for perfect gas with Reynolds stress turbulence
C MAXP   :  maximum number of properties
C           =  2 for inviscid or laminar
C           =  3 for turbulent flow
C           =  4 for Reynolds Stress turbulence model
C           =  5 for Algebraic Reynolds Stress turbulence model
C MAXW   :  maximum size of additional work array (MXSECT*MAXW)
C           = 19 for source terms: WORKX(1)     = TKE
C                                  WORKX(2)     = ETILDE
C                                  WORKX(3)     = XSIW
C                                  WORKX(4-5)   = FDAMP
C                                  WORKX(6)     = EPSC
C                                  WORKX(7)     = PDIL
C                                  WORKX( 8-13) = SIJ
C                                  WORKX(14-19) = WIJ
C MAXTQ  :  maximum number of wall function data stored
C           =  2 for (tau_wall and qdot_wall)
C MAXMDL :  maximum size of array describing turbulence model (IMODEL)
C MXTRSG :  maximum number of transition specification segments
C MXSECT :  maximum size of a cross section i.e.,
C           maximum of (ixj, jxk or ixk) for all blocks
C           used to dimension temporary space for q(+,-) and f.
C MXSIZE :  maximum size of any block, used to dimension RES array
C           = maximum of (JDIM+3)*(KDIM+3)*(IDIM+3) of all blocks
C MXSIZ4 :  maximum size of any block, used to dimension FHAT for 4th order
C           = 1 for 1st or 2nd order schemes
C           = maximum of (JDIM+3)*(KDIM+3)*(IDIM+3) of all blocks for 4th order
C MXCRS  :  maximum size of all coarse levels of all blocks used to store
C           the multigrid forcing function
C MXRANK :  maximum rank of Jacobian blocks
C           =  5 for perfect gas
C           =  7 for perfect gas with 2 equation turbulence model
C           = 12 for perfect gas with Reynolds stress turbulence
C MXABC  :  maximum number of storage locations for tridiagonal system to invert
C           =  NPL*max(IDIM*JDIM,JDIM*KDIM) for (AF3F)
C              where NPL is the number of secondary planes vectorized over
C MXRM   :  maximum amount of storage for the RM array
C           =  MXSECT for LGS and MARCH
C           =  not necessary for RK, AF3F
C MXSTAG :  maximum number of stages for multistage time integration
C MXTMLV :  maximum number of additional time levels for unsteady calculation
C           =  1 for steady (and set MXQNPT = 1)
C           =  2 for iterative, implicit unsteady
C           =  3 for tau-ts iterative unsteady with 2nd order pseudo sub-iter
C
      PARAMETER (MAXQ   =    12)
      PARAMETER (MXPTS  = 56240)
      PARAMETER (MXSIZE = 41040)
      PARAMETER (MXSIZ4 = 1)
      PARAMETER (MXCRS  = 15200)
      PARAMETER (MXSECT = 8208)
      PARAMETER (MXTMLV = 3)
      PARAMETER (MXBLKS =   20)
      PARAMETER (MXLVLS =    4)
      PARAMETER (MXCFS  =    4)
      PARAMETER (MXBCS  =   10)
      PARAMETER (MXCUTS =  100)
      PARAMETER (MXPRT  =   20)
      PARAMETER (MXPPTS = MXPTS)
      PARAMETER (MXQNPT = MXPTS)
      PARAMETER (MXNODE = MXPTS)
      PARAMETER (MXRKPT = MXPTS)
      PARAMETER (MXBCPT = 1000)
      PARAMETER (MXPROF = 10)
      PARAMETER (MAXF   = MAXQ)
      PARAMETER (MAXP   =    5)
      PARAMETER (MAXW   =   19)
      PARAMETER (MAXTQ  =    2)
      PARAMETER (MAXMDL =   13)
      PARAMETER (MXTRSG = MXBLKS)
      PARAMETER (MXRANK = MAXQ)
      PARAMETER (MXABC  = MXSECT)
      PARAMETER (MXRM   = MXSECT)
      PARAMETER (MXSTAG = 6)
C
C     Commons
C
      include 'common.inc'
      include 'histry.inc'
C
C     PERMANENT STORAGE FOR ALL ZONES/BLOCKS
C
C     Storage for flow variables, turbulent eddy viscosity,
C     metrics, volumes, jacobians and grid.
C
      COMMON /LOCAL/  Q     (MXPTS *MAXQ),
     1                QN    (MXQNPT*MAXQ*MXTMLV),
     2                PROPS (MXPPTS*MAXP),
     3                S     (MXPTS*4*3),
     4                VOL   (MXPTS),
     5                DTJ   (MXPTS),
     6                R     (MXNODE*3),
     7                QBC   (MXBCPT*MAXQ)
C
C     Dimensions of domains
C
      DIMENSION IDIM  (MXBLKS,MXLVLS),
     1          JDIM  (MXBLKS,MXLVLS),
     2          KDIM  (MXBLKS,MXLVLS)
C
C     Extra dimensions for input of grids
C
      DIMENSION IDIMIN(MXBLKS),
     1          JDIMIN(MXBLKS),
     2          KDIMIN(MXBLKS)
C
C     Offsets of domains used to calculate location in total storage
C     of Q,S,... of a given domain.
C     IOFFQN offset for previous time level storage for QN
C     IOFFQC offset for coarse grid storage for QCRS and RESCRS.
C     IOFQBC offset for multiple profile boundary condition segments
C
      DIMENSION IOFF  (MXBLKS,MXLVLS),
     1          IOFFS (MXBLKS,MXLVLS),
     2          IOFFQ (MXBLKS,MXLVLS),
     3          IOFFP (MXBLKS,MXLVLS),
     4          IOFFQN(MXBLKS,MXLVLS),
     5          IOFFQC(MXBLKS,MXLVLS),
     6          IOFQBC(MXPROF,MXLVLS)
C
C     Boundary condition data.
C     IBCPRF is re-ordered BC data to read in profile BC segments.
C
      DIMENSION IBCDAT(10,MXBCS,MXBLKS,MXLVLS),  NBCS(MXBLKS),
     1          IBCPRF(10,MXPROF,MXLVLS)
C
C     Cut (domain to domain communication) data.
C
      DIMENSION ICUTS (21,MXCUTS,MXLVLS)
      INTEGER   NCUTS
      CHARACTER*20 CUTNAM(MXCUTS)
C
C     Printout control data.
C     IPRINT, NPRINT control output at end of iteration cycle
C     IPRMON, NPRMON control output during iteration cycle
C
      DIMENSION IPRINT(10,MXPRT,MXBLKS), NPRINT(MXBLKS),
     1          IPRMON(10,MXPRT,MXBLKS), NPRMON(MXBLKS)
C
C     Data controlling PLOT3D output
C
      LOGICAL IFPLT3, BINPLT
C
C     Data controlling grid type
C
      LOGICAL GRDBIN
C
C     Data controlling the time integration
C
      DIMENSION NITS  (MXCFS), MGLVLS(MXCFS), ITSLVL(MXLVLS,MXCFS)
      DIMENSION RKALPH(MXSTAG)
C
C     Data controlling the accuracy and scheme used.
C
      DIMENSION IORDER(3,MXBLKS,MXLVLS,MXCFS),
     1          LIMIT (3,MXBLKS),
     2          RKAP  (3,MXBLKS),
     3          IFLUX (MXBLKS),
     4          ITORDR(3)
      LOGICAL   DIAG  (3,MXBLKS)
C
C     Data controlling the viscous/inviscid calculation
C
      LOGICAL   VISCOS(3,MXBLKS)
C
C     Data controlling calculation of delq
C
      DIMENSION IFDELQ(MAXQ)
C
C     Data controlling the turbulence model
C
      DIMENSION IMODEL(MAXMDL),
     1          IMODLX(MAXMDL)
C
C     Data controlling the specification of transition location
C
      DIMENSION ITRSEG(7,MXTRSG)
C
C     Storage for L2 Norms
C     For Perfect Gas:
C          R2NORM(1)   = L2 Norm of the mass conservation equation
C          R2NORM(2-4) = L2 Norm of the momentum equations
C          R2NORM(5)   = L2 Norm of the energy equation
C          R2NORM(6)   = L2 Norm of all equations
C     R2NORM  -> L2 Norm of transport equations (includes dQ/dt for iterative,
C                                                implicit scheme)
C     R2DQDT  -> L2 Norm of dQ/dt terms in iterative, implicit scheme
C
      DIMENSION R2NORM(MAXF+1),
     1          R2DQDT(MAXF+1),
     2          NBRPTS(MXLVLS)
C
C     Storage for forces
C     FORCE   -> Forces integrated in x, y, z directions
C     RCNTR   -> Location to calculate point vortex and moments about
C
      DIMENSION FORCE(3),
     1          RCNTR(3)
C
C     Data for diagnostic output
C
      REAL      RESMAX
      INTEGER   IFRSMX,
     1          IRESMX(0:3)
      INTEGER   NFIXQ (MAXQ),
     1          NRELIZ(MAXQ),
     2          NPRLIM,
     3          NPRNEG
      DIMENSION QMIN  (MAXQ)
      CHARACTER FIXTYP*7
C
C     STORAGE REQUIRED FOR RUNGE-KUTTA
C     Required on all zones/blocks for the size of the finest grid
C     N.B. This storage is not needed unless using the RK routine
C
      DIMENSION W     (MXRKPT*MAXQ)
C
C     STORAGE REQUIRED FOR MG FORCING FUNCTION AND STORED RESTRICTED Q
C     Required only for coarse grid levels
C
      DIMENSION QCRS  (MXCRS*MAXQ),
     1          RESCRS(MXCRS*MAXF)
C
C     STORAGE REQUIRED FOR A ZONE/BLOCK
C
C     Storage for residuals
C          For (RK, AF)     : store residual over entire block
C          For (LGS, MARCH) : store residuals over a plane of block
C
      DIMENSION RES   (MXSIZE*MAXF)
C
C     Storage for fluxes for fourth order
C
      DIMENSION FHAT  (MXSIZ4*MAXF)
C
C     Storage for MUSCL and flux evaluation
C
      DIMENSION DQP   (MXSECT*MAXQ),
     1          DQM   (MXSECT*MAXQ),
     2          QP    (MXSECT*MAXQ),
     3          QM    (MXSECT*MAXQ),
     4          TAU   (MXSECT*6),
     5          F     (MXSECT*MAXF),
     6          FM    (MXSECT*MAXF),
     7          STEMP (MXSECT*4),
     8          WORKX (MXSECT*MAXW)
C
C     Temporary storage for implicit terms
C          For (RK)         : not needed
C          For (AF3F)       : NPL * max(IDIM*JDIM, JDIM*KDIM)
C                             where NPL is the number of secondary
C                             planes to vectorize over
C          For (MARCH)      : ABC: JDIM*KDIM*2 (store LU of the current plane)
C                             RTEMP,AT: JDIM*KDIM
C
      DIMENSION ABC   (MXABC*MXRANK*MXRANK*3),
     1          RTEMP (MXABC*MXRANK),
     2          AT    (MXABC*MXRANK*MXRANK*3)
C
C     Temporary storage for the I contribution to the implicit scheme
C     for LGS and MARCH.
C
      DIMENSION RM    (MXRM*MXRANK*MXRANK)
C
C     Identity Matrix required in implicit work
C
      DIMENSION AI    (MXRANK*MXRANK)
C
C     Filenames
C     FRDRST  File to read restart from
C     FWRRST  File to write restart to
C     GRDFIL  Array of files to read grid from
C     FPLT3G  File to write PLOT3D Grid file to
C     FPLT3Q  File to write PLOT3D Q (conserved variables) to
C     FPLT3F  File to write PLOT3D function file to
C     FPLT3FN File to write PLOT3D function name file to
C     FPROFL  Array of files to read Profile boundary data from
C     FERROR  File name output if error
C
      CHARACTER*80 FRDRST, FWRRST, GRDFIL(MXBLKS),
     1             FPLT3G, FPLT3Q, FPLT3F, FPLT3FN, FPROFL(MXPROF),
     2             FERROR
C
C     Switches
C          RESTRT -> If true then do a restart
C          VGNRN  -> If true then use Vigneron technique when marching
C          CONTRB -> If true then converting turbulence models on restart
C          MRCHNG -> If true then use marching fluxes in residual
C          INITRS -> If true then initialize residuals to zero (used in MG)
C          IFL2DQ -> If true then calculate L2 norm of dQ/dt term (unsteady)
C          YNCALC -> If true then recalculate Y_normal on restart
C          IFMGFF -> If true then calculate the MG forcing function from the
C                    coarse grid residual in the MG cycle
C
      LOGICAL RESTRT, VGNRN, CONTRB, MRCHNG, INITRS, IFL2DQ, YNCALC,
     1        IFMGFF
C
C     Version Number for Output
C
      CHARACTER*22 VERSN
C
C     Local storage to output number of grid points
C
      DIMENSION NNODES(MXLVLS,2)
C
C 0.  PRELIMINARIES
C     Output Version Number
C
      VERSN  = '$Revision: 4.7 $'
      WRITE (IOUT,1200) VERSN
 1200 FORMAT (' ','ISAAC - ',A22,/)
C
C     Set switch to test for storage errors
C
      IERROR = 0
C
C     Set storage for IMODEL to maximum
C
      NMDL   = MAXMDL
C
C     Set storage for WORKX to maximum
C
      NW     = MAXW
C
C     Set up the Characteristic Array to define the characteristics
C     of the available flux evaluation schemes.
C
      IFCHAR(IFROE,1) = IFDS
C
C     Zero appropriate storage
C
      ITTOT = 0
C
C     Initialize time to zero
C
      TIME  = 0.E0
C
C     Initialize force coefficients
C
      CL    = 0.E0
      CD    = 0.E0
C
C 1.  READ INPUT
C     Read input data controlling the run
C
      NXQ    = MAXQ
      NXCFS  = MXCFS
      NXLVLS = MXLVLS
      NXBLKS = MXBLKS
      NXBCS  = MXBCS
      NXCUTS = MXCUTS
      NXPRT  = MXPRT
      NXSTAG = MXSTAG
      NXPROF = MXPROF
      NXSIZE = MXSIZE
      NXSECT = MXSECT
      NXPTS  = MXPTS
      NXPPTS = MXPPTS
      NXQNPT = MXQNPT
      NXTRSG = MXTRSG
      CALL RDDATA (NXQ, NXCFS, NXLVLS, NXBLKS, NXBCS, NXCUTS, NXPRT,
     1             NCFS, MGLVLS, NBLKS, IDIM, JDIM, KDIM,
     2             NBCS, IBCDAT, NCUTS, ICUTS, CUTNAM,
     3             NPRINT, IPRINT, NPRMON, IPRMON, NITMON,
     4             ITUPJ, ITSLVL, NITS, NSUBIT, NITFO, NITBBC, NITALG,
     5             NITRST, NXSTAG, NSTAGE, RKALPH,
     6             RESTRT, FRDRST, FWRRST, GRDFIL, IGRDTP, GRDBIN,
     7             NXPROF, NPROFL, FPROFL,
     8             IFPLT3, BINPLT, FPLT3G, FPLT3Q, FPLT3F, FPLT3FN,
     9             IORDER, LIMIT, RKAP, IFLUX, VISCOS, DIAG, IMODEL,
     A             IMSTRT, IMEND, TOLER, VGNRN, SIGMA, IFDELQ,
     B             CONTRB, IMODLX, QMIN, ITRSMX, IFFORC, IFRCPR,
     C             YNCALC, NXTRSG, NTRSEG, ITRSEG, RCNTR)
C
      ITURB = IMODEL( 1)
      IASM  = IMODEL(10)
C
C 2.  VERIFY INPUT
C
C     Check input data for BC, CUTS, Print statements
C
      CALL CHKDAT (NBLKS, IDIM, JDIM, KDIM, VISCOS,
     1             NXBCS, NBCS, IBCDAT, NCUTS, ICUTS, CUTNAM,
     2             NXPRT, NPRINT, IPRINT, IERRCD)
      IF (IERRCD .GT. INO) THEN
         IERROR = IERROR + 1
      ENDIF
C
C     Check to verify that NQ >= NP.  This is required due to temporary
C     arrays in DELQ routines.  If NP is ever greater than NQ, need to
C     change the temporary storage.
C
      IF (NP .GT. NQ) THEN
         WRITE (IOUT,8000)
         IERROR = IERROR + 1
      ENDIF
 8000 FORMAT (' ','MAIN  : ERROR-> NP is greater than NQ.',
     1       /' ',15X,'This is not allowed due to temporary storage',
     2       /' ',15X,'allocation in DELQ routines.',
     3       /' ',15X,'The temporary storage for PROPSI and PROPSC ',
     4       /' ',15X,'must be modified.')
C
C     Check the values of constants to make sure that the storage exists
C
      IF (NQ     .GT. MAXQ  ) THEN
         WRITE (IOUT,1505) NQ, MAXQ
         IERROR = IERROR + 1
      ENDIF
C
      IF (NF     .GT. MAXF  ) THEN
         WRITE (IOUT,1510) NF, MAXF
         IERROR = IERROR + 1
      ENDIF
C
      IF (NP     .GT. MAXP  ) THEN
         WRITE (IOUT,1515) NP, MAXP
         IERROR = IERROR + 1
      ENDIF
C
      IF (NRANK  .GT. MXRANK) THEN
         WRITE (IOUT,1520) NRANK, MXRANK
         IERROR = IERROR + 1
      ENDIF
C
      IF (NTMLVL .GT. MXTMLV) THEN
         WRITE (IOUT,1525) NTMLVL, MXTMLV
         IERROR = IERROR + 1
      ENDIF
C
 1505 FORMAT (/' ','MAIN  : Number of variables required  ',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MAXQ   and re-submit.')
 1510 FORMAT (/' ','MAIN  : Number of fluxes required     ',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MAXF   and re-submit.')
 1515 FORMAT (/' ','MAIN  : Number of properties required ',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MAXP   and re-submit.')
 1520 FORMAT (/' ','MAIN  : Size of matrices required     ',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MXRANK and re-submit.')
 1525 FORMAT (/' ','MAIN  : Number of time levels required',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MXTMLV and re-submit.')
C
C     Set up the identity matrix used in implicit terms
C
      CALL IDENT (AI)
C
C 3.  CALCULATE POINTERS
C     a. Calculate dimensions for coarser grids and offset pointers.
C     b. Calculate offset pointers and boundary data.
C     c. Calculate ICUTS  for coarser grids.
C     d. Verify coarse grid BC and CUT data
C     e. Set up IORDER for multigrid
C     f. Output grid summary
C
      NDSIZE = 0
      NDCRS  = 0
      NDSECT = 0
      NDRM   = 0
      NLVLS  = 1
      DO 10 ICFS = 1, NCFS
         ILVL = ICFS + MGLVLS(ICFS) - 1
         IF (ILVL .GT. NLVLS) NLVLS = ILVL
 10   CONTINUE
      IOFFT  = 0
      IOFFST = 0
      IOFFQT = 0
      IOFFPT = 0
      IOFQNT = 0
      IOFQCT = 0
C
C 3-a. Calculate dimensions for coarser grids and test allowable grid levels.
C
      MSTLVL = NLVLS
      DO 20 ILVL = 2, NLVLS
         DO 15 IBLK = 1, NBLKS
            IDIM(IBLK,ILVL) = IDIM(IBLK,ILVL-1) / 2 + 1
            JDIM(IBLK,ILVL) = JDIM(IBLK,ILVL-1) / 2 + 1
            KDIM(IBLK,ILVL) = KDIM(IBLK,ILVL-1) / 2 + 1
C
            IDIMF           = 2 * (IDIM(IBLK,ILVL) - 1) + 1
            JDIMF           = 2 * (JDIM(IBLK,ILVL) - 1) + 1
            IF (THREED) THEN
               KDIMF        = 2 * (KDIM(IBLK,ILVL) - 1) + 1
            ELSE
               KDIMF        = 2
            ENDIF
C
            IF (IDIMF .NE. IDIM(IBLK,ILVL-1) .OR.
     1          JDIMF .NE. JDIM(IBLK,ILVL-1) .OR.
     2          KDIMF .NE. KDIM(IBLK,ILVL-1) ) THEN
               MSTLVL = MIN (MSTLVL, (ILVL-1))
            ENDIF
   15    CONTINUE
   20 CONTINUE
C
      IF (NLVLS  .GT. MSTLVL) THEN
         WRITE (IOUT,1530) NLVLS, MSTLVL
         NLVLS = MSTLVL
      ENDIF
      IF (NCFS   .GT. NLVLS ) THEN
         WRITE (IOUT,1535) NCFS,  NLVLS
         NCFS  = NLVLS
      ENDIF
 1530 FORMAT (/' ','MAIN  : Number of grid levels requested ',I3,
     1             ' exceeds allowable ',I3,
     2        /' ', 8X,'=> Coarser levels are being deleted and ',
     3                 'run continuing.')
 1535 FORMAT (/' ','MAIN  : Number of coarsenings requested ',I3,
     1             ' exceeds allowable ',I3,
     2        /' ', 8X,'=> Coarsenings    are being deleted and ',
     3                 'run continuing.'//)
C
C      Verify all coarsenings fall within NLVLS number of grid levels
C
      DO 25 ICFS = 1, NCFS
         LVLTST = ICFS + MGLVLS(ICFS) - 1
         IF (LVLTST .GT. NLVLS) THEN
            MGLVLS(ICFS) = NLVLS - ICFS + 1
         ENDIF
   25 CONTINUE
C
C 3-b. Calculate offset pointers and boundary data.
C
      DO 50 ILVL = 1, NLVLS
         NBRPTS(ILVL) = 0
         DO 40 IBLK = 1, NBLKS
            IF (ILVL .NE. 1) THEN
C
C      Calculate storage required on coarser grids for forcing function
C
               NDCRS = NDCRS + (IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*
     1                         (KDIM(IBLK,ILVL)+3)
C
C      Calculate IBCDAT for coarser grids.
C
               DO 35 IBC = 1, NBCS(IBLK)
                  IBCDAT( 1,IBC,IBLK,ILVL)=IBCDAT(1,IBC,IBLK,ILVL-1)
                  IBCDAT( 2,IBC,IBLK,ILVL)=IBCDAT(2,IBC,IBLK,ILVL-1)
                  IBCDAT( 3,IBC,IBLK,ILVL)=IBCDAT(3,IBC,IBLK,ILVL-1)/2+1
                  IBCDAT( 4,IBC,IBLK,ILVL)=IBCDAT(4,IBC,IBLK,ILVL-1)/2+1
                  IBCDAT( 5,IBC,IBLK,ILVL)=IBCDAT(5,IBC,IBLK,ILVL-1)/2+1
                  IBCDAT( 6,IBC,IBLK,ILVL)=IBCDAT(6,IBC,IBLK,ILVL-1)/2+1
                  IBCDAT( 7,IBC,IBLK,ILVL)=IBCDAT(7,IBC,IBLK,ILVL-1)/2+1
                  IBCDAT( 8,IBC,IBLK,ILVL)=IBCDAT(8,IBC,IBLK,ILVL-1)/2+1
                  IBCDAT( 9,IBC,IBLK,ILVL)=IBCDAT(9,IBC,IBLK,ILVL-1)/2+1
                  IBCDAT(10,IBC,IBLK,ILVL)=IBCDAT(10,IBC,IBLK,ILVL-1)
   35          CONTINUE
            ENDIF
            NBRPTS(ILVL) = NBRPTS(ILVL) + (IDIM(IBLK,ILVL)-1)*
     1                          (JDIM(IBLK,ILVL)-1)*(KDIM(IBLK,ILVL)-1)
            IOFF  (IBLK,ILVL) = IOFFT
            IOFFS (IBLK,ILVL) = IOFFST
            IOFFQ (IBLK,ILVL) = IOFFQT
            IOFFP (IBLK,ILVL) = IOFFPT
            IOFFQN(IBLK,ILVL) = IOFQNT
            IOFFQC(IBLK,ILVL) = IOFQCT
            IOFFT  = IOFFT  + IDIM(IBLK,ILVL)*JDIM(IBLK,ILVL)*
     1                        KDIM(IBLK,ILVL)
            IOFFST = IOFFST + (IDIM(IBLK,ILVL)+2)*(JDIM(IBLK,ILVL)+2)*
     1                        (KDIM(IBLK,ILVL)+2)
            IOFFQT = IOFFQT + (IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*
     1                        (KDIM(IBLK,ILVL)+3)
            IF (ILVL .NE. 1) THEN
               IOFQCT = IOFQCT+(IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*
     1                        (KDIM(IBLK,ILVL)+3)
            ENDIF
C
            NDSIZE = MAX(NDSIZE,(IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*
     1                          (KDIM(IBLK,ILVL)+3))
            NDSECT = MAX(NDSECT,(IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3))
            NDSECT = MAX(NDSECT,(JDIM(IBLK,ILVL)+3)*(KDIM(IBLK,ILVL)+3))
C
            IF (ISOLVR .EQ. ILGS .OR. ISOLVR .EQ. IMARCH) THEN
               NDRM  = MAX(NDRM,(JDIM(IBLK,ILVL)-1)*(KDIM(IBLK,ILVL)-1))
            ELSE
               NDRM  = 0
            ENDIF
C
C     If running inviscid case (ITURB < ITLMNR), then don't
C     increment the pointer to the PROPS array.  This allows to not
C     store this data for the inviscid case to cut down on memory.
C
            INCP   = (IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*
     1               (KDIM(IBLK,ILVL)+3)
            IF (ITURB .LT. ITLMNR) THEN
               INCP = 0
            ENDIF
            IOFFPT = IOFFPT + INCP
C
C     If running steady case, then don't increment pointer to previous
C     time level data to allow minimum memory configuration for steady cases.
C
            INCQN  = (IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*
     1               (KDIM(IBLK,ILVL)+3)
            IF (ITIMED .EQ. ISTDY) THEN
               INCQN = 0
            ENDIF
            IOFQNT = IOFQNT + INCQN
   40    CONTINUE
C
C 3-c. Calculate ICUTS  for coarser grids.
C
         IF (ILVL .NE. 1) THEN
            DO 45 ICUT = 1, NCUTS
               ICUTS( 1,ICUT,ILVL) = ICUTS( 1,ICUT,ILVL-1)
               ICUTS( 2,ICUT,ILVL) = ICUTS( 2,ICUT,ILVL-1)
               ICUTS( 3,ICUT,ILVL) = ICUTS( 3,ICUT,ILVL-1) / 2 + 1
               ICUTS( 4,ICUT,ILVL) = ICUTS( 4,ICUT,ILVL-1) / 2 + 1
               ICUTS( 5,ICUT,ILVL) = ICUTS( 5,ICUT,ILVL-1) / 2 + 1
               ICUTS( 6,ICUT,ILVL) = ICUTS( 6,ICUT,ILVL-1) / 2 + 1
               ICUTS( 7,ICUT,ILVL) = ICUTS( 7,ICUT,ILVL-1) / 2 + 1
               ICUTS( 8,ICUT,ILVL) = ICUTS( 8,ICUT,ILVL-1) / 2 + 1
               ICUTS( 9,ICUT,ILVL) = ICUTS( 9,ICUT,ILVL-1) / 2 + 1
               ICUTS(10,ICUT,ILVL) = ICUTS(10,ICUT,ILVL-1)
               ICUTS(11,ICUT,ILVL) = ICUTS(11,ICUT,ILVL-1)
               ICUTS(12,ICUT,ILVL) = ICUTS(12,ICUT,ILVL-1) / 2 + 1
               ICUTS(13,ICUT,ILVL) = ICUTS(13,ICUT,ILVL-1) / 2 + 1
               ICUTS(14,ICUT,ILVL) = ICUTS(14,ICUT,ILVL-1) / 2 + 1
               ICUTS(15,ICUT,ILVL) = ICUTS(15,ICUT,ILVL-1) / 2 + 1
               ICUTS(16,ICUT,ILVL) = ICUTS(16,ICUT,ILVL-1) / 2 + 1
               ICUTS(17,ICUT,ILVL) = ICUTS(17,ICUT,ILVL-1) / 2 + 1
               ICUTS(18,ICUT,ILVL) = ICUTS(18,ICUT,ILVL-1) / 2 + 1
               ICUTS(19,ICUT,ILVL) = ICUTS(19,ICUT,ILVL-1)
               ICUTS(20,ICUT,ILVL) = ICUTS(20,ICUT,ILVL-1)
               ICUTS(21,ICUT,ILVL) = ICUTS(21,ICUT,ILVL-1)
   45       CONTINUE
         ENDIF
   50 CONTINUE
C
C 3-d. Verify coarse grid BC and CUT data
C
      IF (NLVLS .GT. 1) THEN
         CALL CHKCRS (NLVLS,  NXBLKS, NBLKS,  IDIM, JDIM, KDIM,
     1                NXBCS,  NBCS,   IBCDAT,
     2                NXCUTS, NCUTS,  ICUTS,  CUTNAM, IERRCD)
         IF (IERRCD .GT. INO) THEN
            IERROR = IERROR + 1
         ENDIF
      ENDIF
C
C 3-e. Set up IORDER for multigrid
C
      IHIGH = 2
      ILOW  = 1
      IF (FOURTH) THEN
         IHIGH = 4
         ILOW  = 4
      ENDIF
C
      DO IBLK = 1, NBLKS
         DO ICFS = 1, NCFS
            LVLONE = NCFS - ICFS + 1
            DO ILVL = 1, NLVLS
               IF (ILVL .EQ. LVLONE) THEN
                  IORDER(1,IBLK,ILVL,ICFS) = IHIGH
                  IORDER(2,IBLK,ILVL,ICFS) = IHIGH
                  IORDER(3,IBLK,ILVL,ICFS) = IHIGH
               ELSE
                  IORDER(1,IBLK,ILVL,ICFS) = ILOW
                  IORDER(2,IBLK,ILVL,ICFS) = ILOW
                  IORDER(3,IBLK,ILVL,ICFS) = ILOW
               ENDIF
            END DO
         END DO
      END DO
C
C 3-f. Output grid summary
C
      WRITE (IOUT,1540) (ILVL, ILVL = 1, NLVLS)
      DO ILVL = 1, NLVLS
         NNODES(ILVL,2) = 0
      END DO
C
      DO IBLK = 1, NBLKS
         DO ILVL = 1, NLVLS
            IF (THREED) THEN
               K = KDIM(IBLK,ILVL)
            ELSE
               K = 1
            ENDIF
            NNODES(ILVL,1) = IDIM(IBLK,ILVL) * JDIM(IBLK,ILVL) * K
            NNODES(ILVL,2) = NNODES(ILVL,2) + NNODES(ILVL,1)
         END DO
         WRITE (IOUT,1541) IBLK,IDIM(IBLK,1),JDIM(IBLK,1),KDIM(IBLK,1),
     1                     (NNODES(ILVL,1), ILVL = 1, NLVLS)
      END DO
      WRITE (IOUT,1542) (NNODES(ILVL,2), ILVL = 1, NLVLS)
      WRITE (IOUT,1543)
C
 1540 FORMAT (///' ','Grid Summary',
     1          /' ',27X,'Number of Grid Points by Mesh Level',
     2          /' ',11X,'IDIM',1X,'JDIM',1X,'KDIM',6(5x,I2,2X))
 1541 FORMAT (   ' ','Block ',I3,':',3I5,6(1X,I8))
 1542 FORMAT (  /' ','Total ',19X,6(1X,I8))
 1543 FORMAT (///' ')
C
C 4.  VERIFY STORAGE
C     Verify sufficient storage available or STOP
C
      IF (IOFFQT .GT. MXPTS ) THEN
         WRITE (IOUT,1000) IOFFQT, MXPTS
         IERROR = IERROR + 1
      ENDIF
C
      IF (IOFFPT .GT. MXPPTS) THEN
         WRITE (IOUT,1001) IOFFPT, MXPPTS
         IERROR = IERROR + 1
      ENDIF
C
      IF (IOFQNT .GT. MXQNPT) THEN
         WRITE (IOUT,1002) IOFQNT, MXQNPT
         IERROR = IERROR + 1
      ENDIF
C
      IF (NDSIZE .GT. MXSIZE) THEN
         WRITE (IOUT,1003) NDSIZE, MXSIZE
         IERROR = IERROR + 1
      ENDIF
C
      IF (NDCRS  .GT. MXCRS ) THEN
         WRITE (IOUT,1004) NDCRS , MXCRS
         IERROR = IERROR + 1
      ENDIF
C
      IF (NDSECT .GT. MXSECT) THEN
         WRITE (IOUT,1005) NDSECT, MXSECT
         IERROR = IERROR + 1
      ENDIF
C
      IF (NDRM   .GT. MXRM  ) THEN
         WRITE (IOUT,1006) NDRM, MXRM
         IERROR = IERROR + 1
      ENDIF
C
      IF (FOURTH) THEN
         IF (NDSIZE .GT. MXSIZ4) THEN
            WRITE (IOUT,1007) NDSIZE, MXSIZ4
            IERROR = IERROR + 1
         ENDIF
      ENDIF
C
      IF (IERROR .GT. 0    ) THEN
         WRITE (IOUT,1009) IERROR
         STOP
      ENDIF
C
 1000 FORMAT (/' ','MAIN  : Storage required for Q variables  ',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXPTS  in MAIN and re-submit.')
 1001 FORMAT (/' ','MAIN  : Storage required for PROPS        ',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXPPTS in MAIN and re-submit.')
 1002 FORMAT (/' ','MAIN  : Storage required for QN           ',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXQNPT in MAIN and re-submit.')
 1003 FORMAT (/' ','MAIN  : Storage required for RES          ',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXSIZE in MAIN and re-submit.')
 1004 FORMAT (/' ','MAIN  : Storage required for RESCRS       ',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXCRS  in MAIN and re-submit.')
 1005 FORMAT (/' ','MAIN  : Storage required for cross-section',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXSECT in MAIN and re-submit.')
 1006 FORMAT (/' ','MAIN  : Storage required for RM array     ',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXRM   in MAIN and re-submit.')
 1007 FORMAT (/' ','MAIN  : Storage required for FHAT 4th ordr',
     1             I9,' exceeds allocated ',I9,
     2        /' ', 8X,'=> Increase MXSIZ4 in MAIN and re-submit.')
 1009 FORMAT (/' ','MAIN  : Storage or input errors have occured = ',I3,
     1        /' ', 8X,'Please fix and re-submit.',
     2        /' ', 8X,'RUN ABORTING!')
C
C 5.  INPUT GRID
C     a. Read in grid for all blocks.
C     b. Loop over cuts and check the validity of the grid cuts
C     c. Extend each block grid from 1:DIM,... to 0:DIM+1,... and calculate
C        coarser grids as every other grid point from next finer grid.
C     d. Loop over cuts on all levels blocks to set image points of the grid.
C     e. Calculate metrics and volumes, reset volumes to be non-zero for
C        boundary conditions that do not lie on a face
C
C 5-a. Read in grid for all blocks, finest grid level.
C
      CALL RDGRID (NBLKS, IDIM, JDIM, KDIM, IOFFS, GRDFIL, R,
     1             IDIMIN, JDIMIN, KDIMIN, IGRDTP, GRDBIN, IEOF, IERRCD)
      IF (IEOF .NE. INO .OR. IERRCD .NE. INO) THEN
         STOP
      ENDIF
C
C 5-b. Loop over cuts and check the validity of the grid cuts
C
      IERRCD = INO
      ILVL   = 1
      DO 55 ICUT = 1, NCUTS
         IBLK1 = ICUTS( 1,ICUT,ILVL)
         IBLK2 = ICUTS(10,ICUT,ILVL)
         IR1   = IOFFS(IBLK1,ILVL) * 3    + 1
         IR2   = IOFFS(IBLK2,ILVL) * 3    + 1
         CALL CHKCUT (IBLK1, IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     1                KDIM(IBLK1,ILVL), R(IR1),
     2                IBLK2, IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     3                KDIM(IBLK2,ILVL), R(IR2), ICUTS(1,ICUT,ILVL),
     4                CUTNAM(ICUT), IERRCD)
   55 CONTINUE
      IF (IERRCD .NE. INO) THEN
         STOP
      ENDIF
C
C 5-c. Extend each block grid and calculate coarser meshes.
C
      DO 65 IBLK = 1, NBLKS
         ILVL = 1
         IR   = IOFFS(IBLK,ILVL) * 3     + 1
         CALL GDXTND (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                KDIM(IBLK,ILVL), R(IR))
C
         DO 60 ILVL = 2, NLVLS
            IRF  = IOFFS(IBLK,ILVL-1) * 3   + 1
            IR   = IOFFS(IBLK,ILVL  ) * 3   + 1
            CALL CRSGRD (IDIM(IBLK,ILVL-1), JDIM(IBLK,ILVL-1),
     1                   KDIM(IBLK,ILVL-1), R(IRF),
     2                   IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     3                   KDIM(IBLK,ILVL), R(IR))
            CALL GDXTND (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), R(IR))
 60      CONTINUE
 65   CONTINUE
C
C 5-d. Loop over cuts setting grid image points
C
      DO 75 ILVL = 1, NLVLS
         DO 70 ICUT = 1, NCUTS
            IBLK1 = ICUTS( 1,ICUT,ILVL)
            IBLK2 = ICUTS(10,ICUT,ILVL)
            IR1   = IOFFS(IBLK1,ILVL) * 3    + 1
            IR2   = IOFFS(IBLK2,ILVL) * 3    + 1
            CALL GRDCUT (IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     1                   KDIM(IBLK1,ILVL), R(IR1),
     2                   IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     3                   KDIM(IBLK2,ILVL), R(IR2), ICUTS(1,ICUT,ILVL))
   70    CONTINUE
   75 CONTINUE
C
C 5-e. Calculate metrics and volumes and reset volumes for some bcs.
C      Reset interior volumes on coarser meshes to be the collection of the
C      fine grid volumes to ensure that the coarse grid transfer operator
C      generates a smooth and accurate coarse grid representation of the fine
C      grid solution.
C
      IERRCD = INO
      DO 85 IBLK = 1, NBLKS
         DO 80 ILVL = 1, NLVLS
            IR   = IOFFS(IBLK,ILVL) * 3     + 1
            IS   = IOFFS(IBLK,ILVL) * 4 * 3 + 1
            IV   = IOFFS(IBLK,ILVL)         + 1
            CALL METRIC (IBLK, ILVL, IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), R(IR), S(IS), VOL(IV), IERRCD)
            CALL METBC  (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), S(IS), VOL(IV),
     2                   NBCS(IBLK), IBCDAT(1,1,IBLK,ILVL))
            IF (ILVL .GT. 1) THEN
               IVF  = IOFFS(IBLK,ILVL-1)    + 1
               CALL COLV2H (IDIM(IBLK,ILVL-1), JDIM(IBLK,ILVL-1),
     1                      KDIM(IBLK,ILVL-1), VOL(IVF),
     2                      IDIM(IBLK,ILVL),   JDIM(IBLK,ILVL),
     3                      KDIM(IBLK,ILVL),   VOL(IV),  QP)
            ENDIF
   80    CONTINUE
   85 CONTINUE
      IF (IERRCD .NE. INO) THEN
         STOP
      ENDIF
C
C 6.  INITIALIZATION
C     Initialize each block and each grid level to freestream.
C     Initialize each block and each grid level properties.
C     Initialize each block and each grid level at additional time levels.
C     Initialize each block and each grid level wall functions.
C
      DO 100 ILVL = 1, NLVLS
         DO 90 IBLK = 1, NBLKS
            IQ  = IOFFQ(IBLK,ILVL) * NQ    + 1
            IV  = IOFFS(IBLK,ILVL)         + 1
            CALL INIT   (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), Q(IQ), ITURB)
C
            IF (IASM   .EQ. IASMGS) THEN
               IP  = IOFFP(IBLK,ILVL) * NP    + 1
               CALL INITPR (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                      KDIM(IBLK,ILVL), PROPS(IP), ITURB)
            ENDIF
C
            IF (ITIMED .EQ. IUNSTD) THEN
               IQN    = IOFFQN(IBLK,ILVL) * NQ * NTMLVL + 1
               CALL INITQN (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                      KDIM(IBLK,ILVL), Q(IQ), QN(IQN),
     2                      QP, QM, IMODEL)
            ENDIF
C
            IF (IFWALF) THEN
               IP  = IOFFP(IBLK,ILVL) * NP    + 1
               CALL INITTQ (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                      KDIM(IBLK,ILVL), PROPS(IP),
     2                      NBCS(IBLK), IBCDAT(1,1,IBLK,ILVL))
            ENDIF
  90     CONTINUE
 100  CONTINUE
C
C     Loop over all boundary conditions to check for a PROFILE or
C     SUBSONIC PROFILE bc, then read in the boundary data for the
C     PROFILE or SUBSONIC PROFILE bcs on the fine grid
C     and calculate the coarsened profile data for coarse grids.
C     Set all offsets to zero in case there are no profile boundary segments.
C     i.  Re-order profile BC segment data based on profile number
C     ii. Loop over all profile segments in order and calculate offsets,
C         read in profile data and coarsen data
C
C     i.  Re-order profile BC segment data based on profile number
C
      DO 115 IBLK = 1, NBLKS
         DO 110 IBC = 1, NBCS(IBLK)
            IBCTYP = IBCDAT(1,IBC,IBLK,1)
            IF (IBCTYP .EQ. IPROFL .OR. IBCTYP .EQ. IPROSB) THEN
               INPROF = IBCDAT(10,IBC,IBLK,1)
               DO 105 ILVL = 1, NLVLS
                  DO 104 L = 1, 10
                     IBCPRF(L,INPROF,ILVL) = IBCDAT(L,IBC,IBLK,ILVL)
  104             CONTINUE
  105          CONTINUE
            ENDIF
  110    CONTINUE
  115 CONTINUE
C
C     ii. Loop over all profile segments in order and calculate offsets,
C         read in profile data and coarsen data
C
      NDBCPT = 0
      IERRCD = INO
      IERRC2 = INO
      DO 125 ILVL = 1, NLVLS
         IOFQBC(1,ILVL) = 0
         DO 120 INPROF = 1, NPROFL
            ISTRT  = IBCPRF( 4,INPROF,ILVL)
            IEND   = IBCPRF( 5,INPROF,ILVL)
            JSTRT  = IBCPRF( 6,INPROF,ILVL)
            JEND   = IBCPRF( 7,INPROF,ILVL)
            KSTRT  = IBCPRF( 8,INPROF,ILVL)
            KEND   = IBCPRF( 9,INPROF,ILVL)
C
            IOFQBC(INPROF,ILVL) = NDBCPT
            IQBC   = IOFQBC(INPROF,ILVL) * NQ + 1
C
            NPTS   = (IEND-ISTRT+1) * (JEND-JSTRT+1) *
     1               (KEND-KSTRT+1)
            NDBCPT = NDBCPT + NPTS
C
            IF (NDBCPT .GT. MXBCPT) THEN
               IERRCD = IYES
            ENDIF
C
            IF (IERRCD .EQ. INO) THEN
               IF (ILVL .EQ. 1) THEN
                  WRITE (IOUT,1410) FPROFL(INPROF)
                  FERROR = FPROFL(INPROF)
                  LOCATION=1 !DJB
                  OPEN (IRDBC,FILE=FPROFL(INPROF),STATUS='OLD',
     1                        FORM='FORMATTED',ERR=990)
                  CALL RDPRFL (NPTS, QBC(IQBC),
     2                         IBCPRF(1,INPROF,ILVL), IERRC2)
               ELSE
                  ISTRTF  = IBCPRF( 4,INPROF,ILVL-1)
                  IENDF   = IBCPRF( 5,INPROF,ILVL-1)
                  JSTRTF  = IBCPRF( 6,INPROF,ILVL-1)
                  JENDF   = IBCPRF( 7,INPROF,ILVL-1)
                  KSTRTF  = IBCPRF( 8,INPROF,ILVL-1)
                  KENDF   = IBCPRF( 9,INPROF,ILVL-1)
                  NPTSF   = (IENDF-ISTRTF+1) * (JENDF-JSTRTF+1) *
     1                      (KENDF-KSTRTF+1)
                  IQBCF   = IOFQBC(INPROF,ILVL-1) * NQ + 1
                  CALL CRSPRF (NPTSF, QBC(IQBCF),
     1                         IBCPRF(1,INPROF,ILVL-1),
     2                         NPTS,  QBC(IQBC),
     3                         IBCPRF(1,INPROF,ILVL), IERRCD)
               ENDIF
            ENDIF
  120    CONTINUE
  125 CONTINUE
C
      IF (IERRCD .NE. INO) THEN
         WRITE (IOUT,1420) NDBCPT, MXBCPT
      ENDIF
C
      IF (IERRCD .NE. INO .OR. IERRC2 .NE. INO) THEN
         STOP
      ENDIF
C
 1410 FORMAT (//' ','MAIN  : Reading input profile from the file:',
     1         /' ',10X,A80)
 1420 FORMAT (' ','MAIN  : ERROR-> Number of boundary points  ',I10,
     1       /' ','                exceeds allocated (MXBCPT) ',I10,
     2       /' ','        Increase MXBCPT in MAIN and resubmit.',
     3       /' ', 8X,'RUN ABORTING!')
C
C 7.  RESTART
C     If this is a restart solution, then read in restart data.
C     The logic here is a little confusing so pay attention:
C     (The restart/conversion process plays with NQ, NP.  It must reset NQ, NP
C      to be the correct value before leaving this section)
C
C     Begin{Restart/Conversion}
C        Open Files
C        Set NQTO,NFTO, NPTO         <- the number of variables of TO
C                                       turbulence model
C                                       (this is NQ,NP as set in RDDATA)
C        Set NQFROM,NFFROM,NPFROM    <- the number of variables of FROM
C                                       turbulence model
C        Set NQ <- NQFROM, NF <- NFFROM, NP <- NPFROM
C        For Each Block
C           If NORMAL Restart ( .not. contrb )
C              begin
C                 1. Read restart data into Q, PROPS
C                 2. If unsteady, convert QN to conserved variables
C                    N.B. storage for tke in convert is over entire block!
C              end
C           Else (doing a restart with turbulence model conversion)
C              begin
C                 1. Read restart data of NQFROM variables  into RES,
C                                         NPFROM properties into W
C                    (RES is dimensioned  to hold 1 block of Q,
C                     W   is large enough to hold 1 block of PROPS)
C                 2. Call conversion routine to convert from one turbulence
C                    model to another.  Returns the new model in Q, PROPS.
C                    Note: The PROPS will be updated after this section.
C                 3. If unsteady, output error as this is not yet supported
C              end
C           Endif
C        Next Block
C        Set NQ <- NQTO, NF <- NFTO, NP <- NPTO
C        Close Files
C     End{Restart/Conversion}
C
      IF ( RESTRT ) THEN
         WRITE (IOUT,1500)
 1500 FORMAT (' ','MAIN  : Reading Restart File'/)
         FERROR = FRDRST
                  LOCATION=2 !DJB
         OPEN (IRDRST,FILE=FRDRST,STATUS='OLD',FORM='UNFORMATTED',
     1                ERR=990)
         REWIND (IRDRST)
C
         NQTO   = NQ
         NFTO   = NF
         NPTO   = NP
C
         IF ( .NOT. CONTRB ) THEN
            NQFROM = NQ
            NFFROM = NF
            NPFROM = NP
         ELSE
            ITURBX = IMODLX( 1)
            IF (ITURBX .EQ. ITLMNR .OR. ITURBX .EQ. ITBLMX) THEN
               NQFROM =  5
               NFFROM =  5
               NPFROM =  5
            ELSE IF (ITURBX .EQ. ITKE .OR. ITURBX .EQ. ITKW) THEN
               NQFROM =  7
               NFFROM =  7
               NPFROM =  5
            ELSE IF (ITURBX .EQ. ITRS) THEN
               NQFROM = 12
               NFFROM = 12
               NPFROM =  5
            ELSE
               WRITE (IOUT,1600) ITURBX
 1600 FORMAT (' ','MAIN  : ERROR-> Invalid FROM turbulence model = ',I5,
     1       /' ', 8X,'RUN ABORTING!')
               STOP
            ENDIF
         ENDIF
C
C     Now reset NQ, NF, NP to be NQFROM, NFFROM, NPFROM
C
         NQ     = NQFROM
         NF     = NFFROM
         NP     = NPFROM
C
C     Loop over all grid levels that are written in the restart file
C
         ILVL = 1
  130    CONTINUE
         DO 135 IBLK = 1, NBLKS
            IQ  = IOFFQ (IBLK,ILVL) * NQTO          + 1
            IQN = IOFFQN(IBLK,ILVL) * NQTO * NTMLVL + 1
            IP  = IOFFP (IBLK,ILVL) * NPTO          + 1
            IS  = IOFFS (IBLK,ILVL) * 4 * 3         + 1
            IV  = IOFFS (IBLK,ILVL)                 + 1
            IF ( .NOT. CONTRB ) THEN
               CALL RDREST (ITURB , IBLK, ILVL, IDIM(IBLK,ILVL),
     1                      JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     2                      Q(IQ), QN(IQN), PROPS(IP), IEOF, IERRCD)
C
               IF (IEOF   .EQ. IYES) THEN
                  GO TO 139
               ENDIF
               IF (IERRCD .NE. INO ) THEN
                  WRITE (IOUT,1545)
 1545 FORMAT (' ','MAIN  : ERROR-> Error in restart grid level ',I3,
     1       /' ', 8X,'RUN ABORTING!')
                  STOP
               ENDIF
C
               IF (ITIMED .EQ. IUNSTD) THEN
                  IF (INITTD) THEN
                     IQ    = IOFFQ (IBLK,ILVL) * NQ          + 1
                     IQN   = IOFFQN(IBLK,ILVL) * NQ * NTMLVL + 1
                     CALL INITQN (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                            KDIM(IBLK,ILVL), Q(IQ), QN(IQN),
     2                            QP, QM, IMODEL)
                  ELSE
                     NNPTS = (IDIM(IBLK,ILVL)+3) * (JDIM(IBLK,ILVL)+3) *
     1                       (KDIM(IBLK,ILVL)+3) * (NTIME-1)
                     CALL CONP2C (ITURB, NNPTS, QN(IQN), RES)
                  ENDIF
               ENDIF
C
            ELSE
               ITURBX = IMODLX( 1)
               CALL RDREST (ITURBX, IBLK, ILVL, IDIM(IBLK,ILVL),
     1                      JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     2                      RES,   QN(IQN), W, IEOF, IERRCD)
C
               IF (IEOF   .EQ. IYES) THEN
                  GO TO 139
               ENDIF
               IF (IERRCD .NE. INO ) THEN
                  STOP
               ENDIF
               IF (ITIMED .EQ. IUNSTD) THEN
                  WRITE (IOUT,1555)
 1555 FORMAT (' ','MAIN  : ERROR-> Conversion of unsteady calculation ',
     1            'is not supported.',
     2       /' ', 8X,'RUN ABORTING!')
                  STOP
               ENDIF
C
C     Temporary variables passed to the conversion routine
C         QP     for QC (variables in one-dimensional array)
C         FM     for PROPSC (properties in one-dimensional array - this is
C                            passed in using FM.  Must always be sure that
C                            NP <= NQ or else will need to fix this)
C         QM     for DQDX (derivatives of Q in x direction at cell centers)
C         DQP    for DQDY (derivatives of Q in y direction at cell centers)
C         DQM    for DQDZ (derivatives of Q in z direction at cell centers)
C
               WRITE (IOUT,1550)
 1550 FORMAT (/' ','MAIN  : Converting Solution to New Turbulence ',
     1             'Model')
               CALL CONVRT (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                      KDIM(IBLK,ILVL),
     2                      IMODLX, RES,   W,         NQFROM, NPFROM,
     3                      IMODEL, Q(IQ), PROPS(IP), NQTO,   NPTO,
     4                      S(IS), VOL(IV),
     5                      QP, FM, QM, DQP, DQM, TAU, F,
     6                      IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK), IFDELQ)
            ENDIF
  135    CONTINUE
C
C     Output message, Increment grid level counter, Return to read next
C     coarser grid.
C     Do not read coarser grids if current run does not require it.
C
         WRITE (IOUT,1570) ILVL
 1570 FORMAT (' ','MAIN  :         Read Restart Grid Level ',I3)
         ILVL = ILVL + 1
         IF (ILVL .GT. NLVLS) GO TO 139
         GO TO 130
C
C     Finished reading all grid levels
C
  139    CONTINUE
         WRITE (IOUT,*)
C
C     Now reset NQ, NF, NP back to NQTO, NFTO, NPTO
C
         NQ     = NQTO
         NF     = NFTO
         NP     = NPTO
         CLOSE (IRDRST)
C
C     Check that ITTOT + NITS(all mesh sequences) is less than MXHIST
C
         NITTOT = ITTOT
         DO 138 ICFS = 1, NCFS
            NITTOT = NITTOT + NITS(ICFS)
  138    CONTINUE
         IF (NITTOT .GT. MXHIST) THEN
            WRITE (IOUT,1580) NITTOT, MXHIST
            STOP
         ENDIF
      ENDIF
 1580 FORMAT (' ','MAIN  : ERROR-> Length of residual history    ',
     1            ' (ITTOT + NITS)      ',I6,
     2       /' ',15X,' exceeds maximum allocated      (MXHIST ',
     3            'in hstry.h) ',I6,
     4       /' ',15X,' Increase MXHIST to be greater than ',
     5                'ITTOT + NITS and recompile.',
     6       /' ', 8X,'RUN ABORTING!')
C
C 8.  CALCULATE YNORML
C     a. Calculate y_normal for initial run or if user forces
C     b. Calculate R(cell centers);
C        Set y_normal = abs(y_normal) to allow for re-setting of transition
C        locations
C     c. Set y_normal = - (y_normal) to specify transition location
C     d. If RESTART calculate forces if needed for the 2D farfield vortex bc
C
C 8-a. Calculate y_normal - Do not recalculate if restarting, unless
C      user forces from input.
C         Use DTJ as temporary storage for y_normal.
C
      IF ( (ITURB .GE. ITLMNR .AND. (.NOT. RESTRT))
     1     .OR. YNCALC ) THEN
         NXNODE = MXNODE
         CALL YNORM  (NXLVLS, NXBLKS, NXBCS, NXPPTS, NXNODE,
     1                IOFFS, IOFFP,
     2                NLVLS,  NBLKS,  NBCS,  IBCDAT,
     3                IDIM, JDIM, KDIM, R, PROPS, DTJ)
      END IF
C
C 8-b. Calculate R(Cell Centers); Set y_normal = abs(y_normal)
C      Set R to contain position vector of cell center for the normal dependent
C      source terms of the Reynolds stress turbulent models.  R(cell centers)
C      is also needed in the output subroutine.
C      Use RES as temporary storage of one block, then copy the R(cell centers)
C      back into R.
C
      DO 88 ILVL = 1, NLVLS
         DO 87 IBLK = 1, NBLKS
            IR   = IOFFS(IBLK,ILVL) * 3     + 1
            CALL RCENTR (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), R(IR), RES,
     2                   IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK))
            CALL RCCOPY (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), RES, R(IR))
C
            IP   = IOFFP(IBLK,ILVL) * NP    + 1
            NPTS = (IDIM(IBLK,ILVL)+3) * (JDIM(IBLK,ILVL)+3) *
     1             (KDIM(IBLK,ILVL)+3)
            CALL YNABS  (NPTS, PROPS(IP))
   87    CONTINUE
   88 CONTINUE
C
C 8-c. Set y_normal = - (y_normal) to specify transition location
C      Coarsen and set for all mesh levels
C N.B. This destroys the information in the ITRSEG array.
C
      DO ISEG = 1, NTRSEG
         IBLK = ITRSEG(1,ISEG)
         ILVL = 1
         IP   = IOFFP(IBLK,ILVL) * NP    + 1
         CALL YNTRAN (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                KDIM(IBLK,ILVL), PROPS(IP), ITRSEG(1,ISEG))
         DO ILVL = 2, NLVLS
            DO L = 2, 7
               ITRSEG(L,ISEG) = ITRSEG(L,ISEG) / 2 + 1
            END DO
            IP   = IOFFP(IBLK,ILVL) * NP    + 1
            CALL YNTRAN (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), PROPS(IP), ITRSEG(1,ISEG))
         END DO
      END DO
C
C 8-d. If RESTART then calculate forces if needed for the 2D farfield vortex bc
C      Calculate forces on the grid level to begin the restart on.
C
      IF (RESTRT) THEN
         ILVL = NCFS
         IF (IFFORC .EQ. IYES) THEN
            CALL FRCINT (ITURB,NBLKS,IDIM(1,ILVL),
     1                   JDIM(1,ILVL),  KDIM(1,ILVL),
     2                   IOFF(1,ILVL),  IOFFS(1,ILVL),
     3                   IOFFQ(1,ILVL), IOFFP(1,ILVL),
     4                   Q, PROPS, S, R, NXBCS, NBCS,
     5                   IBCDAT(1,1,1,ILVL), FORCE, CL, CD)
         ENDIF
      ENDIF
C
C 9.  INITIALIZE PROPERTIES
C     Initialize the PROPERTIES array.
C     Use QP, QM, F and DQP as temporary arrays.
C
      DO 150 ILVL = 1, NLVLS
         DO 140 IBLK = 1, NBLKS
            IQ = IOFFQ(IBLK,ILVL) * NQ    + 1
            IP = IOFFP(IBLK,ILVL) * NP    + 1
            IS = IOFFS(IBLK,ILVL) * 4 * 3 + 1
            IV = IOFFS(IBLK,ILVL)         + 1
            IPSTRT = 1
            IPEND  = IDIM(IBLK,ILVL) + 1
            IF (ITURB .GE. ITLMNR) THEN
               CALL PRPRTY (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                      KDIM(IBLK,ILVL), IPSTRT, IPEND, MXSECT,
     2                      Q(IQ), PROPS(IP), S(IS), VOL(IV),
     3                      IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     4                      IMODEL, IFDELQ,
     5                      STEMP, QP, F, FM, QM, DQP, DQM, WORKX)
            ENDIF
  140    CONTINUE
  150 CONTINUE
C
C 10. BOUNDARY CONDITION INITIALIZATION AND VERIFICATION
C     Do boundary conditions for all blocks and all levels.  Use QP for work.
C     a. Initialize boundary data to infinity to check input bc data
C     b. Update boundary conditions
C     c. Update Cuts
C     d. Update properties array (synchronize properties with mean flow)
C     e. Update boundary conditions (ensure turbulent bcs use updated props)
C     f. Check boundary data to verify input bc data
C
      DO 170 ILVL = 1, NLVLS
         DO 160 IBLK = 1, NBLKS
            IQ = IOFFQ(IBLK,ILVL) * NQ    + 1
            IP = IOFFP(IBLK,ILVL) * NP    + 1
            IS = IOFFS(IBLK,ILVL) * 4 * 3 + 1
            IV = IOFFS(IBLK,ILVL)         + 1
            IR = IOFFS(IBLK,ILVL) * 3     + 1
C
C     Storage for PROPS
C
            IF (ITURB .GE. ITLMNR) THEN
               NPPTS = (IDIM(IBLK,ILVL)+3) * (JDIM(IBLK,ILVL)+3) *
     1                 (KDIM(IBLK,ILVL)+3)
            ELSE
               NPPTS = MXPPTS
            ENDIF
C
C 10-a. Initialize boundary data to infinity to check input bc data
C       Use WORKX for QTEST.
C
            CALL INITBC (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), Q(IQ), WORKX, ITURB)
C
C 10-b. Update boundary conditions
C
            CALL BC (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     1               1, IDIM(IBLK,ILVL)+1, Q(IQ), PROPS(IP), NPPTS,
     2               S(IS), VOL(IV), R(IR),
     3               NBCS(IBLK), IBCDAT(1,1,IBLK,ILVL),
     4               NXPROF, NPROFL, IOFQBC(1,ILVL), QBC,
     5               VISCOS(1,IBLK), IMODEL, QP, MXSECT, CL, RCNTR)
 160     CONTINUE
 170  CONTINUE
C
C 10-c. Update Cuts
C       Do block boundary conditions (CUTS) for all levels
C
      DO 190 ILVL = 1, NLVLS
         DO 180 ICUT = 1, NCUTS
            IBLK1 = ICUTS( 1,ICUT,ILVL)
            IBLK2 = ICUTS(10,ICUT,ILVL)
            IQ1   = IOFFQ(IBLK1,ILVL) * NQ    + 1
            IQ2   = IOFFQ(IBLK2,ILVL) * NQ    + 1
            CALL CUT (IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     1                KDIM(IBLK1,ILVL), Q(IQ1),
     2                IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     3                KDIM(IBLK2,ILVL), Q(IQ2), ICUTS(1,ICUT,ILVL), NQ)
            IF (ITURB .GE. ITLMNR) THEN
               IP1   = IOFFP(IBLK1,ILVL) * NP    + 1
               IP2   = IOFFP(IBLK2,ILVL) * NP    + 1
               CALL CUT (IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     1                   KDIM(IBLK1,ILVL), PROPS(IP1),
     2                   IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     3                   KDIM(IBLK2,ILVL), PROPS(IP2),
     4                   ICUTS(1,ICUT,ILVL), NP)
            ENDIF
  180    CONTINUE
  190 CONTINUE
C
C 10-d,e. Recalculate properties and boundary conditions as properties
C         are functions of quantities just set in BC and some BCs are
C         functions of the properties.
C
      DO 200 ILVL = 1, NLVLS
         DO 195 IBLK = 1, NBLKS
            IQ = IOFFQ(IBLK,ILVL) * NQ    + 1
            IP = IOFFP(IBLK,ILVL) * NP    + 1
            IS = IOFFS(IBLK,ILVL) * 4 * 3 + 1
            IV = IOFFS(IBLK,ILVL)         + 1
            IR = IOFFS(IBLK,ILVL) * 3     + 1
C
C     Storage for PROPS
C
            IF (ITURB .GE. ITLMNR) THEN
               NPPTS = (IDIM(IBLK,ILVL)+3) * (JDIM(IBLK,ILVL)+3) *
     1                 (KDIM(IBLK,ILVL)+3)
            ELSE
               NPPTS = MXPPTS
            ENDIF
C
            IF (ITURB .GE. ITLMNR) THEN
               IPSTRT = 1
               IPEND  = IDIM(IBLK,ILVL) + 1
C
C 10-d. Update properties array (synchronize properties with mean flow)
C
               CALL PRPRTY (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                      KDIM(IBLK,ILVL), IPSTRT, IPEND, MXSECT,
     2                      Q(IQ), PROPS(IP), S(IS), VOL(IV),
     3                      IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     4                      IMODEL, IFDELQ,
     5                      STEMP, QP, F, FM, QM, DQP, DQM, WORKX)
C
C 10-e. Update boundary conditions (ensure turbulent bcs use updated props)
C
               CALL BC (IDIM(IBLK,ILVL),JDIM(IBLK,ILVL),KDIM(IBLK,ILVL),
     1                  1, IDIM(IBLK,ILVL)+1, Q(IQ), PROPS(IP), NPPTS,
     2                  S(IS), VOL(IV), R(IR),
     3                  NBCS(IBLK), IBCDAT(1,1,IBLK,ILVL),
     4                  NXPROF, NPROFL, IOFQBC(1,ILVL), QBC,
     5                  VISCOS(1,IBLK), IMODEL, QP, MXSECT, CL, RCNTR)
            ENDIF
 195     CONTINUE
 200  CONTINUE
C
C 10-f. Check boundary data to verify input bc data
C       Check each block on each level to verify that all boundary conditions
C       have been initialized.
C
      IBCERR = 0
      DO 220 ILVL = 1, NLVLS
         DO 210 IBLK = 1, NBLKS
            IQ = IOFFQ(IBLK,ILVL) * NQ    + 1
            CALL CHCKBC (ILVL, IBLK, IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), Q(IQ), IBCERR)
  210    CONTINUE
  220 CONTINUE
      IF (IBCERR .GT. 0) THEN
         WRITE (IOUT,1400) IBCERR
         STOP
      ENDIF
 1400 FORMAT (' ','MAIN  : ERROR-> ',I8,' Unset Boundary Conditions.',
     1       /' ', 8X,'RUN ABORTING!')
C
C 11. MARCHING CALCULATION
C     If Marching, then call marching procedure
C
      IF (ISOLVR .EQ. IMARCH) THEN
         IBLK  = 1
         ILVL  = 1
         ICFS  = 1
         IQ    = IOFFQ (IBLK,ILVL) * NQ          + 1
         IQN   = IOFFQN(IBLK,ILVL) * NQ * NTMLVL + 1
         IP    = IOFFP (IBLK,ILVL) * NP          + 1
         IS    = IOFFS (IBLK,ILVL) * 4 * 3       + 1
         IV    = IOFFS (IBLK,ILVL)               + 1
         IR    = IOFFS (IBLK,ILVL) * 3           + 1
         ID    = IOFF  (IBLK,ILVL)               + 1
C
C     Temporary(?) fix for the global storage of the LU when marching
C
         NABC = MXABC / 2
C
C     Storage for QN - Marching shouldn't be unsteady!
C
         IF (ITIMED .EQ. IUNSTD) THEN
            NQNPTS = (IDIM(IBLK,ILVL)+3) * (JDIM(IBLK,ILVL)+3) *
     1               (KDIM(IBLK,ILVL)+3)
            IFL2DQ = .TRUE.
         ELSE
            NQNPTS = MXQNPT
            IFL2DQ = .FALSE.
         ENDIF
C
C     Storage for PROPS
C
         IF (ITURB .GE. ITLMNR) THEN
            NPPTS = (IDIM(IBLK,ILVL)+3) * (JDIM(IBLK,ILVL)+3) *
     1              (KDIM(IBLK,ILVL)+3)
         ELSE
            NPPTS = MXPPTS
         ENDIF
C
C     Initialize error code
C
         IERRCD = INO
C
         CALL MARCH (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     1          MXSECT, NABC, Q(IQ), QN(IQN), NQNPTS, PROPS(IP), NPPTS,
     2          S(IS), VOL(IV), R(IR),
     3          DTJ(ID), RES, FHAT, DQP,DQM,QP,QM,TAU,F,FM,STEMP,WORKX,
     4          IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     5          NXPROF, NPROFL, IOFQBC(1,ILVL), QBC,
     6          ICUTS(1,1,ILVL), NCUTS, R2NORM, ITRSMX, RESMAX, IRESMX,
     7          IORDER(1,IBLK,1,1), LIMIT(1,IBLK), RKAP(1,IBLK),
     8          IFLUX(IBLK), VISCOS(1,IBLK), IMODEL, IFDELQ,
     9          ABC, RM, RTEMP, AT, AI,
     A          IMSTRT, IMEND, NITS(ICFS), NITFO, NITALG, ITUPJ,
     B          TOLER, VGNRN, SIGMA, ITER, QMIN, NFIXQ, NRELIZ,
     C          NPRLIM, NPRNEG, IFL2DQ, R2DQDT, CL, RCNTR, IERRCD)
C
         IF (IERRCD .NE. INO) THEN
            WRITE (IOUT,1405) QMIN(1), NFIXQ(1), QMIN(5), NFIXQ(5)
            GO TO 910
         ENDIF
 1405 FORMAT (///' ','MAIN  : FIXQ  : ERROR-> Density  < ',1PE9.2,
     1               ' at',I7,' locations'
     2          /' ','                        Pressure < ',1PE9.2,
     3               ' at',I7,' locations'
     4          /' ','RUN ABORTING! Attempting to write output ',
     5               'and restart files.',
     6        ///' ')
      ELSE
C
C 12. TIME DEPENDENT CALCULATION
C
C     Calculate execution time of run
C
         MRCHNG = .FALSE.
C
C     Initialize error code
C
         IERRCD = INO
C
C     Loop over coarse to fine sequences
C
         ITRUN  = 0
         DO 900 ICFS = 1, NCFS
            LVLONE = NCFS - ICFS + 1
C
C     Loop over number of iterations
C
            DO 800 ITER = 1, NITS(LVLONE)
C
C     Check for presence of STOP file; if it exists, write restart and quit
C
               OPEN (ISTOPFL,FILE='STOP',STATUS='OLD',ERR=701)
               WRITE (IOUT,1490)
               GO TO 905
 1490 FORMAT (//' ','MAIN  : STOP file encountered! Run stopping.'//)
C
C     STOP does not exist; continue run
C
  701          CONTINUE
C
C     If unsteady calculation then
C       i.   Update TIME
C       ii.  Collect Q to coarser levels at time level n
C       iii. Shift Q, QN for next time step
C
               IF (ITIMED .EQ. IUNSTD) THEN
C
C     i.   Update TIME
C
                  TIME = TIME + TIMEDT
C
C     ii.  Collect Q to coarser levels at time level n
C
                  DO 710 ILVL = LVLONE+1, LVLONE + MGLVLS(LVLONE) - 1
                     DO 705 IBLK = 1, NBLKS
                        IQF = IOFFQ(IBLK,ILVL-1) * NQ    + 1
                        IVF = IOFFS(IBLK,ILVL-1)         + 1
                        IQ  = IOFFQ(IBLK,ILVL)   * NQ    + 1
                        IV  = IOFFS(IBLK,ILVL)           + 1
C
C     Temporary storage: QP for QS, RES for TKE
C
                        CALL COLQ2H (IDIM(IBLK,ILVL-1),
     1                              JDIM(IBLK,ILVL-1),KDIM(IBLK,ILVL-1),
     2                              Q(IQF), VOL(IVF),
     3                              IDIM(IBLK,ILVL),  JDIM(IBLK,ILVL),
     4                              KDIM(IBLK,ILVL),  Q(IQ), VOL(IV),
     5                              QP, ITURB, RES)
  705                CONTINUE
  710             CONTINUE
C
C     iii. Shift Q, QN for next time step
C
                  DO 720 ILVL = LVLONE, LVLONE + MGLVLS(LVLONE) - 1
                     DO 715 IBLK = 1, NBLKS
                        IQ     = IOFFQ (IBLK,ILVL) * NQ          + 1
                        IQN    = IOFFQN(IBLK,ILVL) * NQ * NTMLVL + 1
C
                        CALL QNSHFT (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                               KDIM(IBLK,ILVL), Q(IQ), QN(IQN),
     2                               QP, QM, IMODEL)
  715                CONTINUE
  720             CONTINUE
               ENDIF
C
C     End of data shift for next time-accurate time step
C
C     Q is Q^(p) and is initialized to Q^(n) to begin subiterations,
C     QN(1) = Q^(n) and QN(2) = Q^(n-1)
C
C     Perform sub-iterations for each time step
C
               DO 790 ITSUB = 1, NSUBIT
C
C     Set starting multigrid level to be NCFS for coarsest mesh and
C     starting level to be 1 for finest mesh and loop over
C     the multigrid levels.
C
                  DO 700 ILVL = LVLONE, LVLONE + MGLVLS(LVLONE) - 1
C
C     Restrict from fine to coarse level if current level is not finest level
C     Begin Restriction:
C
                     IF (ILVL .NE. LVLONE) THEN
C
C     Collect Q
C
                        DO 300 IBLK = 1, NBLKS
                           IQF = IOFFQ(IBLK,ILVL-1) * NQ    + 1
                           IVF = IOFFS(IBLK,ILVL-1)         + 1
                           IQ  = IOFFQ(IBLK,ILVL)   * NQ    + 1
                           IP  = IOFFP(IBLK,ILVL)   * NP    + 1
                           IS  = IOFFS(IBLK,ILVL)   * 4 * 3 + 1
                           IV  = IOFFS(IBLK,ILVL)           + 1
                           IR  = IOFFS(IBLK,ILVL)   * 3     + 1
C
                           IF (ITURB .GE. ITLMNR) THEN
                              NPPTS = (IDIM(IBLK,ILVL)+3) *
     1                                (JDIM(IBLK,ILVL)+3) *
     2                                (KDIM(IBLK,ILVL)+3)
                           ELSE
                              NPPTS = MXPPTS
                           ENDIF
C
C     Temporary storage: QP for QS, RES for TKE
C
                           CALL COLQ2H (IDIM(IBLK,ILVL-1),
     1                              JDIM(IBLK,ILVL-1),KDIM(IBLK,ILVL-1),
     2                              Q(IQF), VOL(IVF),
     3                              IDIM(IBLK,ILVL),  JDIM(IBLK,ILVL),
     4                              KDIM(IBLK,ILVL),  Q(IQ), VOL(IV),
     5                              QP, ITURB, RES)
C
                           IPSTRT = 1
                           IPEND  = IDIM(IBLK,ILVL) + 1
C
                           CALL BC     (IDIM(IBLK,ILVL),JDIM(IBLK,ILVL),
     1                           KDIM(IBLK,ILVL), IPSTRT, IPEND,
     2                           Q(IQ), PROPS(IP), NPPTS,
     3                           S(IS), VOL(IV), R(IR),
     4                           NBCS(IBLK), IBCDAT(1,1,IBLK,ILVL),
     5                           NXPROF,NPROFL,IOFQBC(1,ILVL),QBC,
     6                           VISCOS(1,IBLK), IMODEL, QP, MXSECT,
     7                           CL, RCNTR)
C
                           IF (ITURB .GE. ITLMNR) THEN
                              CALL PRPRTY (IDIM(IBLK,ILVL),
     1                              JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     2                              IPSTRT, IPEND, MXSECT,
     3                              Q(IQ), PROPS(IP), S(IS), VOL(IV),
     4                              IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     5                              IMODEL, IFDELQ,
     6                              STEMP, QP, F, FM, QM, DQP,DQM,WORKX)
                           ENDIF
 300                    CONTINUE
C
C      Update CUTS
C
                        DO 320 ICUT = 1, NCUTS
                           IBLK1 = ICUTS( 1,ICUT,ILVL)
                           IBLK2 = ICUTS(10,ICUT,ILVL)
                           IQ1   = IOFFQ(IBLK1,ILVL) * NQ    + 1
                           IQ2   = IOFFQ(IBLK2,ILVL) * NQ    + 1
                           CALL CUT (IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     2                               KDIM(IBLK1,ILVL), Q(IQ1),
     3                               IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     4                               KDIM(IBLK2,ILVL), Q(IQ2),
     5                               ICUTS(1,ICUT,ILVL), NQ)
                           IF (ITURB .GE. ITLMNR) THEN
                              IP1   = IOFFP(IBLK1,ILVL) * NP    + 1
                              IP2   = IOFFP(IBLK2,ILVL) * NP    + 1
                              CALL CUT
     1                              (IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     2                               KDIM(IBLK1,ILVL), PROPS(IP1),
     3                               IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     4                               KDIM(IBLK2,ILVL), PROPS(IP2),
     5                               ICUTS(1,ICUT,ILVL), NP)
                           ENDIF
  320                   CONTINUE
C
C     Copy QC and store
C
                        DO 340 IBLK = 1, NBLKS
                           IQ    = IOFFQ (IBLK,ILVL)   * NQ    + 1
                           IQCRS = IOFFQC(IBLK,ILVL)   * NQ    + 1
C
                           NPTS  = (IDIM(IBLK,ILVL)+3) *
     1                             (JDIM(IBLK,ILVL)+3) *
     2                             (KDIM(IBLK,ILVL)+3) * NQ
C
                           CALL CPVCTR (NPTS, Q(IQ), QCRS(IQCRS))
  340                   CONTINUE
C
C     Calculate coarse and fine grid residuals and coarse grid forcing function
C
                        NPRLIM = 0
                        NPRNEG = 0
                        DO 360 IBLK = 1, NBLKS
                           IQF    = IOFFQ (IBLK,ILVL-1) * NQ         + 1
                           IQNF   = IOFFQN(IBLK,ILVL-1) * NQ *NTMLVL + 1
                           IPF    = IOFFP (IBLK,ILVL-1) * NP         + 1
                           ISF    = IOFFS (IBLK,ILVL-1) * 4 * 3      + 1
                           IVF    = IOFFS (IBLK,ILVL-1)              + 1
                           IDF    = IOFF  (IBLK,ILVL-1)              + 1
                           IRF    = IOFFS (IBLK,ILVL-1) * 3          + 1
C
                           IQC    = IOFFQ (IBLK,ILVL)   * NQ         + 1
                           IQNC   = IOFFQN(IBLK,ILVL)   * NQ *NTMLVL + 1
                           IPC    = IOFFP (IBLK,ILVL)   * NP         + 1
                           ISC    = IOFFS (IBLK,ILVL)   * 4 * 3      + 1
                           IVC    = IOFFS (IBLK,ILVL)                + 1
                           IDC    = IOFF  (IBLK,ILVL)                + 1
                           IRC    = IOFFS (IBLK,ILVL)   * 3          + 1
C
                           IRSCRS = IOFFQC(IBLK,ILVL)   * NF         + 1
C
                           IF (ITIMED .EQ. IUNSTD) THEN
                              NQNPTF = (IDIM(IBLK,ILVL-1)+3) *
     1                                 (JDIM(IBLK,ILVL-1)+3) *
     2                                 (KDIM(IBLK,ILVL-1)+3)
                              NQNPTC = (IDIM(IBLK,ILVL)  +3) *
     1                                 (JDIM(IBLK,ILVL)  +3) *
     2                                 (KDIM(IBLK,ILVL)  +3)
                           ELSE
                              NQNPTF = MXQNPT
                              NQNPTC = MXQNPT
                           ENDIF
C
                           IF (ITURB .GE. ITLMNR) THEN
                              NPPTSF = (IDIM(IBLK,ILVL-1)+3) *
     1                                 (JDIM(IBLK,ILVL-1)+3) *
     2                                 (KDIM(IBLK,ILVL-1)+3)
                              NPPTSC = (IDIM(IBLK,ILVL)  +3) *
     1                                 (JDIM(IBLK,ILVL)  +3) *
     2                                 (KDIM(IBLK,ILVL)  +3)
                           ELSE
                              NPPTSF = MXPPTS
                              NPPTSC = MXPPTS
                           ENDIF
C
                           IF (ILVL .EQ. (LVLONE + 1) ) THEN
                              INITRS = .TRUE.
                           ELSE
                              INITRS = .FALSE.
                              IRSCRF = IOFFQC(IBLK,ILVL-1)   * NF  + 1
                              NPTRSF = (IDIM(IBLK,ILVL-1)+1) *
     1                                 (JDIM(IBLK,ILVL-1)+1) *
     2                                 (KDIM(IBLK,ILVL-1)+1) * NF
                              CALL CPVCTR (NPTRSF, RESCRS(IRSCRF), RES)
                           ENDIF
                           MRCHNG = .FALSE.
                           IFL2DQ = .FALSE.
C
                           IPSTRT = 2
                           IPEND  = IDIM(IBLK,ILVL-1)
                           CALL RESID  (IDIM(IBLK,ILVL-1),
     1                              JDIM(IBLK,ILVL-1),KDIM(IBLK,ILVL-1),
     2                              IPSTRT, IPEND, MXSECT,
     3                              Q(IQF), QN(IQNF), NQNPTF,
     4                              PROPS(IPF), NPPTSF, S(ISF),
     5                              VOL(IVF), R(IRF), DTJ(IDF), RES,
     6                              FHAT, DQP, DQM, QP, QM, TAU, F, FM,
     7                              STEMP, WORKX,
     8                              IBCDAT(1,1,IBLK,ILVL-1), NBCS(IBLK),
     9                              IORDER(1,IBLK,ILVL-1,ICFS),
     A                              LIMIT(1,IBLK), RKAP(1,IBLK),
     B                              IFLUX(IBLK), VISCOS(1,IBLK), IMODEL,
     C                              INITRS, IFDELQ, MRCHNG, VGNRN,SIGMA,
     D                              NPRLIM, NPRNEG, IFL2DQ, R2DQDT)
C
C     Set logical to calculate multigrid forcing function on first resid call
C
                           IFMGFF = .TRUE.
C
                           CALL COLR2H (IDIM(IBLK,ILVL-1),
     1                              JDIM(IBLK,ILVL-1),KDIM(IBLK,ILVL-1),
     2                              RES,
     3                              IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     4                              KDIM(IBLK,ILVL), RESCRS(IRSCRS), QP)
  360                   CONTINUE
                     ENDIF
C
C     End   Restriction:
C
C     Update time step.
C     Use DQP as temporary storage for PFACTR.
C
                     IF ( MOD((ITER-1), ITUPDT) .EQ. 0 .AND.
     1                    ITSUB .EQ. 1 ) THEN
                        DTMIN =  999.E0
                        DTMAX = -999.E0
                        DO 400 IBLK = 1, NBLKS
                           IQ    = IOFFQ(IBLK,ILVL) * NQ    + 1
                           IP    = IOFFP(IBLK,ILVL) * NP    + 1
                           ID    = IOFF (IBLK,ILVL)         + 1
                           IV    = IOFFS(IBLK,ILVL)         + 1
                           IS    = IOFFS(IBLK,ILVL) * 4 * 3 + 1
                           CALL DELTAT (IBLK,        IDIM(IBLK,ILVL),
     1                              JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     2                              2, IDIM(IBLK,ILVL),
     3                              Q(IQ), PROPS(IP), DTJ(ID), VOL(IV),
     4                              S(IS), DQP,
     5                              VISCOS(1,IBLK), ITURB, ITER, CFLCUR,
     6                              DTMIN,IBLKMN,IDTMIN,JDTMIN,KDTMIN,
     7                              DTMAX,IBLKMX,IDTMAX,JDTMAX,KDTMAX)
 400                    CONTINUE
C
C     Output minimum and maximum time step/CFL
C
                        IF (DT .GT. 0.0E0) THEN
                           WRITE (IOUT,1440) CFLCUR,
     1                               DTMIN,IBLKMN,IDTMIN,JDTMIN,KDTMIN,
     2                               DTMAX,IBLKMX,IDTMAX,JDTMAX,KDTMAX
                        ELSE
                           WRITE (IOUT,1450) CFLCUR,
     1                               DTMIN,IBLKMN,IDTMIN,JDTMIN,KDTMIN,
     2                               DTMAX,IBLKMX,IDTMAX,JDTMAX,KDTMAX
                        ENDIF
                     ENDIF
 1440 FORMAT (' ','MAIN  : DT =',1PE10.3,'  CFLMIN =',1PE10.3,
     1            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')',
     2       /' ',22X,'  CFLMAX =',1PE10.3,
     3            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')')
 1450 FORMAT (' ','MAIN  : CFL =',1PE10.3,'  DTMIN =',1PE10.3,
     1            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')',
     2       /' ',23X,'  DTMAX =',1PE10.3,
     3            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')')
C
C     Perform ITSLVL iterations (time step integrations) per level.
C
                     DO 600 INRIT = 1, ITSLVL(ILVL,LVLONE)
C
C     Reset norms to zero
C
                        DO 420 L = 1, NF + 1
                           R2NORM(L) = 0.E0
                           R2DQDT(L) = 0.E0
 420                    CONTINUE
C
C     Perform NSTAGE stages of multistage scheme
C
                        DO 550 ISTAGE = 1, NSTAGE
C
C     Reset counters to zero
C
                           DO 425 L = 1, NQ
                              NFIXQ (L) = 0
                              NRELIZ(L) = 0
 425                       CONTINUE
C
C     Counter for limiting of turbulence production
C
                           NPRLIM = 0
                           NPRNEG = 0
C
C     Set up control parameter for calculating maximum residual
C
                           RESMAX = 0.E0
                           IF (INRIT  .EQ. 1 .AND.
     1                         ISTAGE .EQ. 1 .AND.
     2                         MOD((ITER),ITRSMX).EQ.0) THEN
                              IFRSMX = IYES
                           ELSE
                              IFRSMX = INO
                           ENDIF
C
C     Loop over all blocks.
C
                           DO 500 IBLK = 1, NBLKS
                              IQ   = IOFFQ (IBLK,ILVL) * NQ          + 1
                              IQN  = IOFFQN(IBLK,ILVL) * NQ * NTMLVL + 1
                              IP   = IOFFP (IBLK,ILVL) * NP          + 1
                              IS   = IOFFS (IBLK,ILVL) * 4 * 3       + 1
                              IV   = IOFFS (IBLK,ILVL)               + 1
                              IR   = IOFFS (IBLK,ILVL) * 3           + 1
                              ID   = IOFF  (IBLK,ILVL)               + 1
                              IABC = IOFF  (IBLK,ILVL)*NRANK*NRANK*3*3+1
C
C     Storage for QN, calculate L2 norm of dQ/dt only if first stage of
C     multistage scheme and on the finest mesh level
C
                              IF (ITIMED .EQ. IUNSTD) THEN
                                 NQNPTS = (IDIM(IBLK,ILVL)+3) *
     1                                    (JDIM(IBLK,ILVL)+3) *
     2                                    (KDIM(IBLK,ILVL)+3)
                                 IF (ILVL   .EQ. LVLONE .AND.
     1                               ISTAGE .EQ. 1) THEN
                                    IFL2DQ = .TRUE.
                                 ELSE
                                    IFL2DQ = .FALSE.
                                 ENDIF
                              ELSE
                                 NQNPTS = MXQNPT
                                 IFL2DQ = .FALSE.
                              ENDIF
C
C     Storage for PROPS
C
                              IF (ITURB .GE. ITLMNR) THEN
                                 NPPTS = (IDIM(IBLK,ILVL)+3) *
     1                                   (JDIM(IBLK,ILVL)+3) *
     2                                   (KDIM(IBLK,ILVL)+3)
                              ELSE
                                 NPPTS = MXPPTS
                              ENDIF
C
C     Set up switch from first order scheme to higher order
C
                              ITORDR(1) = IORDER(1,IBLK,ILVL,ICFS)
                              ITORDR(2) = IORDER(2,IBLK,ILVL,ICFS)
                              ITORDR(3) = IORDER(3,IBLK,ILVL,ICFS)
                              IF (ITER .LE. NITFO) THEN
                                 ITORDR(1) = 1
                                 ITORDR(2) = 1
                                 ITORDR(3) = 1
                              ENDIF
C
C     Set up use of algebraic turbulent eddy viscosity with higher order
C     models for the initial transient
C
                              IF (ITER .LE. NITALG) THEN
                                 MUTALG = .TRUE.
                              ELSE
                                 MUTALG = .FALSE.
                              ENDIF
C
C     If running a viscous case, calculate the PROPS array
C     Use QP, QM, F and DQP as temporary storage.
C
                              IF (ITURB  .GE. ITLMNR .AND.
     1                            ISTAGE .EQ. 1) THEN
                                 CALL PRPRTY (IDIM(IBLK,ILVL),
     1                              JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     2                              1, IDIM(IBLK,ILVL)+1, MXSECT,
     3                              Q(IQ), PROPS(IP), S(IS), VOL(IV),
     4                              IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     5                              IMODEL, IFDELQ,
     6                              STEMP, QP, F, FM, QM, DQP,DQM,WORKX)
                              ENDIF
C
C      Calculate the Residual for the current block and level
C
                              INITRS = .TRUE.
                              IPSTRT = 2
                              IPEND  = IDIM(IBLK,ILVL)
                              CALL RESID  (IDIM(IBLK,ILVL),
     1                              JDIM(IBLK,ILVL),KDIM(IBLK,ILVL),
     2                              IPSTRT, IPEND, MXSECT,
     3                              Q(IQ), QN(IQN), NQNPTS,
     4                              PROPS(IP), NPPTS, S(IS),
     5                              VOL(IV), R(IR), DTJ(ID), RES,
     6                              FHAT, DQP, DQM, QP, QM, TAU, F, FM,
     7                              STEMP, WORKX,
     8                              IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     9                              ITORDR,
     A                              LIMIT(1,IBLK), RKAP(1,IBLK),
     B                              IFLUX(IBLK), VISCOS(1,IBLK), IMODEL,
     C                              INITRS, IFDELQ, MRCHNG, VGNRN,SIGMA,
     D                              NPRLIM, NPRNEG, IFL2DQ, R2DQDT)
C
C     Calculate L2 norms only on the finest mesh
C          If first stage, call l2norm to calculate L2 norm of residual,
C                          call l2max  to calculate maximum residual
C
                              IF (ILVL .EQ. LVLONE) THEN
                                 IF (ISTAGE .EQ. 1) THEN
                                    CALL L2NORM (IDIM(IBLK,ILVL),
     1                                  JDIM(IBLK,ILVL),KDIM(IBLK,ILVL),
     2                                  IPSTRT, IPEND,
     3                                  RES, VOL(IV), R2NORM)
                                    IF (IFRSMX .EQ. IYES) THEN
                                       CALL L2MAX (IBLK,IDIM(IBLK,ILVL),
     1                                  JDIM(IBLK,ILVL),KDIM(IBLK,ILVL),
     2                                  IPSTRT, IPEND,
     3                                  RES, VOL(IV), RESMAX, IRESMX)
         ENDIF
      ENDIF
                              ENDIF
C
C     For MG: i. For the first residual evaluation after coarsening,
C                calculate the MG forcing function
C            ii. Set the residual to RES + FF before time integration
C
                              IF (ILVL .NE. LVLONE) THEN
                                 IRSCRS = IOFFQC(IBLK,ILVL)   * NF  + 1
                                 NPTS   = (IDIM(IBLK,ILVL)+1) *
     1                                    (JDIM(IBLK,ILVL)+1) *
     2                                    (KDIM(IBLK,ILVL)+1) * NF
                                 IF (IFMGFF) THEN
C%%%%%                              CALL CMGFF (NPTS,RESCRS(IRSCRS),RES)
                                    CALL xCMGFF (idim(iblk,ilvl),
     1                                 jdim(iblk,ilvl), kdim(iblk,ilvl),
     2                                 RESCRS(IRSCRS),RES)
                                 ENDIF
C%%%%%                           CALL CRESFF (NPTS, RESCRS(IRSCRS), RES)
                                 CALL xCRESFF (idim(iblk,ilvl),
     1                                 jdim(iblk,ilvl), kdim(iblk,ilvl),
     2                                 RESCRS(IRSCRS),RES)
                              ENDIF
C
                              IF (ISOLVR .EQ. IRKN) THEN
                                 CALL RK (IBLK, IDIM(IBLK,ILVL),
     1                          JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),MXSECT,
     2                          NSTAGE, ISTAGE, RKALPH(ISTAGE),
     3                          Q(IQ), QN(IQN), NQNPTS,
     4                          PROPS(IP), NPPTS, S(IS), VOL(IV),
     5                          R(IR),DTJ(ID), RES, FHAT, DQP,DQM,QP,QM,
     6                          TAU, F, FM, STEMP, WORKX,
     7                          IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     8                          ITORDR, LIMIT(1,IBLK), RKAP(1,IBLK),
     9                          IFLUX(IBLK), VISCOS(1,IBLK),
     A                          IMODEL, IFDELQ, W,
     B                          QMIN, NFIXQ, NRELIZ, NPRLIM, NPRNEG,
     C                          IERRCD)
C
                              ELSE IF (ISOLVR .EQ. IAF3F) THEN
                                 CALL AF3F (IBLK, IDIM(IBLK,ILVL),
     1                       JDIM(IBLK,ILVL), KDIM(IBLK,ILVL), MXSECT,
     2                       MXABC, Q(IQ), QN(IQN), NQNPTS,
     3                       PROPS(IP), NPPTS, S(IS), VOL(IV),
     4                       R(IR), DTJ(ID), RES, FHAT, DQP, DQM, QP,QM,
     5                       TAU, F, FM, STEMP, WORKX,
     6                       IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     7                       ITORDR, LIMIT(1,IBLK), RKAP(1,IBLK),
     8                       IFLUX(IBLK), VISCOS(1,IBLK), DIAG(1,IBLK),
     9                       IMODEL, IFDELQ, ABC, RTEMP, AT, AI,
     A                       QMIN, NFIXQ, NRELIZ, NPRLIM, NPRNEG,IERRCD)
C
                              ENDIF
C
C     Update Boundary Conditions
C
                              CALL BC(IDIM(IBLK,ILVL),JDIM(IBLK,ILVL),
     1                                KDIM(IBLK,ILVL), 1,
     2                                IDIM(IBLK,ILVL)+1,Q(IQ),PROPS(IP),
     3                                NPPTS, S(IS), VOL(IV), R(IR),
     4                                NBCS(IBLK),IBCDAT(1,1,IBLK,ILVL),
     5                                NXPROF,NPROFL,IOFQBC(1,ILVL),QBC,
     6                                VISCOS(1,IBLK),IMODEL,QP, MXSECT,
     7                                CL, RCNTR)
  500                      CONTINUE
C
C     Reset the logical controlling the calculation of the MG forcing function
C
                           IFMGFF = .FALSE.
C
C     Check error code and abort
C
                           IF (IERRCD .NE. INO) THEN
                              WRITE (IOUT,1405) QMIN(1), NFIXQ(1),
     1                                          QMIN(5), NFIXQ(5)
                              GO TO 910
                           ENDIF
C
C     Do block boundary conditions (CUTS)
C
                           DO 530 ICUT = 1, NCUTS
                              IBLK1 = ICUTS( 1,ICUT,ILVL)
                              IBLK2 = ICUTS(10,ICUT,ILVL)
                              IQ1   = IOFFQ(IBLK1,ILVL) * NQ    + 1
                              IQ2   = IOFFQ(IBLK2,ILVL) * NQ    + 1
                              CALL CUT
     1                              (IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     2                               KDIM(IBLK1,ILVL), Q(IQ1),
     3                               IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     4                               KDIM(IBLK2,ILVL), Q(IQ2),
     5                               ICUTS(1,ICUT,ILVL), NQ)
                              IF (ITURB .GE. ITLMNR) THEN
                                 IP1   = IOFFP(IBLK1,ILVL) * NP    + 1
                                 IP2   = IOFFP(IBLK2,ILVL) * NP    + 1
                                 CALL CUT
     1                              (IDIM(IBLK1,ILVL), JDIM(IBLK1,ILVL),
     2                               KDIM(IBLK1,ILVL), PROPS(IP1),
     3                               IDIM(IBLK2,ILVL), JDIM(IBLK2,ILVL),
     4                               KDIM(IBLK2,ILVL), PROPS(IP2),
     5                               ICUTS(1,ICUT,ILVL), NP)
                              ENDIF
  530                      CONTINUE
C
C     End of stage loop
C
  550                   CONTINUE
C
C     Output monitoring data on finest mesh level only
C
                        IF (ILVL .EQ. LVLONE) THEN
C
C     Calculate iteration for output
C
                           ITCUR     = ITER  + ITRUN
                           IT        = ITCUR + ITTOT
C
C     i.  Output monitoring data on subiterations
C
                           IF (ITSUB .NE. 1) THEN
C
C     Output residual data scaled by number of cell centers on current level
C
                              DO 570 LL = 1, NF + 1
                                 R2NORM(LL) = SQRT(R2NORM(LL)) /
     1                                        NBRPTS(ILVL)
                                 R2DQDT(LL) = SQRT(R2DQDT(LL)) /
     1                                        NBRPTS(ILVL)
  570                         CONTINUE
                              WRITE (IOUT,2200) ITCUR, ITSUB,
     1                                          (R2NORM(LL),LL=1,NF+1)
                              IF (ITIMED .EQ. IUNSTD) THEN
                                 WRITE (IOUT,2210) ITCUR, ITSUB,
     1                                      (R2DQDT(LL),LL=1,NF+1)
                              ENDIF
 2200 FORMAT (' ','Iter =',I8,' Subiteration =',I4,8X,
     1            ' Res = ',13(1PE14.7,2X))
 2210 FORMAT (' ','Iter =',I8,' Subiteration =',I4,2X,
     1            ' L2(dQ/dt) = ',13(1PE14.7,2X))
C
C     ii. Output monitoring data only on main iterations
C
                           ELSE
C
C     Output residual data scaled by number of cell centers on current level
C
                              DO 580 LL = 1, NF + 1
                                 R2NORM(LL) = SQRT(R2NORM(LL)) /
     1                                        NBRPTS(ILVL)
                                 R2DQDT(LL) = SQRT(R2DQDT(LL)) /
     1                                        NBRPTS(ILVL)
  580                         CONTINUE
                              R2(IT) = R2NORM(NF+1)
                              IF (ITIMED .EQ. ISTDY) THEN
                                 WRITE (IOUT,2300) ITCUR, IT,
     1                                      (R2NORM(LL),LL=1,NF+1)
                              ELSE
                                 WRITE (IOUT,2305) ITCUR, IT, TIME,
     1                                      (R2NORM(LL),LL=1,NF+1)
                                 WRITE (IOUT,2210) ITCUR, ITSUB,
     1                                      (R2DQDT(LL),LL=1,NF+1)
                              ENDIF
 2300 FORMAT (' ','ITER =',2I8,' RES = ',13(1PE14.7,2X))
 2305 FORMAT (' ','ITER =',2I8,' TIME =',1PE12.5,
     1                         ' RES = ',13(1PE14.7,2X))
C
C     Output maximum residual
C
                              IF (IFRSMX .EQ. IYES) THEN
                                 RESMAX = SQRT (RESMAX)
                                 WRITE (IOUT,2350) ITCUR, IT, RESMAX,
     1                                          (IRESMX(L),L=0,3)
                              ENDIF
 2350 FORMAT (' ','Iter =',2I8,' Max Res = ',1PE12.5,
     1            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')')
C
C     Output if reset turbulence production
C
                              IF (NPRNEG .GT. 0) THEN
                                 WRITE (IOUT,2400) NPRNEG
                              ENDIF
 2400 FORMAT (' ','MAIN  : SRCRES: Turb. Prod reset posit',
     1            'ive   at ',I6,' locations')
C
                              IF (NPRLIM .GT. 0) THEN
                                 WRITE (IOUT,2401) PRDLIM, NPRLIM
                              ENDIF
 2401 FORMAT (' ','MAIN  : SRCRES: Turb. Prod limited to ',1PE10.2,
     1            '*diss at ',I6,' locations')
C
C     Output number of times positivity violated
C
                              DO 585 L = 1, NQ
                                 IF (IFIXQ .EQ. IFIXMN) THEN
                                    FIXTYP = 'Minimum'
                                 ELSE IF (IFIXQ .EQ. IFIXAV) THEN
                                    FIXTYP = 'Average'
                                 ENDIF
                                 IF (NFIXQ(L) .GT. 0) THEN
                                    WRITE (IOUT,2410) L, QMIN(L),
     1                                                NFIXQ(L), FIXTYP
                                 ENDIF
  585                         CONTINUE
 2410 FORMAT (' ','MAIN  : FIXQ  : Q(',I2,') < ',1PE9.2,
     1            ' at ',I7,' locations.  Replaced with ',A7,'.')
C
C     Output number of times realizability violated
C
                              IF (ITURB. EQ. ITRS) THEN
                                 IF (NRELIZ( 9) .GT. 0) THEN
                                    WRITE (IOUT,2420) 'XY', NRELIZ( 9)
                                 ENDIF
C
                                 IF (NRELIZ(10) .GT. 0) THEN
                                    WRITE (IOUT,2420) 'XZ', NRELIZ(10)
                                 ENDIF
C
                                 IF (NRELIZ(11) .GT. 0) THEN
                                    WRITE (IOUT,2420) 'YZ', NRELIZ(11)
                                 ENDIF
                              ENDIF
 2420 FORMAT (' ','MAIN  : REALIZ: Tau_',A2,' violates Schwartz ineq. ',
     1            ' at ',I6,' locations.  Reset.')
C
C     Output Monitor data
C
                              IF ( MOD(ITER, NITMON) .EQ. 0 ) THEN
                                 DO 595 IBLK = 1, NBLKS
                                    IQ = IOFFQ(IBLK,ILVL) * NQ    + 1
                                    CALL MONITR
     1                                (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     2                                 KDIM(IBLK,ILVL), Q(IQ),
     3                                 NPRMON(IBLK), IPRMON(1,1,IBLK))
  595                            CONTINUE
                              ENDIF
                           ENDIF
C
C     Calculate forces: update on each subiteration for 2D farfield vortex bc
C
                           IF (IFFORC .EQ. IYES) THEN
                              CALL FRCINT (ITURB,NBLKS,IDIM(1,ILVL),
     1                               JDIM(1,ILVL),  KDIM(1,ILVL),
     2                               IOFF(1,ILVL),  IOFFS(1,ILVL),
     3                               IOFFQ(1,ILVL), IOFFP(1,ILVL),
     4                               Q, PROPS, S, R, NXBCS, NBCS,
     5                               IBCDAT(1,1,1,ILVL), FORCE, CL, CD)
                           ENDIF
C
C     Output only on LAST sub-iteration
C
                           IF (ITSUB .EQ. NSUBIT) THEN
                              IF (IFRCPR .EQ. IYES) THEN
                                 IF (ITIMED .EQ. ISTDY) THEN
                                    WRITE (IOUT,2480) ITCUR, IT, CL, CD
                                 ELSE
                                    WRITE (IOUT,2485) ITCUR, IT, TIME,
     1                                                CL, CD
                                 ENDIF
                              ENDIF
 2480 FORMAT (' ','Iter =',2I8,' CL = ',1PE13.6,' CD = ',1PE13.6)
 2485 FORMAT (' ','Iter =',2I8,' Time =',1PE12.5,
     1                         ' CL = ',1PE13.6,' CD = ',1PE13.6)
                           ENDIF
                        ENDIF
C
C     End of output
C
  600                CONTINUE
  700             CONTINUE
C
C    Begin Prolongation from coarser meshes
C    1. For each block
C       a. Interpolate coarse grid correction
C       b. Update boundary conditions
C    2. Update Cuts
C
                  DO 750 ILVL = LVLONE + MGLVLS(LVLONE) - 2, LVLONE, -1
                     LVLC  = ILVL + 1
                     LVLF  = ILVL
                     DO 730 IBLK = 1, NBLKS
                        IQC   = IOFFQ (IBLK,LVLC) * NQ    + 1
                        IQCRS = IOFFQC(IBLK,LVLC) * NQ    + 1
                        IQF   = IOFFQ (IBLK,LVLF) * NQ    + 1
                        IPF   = IOFFP (IBLK,LVLF) * NP    + 1
                        ISF   = IOFFS (IBLK,LVLF) * 4 * 3 + 1
                        IVF   = IOFFS (IBLK,LVLF)         + 1
                        IRF   = IOFFS (IBLK,ILVL) * 3     + 1
C
C     Use RES as temporary storage for DQF (RES should be big enough)
C
                        CALL PROLNG (
     1                         IDIM(IBLK,LVLC), JDIM(IBLK,LVLC),
     2                         KDIM(IBLK,LVLC), Q(IQC), QCRS(IQCRS),
     3                         NBCS(IBLK), IBCDAT(1,1,IBLK,LVLC),
     4                         IDIM(IBLK,LVLF), JDIM(IBLK,LVLF),
     5                         KDIM(IBLK,LVLF), Q(IQF), RES,
     6                         IBCDAT(1,1,IBLK,LVLF),
     7                         ITURB, QMIN, NFIXQ, NRELIZ,
     8                         MXSECT, ABC, RTEMP)
C
                        IF (ITURB .GE. ITLMNR) THEN
                           NPPTS = (IDIM(IBLK,LVLF)+3) *
     1                             (JDIM(IBLK,LVLF)+3) *
     2                             (KDIM(IBLK,LVLF)+3)
                        ELSE
                           NPPTS = MXPPTS
                        ENDIF
                        CALL BC     (
     1                         IDIM(IBLK,LVLF),JDIM(IBLK,LVLF),
     2                         KDIM(IBLK,LVLF), 1, IDIM(IBLK,LVLF)+1,
     3                         Q(IQF),PROPS(IPF),NPPTS,S(ISF),VOL(IVF),
     4                         R(IRF),NBCS(IBLK),IBCDAT(1,1,IBLK,LVLF),
     5                         NXPROF, NPROFL, IOFQBC(1,LVLF), QBC,
     6                         VISCOS(1,IBLK), IMODEL, QP, MXSECT,
     7                         CL, RCNTR)
C
                        IF (ITURB .GE. ITLMNR) THEN
                           CALL PRPRTY (IDIM(IBLK,LVLF),
     1                           JDIM(IBLK,LVLF), KDIM(IBLK,LVLF),
     2                           1, IDIM(IBLK,LVLF)+1, MXSECT,
     3                           Q(IQF), PROPS(IPF), S(ISF), VOL(IVF),
     4                           IBCDAT(1,1,IBLK,LVLF), NBCS(IBLK),
     5                           IMODEL, IFDELQ,
     6                           STEMP, QP, F, FM, QM, DQP, DQM, WORKX)
                        ENDIF
  730                CONTINUE
C
C     Update CUTS
C
                     DO 740 ICUT = 1, NCUTS
                        IBLK1 = ICUTS( 1,ICUT,LVLF)
                        IBLK2 = ICUTS(10,ICUT,LVLF)
                        IQ1   = IOFFQ(IBLK1,LVLF) * NQ    + 1
                        IQ2   = IOFFQ(IBLK2,LVLF) * NQ    + 1
                        CALL CUT (IDIM(IBLK1,LVLF), JDIM(IBLK1,LVLF),
     1                            KDIM(IBLK1,LVLF), Q(IQ1),
     2                            IDIM(IBLK2,LVLF), JDIM(IBLK2,LVLF),
     3                            KDIM(IBLK2,LVLF), Q(IQ2),
     4                            ICUTS(1,ICUT,LVLF), NQ)
                        IF (ITURB .GE. ITLMNR) THEN
                           IP1   = IOFFP(IBLK1,LVLF) * NP    + 1
                           IP2   = IOFFP(IBLK2,LVLF) * NP    + 1
                           CALL CUT (IDIM(IBLK1,LVLF), JDIM(IBLK1,LVLF),
     1                               KDIM(IBLK1,LVLF), PROPS(IP1),
     2                               IDIM(IBLK2,LVLF), JDIM(IBLK2,LVLF),
     3                               KDIM(IBLK2,LVLF), PROPS(IP2),
     4                               ICUTS(1,ICUT,LVLF), NP)
                        ENDIF
  740                CONTINUE
  750             CONTINUE
C
C    End   Prolongation
C
  790          CONTINUE
C
C    End   Sub-iterations; Q = Q^(n+1)
C
C    Output intermediate restart file - but not on the last iteration
C
               IF (ITER/NITRST*NITRST .EQ. ITER         .AND.
     1             ITER               .NE. NITS(LVLONE)) THEN
                  CALL WRREST (NXBLKS, NXLVLS, NXPTS,  NXQNPT, NXPPTS,
     1                         NXBCS,  NXSIZE, NXSECT,
     2                         IOFFS,  IOFFQ,  IOFFP,  IOFFQN,
     3                         NBLKS,  NLVLS,  IMODEL, IFDELQ, ITER,
     4                         IDIM,   JDIM,   KDIM,
     5                         Q, QN, PROPS, S, VOL, NBCS, IBCDAT,
     6                         RES, QP, QM, DQP, DQM, F, FM,WORKX,STEMP,
     7                         FWRRST, IERRCD)
                  IF (IERRCD .NE. INO) GO TO 999
               ENDIF
  800       CONTINUE
C
C 12-c. If not finest grid, then interpolate to the next finer grid and
C       update the properties and boundary conditions.
C
            IF (ICFS .NE. NCFS) THEN
               LVLC = NCFS - ICFS + 1
               LVLF = LVLC - 1
               WRITE (IOUT,8100) LVLC, LVLF
 8100 FORMAT (//' ','MAIN  : Interpolating from grid level ',I3,
     1              ' to grid level ',I3//)
C
C 12-c-i.   Interpolate coarse grid to fine grid for each block.
C           Modify cell face bc data to be at ghost cells then call
C           interpolation routine.
C
               DO 850 IBLK = 1, NBLKS
                  IQC = IOFFQ(IBLK,LVLC) * NQ    + 1
                  IQF = IOFFQ(IBLK,LVLF) * NQ    + 1
                  CALL QBCMOD (IDIM(IBLK,LVLC), JDIM(IBLK,LVLC),
     1                         KDIM(IBLK,LVLC), Q(IQC),
     2                         NBCS(IBLK), IBCDAT(1,1,IBLK,LVLC))
                  CALL INT2HQ (IDIM(IBLK,LVLC), JDIM(IBLK,LVLC),
     1                         KDIM(IBLK,LVLC), Q(IQC),
     2                         IDIM(IBLK,LVLF), JDIM(IBLK,LVLF),
     3                         KDIM(IBLK,LVLF), Q(IQF))
                  CALL QBCFIX (IDIM(IBLK,LVLC), JDIM(IBLK,LVLC),
     1                         KDIM(IBLK,LVLC), Q(IQC),
     2                         NBCS(IBLK), IBCDAT(1,1,IBLK,LVLC))
  850          CONTINUE
C
C 12-c-ii.  Update boundary conditions and properties on each block
C
               DO 870 IBLK = 1, NBLKS
                  IQ = IOFFQ(IBLK,LVLF) * NQ    + 1
                  IP = IOFFP(IBLK,LVLF) * NP    + 1
                  IS = IOFFS(IBLK,LVLF) * 4 * 3 + 1
                  IV = IOFFS(IBLK,LVLF)         + 1
                  IR = IOFFS(IBLK,LVLF) * 3     + 1
C
                  IF (ITURB .GE. ITLMNR) THEN
                     NPPTS = (IDIM(IBLK,LVLF)+3) * (JDIM(IBLK,LVLF)+3) *
     1                       (KDIM(IBLK,LVLF)+3)
                     IPSTRT = 1
                     IPEND  = IDIM(IBLK,LVLF) + 1
C
C           Update properties array
C
                     CALL PRPRTY (IDIM(IBLK,LVLF), JDIM(IBLK,LVLF),
     1                            KDIM(IBLK,LVLF), IPSTRT, IPEND,MXSECT,
     2                            Q(IQ), PROPS(IP), S(IS), VOL(IV),
     3                            IBCDAT(1,1,IBLK,LVLF), NBCS(IBLK),
     4                            IMODEL, IFDELQ,
     5                            STEMP, QP, F, FM, QM, DQP, DQM, WORKX)
                  ELSE
                     NPPTS = MXPPTS
                  ENDIF
C
C           Update boundary conditions
C
                  CALL BC (IDIM(IBLK,LVLF),JDIM(IBLK,LVLF),
     1                  KDIM(IBLK,LVLF), 1, IDIM(IBLK,LVLF)+1,
     2                  Q(IQ), PROPS(IP), NPPTS, S(IS), VOL(IV), R(IR),
     3                  NBCS(IBLK), IBCDAT(1,1,IBLK,LVLF),
     4                  NXPROF, NPROFL, IOFQBC(1,LVLF), QBC,
     5                  VISCOS(1,IBLK), IMODEL, QP, MXSECT, CL, RCNTR)
 870           CONTINUE
C
C 12-c-iii. Do block boundary conditions (CUTS)
C
               DO 890 ICUT = 1, NCUTS
                  IBLK1 = ICUTS( 1,ICUT,LVLF)
                  IBLK2 = ICUTS(10,ICUT,LVLF)
                  IQ1   = IOFFQ(IBLK1,LVLF) * NQ    + 1
                  IQ2   = IOFFQ(IBLK2,LVLF) * NQ    + 1
                  CALL CUT (IDIM(IBLK1,LVLF), JDIM(IBLK1,LVLF),
     1                      KDIM(IBLK1,LVLF), Q(IQ1),
     2                      IDIM(IBLK2,LVLF), JDIM(IBLK2,LVLF),
     3                      KDIM(IBLK2,LVLF), Q(IQ2),
     4                      ICUTS(1,ICUT,LVLF), NQ)
                  IF (ITURB .GE. ITLMNR) THEN
                     IP1   = IOFFP(IBLK1,LVLF) * NP    + 1
                     IP2   = IOFFP(IBLK2,LVLF) * NP    + 1
                     CALL CUT (IDIM(IBLK1,LVLF), JDIM(IBLK1,LVLF),
     1                         KDIM(IBLK1,LVLF), PROPS(IP1),
     2                         IDIM(IBLK2,LVLF), JDIM(IBLK2,LVLF),
     3                         KDIM(IBLK2,LVLF), PROPS(IP2),
     4                         ICUTS(1,ICUT,LVLF), NP)
                  ENDIF
  890          CONTINUE
            ENDIF
            ITRUN = ITRUN + NITS(LVLONE)
  900    CONTINUE
C
C     Jump here if STOP file is encountered
C
  905    CONTINUE
C
C     Calculate execution time of run
C
      ENDIF
C
C 13. OUTPUT RESTART DATA
C     Update properties.
C     If unsteady, convert QN to primitive (N.B. storage for tke is over nnpts)
C     Write restart file.
C
  910 CONTINUE
C
      CALL WRREST (NXBLKS, NXLVLS, NXPTS,  NXQNPT, NXPPTS,
     1             NXBCS,  NXSIZE, NXSECT,
     2             IOFFS,  IOFFQ,  IOFFP,  IOFFQN,
     3             NBLKS,  NLVLS,  IMODEL, IFDELQ, ITRUN,
     4             IDIM,   JDIM,   KDIM,
     5             Q, QN, PROPS, S, VOL, NBCS, IBCDAT,
     6             RES, QP, QM, DQP, DQM, F, FM, WORKX, STEMP,
     7             FWRRST, IERRCD)
      IF (IERRCD .NE. INO) GO TO 999
C
C 14. OUTPUT
C     Write output and PLOT3D output
C     (PLOT3D output in multiple grid format)
C     Use RES array as temporary space to interpolate the grid
C     nodal values to cell centers.
C
      ILVL = 1
      IFPLT3=.FALSE. !DJB-NOT DOING THE BINARY PLOT THING
      IF ( IFPLT3 ) THEN
C
C Binary PLOT3D output
C
         BINPLT=.FALSE. !DJB-NOT DOING THE BINARY THING
         IF(BINPLT)THEN
C Grid
            FERROR = FPLT3G
                  LOCATION=3 !DJB
            OPEN (IPLT3G,FILE=FPLT3G,FORM='UNFORMATTED',ERR=990)
            WRITE (IPLT3G) NBLKS
            IF ( THREED ) THEN
               WRITE (IPLT3G) (IDIM(IBLK,ILVL)+1,JDIM(IBLK,ILVL)+1,
     1                         KDIM(IBLK,ILVL)+1,IBLK=1,NBLKS)
            ELSE
               WRITE (IPLT3G) (IDIM(IBLK,ILVL)+1,JDIM(IBLK,ILVL)+1,
     1                         IBLK=1,NBLKS)
            ENDIF
C Solution
            FERROR = FPLT3Q
                  LOCATION=4 !DJB
            OPEN (IPLT3Q,FILE=FPLT3Q,FORM='UNFORMATTED',ERR=990)
            WRITE (IPLT3Q) NBLKS
            IF ( THREED ) THEN
               WRITE (IPLT3Q) (IDIM(IBLK,ILVL)+1,JDIM(IBLK,ILVL)+1,
     1                         KDIM(IBLK,ILVL)+1,IBLK=1,NBLKS)
            ELSE
               WRITE (IPLT3Q) (IDIM(IBLK,ILVL)+1,JDIM(IBLK,ILVL)+1,
     1                         IBLK=1,NBLKS)
            ENDIF
C Function file
            IF (NQ .GT. 5) THEN
               FERROR = FPLT3F
               NVAR   = (NQ - 5) + NP
                  LOCATION=5 !DJB
               OPEN (IPLT3F,FILE=FPLT3F,FORM='UNFORMATTED',ERR=990)
               WRITE (IPLT3F) NBLKS
               IF ( THREED ) THEN
                  WRITE (IPLT3F) (IDIM(IBLK,ILVL)+1,JDIM(IBLK,ILVL)+1,
     1                            KDIM(IBLK,ILVL)+1,NVAR,IBLK=1,NBLKS)
               ELSE
                  WRITE (IPLT3F) (IDIM(IBLK,ILVL)+1,JDIM(IBLK,ILVL)+1,
     1                            NVAR,IBLK=1,NBLKS)
               ENDIF
            ENDIF
C
C Formatted PLOT3D output
C
          ELSE
C Grid
            FERROR = FPLT3G
                  LOCATION=6 !DJB
            OPEN (IPLT3G,FILE=FPLT3G,FORM='FORMATTED',ERR=990)
            WRITE (IPLT3G,'(I5)')  NBLKS
            IF ( THREED ) THEN
               WRITE (IPLT3G,'(3I5)') (IDIM(IBLK,ILVL)+1,
     1                                 JDIM(IBLK,ILVL)+1,
     2                                 KDIM(IBLK,ILVL)+1,IBLK=1,NBLKS)
            ELSE
               WRITE (IPLT3G,'(3I5)') (IDIM(IBLK,ILVL)+1,
     1                                 JDIM(IBLK,ILVL)+1,
     2                                 IBLK=1,NBLKS)
            ENDIF
C Solution
            FERROR = FPLT3Q
                  LOCATION=7 !DJB
            OPEN (IPLT3Q,FILE=FPLT3Q,FORM='FORMATTED',ERR=990)
            WRITE (IPLT3Q,'(I5)')  NBLKS
            IF ( THREED ) THEN
               WRITE (IPLT3Q,'(3I5)') (IDIM(IBLK,ILVL)+1,
     1                                 JDIM(IBLK,ILVL)+1,
     2                                 KDIM(IBLK,ILVL)+1,IBLK=1,NBLKS)
            ELSE
               WRITE (IPLT3Q,'(3I5)') (IDIM(IBLK,ILVL)+1,
     1                                 JDIM(IBLK,ILVL)+1,
     2                                 IBLK=1,NBLKS)
            ENDIF
C Function file
            IF (NQ .GT. 5) THEN
               FERROR = FPLT3F
               NVAR   = (NQ - 5) + NP
                  LOCATION=8 !DJB
               OPEN (IPLT3F,FILE=FPLT3F,FORM='FORMATTED',ERR=990)
               WRITE (IPLT3F,'(I5)') NBLKS
               IF ( THREED ) THEN
                  WRITE (IPLT3F,'(4I5)') (IDIM(IBLK,ILVL)+1,
     1                                    JDIM(IBLK,ILVL)+1,
     2                                    KDIM(IBLK,ILVL)+1,
     3                                    NVAR,IBLK=1,NBLKS)
               ELSE
                  WRITE (IPLT3F,'(4I5)') (IDIM(IBLK,ILVL)+1,
     1                                    JDIM(IBLK,ILVL)+1,
     2                                    NVAR,IBLK=1,NBLKS)
               ENDIF
            ENDIF
          ENDIF
      ENDIF
C
C Plot3d function name file
C
      IF(.FALSE.)THEN !DJB-NOT DOING THIS
        IF(NQ.GT.5)THEN
          FERROR = FPLT3FN
                    LOCATION=9 !DJB
          OPEN(IPLT3FN,FILE=FPLT3FN,FORM='FORMATTED',ERR=990)
          CALL PLOT3DFN (ITURB)
          CLOSE (IPLT3FN)
        ENDIF
      ENDIF
C
C Finished writing PLOT3D headers
C
      IFPLT3=.TRUE. !DJB ALWAYS WANT OUTPUT
      DO IBLK=1,NBLKS
        IQ=IOFFQ(IBLK,ILVL)*NQ+1
        IP=IOFFP(IBLK,ILVL)*NP+1
        IR=IOFFS(IBLK,ILVL)*3+1
        IS=IOFFS(IBLK,ILVL)*4*3+1
        IV=IOFFS(IBLK,ILVL)+1
        INCP=(IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*(KDIM(IBLK,ILVL)+3)
        IP2=IP+INCP
        IP3=IP2+INCP
        CALL OUTPUT(IDIM(IBLK,ILVL),JDIM(IBLK,ILVL),KDIM(IBLK,ILVL),
     &    Q(IQ),PROPS(IP),PROPS(IP2),PROPS(IP3),ITURB,R(IR),IBLK,
     &    NPRINT(IBLK),IPRINT(1,1,IBLK))
        IF(IFPLT3)THEN
          IF(BINPLT)THEN
            WRITE(IPLT3Q)FSMACH,ALPHA,RE,TIME
          ELSE
            WRITE(IPLT3Q,'(4E16.8)')FSMACH,ALPHA,RE,TIME
          ENDIF
          DO ICUT=1,NCUTS
            IF(ICUTS(1,ICUT,ILVL).EQ.IBLK)THEN
              CALL CUT3D(IDIM(IBLK,ILVL),JDIM(IBLK,ILVL),
     1          KDIM(IBLK,ILVL),Q(IQ),ICUTS(1,ICUT,ILVL))
            ENDIF
          ENDDO
          CALLPLOT3D(IDIM(IBLK,ILVL),JDIM(IBLK,ILVL),
     1      KDIM(IBLK,ILVL),Q(IQ),PROPS(IP),R(IR),BINPLT)
        ENDIF
      ENDDO
C
C Output skin friction and heat transfer data
C
      DO 982 IBLK = 1, NBLKS
         IQ = IOFFQ(IBLK,ILVL) * NQ    + 1
         IP = IOFFP(IBLK,ILVL) * NP    + 1
         IR = IOFFS(IBLK,ILVL) * 3     + 1
         IS = IOFFS(IBLK,ILVL) * 4 * 3 + 1
         IV = IOFFS(IBLK,ILVL)         + 1
C
         INCP   = (IDIM(IBLK,ILVL)+3)*(JDIM(IBLK,ILVL)+3)*
     1            (KDIM(IBLK,ILVL)+3)
         IP2 = IP  + INCP
         IP3 = IP2 + INCP
C
         DO 981 IBC = 1, NBCS(IBLK)
            IF ( (IBCDAT(1,IBC,IBLK,ILVL) .EQ. IWALL .OR.
     1            IBCDAT(1,IBC,IBLK,ILVL) .EQ. IWALFN ) ) THEN
               CALL SFHT  (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                     KDIM(IBLK,ILVL), 2, IDIM(IBLK,ILVL),ITURB,
     2                     Q(IQ), PROPS(IP), S(IS), VOL(IV),
     3                     IBCDAT(1,IBC,IBLK,ILVL), R(IR), IBLK)
            ENDIF
  981    CONTINUE
  982 CONTINUE
C
      GO TO 999
C
C 15.   Error Handling Section
C 15-a. Bad file name
C
  990 CONTINUE
      WRITE(IOUT,9990)FERROR
 9990 FORMAT('MAIN: ERROR-> Error opening file ',A80)
      WRITE(*,*)'LOCATION=',LOCATION !DJB
      GO TO 999
C
C 16.   Close output and finish
C
  999 CONTINUE
      CLOSE (IOUT)
C
C     Finished with ISAAC run.
C
      STOP
      END
C
C Revision 4.3  2001/06/08 06:25:38  jhmorr
C Fixed error in BCPRSB where S, PROPS are dimensioned but not passed
C
C Revision 4.2  2001/06/08 04:56:15  jhmorr
C Added notice
C
C Revision 4.1.1.16  1998/09/22 14:16:17  jhmorr
C Removed S from bchshr routine; it is not used.
C
C Revision 4.1.1.15  1998/06/20  18:55:58  jhmorr
C Modify shear condition to match Tavoularis and Corrsin.
C
C Revision 4.1.1.14  1998/06/11  00:29:32  jhmorr
C Removed debug output.
C
C Revision 4.1.1.13  1998/06/10  23:58:38  jhmorr
C Corrections to shear and domain constants in homogeneous shear BC.
C
C Revision 4.1.1.12  1998/06/10  19:19:40  jhmorr
C Added numbers for the homogeneous shear test case.
C
C Revision 4.1.1.11  1998/06/10  14:01:21  jhmorr
C Added check for INC being too large in homogeneous shear BC.
C
C Revision 4.1.1.10  1998/06/06  20:23:33  jhmorr
C Updates to corrected homogeneous shear BC.
C
C Revision 4.1.1.9  1998/06/06  18:55:11  jhmorr
C Corrections to calculate the initial interpolating point for the
C homogeneous shear BC.
C
C Revision 4.1.1.8  1998/06/06  14:38:51  jhmorr
C Corrected error for the second BC on the outer boundary for the homogeneous
C shear BC due to setting deltai = - deltai.
C
C Revision 4.1.1.7  1998/06/06  14:12:11  jhmorr
C Moved invariant calculation of interpolating coefficients outside
C of the loop.
C
C Revision 4.1.1.6  1998/06/06  13:54:44  jhmorr
C Modified calculation of DX0 to make it independent of the loop index.
C
C Revision 4.1.1.5  1998/06/06  13:42:46  jhmorr
C Correction in calculation of DX0 in homogeneous shear BC. DELTAI
C must have the sign of the difference.
C
C Revision 4.1.1.4  1998/06/04  21:24:38  jhmorr
C Corrections to homogeneous shear BC. Also correction to PERIODIC
C BC to loop over np for the properties array.
C
C Revision 4.1.1.3  1998/06/04  13:50:00  jhmorr
C Correction to indices and calculated dxs for homogeneous shear.
C
C Revision 4.1.1.2  1998/05/30  15:40:22  jhmorr
C Added call to homogeneous shear bc.
C
C Revision 4.1.1.1  1998/05/30  15:31:27  jhmorr
C Added initial coding of homogeneous shear boundary condition.
C
C Revision 4.1  1998/04/14  20:34:58  jhmorr
C Alpha 4.1.
C
      SUBROUTINE BC     (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, NPPTS, S, VOL, RC,
     2                   NBCS, IBCDAT, NXPROF, NPROFL, IOFQBC, QBC,
     3                   VISCOS, IMODEL, WORK, MXSECT, CL, RCNTR)
C
C Routine to set boundary conditions. This routine calls the individual
C boundary condition routines to set each type of boundary condition.
C The boundary condition routines extend the BCs from I=2 to I=1 and
C I=IDIM to I=IDIM+1 and similarly for J and K faces to set the corner
C data. Therefore, calling this routine with IPSTRT=2 is identical to
C using IPSTRT=1 and IPEND=IDIM is identical to IPEND=IDIM+1.
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RC             : Position vector at cell centers
C NBCS           : Number of boundary conditions for current block
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C NXPROF         : Maximum number of profile boundary condition segments
C NPROFL         : Number of profile boundary condition segments
C IOFQBC         : Offsets for QBC array
C QBC            : Boundary condition array - for PROFILE data
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C IMODEL         : Turbulence model array
C WORK           : Work array
C MXSECT         : Maximum size of the work array
C CL             : Lift coefficient. Used for 2D farfield vortex bc.
C RCNTR          : Center of airfoil. Used as location of point vortex.
C                  Also used as airfoil location at which to calculate moments.
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          RC    (1:JDIM+1,1:KDIM+1,1:IDIM+1,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IOFQBC(NXPROF)
      DIMENSION QBC   (*)
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION WORK  (MXSECT,NQ)
C
      LOGICAL   VISCOS(3)
C
      DIMENSION RCNTR (3)
C
C Need to add Logic to avoid calling the IDIR = 1 (I) direction boundary
C     conditions when in the interior of the domain and using a planar
C     time integration scheme (e.g. LGS, MARCH).  Need to allow for the
C     call for other time integration schemes and when using a planar
C     scheme on the first plane for a conical solution procedure.
C
      ITURB = IMODEL(1)
C
      DO 900 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
C
C     Do not call K-direction boundary conditions for 2D flows
C
         IDIR   = IBCDAT(2,IBC)
         IF (.NOT.THREED .AND. .NOT.AXISYM .AND. IDIR .EQ. 3) GO TO 900
C
C     Wall boundary condition
C
         IF (IBCTYP .EQ. IWALL) THEN
            CALL BCWALL (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Wall Functions boundary condition
C
         ELSE IF (IBCTYP .EQ. IWALFN) THEN
            CALL BCWALF (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, VOL, IBCDAT(1,IBC))
C
C     Tangency boundary condition
C
         ELSE IF (IBCTYP .EQ. ITAN) THEN
            CALL BCTAN  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Farfield boundary condition
C
         ELSE IF (IBCTYP .EQ. IFAR) THEN
            CALL BCFAR  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     2D Farfield boundary condition with point vortex correction
C
         ELSE IF (IBCTYP .EQ. IFAR2D) THEN
            CALL BCFR2D (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, RC, IBCDAT(1,IBC), CL, RCNTR)
C
C     Extrapolation boundary condition
C     This is general for any number of equations
C
         ELSE IF (IBCTYP .EQ. IEXT) THEN
            CALL BCEXT  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Fix boundary condition
C
         ELSE IF (IBCTYP .EQ. IFIX) THEN
            CALL BCFIX  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Jet boundary condition
C
         ELSE IF (IBCTYP .EQ. IJET) THEN
            CALL BCJET  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Symmetry boundary condition
C
         ELSE IF (IBCTYP .EQ. ISYMXY .OR. IBCTYP .EQ. ISYMXZ
     1                               .OR. IBCTYP .EQ. ISYMYZ) THEN
            CALL BCSYM  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC), WORK)
C
C     Periodic boundary condition
C
         ELSE IF (IBCTYP .EQ. IPERD) THEN
            CALL BCPERD (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Profile boundary condition
C
         ELSE IF (IBCTYP .EQ. IPROFL) THEN
            ISTRT  = IBCDAT( 4,IBC)
            IEND   = IBCDAT( 5,IBC)
            JSTRT  = IBCDAT( 6,IBC)
            JEND   = IBCDAT( 7,IBC)
            KSTRT  = IBCDAT( 8,IBC)
            KEND   = IBCDAT( 9,IBC)
            INPROF = IBCDAT(10,IBC)
            IQBC   = IOFQBC(INPROF) * NQ + 1
            NPTS   = (IEND-ISTRT+1) * (JEND-JSTRT+1) * (KEND-KSTRT+1)
            CALL BCPRFL (IDIM, JDIM, KDIM, IPSTRT, IPEND, NPTS,
     1                   Q, QBC(IQBC), S, IBCDAT(1,IBC), IERROR)
C
C     Subsonic Profile boundary condition
C     - call profile bc first and then update the pressure
C
         ELSE IF (IBCTYP .EQ. IPROSB) THEN
            ISTRT  = IBCDAT( 4,IBC)
            IEND   = IBCDAT( 5,IBC)
            JSTRT  = IBCDAT( 6,IBC)
            JEND   = IBCDAT( 7,IBC)
            KSTRT  = IBCDAT( 8,IBC)
            KEND   = IBCDAT( 9,IBC)
            INPROF = IBCDAT(10,IBC)
            IQBC   = IOFQBC(INPROF) * NQ + 1
            NPTS   = (IEND-ISTRT+1) * (JEND-JSTRT+1) * (KEND-KSTRT+1)
            CALL BCPRFL (IDIM, JDIM, KDIM, IPSTRT, IPEND, NPTS,
     1                   Q, QBC(IQBC), S, IBCDAT(1,IBC), IERROR)
            CALL BCPRSB (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, IBCDAT(1,IBC), IERROR)
C
C     Subsonic Inflow  boundary condition
C
         ELSE IF (IBCTYP .EQ. IINFLO) THEN
            CALL BCSIN  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Subsonic Outflow boundary condition
C
         ELSE IF (IBCTYP .EQ. IOUTFL) THEN
            CALL BCSOUT (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Axisymmetric boundary condition
C
         ELSE IF (IBCTYP .EQ. IAXISM) THEN
            CALL BCAXI  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Axisymmetric centerline boundary condition
C
         ELSE IF (IBCTYP .EQ. IAXICL) THEN
            CALL BCAXCL (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT(1,IBC))
C
C     Homogeneous Shear Periodic boundary condition
C
C N.B. Need to fix the WORK array here
C
         ELSE IF (IBCTYP .EQ. IHSHR) THEN
            CALL BCHSHR (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, IBCDAT(1,IBC),
     2                   WORK(1,1), WORK(1,2))
C
C     Error
C
         ELSE
            WRITE (IOUT,1000) IBC, IBCTYP
         ENDIF
 900  CONTINUE
C
C     Finished with boundary condition routine
      RETURN
 1000 FORMAT (' ','BC    : ERROR-> An illegal boundary condition ',
     1            'type occurs in the ',I3,
     2            ' boundary condition and is = ',I3)
      END
      SUBROUTINE BCAXI  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to set the axisymmetric boundary condition.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 0. Constants for rotation (2 theta) as the grid is rotated theta and the
C    bc data point is a ghost point.
C
      PI        = ACOS(-1.E0)
      STHETA    = SIN (2.E0 * AXIDTH * PI / 180.E0)
      CTHETA    = COS (2.E0 * AXIDTH * PI / 180.E0)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C      SGNM   is sign for the rotation (negative for K = 1    boundary,
C                                       positive for K = KDIM boundary)
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCM   = 1
         SGNM   = - 1.E0
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCM   = IJKDIM(IDIR)
         SGNM   = 1.E0
      ENDIF
C
      STHETA = STHETA * SGNM
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            U    = Q(JN, KN, IN, 2)
            V    = Q(JN, KN, IN, 3)
            W    = Q(JN, KN, IN, 4)
C
            UAXI = U
            VAXI = V * CTHETA
            WAXI = V * STHETA
C
            Q(JBC ,KBC ,IBC ,1) = Q(JN  ,KN  ,IN  ,1)
            Q(JBC ,KBC ,IBC ,2) = UAXI
            Q(JBC ,KBC ,IBC ,3) = VAXI
            Q(JBC ,KBC ,IBC ,4) = WAXI
            Q(JBC ,KBC ,IBC ,5) = Q(JN  ,KN  ,IN  ,5)
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon, k-omega
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
               Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
C
C Stresses in cylindrical coordinates are invariant in theta
C => Tau_ij_bc = Tau_ij_n (cylindrical coordinates)
C    Note also that Tau_r,theta = Tau_theta,z = 0
C
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               TAUXXN = Q(JN  ,KN  ,IN  , 6)
               TAUYYN = Q(JN  ,KN  ,IN  , 7)
               TAUZZN = Q(JN  ,KN  ,IN  , 8)
               TAUXYN = Q(JN  ,KN  ,IN  , 9)
               TAUXZN = Q(JN  ,KN  ,IN  ,10)
               TAUYZN = Q(JN  ,KN  ,IN  ,11)
C
C Cylindrical coordinates (r,theta,z correspond to R,T(theta),S(streamwise))
C
               TAURR  = TAUYYN
               TAUTT  = TAUZZN
               TAUSS  = TAUXXN
               TAURS  = TAUXYN
C
C Back to Cartesian
C
               TAUXX  =   TAUSS
               TAUYY  =   CTHETA*CTHETA*TAURR + STHETA*STHETA*TAUTT
               TAUZZ  =   STHETA*STHETA*TAURR + CTHETA*CTHETA*TAUTT
               TAUXY  =   CTHETA * TAURS
               TAUXZ  = - STHETA * TAURS
               TAUYZ  =   CTHETA*STHETA*(TAUTT - TAURR)
C
               Q(JBC ,KBC ,IBC , 6) = TAUXX
               Q(JBC ,KBC ,IBC , 7) = TAUYY
               Q(JBC ,KBC ,IBC , 8) = TAUZZ
               Q(JBC ,KBC ,IBC , 9) = TAUXY
               Q(JBC ,KBC ,IBC ,10) = TAUXZ
               Q(JBC ,KBC ,IBC ,11) = TAUYZ
               Q(JBC ,KBC ,IBC ,12) = Q(JN  ,KN  ,IN  ,12)
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with FIX boundary condition
      RETURN
      END
      SUBROUTINE BCAXCL (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to set the axisymmetric centerline boundary condition for y = 0.
C N.B. ONLY FOR Y = 0.
C Set scalars equal to interior value, reflect v velocity.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C      SGNM   is sign for the rotation (negative for K = 1    boundary,
C                                       positive for K = KDIM boundary)
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCN2  = 3
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for Mean Variables
C    Set scalars equal to interior value, reflect v velocity about y = 0.
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            Q(JBC ,KBC ,IBC ,1) =   Q(JN  ,KN  ,IN  ,1)
            Q(JBC ,KBC ,IBC ,2) =   Q(JN  ,KN  ,IN  ,2)
            Q(JBC ,KBC ,IBC ,3) = - Q(JN  ,KN  ,IN  ,3)
            Q(JBC ,KBC ,IBC ,4) =   Q(JN  ,KN  ,IN  ,4)
            Q(JBC ,KBC ,IBC ,5) =   Q(JN  ,KN  ,IN  ,5)
C
            Q(JBC2,KBC2,IBC2,1) =   Q(JN2 ,KN2 ,IN2 ,1)
            Q(JBC2,KBC2,IBC2,2) =   Q(JN2 ,KN2 ,IN2 ,2)
            Q(JBC2,KBC2,IBC2,3) = - Q(JN2 ,KN2 ,IN2 ,3)
            Q(JBC2,KBC2,IBC2,4) =   Q(JN2 ,KN2 ,IN2 ,4)
            Q(JBC2,KBC2,IBC2,5) =   Q(JN2 ,KN2 ,IN2 ,5)
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon, k-omega
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
               Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
               Q(JBC2,KBC2,IBC2,6) = Q(JN2 ,KN2 ,IN2 ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JN2 ,KN2 ,IN2 ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
C
C Infinity conditions
C
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               TAUXX = Q(JN  ,KN  ,IN  , 6)
               TAUYY = Q(JN  ,KN  ,IN  , 7)
               TAUZZ = Q(JN  ,KN  ,IN  , 8)
               TAUXY = Q(JN  ,KN  ,IN  , 9)
               TAUXZ = Q(JN  ,KN  ,IN  ,10)
               TAUYZ = Q(JN  ,KN  ,IN  ,11)
C
               Q(JBC ,KBC ,IBC , 6) = TAUXX
               Q(JBC ,KBC ,IBC , 7) = TAUYY
               Q(JBC ,KBC ,IBC , 8) = TAUZZ
               Q(JBC ,KBC ,IBC , 9) = TAUXY
               Q(JBC ,KBC ,IBC ,10) = TAUXZ
               Q(JBC ,KBC ,IBC ,11) = TAUYZ
               Q(JBC ,KBC ,IBC ,12) = Q(JN  ,KN  ,IN  ,12)
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JN2 ,KN2 ,IN2 , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JN2 ,KN2 ,IN2 , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JN2 ,KN2 ,IN2 , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JN2 ,KN2 ,IN2 , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JN2 ,KN2 ,IN2 ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JN2 ,KN2 ,IN2 ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JN2 ,KN2 ,IN2 ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with FIX boundary condition
      RETURN
      END
      SUBROUTINE BCEXT  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do First Order Extrapolation boundary condition.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for all variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCM   = 1
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCM   = IJKDIM(IDIR)
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for ALL Variables
C
      DO 130 L = 1, NQ
         DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,L) = Q(JN  ,KN  ,IN  ,L)
               Q(JBC2,KBC2,IBC2,L) = Q(JN  ,KN  ,IN  ,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C Finished with First Order Extrapolation boundary condition
      RETURN
      END
      SUBROUTINE BCFAR  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do FARFIELD (1-dimensional Riemann invariants) boundary condition.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCM   = 1
         SGNM   = 1.E0
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCM   = IJKDIM(IDIR)
         SGNM   = - 1.E0
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C Conditions at infinity
C
      SINF  = PREF / RHOINF**GAMMA
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C       U (dot) n > 0  for inflow  to   domain
C                 < 0  for outflow from domain
C The use of the SGNM variable sets up one set of logic
C to handle both the inner and outer boundary cases.
C
            SX    = S(JM,KM,IM,1,IDIR) * SGNM
            SY    = S(JM,KM,IM,2,IDIR) * SGNM
            SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
            QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1            + Q(JN,KN,IN,4) * SZ
            QINF  = UINF * SX + VINF * SY + WINF * SZ
            RHON  = Q(JN,KN,IN,1)
            PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
            AEXT  = SQRT (GAMMA * PN / RHON)
            REXT  = QEXT - 2.E0 * AEXT / GAMM1
            RINF  = QINF + 2.E0 * AINF / GAMM1
            QDOTN = 0.5E0 * (REXT + RINF)
            A     = 0.25E0 * GAMM1 * (RINF - REXT)
            RMACH = QDOTN / A
            SEXT  = PN   / RHON  **GAMMA
C
C Inflow
C
            IF (QDOTN .GT. 0.E0) THEN
C
C     Supersonic Inflow - Data Specified
C
               IF (ABS(RMACH) .GE. 1.0E0) THEN
                  Q(JBC ,KBC ,IBC ,1) = RHOINF
                  Q(JBC ,KBC ,IBC ,2) = UINF
                  Q(JBC ,KBC ,IBC ,3) = VINF
                  Q(JBC ,KBC ,IBC ,4) = WINF
                  Q(JBC ,KBC ,IBC ,5) = PREF
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ELSE
C
C     Subsonic Inflow - One Dimensional Riemann Problem
C     From Jameson and Baker, AIAA 83-1929
C
                  RHOBC  = (A*A / (GAMMA*SINF))**(1.E0/GAMM1)
                  Q(JBC ,KBC ,IBC ,1) = RHOBC
                  Q(JBC ,KBC ,IBC ,2) = UINF + (QDOTN-QINF)*SX
                  Q(JBC ,KBC ,IBC ,3) = VINF + (QDOTN-QINF)*SY
                  Q(JBC ,KBC ,IBC ,4) = WINF + (QDOTN-QINF)*SZ
                  Q(JBC ,KBC ,IBC ,5) = RHOBC * A * A / GAMMA
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ENDIF
C
C Outflow
C
            ELSE
C
C     Supersonic Outflow - Data Extrapolated
C
               IF (ABS(RMACH) .GE. 1.0E0) THEN
                  Q(JBC ,KBC ,IBC ,1) = Q(JN  ,KN  ,IN  ,1)
                  Q(JBC ,KBC ,IBC ,2) = Q(JN  ,KN  ,IN  ,2)
                  Q(JBC ,KBC ,IBC ,3) = Q(JN  ,KN  ,IN  ,3)
                  Q(JBC ,KBC ,IBC ,4) = Q(JN  ,KN  ,IN  ,4)
                  Q(JBC ,KBC ,IBC ,5) = Q(JN  ,KN  ,IN  ,5)
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ELSE
C
C     Subsonic Outflow - One Dimensional Riemann Problem
C     From Jameson and Baker, AIAA 83-1929
C
                  RHOBC  = (A*A / (GAMMA*SEXT))**(1.E0/GAMM1)
                  Q(JBC ,KBC ,IBC ,1) = RHOBC
                  Q(JBC ,KBC ,IBC ,2) = Q(JN,KN,IN,2) + (QDOTN-QEXT)*SX
                  Q(JBC ,KBC ,IBC ,3) = Q(JN,KN,IN,3) + (QDOTN-QEXT)*SY
                  Q(JBC ,KBC ,IBC ,4) = Q(JN,KN,IN,4) + (QDOTN-QEXT)*SZ
                  Q(JBC ,KBC ,IBC ,5) = RHOBC * A * A / GAMMA
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ENDIF
            ENDIF
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C
               SX    = S(JM,KM,IM,1,IDIR) * SGNM
               SY    = S(JM,KM,IM,2,IDIR) * SGNM
               SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1               + Q(JN,KN,IN,4) * SZ
               QINF  = UINF * SX + VINF * SY + WINF * SZ
               RHON  = Q(JN,KN,IN,1)
               PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
               AEXT  = SQRT (GAMMA * PN / RHON)
               REXT  = QEXT - 2.E0 * AEXT / GAMM1
               RINF  = QINF + 2.E0 * AINF / GAMM1
               QDOTN = 0.5E0 * (REXT + RINF)
C
C Inflow - Data specified from freestream
C
C-             IF (QDOTN .GT. 0.E0) THEN
C
C-                Q(JBC ,KBC ,IBC ,6) = TKEINF
C-                Q(JBC ,KBC ,IBC ,7) = EPSINF
C
C-                Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
C-                Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C
C Outflow - Data extrapolated from interior
C
C-             ELSE
C
                  Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
                  Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
                  Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
                  Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C-             ENDIF
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C
               SX    = S(JM,KM,IM,1,IDIR) * SGNM
               SY    = S(JM,KM,IM,2,IDIR) * SGNM
               SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1               + Q(JN,KN,IN,4) * SZ
               QINF  = UINF * SX + VINF * SY + WINF * SZ
               RHON  = Q(JN,KN,IN,1)
               PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
               AEXT  = SQRT (GAMMA * PN / RHON)
               REXT  = QEXT - 2.E0 * AEXT / GAMM1
               RINF  = QINF + 2.E0 * AINF / GAMM1
               QDOTN = 0.5E0 * (REXT + RINF)
C
C Inflow - Data specified from freestream
C
C-             IF (QDOTN .GT. 0.E0) THEN
C
C-                Q(JBC ,KBC ,IBC ,6) = TKEINF
C-                Q(JBC ,KBC ,IBC ,7) = OMEINF
C
C-                Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
C-                Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C
C Outflow - Data extrapolated from interior
C
C-             ELSE
C
                  Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
                  Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
                  Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
                  Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C-             ENDIF
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C
               SX    = S(JM,KM,IM,1,IDIR) * SGNM
               SY    = S(JM,KM,IM,2,IDIR) * SGNM
               SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1               + Q(JN,KN,IN,4) * SZ
               QINF  = UINF * SX + VINF * SY + WINF * SZ
               RHON  = Q(JN,KN,IN,1)
               PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
               AEXT  = SQRT (GAMMA * PN / RHON)
               REXT  = QEXT - 2.E0 * AEXT / GAMM1
               RINF  = QINF + 2.E0 * AINF / GAMM1
               QDOTN = 0.5E0 * (REXT + RINF)
C
C Inflow - Data specified from freestream
C
C-             IF (QDOTN .GT. 0.E0) THEN
C
C-                Q(JBC ,KBC ,IBC , 6) = TAUINF(1)
C-                Q(JBC ,KBC ,IBC , 7) = TAUINF(2)
C-                Q(JBC ,KBC ,IBC , 8) = TAUINF(3)
C-                Q(JBC ,KBC ,IBC , 9) = TAUINF(4)
C-                Q(JBC ,KBC ,IBC ,10) = TAUINF(5)
C-                Q(JBC ,KBC ,IBC ,11) = TAUINF(6)
C-                Q(JBC ,KBC ,IBC ,12) = EPSINF
C
C-                Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
C-                Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
C-                Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
C-                Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
C-                Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
C-                Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
C-                Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
C
C Outflow - Data extrapolated from interior
C
C-             ELSE
C
                  Q(JBC ,KBC ,IBC , 6) = Q(JN  ,KN  ,IN  , 6)
                  Q(JBC ,KBC ,IBC , 7) = Q(JN  ,KN  ,IN  , 7)
                  Q(JBC ,KBC ,IBC , 8) = Q(JN  ,KN  ,IN  , 8)
                  Q(JBC ,KBC ,IBC , 9) = Q(JN  ,KN  ,IN  , 9)
                  Q(JBC ,KBC ,IBC ,10) = Q(JN  ,KN  ,IN  ,10)
                  Q(JBC ,KBC ,IBC ,11) = Q(JN  ,KN  ,IN  ,11)
                  Q(JBC ,KBC ,IBC ,12) = Q(JN  ,KN  ,IN  ,12)
C
                  Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
                  Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
                  Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
                  Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
                  Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
                  Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
                  Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
C-             ENDIF
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with FARFIELD boundary condition
      RETURN
      END
      SUBROUTINE BCFR2D (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, RC, IBCDAT, CL, RCNTR)
C
C Routine to do 2D FARFIELD (1-dimensional Riemann invariants) boundary
C condition with a point vortex correction. The theory of the farfield bc
C with a point vortex correction is available in AIAA Paper 85-0020 by
C J.L. Thomas and M. D. Salas.
C
C N.B. This BC is ONLY valid for a 2D airfoil flow.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C RC             : Position vector at cell centers
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C CL             : Lift coefficient.  Used to calculate circulation.
C RCNTR          : Center of airfoil. Used as location of point vortex.
C                  Also used as airfoil location at which to calculate moments.
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          RC    (1:JDIM+1,1:KDIM+1,1:IDIM+1,3)
C
      DIMENSION IBCDAT(10)
C
      DIMENSION RCNTR (3)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCM   = 1
         SGNM   = 1.E0
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCM   = IJKDIM(IDIR)
         SGNM   = - 1.E0
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C Conditions at infinity
C
      SINF   = PREF / RHOINF**GAMMA
C
C Calculate circulation, compressibility factor, and constants for the
C point vortex correction.
C     AREARF is the airfoil chord in 2D.
C
      PI     = ACOS(-1.E0)
      ALPHAR = ALPHA * PI / 180.E0
C
      CBETA  = SQRT ( ABS (1.E0 - FSMACH * FSMACH) )
      FCONST = 0.25E0 * FSMACH * CL * AREARF * CBETA / PI
C-----write (iout,'(a,2e15.7)') ' cbeta, fconst: ', cbeta, fconst
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C       U (dot) n > 0  for inflow  to   domain
C                 < 0  for outflow from domain
C The use of the SGNM variable sets up one set of logic
C to handle both the inner and outer boundary cases.
C
            SX    = S(JM,KM,IM,1,IDIR) * SGNM
            SY    = S(JM,KM,IM,2,IDIR) * SGNM
            SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
C Calculate the farfield velocity as the freestream velocity plus a correction
C due to a point vortex on the airfoil. 2D ONLY => WFAR = 0.
C      atan2 returns -pi < theta < pi
C
            XFAR  = RC(JBC,KBC,IBC,1) - RCNTR(1)
            YFAR  = RC(JBC,KBC,IBC,2) - RCNTR(2)
            RFAR  = SQRT (XFAR * XFAR + YFAR * YFAR)
            ANGLE = ATAN2 (YFAR, XFAR)
C
            FVORT = FCONST /
     1              (RFAR * (1.E0 - (FSMACH*SIN(ANGLE-ALPHAR))**2))
            UFAR  = UINF + FVORT * SIN (ANGLE)
            VFAR  = VINF - FVORT * COS (ANGLE)
C-----write (iout,'(a,3i5,4e13.5)') ' i,j,k,x,y,r,a ', ibc, jbc, kbc,
C----1          xfar, yfar, rfar, angle
C-----write (iout,'(a,15x,3e13.5)') ' fvort,ufar,vf ', fvort, ufar, vfar
C
            QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
            QINF  = UFAR * SX + VFAR * SY
            RHON  = Q(JN,KN,IN,1)
            PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
            AEXT  = SQRT (GAMMA * PN / RHON)
            REXT  = QEXT - 2.E0 * AEXT / GAMM1
            RINF  = QINF + 2.E0 * AINF / GAMM1
            QDOTN = 0.5E0 * (REXT + RINF)
            A     = 0.25E0 * GAMM1 * (RINF - REXT)
            RMACH = QDOTN / A
            SEXT  = PN   / RHON  **GAMMA
C
C Inflow
C
            IF (QDOTN .GT. 0.E0) THEN
C
C     Supersonic Inflow - Data Specified
C
               IF (ABS(RMACH) .GE. 1.0E0) THEN
                  Q(JBC ,KBC ,IBC ,1) = RHOINF
                  Q(JBC ,KBC ,IBC ,2) = UINF
                  Q(JBC ,KBC ,IBC ,3) = VINF
                  Q(JBC ,KBC ,IBC ,4) = WINF
                  Q(JBC ,KBC ,IBC ,5) = PREF
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ELSE
C
C     Subsonic Inflow - One Dimensional Riemann Problem
C     From Jameson and Baker, AIAA 83-1929
C
                  RHOBC  = (A*A / (GAMMA*SINF))**(1.E0/GAMM1)
                  Q(JBC ,KBC ,IBC ,1) = RHOBC
                  Q(JBC ,KBC ,IBC ,2) = UFAR + (QDOTN-QINF)*SX
                  Q(JBC ,KBC ,IBC ,3) = VFAR + (QDOTN-QINF)*SY
                  Q(JBC ,KBC ,IBC ,4) = 0.E0
                  Q(JBC ,KBC ,IBC ,5) = RHOBC * A * A / GAMMA
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ENDIF
C
C Outflow
C
            ELSE
C
C     Supersonic Outflow - Data Extrapolated
C
               IF (ABS(RMACH) .GE. 1.0E0) THEN
                  Q(JBC ,KBC ,IBC ,1) = Q(JN  ,KN  ,IN  ,1)
                  Q(JBC ,KBC ,IBC ,2) = Q(JN  ,KN  ,IN  ,2)
                  Q(JBC ,KBC ,IBC ,3) = Q(JN  ,KN  ,IN  ,3)
                  Q(JBC ,KBC ,IBC ,4) = Q(JN  ,KN  ,IN  ,4)
                  Q(JBC ,KBC ,IBC ,5) = Q(JN  ,KN  ,IN  ,5)
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ELSE
C
C     Subsonic Outflow - One Dimensional Riemann Problem
C     From Jameson and Baker, AIAA 83-1929
C
                  RHOBC  = (A*A / (GAMMA*SEXT))**(1.E0/GAMM1)
                  Q(JBC ,KBC ,IBC ,1) = RHOBC
                  Q(JBC ,KBC ,IBC ,2) = Q(JN,KN,IN,2) + (QDOTN-QEXT)*SX
                  Q(JBC ,KBC ,IBC ,3) = Q(JN,KN,IN,3) + (QDOTN-QEXT)*SY
                  Q(JBC ,KBC ,IBC ,4) = Q(JN,KN,IN,4) + (QDOTN-QEXT)*SZ
                  Q(JBC ,KBC ,IBC ,5) = RHOBC * A * A / GAMMA
C
                  Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
                  Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
                  Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
                  Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
                  Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
               ENDIF
            ENDIF
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C
               SX    = S(JM,KM,IM,1,IDIR) * SGNM
               SY    = S(JM,KM,IM,2,IDIR) * SGNM
               SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1               + Q(JN,KN,IN,4) * SZ
               QINF  = UINF * SX + VINF * SY + WINF * SZ
               RHON  = Q(JN,KN,IN,1)
               PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
               AEXT  = SQRT (GAMMA * PN / RHON)
               REXT  = QEXT - 2.E0 * AEXT / GAMM1
               RINF  = QINF + 2.E0 * AINF / GAMM1
               QDOTN = 0.5E0 * (REXT + RINF)
C
C Inflow - Data specified from freestream
C
C-             IF (QDOTN .GT. 0.E0) THEN
C
C-                Q(JBC ,KBC ,IBC ,6) = TKEINF
C-                Q(JBC ,KBC ,IBC ,7) = EPSINF
C
C-                Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
C-                Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C
C Outflow - Data extrapolated from interior
C
C-             ELSE
C
                  Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
                  Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
                  Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
                  Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C-             ENDIF
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C
               SX    = S(JM,KM,IM,1,IDIR) * SGNM
               SY    = S(JM,KM,IM,2,IDIR) * SGNM
               SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1               + Q(JN,KN,IN,4) * SZ
               QINF  = UINF * SX + VINF * SY + WINF * SZ
               RHON  = Q(JN,KN,IN,1)
               PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
               AEXT  = SQRT (GAMMA * PN / RHON)
               REXT  = QEXT - 2.E0 * AEXT / GAMM1
               RINF  = QINF + 2.E0 * AINF / GAMM1
               QDOTN = 0.5E0 * (REXT + RINF)
C
C Inflow - Data specified from freestream
C
C-             IF (QDOTN .GT. 0.E0) THEN
C
C-                Q(JBC ,KBC ,IBC ,6) = TKEINF
C-                Q(JBC ,KBC ,IBC ,7) = OMEINF
C
C-                Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
C-                Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C
C Outflow - Data extrapolated from interior
C
C-             ELSE
C
                  Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
                  Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
                  Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
                  Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
C-             ENDIF
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Check U (dot) n for inflow/outflow determination
C
               SX    = S(JM,KM,IM,1,IDIR) * SGNM
               SY    = S(JM,KM,IM,2,IDIR) * SGNM
               SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1               + Q(JN,KN,IN,4) * SZ
               QINF  = UINF * SX + VINF * SY + WINF * SZ
               RHON  = Q(JN,KN,IN,1)
               PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariants
C - the sign of U dot n handles the sign change in the Riemann invariants
C
               AEXT  = SQRT (GAMMA * PN / RHON)
               REXT  = QEXT - 2.E0 * AEXT / GAMM1
               RINF  = QINF + 2.E0 * AINF / GAMM1
               QDOTN = 0.5E0 * (REXT + RINF)
C
C Inflow - Data specified from freestream
C
C-             IF (QDOTN .GT. 0.E0) THEN
C
C-                Q(JBC ,KBC ,IBC , 6) = TAUINF(1)
C-                Q(JBC ,KBC ,IBC , 7) = TAUINF(2)
C-                Q(JBC ,KBC ,IBC , 8) = TAUINF(3)
C-                Q(JBC ,KBC ,IBC , 9) = TAUINF(4)
C-                Q(JBC ,KBC ,IBC ,10) = TAUINF(5)
C-                Q(JBC ,KBC ,IBC ,11) = TAUINF(6)
C-                Q(JBC ,KBC ,IBC ,12) = EPSINF
C
C-                Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
C-                Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
C-                Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
C-                Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
C-                Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
C-                Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
C-                Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
C
C Outflow - Data extrapolated from interior
C
C-             ELSE
C
                  Q(JBC ,KBC ,IBC , 6) = Q(JN  ,KN  ,IN  , 6)
                  Q(JBC ,KBC ,IBC , 7) = Q(JN  ,KN  ,IN  , 7)
                  Q(JBC ,KBC ,IBC , 8) = Q(JN  ,KN  ,IN  , 8)
                  Q(JBC ,KBC ,IBC , 9) = Q(JN  ,KN  ,IN  , 9)
                  Q(JBC ,KBC ,IBC ,10) = Q(JN  ,KN  ,IN  ,10)
                  Q(JBC ,KBC ,IBC ,11) = Q(JN  ,KN  ,IN  ,11)
                  Q(JBC ,KBC ,IBC ,12) = Q(JN  ,KN  ,IN  ,12)
C
                  Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
                  Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
                  Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
                  Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
                  Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
                  Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
                  Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
C-             ENDIF
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with FARFIELD boundary condition
      RETURN
      END
      SUBROUTINE BCFIX  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to FIX the boundary condition to the freestream condition.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCM   = 1
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCM   = IJKDIM(IDIR)
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            Q(JBC ,KBC ,IBC ,1) = RHOINF
            Q(JBC ,KBC ,IBC ,2) = UINF
            Q(JBC ,KBC ,IBC ,3) = VINF
            Q(JBC ,KBC ,IBC ,4) = WINF
            Q(JBC ,KBC ,IBC ,5) = PREF
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = TKEINF
               Q(JBC ,KBC ,IBC ,7) = EPSINF
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = TKEINF
               Q(JBC ,KBC ,IBC ,7) = OMEINF
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
C
C Infinity conditions
C
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC , 6) = TAUINF(1)
               Q(JBC ,KBC ,IBC , 7) = TAUINF(2)
               Q(JBC ,KBC ,IBC , 8) = TAUINF(3)
               Q(JBC ,KBC ,IBC , 9) = TAUINF(4)
               Q(JBC ,KBC ,IBC ,10) = TAUINF(5)
               Q(JBC ,KBC ,IBC ,11) = TAUINF(6)
               Q(JBC ,KBC ,IBC ,12) = EPSINF
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with FIX boundary condition
      RETURN
      END
      SUBROUTINE BCJET  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do JET boundary condition.
C Presently, this is only useful where the jet conditions are prescribed,
C i.e. supersonic jet. This can be used for single/multiple jets of the
C same inflow conditions or for a shear layer simulation.
C
C The jet conditions are passed in through a common in non-dimensional form as:
C      UJET   = u(jet) / ainf
C      VJET   = v(jet) / ainf
C      WJET   = w(jet) / ainf
C      TJET   = T(jet) / Tinf
C      PJET   = p(jet) / (rhoinf * ainf**2)
C The value of the Jet density is then derived as:
C      RHOJET = GAMMA * PJET / TJET
C
C               gamma * p(jet) / (rhoinf * ainf**2)
C             = -----------------------------------
C                       T(jet) / Tinf
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCM   = 1
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCM   = IJKDIM(IDIR)
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            Q(JBC ,KBC ,IBC ,1) = RHOJET
            Q(JBC ,KBC ,IBC ,2) = UJET
            Q(JBC ,KBC ,IBC ,3) = VJET
            Q(JBC ,KBC ,IBC ,4) = WJET
            Q(JBC ,KBC ,IBC ,5) = PJET
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = TKEJET
               Q(JBC ,KBC ,IBC ,7) = EPSJET
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = TKEJET
               Q(JBC ,KBC ,IBC ,7) = OMEJET
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC , 6) = TAUJET(1)
               Q(JBC ,KBC ,IBC , 7) = TAUJET(2)
               Q(JBC ,KBC ,IBC , 8) = TAUJET(3)
               Q(JBC ,KBC ,IBC , 9) = TAUJET(4)
               Q(JBC ,KBC ,IBC ,10) = TAUJET(5)
               Q(JBC ,KBC ,IBC ,11) = TAUJET(6)
               Q(JBC ,KBC ,IBC ,12) = EPSJET
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with JET boundary condition
      RETURN
      END
      SUBROUTINE BCPERD (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do PERIODIC boundary condition in a coordinate direction.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for all variables
C     3. Set boundary conditions for all properties
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCPR  is the periodic location corresponding to IBCPT
C      IBCPR2 is the periodic location corresponding to IBCPT2
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCPR  = IJKDIM(IDIR)
         IBCPR2 = IJKDIM(IDIR) - 1
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCPR  = 2
         IBCPR2 = 3
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for ALL Variables
C
      DO 130 L = 1, NQ
         DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IPR  = IBCPR *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JPR  = IBCPR *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KPR  = IBCPR *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IPR2 = IBCPR2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JPR2 = IBCPR2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KPR2 = IBCPR2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,L) = Q(JPR ,KPR ,IPR ,L)
               Q(JBC2,KBC2,IBC2,L) = Q(JPR2,KPR2,IPR2,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C 3. Boundary conditions for ALL properties
C
      DO 330 L = 1, NP
         DO 320 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 310 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IPR  = IBCPR *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JPR  = IBCPR *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KPR  = IBCPR *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IPR2 = IBCPR2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JPR2 = IBCPR2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KPR2 = IBCPR2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               PROPS(JBC ,KBC ,IBC ,L) = PROPS(JPR ,KPR ,IPR ,L)
               PROPS(JBC2,KBC2,IBC2,L) = PROPS(JPR2,KPR2,IPR2,L)
  310       CONTINUE
  320    CONTINUE
  330 CONTINUE
C
C Finished with PERIODIC boundary condition
      RETURN
      END
      SUBROUTINE BCPRFL (IDIM, JDIM, KDIM, IPSTRT, IPEND, NPTS,
     1                   Q, QBC, S, IBCDAT, IERROR)
C
C Routine to set boundary condition from input profile
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C NPTS           : Number of points in QBC array for this bc segment
C Q              : Primitive variables at cell centers
C QBC            : Boundary data from the PROFILE data
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C IERROR         : Error code
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QBC   (NPTS,NQ),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C     Store boundary condition data in mnemonic names
C     N.B. Do not modify ISTRT or IEND as they are used to calculate indices
C
      IBCTYP = IBCDAT(1)
      IDIR   = IBCDAT(2)
      INROUT = IBCDAT(3)
      ISTRT  = IBCDAT(4)
      IEND   = IBCDAT(5)
      JSTRT  = IBCDAT(6)
      JEND   = IBCDAT(7)
      KSTRT  = IBCDAT(8)
      KEND   = IBCDAT(9)
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C          IBC  is the boundary condition location
C          IBC2 is the boundary condition location outside the block from IBC
C          IN   is the point to the inside of the block from IBC
C
C     I Direction
C
      IF (IDIR .EQ. 1) THEN
         IF (INROUT .EQ. 1) THEN
            IBC  = 1
            IBC2 = 0
            IN   = 2
         ELSE
            IBC  = IDIM + 1
            IBC2 = IDIM + 2
            IN   = IDIM
         ENDIF
         DO 130 L = 1, NQ
            DO 120 K = KSTRT, KEND
               DO 110 J = JSTRT, JEND
                  JKBCPT = (J-JSTRT+1) + (K-KSTRT)*(JEND-JSTRT+1)
                  Q(J,K,IBC,L)  = QBC(JKBCPT,L)
                  Q(J,K,IBC2,L) = Q(J,K,IBC,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
C
C     J Direction
C
      ELSE IF (IDIR .EQ. 2) THEN
         IF (INROUT .EQ. 1) THEN
            JBC  = 1
            JBC2 = 0
            JN   = 2
         ELSE
            JBC  = JDIM + 1
            JBC2 = JDIM + 2
            JN   = JDIM
         ENDIF
         DO 230 L = 1, NQ
            DO 220 I = MAX(ISTRT, IPSTRT), MIN(IEND, IPEND)
               DO 210 K = KSTRT, KEND
                  IKBCPT = (K-KSTRT+1) + (I-ISTRT)*(KEND-KSTRT+1)
                  Q(JBC,K,I,L)  = QBC(IKBCPT,L)
                  Q(JBC2,K,I,L) = Q(JBC,K,I,L)
  210          CONTINUE
  220       CONTINUE
  230    CONTINUE
C
C     K Direction
C
      ELSE IF (IDIR .EQ. 3) THEN
         IF (INROUT .EQ. 1) THEN
            KBC  = 1
            KBC2 = 0
            KN   = 2
         ELSE
            KBC  = KDIM + 1
            KBC2 = KDIM + 2
            KN   = KDIM
         ENDIF
         DO 330 L = 1, NQ
            DO 320 I = MAX(ISTRT, IPSTRT), MIN(IEND, IPEND)
               DO 310 J = JSTRT, JEND
                  JIBCPT = (J-JSTRT+1) + (I-ISTRT)*(JEND-JSTRT+1)
                  Q(J,KBC,I,L)  = QBC(JIBCPT,L)
                  Q(J,KBC2,I,L) = Q(J,KBC,I,L)
  310          CONTINUE
  320       CONTINUE
  330    CONTINUE
      ELSE
         WRITE (IOUT,1000) IDIR
         IERROR = IYES
      ENDIF
C
C     Finished with PROFILE boundary condition
      RETURN
 1000 FORMAT (' ','BC    : ERROR-> Illegal direction = ',I3,
     1            ' in BCPRFL.')
      END
      SUBROUTINE BCPRSB (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, IBCDAT, IERROR)
C
C Routine to modify the pressure for the SUBSONIC PROFILE CC boundary
C condition. The routine bcprfl must first be called to set the profile
C data. This routine then applies a subsonic condition on the pressure.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for pressure
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C--  1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
C--  2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for pressure
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            Q(JBC ,KBC ,IBC ,5) = Q(JN  ,KN  ,IN  ,5)
            Q(JBC2,KBC2,IBC2,5) = Q(JN  ,KN  ,IN  ,5)
  110    CONTINUE
  120 CONTINUE
C
C Finished with SUBSONIC PROFILE CC boundary condition
      RETURN
      END
      SUBROUTINE BCSIN  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do SUBSONIC INFLOW boundary condition.  This routine is based
C on Jeff White's recommendation to use the following: specify total pressure
C and total Temperature, specify flow direction, extrapolate velocities from
C the interior, solve for the speed of sound, get M, calculate static
C conditions using isentropic relations.  Then specify turbulence quantities.
C
C This routine should be used for nozzles, tunnels, etc.
C
C NOTE: This routine cannot currently be used on a boundary that adjoins
C       a WALL or WALL FUNCTION boundary.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCM   = 1
         SGNM   = 1.E0
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCM   = IJKDIM(IDIR)
         SGNM   = - 1.E0
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C Conditions at infinity
C
      SINF  = PREF / RHOINF**GAMMA
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Set the flow direction to use.  Jeff recommends three options:
C     i. Normal to boundary face - default
C    ii. Aligned with local grid - better for highly curved nozzles
C   iii. User input              - to handle other cases
C Current implementation is for i.
C
C The use of the SGNM variable sets up one set of logic
C to handle both the inner and outer boundary cases.
C
            SX    = S(JM,KM,IM,1,IDIR) * SGNM
            SY    = S(JM,KM,IM,2,IDIR) * SGNM
            SZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
            QEXT  = Q(JN,KN,IN,2) * SX + Q(JN,KN,IN,3) * SY
     1            + Q(JN,KN,IN,4) * SZ
            RHON  = Q(JN,KN,IN,1)
            PN    = Q(JN,KN,IN,5)
C
C One Dimensional Riemann invariant
C - the sign of U dot n handles the sign change in the Riemann invariants
C
            AEXT  = SQRT (GAMMA * PN / RHON)
            REXT  = QEXT - 2.E0 * AEXT / GAMM1
            HTEXT = (AEXT*AEXT/GAMM1 + 0.5E0*QEXT*QEXT)
            A     = ( - REXT + SQRT(REXT*REXT
     1                          +(GAMMA+1.E0)*(HTEXT-0.5E0*REXT*REXT)) )
     2              * GAMM1 / (GAMMA + 1.E0)
            QDOTN = REXT + 2.E0 * A / GAMM1
            RMACH = QDOTN / A
C
C Isentropic relationships
C
            ARG   = 1.E0 + 0.5E0 * GAMM1 * RMACH * RMACH
            P     = PTOTBC / ARG**(GAMMA/GAMM1)
            T     = TTOTBC / ARG
            RHO   = GAMMA * P / T
C
C Mean Variables
C
            Q(JBC ,KBC ,IBC ,1) = RHO
            Q(JBC ,KBC ,IBC ,2) = QDOTN * SX
            Q(JBC ,KBC ,IBC ,3) = QDOTN * SY
            Q(JBC ,KBC ,IBC ,4) = QDOTN * SZ
            Q(JBC ,KBC ,IBC ,5) = P
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
C
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = TKEINF
               Q(JBC ,KBC ,IBC ,7) = EPSINF
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = TKEINF
               Q(JBC ,KBC ,IBC ,7) = OMEINF
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC , 6) = TAUINF(1)
               Q(JBC ,KBC ,IBC , 7) = TAUINF(2)
               Q(JBC ,KBC ,IBC , 8) = TAUINF(3)
               Q(JBC ,KBC ,IBC , 9) = TAUINF(4)
               Q(JBC ,KBC ,IBC ,10) = TAUINF(5)
               Q(JBC ,KBC ,IBC ,11) = TAUINF(6)
               Q(JBC ,KBC ,IBC ,12) = EPSINF
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with SUBSONIC INFLOW boundary condition
      RETURN
      END
      SUBROUTINE BCSOUT (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do SUBSONIC OUTFLOW boundary condition.  This is based on Jeff
C White's recommendation for the following: specify static pressure and
C extrapolate everything else.
C
C This routine should be used for nozzles, tunnels, etc.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            Q(JBC ,KBC ,IBC ,1) = Q(JN  ,KN  ,IN  ,1)
            Q(JBC ,KBC ,IBC ,2) = Q(JN  ,KN  ,IN  ,2)
            Q(JBC ,KBC ,IBC ,3) = Q(JN  ,KN  ,IN  ,3)
            Q(JBC ,KBC ,IBC ,4) = Q(JN  ,KN  ,IN  ,4)
            Q(JBC ,KBC ,IBC ,5) = PBAKBC
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
               Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,6) = Q(JN  ,KN  ,IN  ,6)
               Q(JBC ,KBC ,IBC ,7) = Q(JN  ,KN  ,IN  ,7)
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC , 6) = Q(JN  ,KN  ,IN  , 6)
               Q(JBC ,KBC ,IBC , 7) = Q(JN  ,KN  ,IN  , 7)
               Q(JBC ,KBC ,IBC , 8) = Q(JN  ,KN  ,IN  , 8)
               Q(JBC ,KBC ,IBC , 9) = Q(JN  ,KN  ,IN  , 9)
               Q(JBC ,KBC ,IBC ,10) = Q(JN  ,KN  ,IN  ,10)
               Q(JBC ,KBC ,IBC ,11) = Q(JN  ,KN  ,IN  ,11)
               Q(JBC ,KBC ,IBC ,12) = Q(JN  ,KN  ,IN  ,12)
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with SUBSONIC OUTFLOW boundary condition
      RETURN
      END
      SUBROUTINE BCSYM  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT, SYM)
C
C Routine to do SYMMETRY boundary condition.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Setup variables for even/odd symmetry
C     3. Set boundary conditions for all variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C SYM            : Variable for even/odd symmetry
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
      DIMENSION SYM   (NQ)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCN2  is the second point inside of the block from IBCPT
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCN2  = 3
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Set up the symmetry array such that all variables are
C    reflected across the symmetry plane.
C
      IF ( IBCTYP .EQ. ISYMXY ) THEN
         ISYMDR = 3
         IASYM1 = 10
         IASYM2 = 11
      ELSE IF ( IBCTYP .EQ. ISYMXZ ) THEN
         ISYMDR = 2
         IASYM1 = 9
         IASYM2 = 11
      ELSE IF ( IBCTYP .EQ. ISYMYZ ) THEN
         ISYMDR = 1
         IASYM1 = 9
         IASYM2 = 10
      ENDIF
      DO 100 L = 1, NQ
         SYM(L) = 1.E0
 100  CONTINUE
C
      SYM(ISYMDR+1) = -1.E0
      IF (ITURB .EQ. ITRS) THEN
         SYM(IASYM1) = -1.E0
         SYM(IASYM2) = -1.E0
      ENDIF
C
C 3. Boundary conditions for all Variables
C
      DO 130 L = 1, NQ
         DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               Q(JBC ,KBC ,IBC ,L) = SYM(L) * Q(JN  ,KN  ,IN  ,L)
               Q(JBC2,KBC2,IBC2,L) = SYM(L) * Q(JN2 ,KN2 ,IN2 ,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C Finished with SYMMETRY boundary condition
      RETURN
      END
      SUBROUTINE BCTAN  (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do TANGENCY (inviscid wall) boundary condition.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCN2  = 3
         IBCM   = 1
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
         IBCM   = IJKDIM(IDIR)
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            RHON  = Q(JN ,KN ,IN ,1)
            PN    = Q(JN ,KN ,IN ,5)
            PN2   = Q(JN2,KN2,IN2,5)
C
C-1st order PW    = PN
            PW    = (9.E0 * PN - PN2) / 8.E0
            RHOW  = ( PW / (PN/RHON**GAMMA) )**(1.E0/GAMMA)
C
            UBAR  = Q(JN,KN,IN,2) * S(JM,KM,IM,1,IDIR)
     1            + Q(JN,KN,IN,3) * S(JM,KM,IM,2,IDIR)
     2            + Q(JN,KN,IN,4) * S(JM,KM,IM,3,IDIR)
C
            Q(JBC ,KBC ,IBC ,1) = RHOW
            Q(JBC ,KBC ,IBC ,2) = Q(JN,KN,IN,2)-UBAR*S(JM,KM,IM,1,IDIR)
            Q(JBC ,KBC ,IBC ,3) = Q(JN,KN,IN,3)-UBAR*S(JM,KM,IM,2,IDIR)
            Q(JBC ,KBC ,IBC ,4) = Q(JN,KN,IN,4)-UBAR*S(JM,KM,IM,3,IDIR)
            Q(JBC ,KBC ,IBC ,5) = PW
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               TKEN = Q(JN,KN,IN,6)
               EPSN = Q(JN,KN,IN,7)
               TKEW = TKEN
               EPSW = EPSN
C
               Q(JBC ,KBC ,IBC ,6) = TKEW
               Q(JBC ,KBC ,IBC ,7) = EPSW
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               TKEN = Q(JN,KN,IN,6)
               OMEN = Q(JN,KN,IN,7)
               TKEW = TKEN
               OMEW = OMEN
C
               Q(JBC ,KBC ,IBC ,6) = TKEW
               Q(JBC ,KBC ,IBC ,7) = OMEW
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               TXXN = Q(JN,KN,IN, 6)
               TYYN = Q(JN,KN,IN, 7)
               TZZN = Q(JN,KN,IN, 8)
               TXYN = Q(JN,KN,IN, 9)
               TXZN = Q(JN,KN,IN,10)
               TYZN = Q(JN,KN,IN,11)
               EPSN = Q(JN,KN,IN,12)
               TXXW = TXXN
               TYYW = TYYN
               TZZW = TZZN
               TXYW = TXYN
               TXZW = TXZN
               TYZW = TYZN
               EPSW = EPSN
C
               Q(JBC ,KBC ,IBC , 6) = TXXW
               Q(JBC ,KBC ,IBC , 7) = TYYW
               Q(JBC ,KBC ,IBC , 8) = TZZW
               Q(JBC ,KBC ,IBC , 9) = TXYW
               Q(JBC ,KBC ,IBC ,10) = TXZW
               Q(JBC ,KBC ,IBC ,11) = TYZW
               Q(JBC ,KBC ,IBC ,12) = EPSW
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with TANGENCY boundary condition
      RETURN
      END
      SUBROUTINE BCWALL (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, IBCDAT)
C
C Routine to do VISCOUS WALL boundary condition.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for the mean variables
C     3. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C Set control for higher order evaluation of PW
C     IHIORD = 0 for first  order
C     IHIORD = 1 for higher order
C
      IF (FOURTH) THEN
         IHIORD = 1
      ELSE
         IHIORD = 0
      ENDIF
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT(3) = 2
         IEND (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCN2  = 3
         IBCN3  = 4
         IBCM   = 1
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
         IBCN3  = IJKDIM(IDIR) - 2
         IBCM   = IJKDIM(IDIR)
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Boundary conditions for Mean Variables
C
      DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
         DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN3  = IBCN3 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN3  = IBCN3 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN3  = IBCN3 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C-1st order PW    = Q(JN,KN,IN,5)
            PN    = Q(JN ,KN ,IN ,5)
            PN2   = Q(JN2,KN2,IN2,5)
            PN3   = Q(JN3,KN3,IN3,5)
C-2nd order PW    = (9.E0 * PN - PN2) / 8.E0
C-3rd order PW    = (225.E0 * PN - 50.E0 * PN2 + 9.E0 * PN3) / 184.E0
            PW    = (1 - IHIORD) * PN +
     1              IHIORD * (225.E0*PN - 50.E0*PN2 + 9.E0*PN3) / 184.E0
            IF ( TWSPE ) THEN
               RHOW = GAMMA * PW / ( TWALL / TINF )
            ELSE
               RHOW = Q(JN,KN,IN,1)
            ENDIF
            Q(JBC ,KBC ,IBC ,1) = RHOW
            Q(JBC ,KBC ,IBC ,2) = 0.E0
            Q(JBC ,KBC ,IBC ,3) = 0.E0
            Q(JBC ,KBC ,IBC ,4) = 0.E0
            Q(JBC ,KBC ,IBC ,5) = PW
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
  110    CONTINUE
  120 CONTINUE
C
C 3-a. Boundary conditions for Two-Equation variables
C
C 3-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               RHOW   = Q    (JBC,KBC,IBC,1)
               RMUW   = PROPS(JBC,KBC,IBC,1)
C
               TKEN   = Q    (JN ,KN ,IN ,6)
               YNORML = ABS (PROPS(JN ,KN ,IN ,4))
C
C Wall boundary condition for epsilon from Speziale
C epsilon+(wall) = 2 NU K+(1) / Y+(1)**2
C
               EPSLNW = 2.E0 * RMUW / RHOW * TKEN
     1                  / (YNORML * YNORML + RSMASQ) * FSMACH / RE
C
               Q(JBC ,KBC ,IBC ,6) = 0.E0
               Q(JBC ,KBC ,IBC ,7) = EPSLNW
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  210       CONTINUE
  220    CONTINUE
C
C 3-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         DO 240 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               RHOW   = Q    (JBC,KBC,IBC,1)
               RMUW   = PROPS(JBC,KBC,IBC,1)
C
               YNORML = ABS (PROPS(JN ,KN ,IN ,4))
C
C-----Begin wall BC based on Wilcox's rough wall approach
C     Calculate the velocity parallel to the wall at the cell center off
C     the wall.  U(parallel) = U - UBAR where U is the total velocity vector
C     and UBAR is the velocity normal to the wall.  (Velocity on the wall
C     should be identically zero)
C     VELN is magnitude of the parallel velocity at point N
C
C              UBARN = S(JM,KM,IM,1,IDIR) * Q(JN,KN,IN,2)
C    1               + S(JM,KM,IM,2,IDIR) * Q(JN,KN,IN,3)
C    2               + S(JM,KM,IM,3,IDIR) * Q(JN,KN,IN,4)
C              VELN  = SQRT((Q(JN,KN,IN,2)-UBARN*S(JM,KM,IM,1,IDIR))**2
C    1                     +(Q(JN,KN,IN,3)-UBARN*S(JM,KM,IM,2,IDIR))**2
C    2                     +(Q(JN,KN,IN,4)-UBARN*S(JM,KM,IM,3,IDIR))**2)
C
C     Tau(wall) = mu * du/dn
C
C              DVELDN = VELN / (YNORML + RSMALL)
C              TAUW   = RMUW * DVELDN
C
C     Kr+         = utau *  rho(wall) * Kr / mu(wall)
C     Omega(wall) = utau**2 rho(wall) * Sr / mu(wall)
C     If Kr = 0, set Kr+ = 5 -> hydraulically smooth
C
C              IF (ROUGHK .GT. 0.E0) THEN
C                 RKRPLS = SQRT (RHOW * TAUW) * ROUGHK / RMUW
C              ELSE
C                 RKRPLS = 5.E0
C              ENDIF
C
C              IF (RKRPLS .GE. 25.0E0) THEN
C                 SR =  100.E0 / RKRPLS
C              ELSE
C                 SR = 2500.E0 / (RKRPLS * RKRPLS)
C              ENDIF
C
C              OMEGAW = DVELDN * SR
C-----End   wall BC based on Wilcox's rough wall approach
C-----Begin wall BC based on Menter (NASA TM 103975)
               OMEGAW = 60.E0*RMUW / (BKW*RHOW*YNORML*YNORML+RSMASQ)
     1                  *FSMACH/RE
C-----End   wall BC based on Menter (NASA TM 103975)
C
               Q(JBC ,KBC ,IBC ,6) = 0.E0
               Q(JBC ,KBC ,IBC ,7) = OMEGAW
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  230       CONTINUE
  240    CONTINUE
C
C 3-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 260 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 250 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               RHOW  = Q    (JBC,KBC,IBC,1)
               RMUW  = PROPS(JBC,KBC,IBC,1)
C
               TKEN  = 0.5E0*(Q(JN,KN,IN,6)+Q(JN,KN,IN,7)+Q(JN,KN,IN,8))
               YNORML= ABS (PROPS(JN ,KN ,IN ,4))
C
C Wall boundary condition for epsilon from Speziale
C epsilon+(wall) = 2 NU K+(1) / Y+(1)**2
C
               EPSLNW = 2.E0 * RMUW / RHOW * TKEN
     1                  / (YNORML * YNORML + RSMASQ) * FSMACH / RE
C
               Q(JBC ,KBC ,IBC , 6) = 0.E0
               Q(JBC ,KBC ,IBC , 7) = 0.E0
               Q(JBC ,KBC ,IBC , 8) = 0.E0
               Q(JBC ,KBC ,IBC , 9) = 0.E0
               Q(JBC ,KBC ,IBC ,10) = 0.E0
               Q(JBC ,KBC ,IBC ,11) = 0.E0
               Q(JBC ,KBC ,IBC ,12) = EPSLNW
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  250       CONTINUE
  260    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with WALL boundary condition
      RETURN
      END
      SUBROUTINE BCWALF (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, S, VOL, IBCDAT)
C
C Routine to do TURBULENT WALL FUNCTION boundary condition.
C
C This routine is organized as follows:
C     1. Setup constants for turbulent wall functions
C     2. Setup variables for looping
C     3. Set boundary conditions for the mean variables
C     4. Set additional boundary conditions for turbulence variables:
C        a. Two-Equation variables
C           i.  K-epsilon
C           ii. K-omega
C        b. Reynolds stress variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C VOL            : Cell volumes
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3),
     3          ISTRTI(3),
     4          IENDI (3)
C
C 1. Control of iterative process
C
      MAXIT  = 50
C
C 32-Bit machine can't converge 1x10-7
C
      TOLER  = 1.E-06
C
C No underrelaxation results in more planes not converging,
C underrelaxation with RELAX = .9 converges more rapidly (11 to 20 cycles)
C than none but some planes still do not converge (get in limit cycle)
C RELAX = .5 requires 14 iterations instead of 11 but is more robust
C
      RELAX  = 0.5E0
C
C Constants for wall functions
C
      RKAPVK = 0.41E0
      ESTAR  = 9.0E0
      YV     = 11.6E0
      SCALE  = SQRT (RE / FSMACH)
C
C 2. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C ISTRTI, IENDI correspond to the Interior of the boundary condition face
C i.e., this does not extend to the edge/corner
C
      DO 5 L = 1, 3
         ISTRTI(L) = ISTRT(L)
         IENDI (L) = IEND (L)
    5 CONTINUE
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C Reset kstrt, kend to 2 for improved efficiency on two-dimensional flows.
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
      IF (.NOT. THREED .AND. .NOT. AXISYM) THEN
         ISTRT (3) = 2
         IEND  (3) = 2
         ISTRTI(3) = 2
         IENDI (3) = 2
      ENDIF
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCN2  = 3
         IBCM   = 1
         IBCM2  = 2
         SGNM   = 1.E0
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
         IBCM   = IJKDIM(IDIR)
         IBCM2  = IJKDIM(IDIR) - 1
         SGNM   = - 1.E0
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2-b. Set the boundary conditions on the edges/corners
C
      IF (ISTRT(IC2) .EQ. 1) THEN
         I2 = ISTRT(IC2)
         DO 210 I3 = ISTRT(IC3), IEND(IC3)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            RHON = Q(JN ,KN ,IN ,1)
            PN   = Q(JN ,KN ,IN ,5)
C
            Q(JBC ,KBC ,IBC ,1) = RHON
            Q(JBC ,KBC ,IBC ,2) = 0.E0
            Q(JBC ,KBC ,IBC ,3) = 0.E0
            Q(JBC ,KBC ,IBC ,4) = 0.E0
            Q(JBC ,KBC ,IBC ,5) = PN
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
C
            PROPS (JBC2,KBC2,IBC2,ITQTAU) = 0.E0
            PROPS (JBC2,KBC2,IBC2,ITQDOT) = 0.E0
  210    CONTINUE
      ENDIF
C
      IF (IEND (IC2) .EQ. (IJKDIM(IC2)+1)) THEN
         I2 = IEND (IC2)
         DO 220 I3 = ISTRT(IC3), IEND(IC3)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            RHON = Q(JN ,KN ,IN ,1)
            PN   = Q(JN ,KN ,IN ,5)
C
            Q(JBC ,KBC ,IBC ,1) = RHON
            Q(JBC ,KBC ,IBC ,2) = 0.E0
            Q(JBC ,KBC ,IBC ,3) = 0.E0
            Q(JBC ,KBC ,IBC ,4) = 0.E0
            Q(JBC ,KBC ,IBC ,5) = PN
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
C
            PROPS (JBC2,KBC2,IBC2,ITQTAU) = 0.E0
            PROPS (JBC2,KBC2,IBC2,ITQDOT) = 0.E0
  220    CONTINUE
      ENDIF
C
      IF (ISTRT(IC3) .EQ. 1) THEN
         I3 = ISTRT(IC3)
         DO 230 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            RHON = Q(JN ,KN ,IN ,1)
            PN   = Q(JN ,KN ,IN ,5)
C
            Q(JBC ,KBC ,IBC ,1) = RHON
            Q(JBC ,KBC ,IBC ,2) = 0.E0
            Q(JBC ,KBC ,IBC ,3) = 0.E0
            Q(JBC ,KBC ,IBC ,4) = 0.E0
            Q(JBC ,KBC ,IBC ,5) = PN
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
C
            PROPS (JBC2,KBC2,IBC2,ITQTAU) = 0.E0
            PROPS (JBC2,KBC2,IBC2,ITQDOT) = 0.E0
  230    CONTINUE
      ENDIF
C
      IF (IEND (IC3) .EQ. (IJKDIM(IC3)+1)) THEN
         I3 = IEND (IC3)
         DO 240 I2 = ISTRT(IC2), IEND(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            RHON = Q(JN ,KN ,IN ,1)
            PN   = Q(JN ,KN ,IN ,5)
C
            Q(JBC ,KBC ,IBC ,1) = RHON
            Q(JBC ,KBC ,IBC ,2) = 0.E0
            Q(JBC ,KBC ,IBC ,3) = 0.E0
            Q(JBC ,KBC ,IBC ,4) = 0.E0
            Q(JBC ,KBC ,IBC ,5) = PN
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
C
            PROPS (JBC2,KBC2,IBC2,ITQTAU) = 0.E0
            PROPS (JBC2,KBC2,IBC2,ITQDOT) = 0.E0
  240    CONTINUE
      ENDIF
C
C 3. Boundary conditions for Mean Variables using Wall Functions
C    Compute using the wall functions only in the INTERIOR of the boundary
C
      DO 320 I3 = ISTRTI(IC3), IENDI(IC3)
CDIR$ IVDEP
         DO 310 I2 = ISTRTI(IC2), IENDI(IC2)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM2  = IBCM2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM2  = IBCM2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM2  = IBCM2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C---------- RHOW   = Q(JBC,KBC,IBC,1)
            RHON   = Q(JN ,KN ,IN ,1)
            PN     = Q(JN ,KN ,IN ,5)
C
C Calculate velocity magnitude parallel to the wall
C
            UDOTN  = ( Q(JN,KN,IN,2) * S(JM,KM,IM,1,IDIR) +
     1                 Q(JN,KN,IN,3) * S(JM,KM,IM,2,IDIR) +
     2                 Q(JN,KN,IN,4) * S(JM,KM,IM,3,IDIR) ) * SGNM
            UPN    = Q(JN,KN,IN,2) - UDOTN * SGNM * S(JM,KM,IM,1,IDIR)
            VPN    = Q(JN,KN,IN,3) - UDOTN * SGNM * S(JM,KM,IM,2,IDIR)
            WPN    = Q(JN,KN,IN,4) - UDOTN * SGNM * S(JM,KM,IM,3,IDIR)
            UPARN  = SQRT( UPN*UPN + VPN*VPN + WPN*WPN )
C
            UDOTN2 = ( Q(JN2,KN2,IN2,2) * S(JM2,KM2,IM2,1,IDIR) +
     1                 Q(JN2,KN2,IN2,3) * S(JM2,KM2,IM2,2,IDIR) +
     2                 Q(JN2,KN2,IN2,4) * S(JM2,KM2,IM2,3,IDIR) ) * SGNM
            UPN2   = Q(JN2,KN2,IN2,2)-UDOTN2*SGNM*S(JM2,KM2,IM2,1,IDIR)
            VPN2   = Q(JN2,KN2,IN2,3)-UDOTN2*SGNM*S(JM2,KM2,IM2,2,IDIR)
            WPN2   = Q(JN2,KN2,IN2,4)-UDOTN2*SGNM*S(JM2,KM2,IM2,3,IDIR)
            UPARN2 = SQRT( UPN2*UPN2 + VPN2*VPN2 + WPN2*WPN2 )
C
            TN     = GAMMA * PN / RHON
C
            RMUW   = PROPS(JBC,KBC,IBC,1)
            RMUN   = PROPS(JN ,KN ,IN ,1)
            YNORML = ABS (PROPS(JN ,KN ,IN ,4))
            YNORML = MAX (YNORML, RSMALL)
C
C Calculate normal Reynolds stress
C
            IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
               TKEN   = Q(JN,KN,IN,6)
               TAUNN  = 2.E0 / 3.E0 * TKEN
            ELSE IF (ITURB .EQ. ITRS) THEN
C
               RNX    = S(JM,KM,IM,1,IDIR) * SGNM
               RNY    = S(JM,KM,IM,2,IDIR) * SGNM
               RNZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               TAUXX  = Q(JN,KN,IN, 6)
               TAUYY  = Q(JN,KN,IN, 7)
               TAUZZ  = Q(JN,KN,IN, 8)
               TAUXY  = Q(JN,KN,IN, 9)
               TAUXZ  = Q(JN,KN,IN,10)
               TAUYZ  = Q(JN,KN,IN,11)
C
C Transform stresses to local streamwise, normal coordinates
C
               TAUNN  =   RNX*RNX*TAUXX + RNY*RNY*TAUYY + RNZ*RNZ*TAUZZ
     1            + 2.E0*(RNX*RNY*TAUXY + RNX*RNZ*TAUXZ + RNY*RNZ*TAUYZ)
C
            ELSE
               TAUNN  = 0.E0
            ENDIF
C+++++++
C+++        IF (S(JM,KM,IM,4,IDIR) .LE. 0.E0 .AND.
C+++ 1          VOL(JM,KM,IM)        .LE. 0.E0) THEN
C+++           WRITE (iout,'(a,3i5)') ' i, j, k ', im, jm, km
C+++        END IF
C+++++++
C
C Wall pressure boundary condition and wall density
C
            PW     = PN + RHON * TAUNN
            IF ( TWSPE ) THEN
               TW    = TWALL / TINF
            ELSE
               TW    = TN + 0.5E0 * UPARN * UPARN * GAMM1 * PRT
            ENDIF
            RHOW = GAMMA * PW / TW
C
C Initialize Tau_w for iterative procedure to previous result
C
            TAUW   = PROPS (JBC2,KBC2,IBC2,ITQTAU)
C
C Iterate on tau_w
C
            DO 300 ITER = 1, MAXIT
               YPLUSN = SCALE * YNORML * SQRT (ABS(TAUW) * RHOW) / RMUW
C
C Case 1: Y+_N > YV ==> u+ = Ln(y+) / kappa + B
C
               IF (YPLUSN .GT. YV) THEN
                  RMUTN = SCALE * RKAPVK * YNORML * SQRT(ABS(TAUW)*RHON)
                  IF ( TWSPE ) THEN
                     TW    = TWALL / TINF
                     QW    = TAUW * ( (TW - TN) / (PRT * UPARN + RSMALL)
     1                              - 0.5E0 * GAMM1 * UPARN )
                  ELSE
                     QW    = 0.E0
                     TW    = TN + 0.5E0 * UPARN * UPARN * GAMM1 * PRT
                  ENDIF
                  RHOW = GAMMA * PW / TW
C
C Calculate U_C_N
C
                  DEN1  = SQRT( QW*QW + 2.E0*TW/(GAMM1*PRT)*TAUW*TAUW )
                  DEN1  = MAX (DEN1, 1.e-08)
                  ARG11 = (QW + UPARN*TAUW) / DEN1
                  ARG12 = (QW) / DEN1
                  ARG11 = MIN (  1.E0, ARG11 )
                  ARG11 = MAX ( -1.E0, ARG11 )
                  ARG12 = MIN (  1.E0, ARG12 )
                  ARG12 = MAX ( -1.E0, ARG12 )
                  UCN   = SQRT( 2.E0*TW/(GAMM1*PRT) )
     1                    * ( ASIN(ARG11) - ASIN(ARG12) )
C
C Calculate Tau_w
C
                  TAUWN = RHOW*(RKAPVK*UCN/LOG(ESTAR*YPLUSN))**2
     1                    *RE/FSMACH
C
C Case 2: Y+_N < YV ==> u+ = y+
C
               ELSE
                  IF ( TWSPE ) THEN
                     TW    = TWALL / TINF
                     QW    = TAUW * ( (TW - TN) / (PRT * UPARN + RSMALL)
     1                              - 0.5E0 * GAMM1 * UPARN )
                  ELSE
                     QW    = 0.E0
                     TW    = TN + 0.5E0 * UPARN * UPARN * GAMM1 * PRT
                  ENDIF
                  RHOW = GAMMA * PW / TW
C
C Calculate Tau_w
C
                  TAUWN = (UPARN * RMUN / YNORML)
               ENDIF
C
C Update Tauw
C
               ERROR = TAUWN - TAUW
               TAUW  = (1.E0 - RELAX) * TAUW + RELAX * TAUWN
C
C Converged?
C
               RELERR = ABS(ERROR) / (ABS(TAUW) + 1.E-10)
               IF (RELERR .LT. TOLER) GO TO 305
  300       CONTINUE
            WRITE (IOUT,1010) IBC, JBC, KBC, MAXIT, RELERR, TOLER,YPLUSN
  305       CONTINUE
C
C Pass back the wall shear stress and heat transfer
C Note: this will always develop TAUW >= 0.  The direction of TAUW is
C       assumed to align with the local velocity direction.  SGNM is
C       required here to handle DIM end of coordinate direction.
C
            PROPS (JBC2,KBC2,IBC2,ITQTAU) = TAUW
            PROPS (JBC2,KBC2,IBC2,ITQDOT) = QW
C
C Calculate wall velocity so that du/dy at wall-function cell is from log-law.
C Velocity at the interface of the first cell (wall-function cell) is
C calculated as the average of the values on either side of the interface
C since the solution point in the wall-function cell is equidistant from
C the interface.  This calculates the magnitude of the wall velocity.  Its
C direction is taken as aligned with the velocity parallel to the wall.
C Therefore, UINT, DUDY2, DYINT are all positive quantities.
C
            UINT   = 0.5E0 * ( UPARN + UPARN2 )
            UTAUW  = SQRT (ABS(TAUW) / RHOW * FSMACH / RE)
            DUDY2  = UTAUW / (RKAPVK * YNORML)
            DYINT  = 0.5E0 * (YNORML + PROPS(JN2,KN2,IN2,4))
            UPWALL = UINT - DUDY2 * DYINT
C
C Set wall mean quantities
C
            UPARN  = MAX ( UPARN, RSMALL )
            Q(JBC ,KBC ,IBC ,1) = RHOW
            Q(JBC ,KBC ,IBC ,2) = UPN * UPWALL / UPARN
            Q(JBC ,KBC ,IBC ,3) = VPN * UPWALL / UPARN
            Q(JBC ,KBC ,IBC ,4) = WPN * UPWALL / UPARN
            Q(JBC ,KBC ,IBC ,5) = PW
C
            Q(JBC2,KBC2,IBC2,1) = Q(JBC ,KBC ,IBC ,1)
            Q(JBC2,KBC2,IBC2,2) = Q(JBC ,KBC ,IBC ,2)
            Q(JBC2,KBC2,IBC2,3) = Q(JBC ,KBC ,IBC ,3)
            Q(JBC2,KBC2,IBC2,4) = Q(JBC ,KBC ,IBC ,4)
            Q(JBC2,KBC2,IBC2,5) = Q(JBC ,KBC ,IBC ,5)
  310    CONTINUE
  320 CONTINUE
C
C 4-a. Boundary conditions for Two-Equation variables
C
C 4-a-i. Boundary conditions for k-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         DO 420 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 410 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               RHOW   = Q    (JBC ,KBC ,IBC ,1)
C
               TAUW   = PROPS(JBC2,KBC2,IBC2,ITQTAU)
               YNORML = ABS (PROPS(JN  ,KN  ,IN  ,4))
               YNORML = MAX ( YNORML, RSMALL )
C
C Boundary condition for tke     = abs (tau_w) / rho / sqrt(C_mu)
C Boundary condition for epsilon = (sqrt(C_mu) k)^(3/2) / kappa y
C
               CMURT  = SQRT (CMU)
               TKEN   = ABS (TAUW) / RHOW / CMURT * FSMACH / RE
               TKEN   = MAX (TKEN, RSMALL)
C
               TERM   = CMURT * TKEN
               EPSLNN = TERM * SQRT (TERM) / (RKAPVK * YNORML)
               EPSLNN = MAX (EPSLNN, RSMALL)
               EPSLNW = EPSLNN
C
               Q(JN  ,KN  ,IN  ,6) = TKEN
               Q(JN  ,KN  ,IN  ,7) = EPSLNW
C
               Q(JBC ,KBC ,IBC ,6) = 0.E0
               Q(JBC ,KBC ,IBC ,7) = EPSLNW
C
               Q(JBC2,KBC2,IBC2,6) = Q(JBC ,KBC ,IBC ,6)
               Q(JBC2,KBC2,IBC2,7) = Q(JBC ,KBC ,IBC ,7)
  410       CONTINUE
  420    CONTINUE
C
C 4-a-ii. Boundary conditions for k-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
      write (iout,'(a)') ' Wall functions not implemented for k-w'
      stop
         DO 440 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 430 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               RHOW   = Q    (JBC,KBC,IBC,1)
               RMUW   = PROPS(JBC,KBC,IBC,1)
C
               YNORML = ABS (PROPS(JN ,KN ,IN ,4))
C
  430       CONTINUE
  440    CONTINUE
C
C 4-b. Boundary conditions for Reynolds stress variables
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 460 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
            DO 450 I2 = ISTRT(IC2), IEND(IC2)
C
               IBC   = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC   = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC   = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IBC2  = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JBC2  = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KBC2  = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN    = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN    = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN    = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IN2   = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JN2   = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KN2   = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IM    = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JM    = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KM    = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Set up normals for local coordinate system (s=SP, n=RN, t) where
C n is normal to the surface, s is parallel to the surface aligned with
C the flow, and t is perpendicular to s, n (and is not needed)
C
               RNX    = S(JM,KM,IM,1,IDIR) * SGNM
               RNY    = S(JM,KM,IM,2,IDIR) * SGNM
               RNZ    = S(JM,KM,IM,3,IDIR) * SGNM
C
               UDOTN  = Q(JN,KN,IN,2) * RNX + Q(JN,KN,IN,3) * RNY +
     1                  Q(JN,KN,IN,4) * RNZ
               UPN    = Q(JN,KN,IN,2) - UDOTN * RNX
               VPN    = Q(JN,KN,IN,3) - UDOTN * RNY
               WPN    = Q(JN,KN,IN,4) - UDOTN * RNZ
               UPARN  = SQRT( UPN*UPN + VPN*VPN + WPN*WPN )
               IF (UPARN .EQ. 0.E0) THEN
                  SPX    = SHATX
                  SPY    = SHATY
                  SPZ    = SHATZ
               ELSE
                  SPX    = UPN / UPARN
                  SPY    = VPN / UPARN
                  SPZ    = WPN / UPARN
               ENDIF
C
               RHOW   = Q    (JBC ,KBC ,IBC ,1)
C
               TAUW   = PROPS(JBC2,KBC2,IBC2,ITQTAU)
               YNORML = ABS (PROPS(JN ,KN ,IN ,4))
               YNORML = MAX ( YNORML, RSMALL )
C
               RHO    = Q(JN,KN,IN, 1)
               TAUXX  = Q(JN,KN,IN, 6)
               TAUYY  = Q(JN,KN,IN, 7)
               TAUZZ  = Q(JN,KN,IN, 8)
               TAUXY  = Q(JN,KN,IN, 9)
               TAUXZ  = Q(JN,KN,IN,10)
               TAUYZ  = Q(JN,KN,IN,11)
               TKEN   = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
               UTAUW  = SQRT (ABS(TAUW) / RHOW * FSMACH / RE)
               DUPDN  = UTAUW / (RKAPVK * YNORML)
C
C Transform stresses to local streamwise, normal coordinates
C
               TAUNN  =   RNX*RNX*TAUXX + RNY*RNY*TAUYY + RNZ*RNZ*TAUZZ
     1            + 2.E0*(RNX*RNY*TAUXY + RNX*RNZ*TAUXZ + RNY*RNZ*TAUYZ)
               TAUSN  =   SPX*RNX*TAUXX + SPY*RNY*TAUYY + SPZ*RNZ*TAUZZ
     1              + (SPX*RNY+SPY*RNX)*TAUXY + (SPX*RNZ+SPZ*RNX)*TAUXZ
     2              + (SPY*RNZ+SPZ*RNY)*TAUYZ
C
C Set sign of du_parallel/dy_normal as opposite of sign of tausn
C
               DUPDN  = SIGN (DUPDN, (-TAUSN))
C
C Calculate production = - rho * du_i/dx_j * Tau_ij
C
               PROD   = - RHO * TAUSN * DUPDN
C
C Boundary condition for epsilon from Younis' thesis as restriction of
C the epsilon transport equation
C
               CRAT   = CEPS1 / CEPS2 * PROD / RHO
               TAUNN  = ABS (TAUNN)
               EPSLNN = 0.5E0 * (CRAT + SQRT (CRAT*CRAT +
     1              4.E0*CEPSLN/CEPS2*TKEN*TKEN*TAUNN/(YNORML*YNORML)) )
               EPSLNW = EPSLNN
C
               Q(JN  ,KN  ,IN  ,12) = EPSLNW
C
               Q(JBC ,KBC ,IBC , 6) = 0.E0
               Q(JBC ,KBC ,IBC , 7) = 0.E0
               Q(JBC ,KBC ,IBC , 8) = 0.E0
               Q(JBC ,KBC ,IBC , 9) = 0.E0
               Q(JBC ,KBC ,IBC ,10) = 0.E0
               Q(JBC ,KBC ,IBC ,11) = 0.E0
               Q(JBC ,KBC ,IBC ,12) = EPSLNW
C
               Q(JBC2,KBC2,IBC2, 6) = Q(JBC ,KBC ,IBC , 6)
               Q(JBC2,KBC2,IBC2, 7) = Q(JBC ,KBC ,IBC , 7)
               Q(JBC2,KBC2,IBC2, 8) = Q(JBC ,KBC ,IBC , 8)
               Q(JBC2,KBC2,IBC2, 9) = Q(JBC ,KBC ,IBC , 9)
               Q(JBC2,KBC2,IBC2,10) = Q(JBC ,KBC ,IBC ,10)
               Q(JBC2,KBC2,IBC2,11) = Q(JBC ,KBC ,IBC ,11)
               Q(JBC2,KBC2,IBC2,12) = Q(JBC ,KBC ,IBC ,12)
  450       CONTINUE
  460    CONTINUE
C
C No additional bcs
C
      ENDIF
C
C Finished with TURBULENT WALL FUNCTIONS boundary condition
      RETURN
 1010 FORMAT (' ','BCWALF: Tau_w not converged at (I:J:K) ', 3I5,
     1            ' after ', I5, ' iterations.',
     2       /' ','  Rel. Error ', E15.7, 5X, 'Tolerance ', E15.7,
     3            ' Y+ = ',E15.7)
      END
      SUBROUTINE CUT    (IDIM1, JDIM1, KDIM1, Q1,
     1                   IDIM2, JDIM2, KDIM2, Q2, ICUTS, NV)
C
C Routine to do cut boundary condition.
C Flow data stored in Q1 are updated from data in the interior of Q2.
C This routine works for Q or PROPS and needs the size of the array.
C
C IDIM1,JDIM1,KDIM1 : Block 1 dimensions
C Q1                : Block 1 data (Q or PROPS)
C IDIM2,JDIM2,KDIM2 : Block 2 dimensions
C Q2                : Block 2 data (Q or PROPS)
C ICUTS             : Array controlling beginning/ending of cut
C NV                : Number of variables (NV = NQ for Q, NP for PROPS)
C
      include 'common.inc'
      DIMENSION Q1   (0:JDIM1+2,0:KDIM1+2,0:IDIM1+2,NV),
     1          Q2   (0:JDIM2+2,0:KDIM2+2,0:IDIM2+2,NV)
C
      DIMENSION ICUTS(21)
C
      DIMENSION IJKDM1(3), IJKDM2(3)
      DIMENSION ISTR1(3),  IEND1(3),
     1          ISTR2(3),  IEND2(3),
     2          ISGN1(3),  ISGN2(3),
     3          IORD(3),   LEN(3)
C
C     Store IDIM, JDIM, KDIM in IJKDIM for looping
C
      IJKDM1(1) = IDIM1
      IJKDM1(2) = JDIM1
      IJKDM1(3) = KDIM1
      IJKDM2(1) = IDIM2
      IJKDM2(2) = JDIM2
      IJKDM2(3) = KDIM2
C
C     Store boundary condition data in mnemonic names
C
      IDIR1    = ICUTS( 2)
      INOUT1   = ICUTS( 3)
      ISTR1(1) = ICUTS( 4)
      IEND1(1) = ICUTS( 5)
      ISTR1(2) = ICUTS( 6)
      IEND1(2) = ICUTS( 7)
      ISTR1(3) = ICUTS( 8)
      IEND1(3) = ICUTS( 9)
C
      IBLK2    = ICUTS(10)
      IDIR2    = ICUTS(11)
      INOUT2   = ICUTS(12)
      ISTR2(1) = ICUTS(13)
      IEND2(1) = ICUTS(14)
      ISTR2(2) = ICUTS(15)
      IEND2(2) = ICUTS(16)
      ISTR2(3) = ICUTS(17)
      IEND2(3) = ICUTS(18)
C
      IORD(1)  = ICUTS(19)
      IORD(2)  = ICUTS(20)
      IORD(3)  = ICUTS(21)
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INOUT1 = 1) or the outer boundary (INOUT1 > 1)
C          IBCPT  = boundary point of block 1
C          IBCINC = increment to second boundary point of block 1
C                   IBCPT2 = IBCPT + IBCINC
C          INR    = interior point of block 2.
C          INRINC = increment to second interior point of block 2
C                   INR2 = INR + INRINC
C
      IF (INOUT1 .EQ. 1) THEN
         IBCPT  =   1
         IBCINC = - 1
      ELSE
         IBCPT  = IJKDM1(IDIR1) + 1
         IBCINC = 1
      ENDIF
C
      IF (INOUT2 .EQ. 1) THEN
         INR    =   2
         INRINC =   1
      ELSE
         INR    =   IJKDM2(IDIR2)
         INRINC = - 1
      ENDIF
C
C     Find the length of the two outer loops and loop over these using
C     offsets and delta function to set the two cut data points to the
C     two interior data points of block 2.
C
      DO 100 L = 1, 3
C
         LEN(L) = ABS ( IEND1(L) - ISTR1(L) )
C
C     Increment/Decrement
C
         IF ( IEND1(L) .GT. ISTR1(L) ) THEN
            ISGN1(L) =   1
         ELSE
            ISGN1(L) = - 1
         ENDIF
C
C     Increment/Decrement
C
         IF ( IEND2(L) .GT. ISTR2(L) ) THEN
            ISGN2(L) =   1
         ELSE
            ISGN2(L) = - 1
         ENDIF
  100 CONTINUE
C
C     II1 first  boundary point of block 1
C     II2 second boundary point of block 1
C     IN1 first  interior point of block 2
C     IN2 second interior point of block 2
C
      IC1 = ICY (IDIR1, 1)
      IC2 = ICY (IDIR1, 2)
      IC3 = ICY (IDIR1, 3)
C
      JC1 = IORD (IC1)
      JC2 = IORD (IC2)
      JC3 = IORD (IC3)
C
      DO 800 I3 = 0, LEN(IC3)
         DO 700 I2 = 0, LEN(IC2)
            II1 = IBCPT                        * IKD (IC1, 1) +
     1            (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 1) +
     2            (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 1)
            JJ1 = IBCPT                        * IKD (IC1, 2) +
     1            (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 2) +
     2            (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 2)
            KK1 = IBCPT                        * IKD (IC1, 3) +
     1            (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 3) +
     2            (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 3)
C
            II2 = II1 + IBCINC * IKD (IC1, 1)
            JJ2 = JJ1 + IBCINC * IKD (IC1, 2)
            KK2 = KK1 + IBCINC * IKD (IC1, 3)
C
            IN1 = INR                          * IKD (JC1, 1) +
     1            (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 1) +
     2            (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 1)
            JN1 = INR                          * IKD (JC1, 2) +
     1            (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 2) +
     2            (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 2)
            KN1 = INR                          * IKD (JC1, 3) +
     1            (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 3) +
     2            (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 3)
C
            IN2 = IN1 + INRINC * IKD (JC1, 1)
            JN2 = JN1 + INRINC * IKD (JC1, 2)
            KN2 = KN1 + INRINC * IKD (JC1, 3)
C
CDIR$ SHORTLOOP
            DO 600 L = 1, NV
               Q1(JJ1,KK1,II1,L) = Q2(JN1,KN1,IN1,L)
               Q1(JJ2,KK2,II2,L) = Q2(JN2,KN2,IN2,L)
 600        CONTINUE
 700     CONTINUE
 800  CONTINUE
C
C     Finished with Cut boundary condition
      RETURN
      END
      SUBROUTINE BCHSHR (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, IBCDAT, QBC, PBC)
C
C Routine to do PERIODIC boundary condition for HOMOGENEOUS SHEAR in the
C J-direction ONLY.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Set boundary conditions for all variables
C     3. Set boundary conditions for all properties
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start BCs at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end BCs at
C                  (Maximum Value: IDIM+1)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C QBC,PBC        : Temporary storage for Q, PROPS for interpolation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
      DIMENSION IBCDAT(10)
C
C Temporary storage for Q and PROPS for interpolation
C
      DIMENSION QBC   (3-IDIM:2*IDIM-1,NQ),
     1          PBC   (3-IDIM:2*IDIM-1,NP)
C
C 1. Setup memory for looping.
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
C
C This routine is set-up for the J-Direction ONLY!
C
      IF (IDIR .NE. 2) THEN
         WRITE (IOUT,1000) IDIR
         STOP
      END IF
C
C      Calculate the increment in the I coordinate for interpolation
C
      DLENGTH = 1.E0
C--   DUDY    = 0.
      DUDY    = 0.6847688E-01
      DELTAU  = DUDY * DLENGTH
C
      DX      = DLENGTH / FLOAT(IDIM-1)
      DELTA   = DELTAU * TIMEDT
      DELTAI  = DELTA / DX
C
C      Check to see that DELTAI < IDIM; Stop if an error
C
      IF (INT(DELTAI) .GT. IDIM) THEN
         WRITE (IOUT,1005) INT(DELTAI), IDIM
         STOP
      ENDIF
C
C 2.   Boundary conditions for ALL Variables and ALL Properties
C
C      Loop over all K planes
C
      DO K = 1, KDIM+1
C
C 2-a. Set up the arrays to interpolate in
C
         DO JLOOP = 0, 1
C
C      Set needed variables depending on whether the boundary is
C      the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C
            IF (INROUT .EQ. 1) THEN
               DINC   = DELTAI
               INC    = INT(DINC)
               DU     = - DELTAU
               IF (JLOOP .EQ. 0) THEN
                  JBC = 0
                  JPR = JDIM - 1
               ELSE
                  JBC = 1
                  JPR = JDIM
               END IF
            ELSE
               DINC   = - DELTAI
               INC    = INT(DINC)
               DU     = DELTAU
               IF (JLOOP .EQ. 0) THEN
                  JBC = JDIM + 1
                  JPR = 2
               ELSE
                  JBC = JDIM + 2
                  JPR = 3
               END IF
            END IF
C
C      Calculate the initial point in the interpolating stencil as the third
C      grid index to the left of the interpolating point.
C
            IF (DINC .LT. 0) INC = INC - 1
C
C      Calculate the interpolation coefficients. Due to the design of the
C      homogeneous shear case, the interpolation is independent of the
C      location. The interpolation coefficients are then invariant.
C      5th order Lagrange interpolating polynomial. Carnahan, Luther, and
C      Wilkes, p. 27.
C
            DX0 = DINC - FLOAT(INC) + 2.E0
            DX1 = DX0    - 1.E0
            DX2 = DX0    - 2.E0
            DX3 = DX0    - 3.E0
            DX4 = DX0    - 4.E0
            DX5 = DX0    - 5.E0
C
            A0  = -       DX1 * DX2 * DX3 * DX4 * DX5 / 120.E0
            A1  =   DX0       * DX2 * DX3 * DX4 * DX5 /  24.E0
            A2  = - DX0 * DX1       * DX3 * DX4 * DX5 /  12.E0
            A3  =   DX0 * DX1 * DX2       * DX4 * DX5 /  12.E0
            A4  = - DX0 * DX1 * DX2 * DX3       * DX5 /  24.E0
            A5  =   DX0 * DX1 * DX2 * DX3 * DX4       / 120.E0
C
C      Store Q and PROPS in a periodic one-dimensional array to allow
C      for a simple form of the interpolation.
C
            DO I = 2, IDIM
               DO L = 1, NQ
                  QBC(I       ,L) = Q    (JPR,K,I,L)
                  QBC(I+IDIM-1,L) = Q    (JPR,K,I,L)
                  QBC(I-IDIM+1,L) = Q    (JPR,K,I,L)
               END DO
               DO L = 1, NP
                  PBC(I       ,L) = PROPS(JPR,K,I,L)
                  PBC(I+IDIM-1,L) = PROPS(JPR,K,I,L)
                  PBC(I-IDIM+1,L) = PROPS(JPR,K,I,L)
               END DO
            END DO
C
C 2-b. Interpolate
C      5th order Lagrange interpolating polynomial. Carnahan, Luther, and
C      Wilkes, p. 27. The II index is the cell center location of the
C      first point in the interpolating polynomial corresponding to the
C      A0 coefficient.
C
            DO I = 1, IDIM+1
               II = I + INC - 2
C
               DO L = 1, NQ
                  Q    (JBC,K,I,L) = A0 * QBC(II  ,L) + A1 * QBC(II+1,L)
     1                             + A2 * QBC(II+2,L) + A3 * QBC(II+3,L)
     2                             + A4 * QBC(II+4,L) + A5 * QBC(II+5,L)
               END DO
               DO L = 1, NP
                  PROPS(JBC,K,I,L) = A0 * PBC(II  ,L) + A1 * PBC(II+1,L)
     1                             + A2 * PBC(II+2,L) + A3 * PBC(II+3,L)
     2                             + A4 * PBC(II+4,L) + A5 * PBC(II+5,L)
               END DO
            END DO
C
C     Add/Subtract the mean velocity gradient from U
C
            DO I = 1, IDIM+1
               Q(JBC,K,I,2) = Q(JBC,K,I,2) + DU
            END DO
C
         END DO
      END DO
C
C Finished with PERIODIC HOMOGENEOUS SHEAR boundary condition
      RETURN
 1000 FORMAT (' ','ERROR-> BCHSHR: This routine is for the J-direction',
     1            ' only.',
     2       /' ',15x,' An invalid direction ',I2,' has been specified',
     3       /' ',15x,' Run Aborting.')
 1005 FORMAT (' ','ERROR-> BCHSHR: The calculated offset for the ',
     1                             'J-direction ',I5,
     2       /' ','                exceeds the allowed (IDIM) ',I5,
     3       /' ',15x,' Run Aborting.')
      END
C
C  Revision 4.1  2001/11/13 04:45:54  jhmorr
C  Renamed fourth.stub.F to fourth.stub.FOR to fix distribution.
C
C  Revision 4.3  2001/10/29 03:25:31  jhmorr
C  Updated license information
C
C  Revision 4.2  2001/06/08 04:56:16  jhmorr
C  Added notice
C
C  Revision 4.1  2001/06/08 04:17:19  jhmorr
C  Added fourth.stub.F
C
      SUBROUTINE DQCC   (IDIM, JDIM, KDIM, IPSTRT, IPEND, RES, DQ)
      RETURN
      END
      SUBROUTINE DELQI4 (IDIM, JDIM, KDIM, IPSTRT, IPEND, K,
     1                   Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                   STEMP, VOLAUX, QI, PROPSI,
     3                   DQDX, DQDY, DQDZ)
      RETURN
      END
      SUBROUTINE DELQJ4 (IDIM, JDIM, KDIM, I,
     1                   Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                   STEMP, VOLAUX, QI, PROPSI,
     3                   DQDX, DQDY, DQDZ)
      RETURN
      END
      SUBROUTINE DELQK4 (IDIM, JDIM, KDIM, I,
     1                   Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                   STEMP, VOLAUX, QI, PROPSI,
     3                   DQDX, DQDY, DQDZ)
      RETURN
      END
      SUBROUTINE FLUXI4 (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS,
     4                   IORDER, LIMIT, RKAP, IFLUX, VISCOS, IMODEL)
      RETURN
      END
      SUBROUTINE FLUXJ4 (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS,
     4                   IORDER, LIMIT, RKAP, IFLUX, VISCOS, IMODEL)
      RETURN
      END
      SUBROUTINE FLUXK4 (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS,
     4                   IORDER, LIMIT, RKAP, IFLUX, VISCOS, IMODEL)
      RETURN
      END
      SUBROUTINE QICD   (IDIM, JDIM, KDIM, K, IPSTRT, IPEND, Q, QI,
     1                   QC, DQC, IBCDAT, NBCS, IORDER)
      RETURN
      END
      SUBROUTINE QJCD   (IDIM, JDIM, KDIM, I, Q, QI, QC, DQC,
     1                   IBCDAT, NBCS, ITURB, IORDER)
      RETURN
      END
      SUBROUTINE QKCD   (IDIM, JDIM, KDIM, I, Q, QI, QC, DQC,
     1                   IBCDAT, NBCS, ITURB, IORDER)
      RETURN
      END
C
C     Revision 4.4  2001/10/29 03:25:31  jhmorr
C     Updated license information
C
C     Revision 4.3  2001/06/22 03:47:30  jhmorr
C     Add output of function name file. Modify contact information
C
C     Revision 4.2  2001/06/08 04:56:16  jhmorr
C     Added notice
C
C     Revision 4.1.1.1  1998/05/30 15:53:53  jhmorr
C     Added input for homogeneous shear boundary condition.
C
C Revision 4.1  1998/04/14  20:34:58  jhmorr
C Alpha 4.1.
C
      SUBROUTINE CHAPND (STRING1, STRING2)
C
C Routine to append character STRING2 to STRING1.
C
C N.B. This routine assumes that STRING1 is right padded with spaces.
C      Unpredictable results will be returned if STRING1 is not right padded.
C
C STRING1 : Input base character string (with at least one terminating space)
C STRING2 : Input character string to be appended to STRING1
C
      CHARACTER*(*) STRING1,
     1              STRING2
C
      LEN1 = ICHLNG (STRING1)
C
      STRING1 = STRING1(1:LEN1) // STRING2
C
C Finished with CHAPND
      RETURN
      END
      INTEGER FUNCTION ICHLNG (STRING)
C
C Function to return the length of a string defined as the location where
C the first white space is located.
C
C STRING : Input string
C
      CHARACTER*80 STRING
C
      LOC = 1
  100 CONTINUE
      IF (STRING(LOC:LOC) .EQ. ' ') THEN
         GO TO 200
      ENDIF
      LOC = LOC + 1
      IF (LOC .GT. 80) THEN
         GO TO 200
      ENDIF
      GO TO 100
C
C Found space or end of string
C
  200 CONTINUE
      ICHLNG = LOC - 1
      RETURN
      END
      SUBROUTINE MASFLO (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                 Q, S, VOL, FMASS, DQP, DQM, QP, QM, F, FM, STEMP,
     2                 IBCDAT, NBCS, IORDER, LIMIT, RKAP, IFLUX, VISCOS)
C
C     Routine to calculate the mass flow through an I = const
C     plane to be used for convergence tests.
C     This routine is based on the FLUXI routine.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                      (used in dimensioning temporary space used for
C                       calculating q(+,-) and f.
C     Q              : Primitive variables at cell centers
C     S              : Metrics
C     VOL            : Cell volumes
C     FMASS          : Mass flow through the Ith plane
C     DQP,DQM        : Storage for delta q = q(i) - q(i-1)
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     F,FM           : Fluxes at cell interfaces -
C                      if Flux Difference Splitting then F = Flux
C                      if Flux Vector Splitting then F = Fplus, FM = Fminus
C     STEMP          : Storage for metrics passed to flux evaluation routine.
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IORDER         : Order of MUSCL interpolation for I direction
C                      IORDER = 1 first order
C                             = 2 second order (or 'third' order)
C     LIMIT          : Limiter to use for MUSCL interpolation
C     RKAP           : Kappa to use in MUSCL interpolation
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     2          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION FMASS (IDIM),
     1          DQP   (MXSECT,NQ),
     2          DQM   (MXSECT,NQ),
     3          QP    (MXSECT,NQ),
     4          QM    (MXSECT,NQ),
     5          F     (IPSTRT-1:IPEND,2:JDIM,NF),
     6          FM    (IPSTRT-1:IPEND,2:JDIM,NF),
     7          STEMP (IPSTRT-1:IPEND,2:JDIM,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      LOGICAL   VISCOS
C
C     Loop over K calculating Q(+,-), F(Q(+,-)) and updating the Residual.
C
      DO 300 K = 2, KDIM
C
C     Inviscid Residuals
C
         CALL MUSCLI (IDIM, JDIM, KDIM, K, IPSTRT, IPEND,
     1                Q, DQP, DQM, QP, QM,
     2                IBCDAT, NBCS, IORDER, LIMIT, RKAP)
C
C     Calculate the fluxes from q(plus) and q(minus).  Pass only
C     the appropriate metrics from the current direction.
C
         DO 120 I = IPSTRT - 1, IPEND
            DO 110 J = 2, JDIM
               DO 100 L = 1, 3
                  STEMP(I,J,L) = S(J,K,I,L,1)
  100          CONTINUE
  110       CONTINUE
  120    CONTINUE
         NPTS = (IPEND - IPSTRT + 2) * (JDIM - 1)
C
C     Flux Difference Splitting
C
         IF (IFCHAR(IFLUX,1) .EQ. IFDS) THEN
C
C     Add the flux contributions to the residual.
C
            STOP'CALL FDS(IFLUX,NPTS,QP,QM,STEMP,F)'
C
            DO 160 I = IPSTRT - 1, IPEND
               DO 140 J = 2, JDIM
                  FMASS(I) = FMASS(I) + F(I,J,1) * S(J,K,I,4,1)
  140          CONTINUE
  160       CONTINUE
         ENDIF
  300 CONTINUE
C
C     Output the results
C
      DO 500 I = IPSTRT - 1, IPEND
         WRITE (IOUT,1000) I, FMASS(I)
  500 CONTINUE
 1000 FORMAT (' ',' Mass flow through cross section ',I4,' is ',
     1        1PE14.7)
C
C     Finished calculating mass flow through I cross sections
      RETURN
      END
      SUBROUTINE MONITR (IDIM, JDIM, KDIM, Q, NPRMON, IPRMON)
C
C     Routine to monitor output during the iteration cycle
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     Q              : Primitive variables at cell centers
C     NPRMON         : Number of monitor print statements for current block
C     IPRMON         : Monitor print control vector for current block
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION IPRMON(10,NPRMON)
C
      DIMENSION ISTRT(3), IEND(3), INC(3)
C
      CHARACTER*10 TITLE(3)
      DATA TITLE / 'J, K =    ',
     1             'K, I =    ',
     2             'I, J =    ' /
C
C     Loop over all print statements
C
      do 130 i = 0, idim+2
         do 120 k = 0, kdim+2
            do 110 j = 0, jdim+2
               if (q(j,k,i,4) .ne. 0.e0) then
                  write (iout,'(a,3i5,e15.7)') ' i,j,k,w ',
     1                                           i,j,k,q(j,k,i,4)
               endif
  110       continue
  120    continue
  130 continue
C
C     Output a few blank lines to make output look better
C
      WRITE (IOUT,1015)
      RETURN
 1000 FORMAT (//' ',20X,A10,2I5/
     1        ' ','   I   J   K',
     2            6X,'RHO',11X,'U',12X,'V',
     3            12X,'W',9X,'P/PINF',8X,'T/TINF')
 1010 FORMAT (' ',3I4,7E13.5)
 1015 FORMAT (//' ')
      END
      SUBROUTINE OUTPUT (IDIM, JDIM, KDIM, Q, RMU, RMUT, YPLUS, ITURB,
     1                   RC, IBLOCK, NPRINT, IPRINT)
C
C     Routine to write output
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     Q              : Primitive variables at cell centers
C     RMU            : Molecular viscosity at cell centers
C     RMUT           : Turbulent eddy viscosity at cell centers
C     YPLUS          : Y+ at cell centers
C     ITURB          : Turbulence model
C     RC             : Calculated position of grid at cell centers
C     IBLOCK         : Block number to identify output
C     NPRINT         : Number of print statements for current block
C     IPRINT         : Print control vector for current block
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMU   (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     2          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     3          YPLUS (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     4          RC    (JDIM+1,KDIM+1,IDIM+1,3)
C
      DIMENSION IPRINT(10,NPRINT)
C
      DIMENSION ISTRT(3), IEND(3), INC(3)
C
      CHARACTER*10 TITLE(3)
      DATA TITLE / 'J, K =    ',
     1             'K, I =    ',
     2             'I, J =    ' /
C
C     Loop over all print statements
C
      DO 800 IPR = 1, NPRINT
         IDIR     = IPRINT(1,IPR)
         ISTRT(1) = IPRINT(2,IPR)
         ISTRT(2) = IPRINT(3,IPR)
         ISTRT(3) = IPRINT(4,IPR)
         IEND(1)  = IPRINT(5,IPR)
         IEND(2)  = IPRINT(6,IPR)
         IEND(3)  = IPRINT(7,IPR)
         INC(1)   = IPRINT(8,IPR)
         INC(2)   = IPRINT(9,IPR)
         INC(3)   = IPRINT(10,IPR)
         DO 530 I3 = ISTRT(ICY(IDIR,3)), IEND(ICY(IDIR,3)),
     1               INC(ICY(IDIR,3))
            DO 520 I2 = ISTRT(ICY(IDIR,2)), IEND(ICY(IDIR,2)),
     1                  INC(ICY(IDIR,2))
C
C     Output Header
C
               IF (ITURB .EQ. ITLMNR) THEN
                  WRITE (IOUT,1003) IBLOCK, TITLE(IDIR), I2, I3
               ELSE IF (ITURB .EQ. ITBLMX) THEN
                  WRITE (IOUT,1005) IBLOCK, TITLE(IDIR), I2, I3
               ELSE IF (ITURB .EQ. ITKE) THEN
                  WRITE (IOUT,1010) IBLOCK, TITLE(IDIR), I2, I3
               ELSE IF (ITURB .EQ. ITKW) THEN
                  WRITE (IOUT,1015) IBLOCK, TITLE(IDIR), I2, I3
               ELSE IF (ITURB .EQ. ITRS) THEN
                  WRITE (IOUT,1025) IBLOCK, TITLE(IDIR), I2, I3
               ELSE IF (ITURB .EQ. ITLES) THEN
                  WRITE (IOUT,1030) IBLOCK, TITLE(IDIR), I2, I3
               ELSE
                  WRITE (IOUT,1000) IBLOCK, TITLE(IDIR), I2, I3
               ENDIF
C
C     Inner Loop to Print out
C
               DO 510 I1 = ISTRT(ICY(IDIR,1)), IEND(ICY(IDIR,1)),
     1                     INC(ICY(IDIR,1))
                  II = I1*IKD(ICY(IDIR,1),1) + I2*IKD(ICY(IDIR,2),1) +
     1                 I3*IKD(ICY(IDIR,3),1)
                  JJ = I1*IKD(ICY(IDIR,1),2) + I2*IKD(ICY(IDIR,2),2) +
     1                 I3*IKD(ICY(IDIR,3),2)
                  KK = I1*IKD(ICY(IDIR,1),3) + I2*IKD(ICY(IDIR,2),3) +
     1                 I3*IKD(ICY(IDIR,3),3)
                  PPINF = GAMMA * Q(JJ,KK,II,5)
                  TTINF = GAMMA * Q(JJ,KK,II,5) / Q(JJ,KK,II,1)
                  IF (ITURB .EQ. ITLMNR) THEN
                     WRITE (IOUT,1103) II, JJ, KK,
     1                  RC(JJ,KK,II,1), RC(JJ,KK,II,2), RC(JJ,KK,II,3),
     2                  Q(JJ,KK,II,1),  Q(JJ,KK,II,2),  Q(JJ,KK,II,3),
     3                  Q(JJ,KK,II,4),  PPINF, TTINF, RMU(JJ,KK,II)
                  ELSE IF (ITURB .EQ. ITBLMX) THEN
                     WRITE (IOUT,1105) II, JJ, KK,
     1                  RC(JJ,KK,II,1), RC(JJ,KK,II,2), RC(JJ,KK,II,3),
     2                  Q(JJ,KK,II,1),  Q(JJ,KK,II,2),  Q(JJ,KK,II,3),
     3                  Q(JJ,KK,II,4),  PPINF, TTINF, RMU(JJ,KK,II),
     4                  RMUT(JJ,KK,II)
                  ELSE IF (ITURB. EQ. ITKE) THEN
                     RHO   = Q(JJ,KK,II,1)
                     P     = Q(JJ,KK,II,5)
                     TKE   = Q(JJ,KK,II,6)
                     EPSLN = Q(JJ,KK,II,7)
                     ASQ   = GAMMA * P / RHO
                     RMT   = SQRT (2.E0 * TKE / ASQ)
                     RET   = RHO*TKE*TKE/(EPSLN*RMU(JJ,KK,II)+RSMALL) *
     1                       RE / FSMACH
                     WRITE (IOUT,1110) II, JJ, KK,
     1                  RC(JJ,KK,II,1), RC(JJ,KK,II,2), RC(JJ,KK,II,3),
     2                  Q(JJ,KK,II,1),  Q(JJ,KK,II,2),  Q(JJ,KK,II,3),
     3                  Q(JJ,KK,II,4),  PPINF, TTINF, RMU(JJ,KK,II),
     4                  RMUT(JJ,KK,II), Q(JJ,KK,II,6),  Q(JJ,KK,II,7),
     5                  YPLUS(JJ,KK,II), RMT, RET
                  ELSE IF (ITURB .EQ. ITKW) THEN
                     RHO   = Q(JJ,KK,II,1)
                     P     = Q(JJ,KK,II,5)
                     TKE   = Q(JJ,KK,II,6)
                     EPSLN = TKE * Q(JJ,KK,II,7)
                     ASQ   = GAMMA * P / RHO
                     RMT   = SQRT (2.E0 * TKE / ASQ)
                     RET   = RHO*TKE*TKE/(EPSLN*RMU(JJ,KK,II)+RSMALL) *
     1                       RE / FSMACH
                     WRITE (IOUT,1110) II, JJ, KK,
     1                  RC(JJ,KK,II,1), RC(JJ,KK,II,2), RC(JJ,KK,II,3),
     2                  Q(JJ,KK,II,1),  Q(JJ,KK,II,2),  Q(JJ,KK,II,3),
     3                  Q(JJ,KK,II,4),  PPINF, TTINF, RMU(JJ,KK,II),
     4                  RMUT(JJ,KK,II), Q(JJ,KK,II,6),  Q(JJ,KK,II,7),
     5                  YPLUS(JJ,KK,II), RMT, RET
                  ELSE IF (ITURB. EQ. ITRS) THEN
                     WRITE (IOUT,1125) II, JJ, KK,
     1                  RC(JJ,KK,II,1), RC(JJ,KK,II,2), RC(JJ,KK,II,3),
     2                  Q(JJ,KK,II,1),  Q(JJ,KK,II,2),  Q(JJ,KK,II,3),
     3                  Q(JJ,KK,II,4),  PPINF, TTINF, RMU(JJ,KK,II),
     4                  RMUT(JJ,KK,II), Q(JJ,KK,II,6),
     5                  Q(JJ,KK,II,7),  Q(JJ,KK,II,8),  Q(JJ,KK,II,9),
     6                  Q(JJ,KK,II,10), Q(JJ,KK,II,11), Q(JJ,KK,II,12),
     7                  YPLUS(JJ,KK,II)
                  ELSE IF (ITURB .EQ. ITLES) THEN
                     WRITE (IOUT,1130) II, JJ, KK,
     1                  RC(JJ,KK,II,1), RC(JJ,KK,II,2), RC(JJ,KK,II,3),
     2                  Q(JJ,KK,II,1),  Q(JJ,KK,II,2),  Q(JJ,KK,II,3),
     3                  Q(JJ,KK,II,4),  PPINF, TTINF, RMU(JJ,KK,II),
     4                  RMUT(JJ,KK,II)
                  ELSE
                     WRITE (IOUT,1100) II, JJ, KK,
     1                  RC(JJ,KK,II,1), RC(JJ,KK,II,2), RC(JJ,KK,II,3),
     2                  Q(JJ,KK,II,1),  Q(JJ,KK,II,2),  Q(JJ,KK,II,3),
     3                  Q(JJ,KK,II,4),  PPINF, TTINF
                  ENDIF
  510          CONTINUE
  520       CONTINUE
  530    CONTINUE
  800 CONTINUE
      RETURN
C
 1000 FORMAT (//' ','BLOCK = ',I5,10X,A10,2I5/
     1        ' ','   I   J   K',9X,'X',16X,'Y',16X,'Z',
     2            15X,'RHO',15X,'U',16X,'V',
     3            16X,'W',13X,'P/Pinf',12X,'T/Tinf')
 1003 FORMAT (//' ','BLOCK = ',I5,10X,A10,2I5/
     1        ' ','   I   J   K',7X,'X',12X,'Y',12X,'Z',
     2            11X,'RHO',11X,'U',12X,'V',
     3            12X,'W',9X,'P/Pinf',8X,'T/Tinf',9X,'RMU')
 1005 FORMAT (//' ','BLOCK = ',I5,10X,A10,2I5/
     1        ' ','   I   J   K',7X,'X',12X,'Y',12X,'Z',
     2            11X,'RHO',11X,'U',12X,'V',
     3            12X,'W',9X,'P/Pinf',8X,'T/Tinf',9X,'RMU',
     4            8X,'RMUT')
 1010 FORMAT (//' ','BLOCK = ',I5,10X,A10,2I5/
     1        ' ','   I   J   K',7X,'X',12X,'Y',12X,'Z',
     2            11X,'RHO',11X,'U',12X,'V',
     3            12X,'W',9X,'P/Pinf',8X,'T/Tinf',9X,'RMU',
     4            8X,'RMUT',9X,'k',10X,'EPSILON',8X,'Yplus',
     5            7X,'Mach_t',7X,'Re_t')
 1015 FORMAT (//' ','BLOCK = ',I5,10X,A10,2I5/
     1        ' ','   I   J   K',7X,'X',12X,'Y',12X,'Z',
     2            11X,'RHO',11X,'U',12X,'V',
     3            12X,'W',9X,'P/Pinf',8X,'T/Tinf',9X,'RMU',
     4            8X,'RMUT',9X,'k',11X,'OMEGA',8X,'Yplus',
     5            7X,'Mach_t',7X,'Re_t')
 1025 FORMAT (//' ','BLOCK = ',I5,10X,A10,2I5/
     1        ' ','   I   J   K',7X,'X',12X,'Y',12X,'Z',
     2            11X,'RHO',11X,'U',12X,'V',
     3            12X,'W',9X,'P/Pinf',8X,'T/Tinf',9X,'RMU',
     4            8X,'RMUT',9X,'TAUXX',8X,'TAUYY',8X,'TAUZZ',8X,
     5            'TAUXY',8X,'TAUXZ',8X,'TAUYZ',7X,'EPSILON',8X,'Yplus')
 1030 FORMAT (//' ','BLOCK = ',I5,10X,A10,2I5/
     1        ' ','   I   J   K',7X,'X',12X,'Y',12X,'Z',
     2            11X,'RHO',11X,'U',12X,'V',
     3            12X,'W',9X,'P/Pinf',8X,'T/Tinf',9X,'RMU',
     4            8X,'RMUT')
 1100 FORMAT (' ',3I4,10(1PE17.9))
 1103 FORMAT (' ',3I4, 3(1PE13.5), 8(1PE13.5))
 1105 FORMAT (' ',3I4, 3(1PE13.5), 9(1PE13.5))
 1110 FORMAT (' ',3I4, 3(1PE13.5),14(1PE13.5))
 1125 FORMAT (' ',3I4, 3(1PE13.5),17(1PE13.5))
 1130 FORMAT (' ',3I4, 3(1PE13.5), 9(1PE13.5))
C
      END
      SUBROUTINE CUT3D (IDIM, JDIM, KDIM, Q, ICUTS)
C
C     This routine averages the value of the interior and boundary
C     condition flow variable at the cell center for the CUT boundary
C     condition type to the face to coincide with the PLOT3D output.
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION ICUTS (21)
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3),
     3          ISGN  (3),
     4          LEN   (3)
C
C     Store IDIM, JDIM, KDIM in IJKDIM for looping
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C     Store boundary condition data in mnemonic names
C
      IDIR     = ICUTS( 2)
      INOUT    = ICUTS( 3)
      ISTRT(1) = ICUTS( 4)
      IEND (1) = ICUTS( 5)
      ISTRT(2) = ICUTS( 6)
      IEND (2) = ICUTS( 7)
      ISTRT(3) = ICUTS( 8)
      IEND (3) = ICUTS( 9)
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INOUT = 1) or the outer boundary (INOUT > 1)
C          INR    = interior point of block
C          IBCPT  = boundary point of block
C
      IF (INOUT .EQ. 1) THEN
         INR    = 2
         IBCPT  = 1
      ELSE
         INR    = IJKDIM(IDIR)
         IBCPT  = IJKDIM(IDIR) + 1
      ENDIF
C
C     Find the length of the two outer loops and loop over these using
C     offsets and delta function to set the two cut data points to the
C     two interior data points of block 2.
C
      DO 100 L = 1, 3
C
         LEN(L) = ABS ( IEND(L) - ISTRT(L) )
C
C     Increment/Decrement
C
         IF ( IEND(L) .GT. ISTRT(L) ) THEN
            ISGN(L) =   1
         ELSE
            ISGN(L) = - 1
         ENDIF
  100 CONTINUE
C
C     II1 first  boundary point of block 1
C     II2 second boundary point of block 1
C     IN1 first  interior point of block 2
C     IN2 second interior point of block 2
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
      DO 800 I3 = 0, LEN(IC3)
         DO 700 I2 = 0, LEN(IC2)
            IBC = IBCPT                       * IKD (IC1, 1) +
     1            (ISTRT(IC2) + ISGN(IC2)*I2) * IKD (IC2, 1) +
     2            (ISTRT(IC3) + ISGN(IC3)*I3) * IKD (IC3, 1)
            JBC = IBCPT                       * IKD (IC1, 2) +
     1            (ISTRT(IC2) + ISGN(IC2)*I2) * IKD (IC2, 2) +
     2            (ISTRT(IC3) + ISGN(IC3)*I3) * IKD (IC3, 2)
            KBC = IBCPT                       * IKD (IC1, 3) +
     1            (ISTRT(IC2) + ISGN(IC2)*I2) * IKD (IC2, 3) +
     2            (ISTRT(IC3) + ISGN(IC3)*I3) * IKD (IC3, 3)
C
            IN  = INR                         * IKD (IC1, 1) +
     1            (ISTRT(IC2) + ISGN(IC2)*I2) * IKD (IC2, 1) +
     2            (ISTRT(IC3) + ISGN(IC3)*I3) * IKD (IC3, 1)
            JN  = INR                         * IKD (IC1, 2) +
     1            (ISTRT(IC2) + ISGN(IC2)*I2) * IKD (IC2, 2) +
     2            (ISTRT(IC3) + ISGN(IC3)*I3) * IKD (IC3, 2)
            KN  = INR                         * IKD (IC1, 3) +
     1            (ISTRT(IC2) + ISGN(IC2)*I2) * IKD (IC2, 3) +
     2            (ISTRT(IC3) + ISGN(IC3)*I3) * IKD (IC3, 3)
C
CDIR$ SHORTLOOP
            DO 600 L = 1, NQ
               Q(JBC,KBC,IBC,L) = 0.5E0 * (Q(JN,KN,IN,L) +
     1                                     Q(JBC,KBC,IBC,L))
 600        CONTINUE
 700     CONTINUE
 800  CONTINUE
C
C     Finished with Cut boundary condition fix to PLOT3D
      RETURN
      END
      SUBROUTINE PLOT3D(IDIM, JDIM, KDIM, Q, PROPS, RC, BINARY)
C
C Routine to write PLOT3D output. The mean flow variables are output in
C the PLOT3D solution (Q) file in 'conserved' form (neglecting TKE in the
C equation of state) and the turbulence variables and properties (if NQ > 5)
C are output in the function file. The turbulence quantities are output as
C they are calculated and are not converted to 'conserved' form.
C
C This routine is organized as follows:
C     1. Convert mean flow from primitive to 'conserved' variables
C        NOTE: do not include TKE in conversion from pressure to total energy
C              to match the equation of state that is assumed in FAST/PLOT3D
C     2. Write PLOT3D output files (FORMATTED or UNFORMATTED)
C        a. Three-dimensional output
C           i.  Binary    { }
C           ii. Formatted { }
C        b. Two  -dimensional output
C           i.  Binary    { }
C           ii. Formatted { }
C               { a. Grid file     (G)
C                 b. Solution file (Q)
C                 c. If (NQ > 5) write function file (F) }
C     3. Convert mean flow from 'conserved' to primitive variables
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C RC             : Calculated position of grid at cell centers
C BINARY         : Logical for PLOT3D output file type
C                  = TRUE  -> binary (unformatted) file
C                    FALSE -> formatted file
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          RC    (JDIM+1,KDIM+1,IDIM+1,3)
      LOGICAL BINARY
C
C-DJB CREATE PLOT FILES
      OPEN(2,FILE='ISAAC.PLT',STATUS='UNKNOWN')
      IF(THREED)THEN
        WRITE(2,1)
    1   FORMAT('TITLE="3D FLUID FLOW BY ISAAC"',/,
     &         'VARIABLES="X" "Y" "Z" "P" "U" "V" "W"',/,
     &         'ZONE T="RESULTS", F=POINT',/,
     &         'DT=(SINGLE SINGLE SINGLE SINGLE SINGLE SINGLE SINGLE)')
        OPEN(1,FILE='ISAAC.V3D',STATUS='UNKNOWN')
        DO I=1,IDIM+1
          DO J=1,JDIM+1
            DO K=1,KDIM+1
              WRITE(1,3)(RC(J,K,I,L),L=1,3),(Q(J,K,I,L),L=2,4)
              WRITE(2,3)(RC(J,K,I,L),L=1,3),Q(J,K,I,5),
     &          (Q(J,K,I,L),L=2,4)
            ENDDO
          ENDDO
        ENDDO
      ELSE
        WRITE(2,2)
    2   FORMAT('TITLE="2D FLUID FLOW BY ISAAC"',/,
     &         'VARIABLES="X" "Y" "P" "U" "V"',/,
     &         'ZONE T="RESULTS", F=POINT',/,
     &         'DT=(SINGLE SINGLE SINGLE SINGLE SINGLE)')
        OPEN(1,FILE='ISAAC.V2D',STATUS='UNKNOWN')
        DO I=1,IDIM+1
          DO J=1,JDIM+1
            WRITE(1,3)(RC(J,2,I,L),L=1,2),(Q(J,2,I,L),L=2,3)
            WRITE(2,3)(RC(J,2,I,L),L=1,2),Q(J,K,I,5),
     &        (Q(J,2,I,L),L=2,3)
          ENDDO
        ENDDO
      ENDIF
    3 FORMAT(7E13.5)
      CLOSE(1)
      CLOSE(2)
      IF(.TRUE.)RETURN !DJB-DON'T CARE ABOUT THE REST
C
C 1. Convert mean flow from primitive to 'conserved' variables
C    NOTE: do not include TKE in conversion from pressure to total energy
C          to match the equation of state that is assumed in FAST/PLOT3D
C
      DO 130 I = 1, IDIM+1
         DO 120 K = 1, KDIM+1
            DO 110 J = 1, JDIM+1
               Q(J,K,I,5) = Q(J,K,I,5) / GAMM1 + 0.5E0*Q(J,K,I,1)*
     1                           ( Q(J,K,I,2)*Q(J,K,I,2)
     2                           + Q(J,K,I,3)*Q(J,K,I,3)
     3                           + Q(J,K,I,4)*Q(J,K,I,4) )
               Q(J,K,I,2) = Q(J,K,I,2) * Q(J,K,I,1)
               Q(J,K,I,3) = Q(J,K,I,3) * Q(J,K,I,1)
               Q(J,K,I,4) = Q(J,K,I,4) * Q(J,K,I,1)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C 2.   Write PLOT3D output files (FORMATTED or UNFORMATTED)
C
C 2-a. Output for three-dimensional case
C
      IF ( THREED ) THEN
         IF ( BINARY ) THEN
C
C 2-a-i.  Binary output
C
            WRITE (IPLT3G) ((((RC(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                     K=1,KDIM+1),L=1,3)
            WRITE (IPLT3Q) ((((Q (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                     K=1,KDIM+1),L=1,5)
            IF (NQ .GT. 5) THEN
               WRITE (IPLT3F)
     1                     ((((Q    (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                        K=1,KDIM+1),L=6,NQ),
     2                     ((((PROPS(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     3                                        K=1,KDIM+1),L=1,NP)
            ENDIF
         ELSE
C
C 2-a-ii. Formatted output
C
            WRITE (IPLT3G,1000) ((((RC(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                          K=1,KDIM+1),L=1,3)
            WRITE (IPLT3Q,1000) ((((Q (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                          K=1,KDIM+1),L=1,5)
            IF (NQ .GT. 5) THEN
               WRITE (IPLT3F,1000)
     1                       ((((Q    (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     2                                          K=1,KDIM+1),L=6,NQ),
     3                       ((((PROPS(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     4                                          K=1,KDIM+1),L=1,NP)
            ENDIF
         ENDIF
C
C 2-b. Output for two-dimensional case
C      Output as a three-dimensional case with KDIM=1 for FAST
C
      ELSE
         K = 2
         IF ( BINARY ) THEN
C
C 2-b-i.  Binary output
C
            WRITE (IPLT3G) (((RC(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                    L=1,2)
            WRITE (IPLT3Q) (((Q (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                    L=1,3),
     2                      ((Q (J,K,I,5),I=1,IDIM+1),J=1,JDIM+1)
            IF (NQ .GT. 5) THEN
               WRITE (IPLT3F)
     1                     (((Q    (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     2                                       L=6,NQ),
     3                     (((PROPS(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     4                                       L=1,NP)
            ENDIF
         ELSE
C
C 2-b-ii. Formatted output
C
            WRITE (IPLT3G,1000) (((RC(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                         L=1,2)
            WRITE (IPLT3Q,1000) (((Q (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     1                                         L=1,3),
     2                           ((Q (J,K,I,5),I=1,IDIM+1),J=1,JDIM+1)
            IF (NQ .GT. 5) THEN
               WRITE (IPLT3F,1000)
     1                       (((Q    (J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     2                                         L=6,NQ),
     3                       (((PROPS(J,K,I,L),I=1,IDIM+1),J=1,JDIM+1),
     4                                         L=1,NP)
            ENDIF
         ENDIF
      ENDIF
C
C 3.  Convert mean flow from 'conserved' to primitive variables
C
      DO 330 I = 1, IDIM+1
         DO 320 K = 1, KDIM+1
            DO 310 J = 1, JDIM+1
               Q(J,K,I,2) = Q(J,K,I,2) / Q(J,K,I,1)
               Q(J,K,I,3) = Q(J,K,I,3) / Q(J,K,I,1)
               Q(J,K,I,4) = Q(J,K,I,4) / Q(J,K,I,1)
               Q(J,K,I,5) = GAMM1*( Q(J,K,I,5) - 0.5E0*Q(J,K,I,1)*
     1                               ( Q(J,K,I,2)*Q(J,K,I,2)
     2                               + Q(J,K,I,3)*Q(J,K,I,3)
     3                               + Q(J,K,I,4)*Q(J,K,I,4) ) )
  310       CONTINUE
  320    CONTINUE
  330 CONTINUE
 1000 FORMAT(5E16.8)
      RETURN
      END
      SUBROUTINE PLOT3DFN (ITURB)
C
C This routine writes the PLOT3D function name file.
C
C ITURB : Turbulence model
C
C This routine is organized as follows:
C     1. Write function names for turbulence quantities
C        a. K-epsilon
C        b. K-omega
C        c. Reynolds stress
C     2. Write function names for properties
C
      include 'common.inc'
C
C Local storage
C
      INTEGER      L
C
      CHARACTER*25 FUNNAME (5)
C
C 1.   Write function names for turbulence quantities
C 1-a. K-epsilon
C
      IF (ITURB .EQ. ITKE) THEN
         WRITE (IPLT3FN,1000) 'K                        ',
     1                        'Epsilon                  '
C
C 1-b. K-omega
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         WRITE (IPLT3FN,1000) 'K                        ',
     1                        'Omega                    '
C
C 1-c. Reynolds stress
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         WRITE (IPLT3FN,1000) 'Tau_xx                   ',
     1                        'Tau_yy                   ',
     2                        'Tau_zz                   ',
     3                        'Tau_xy                   ',
     4                        'Tau_xz                   ',
     5                        'Tau_yz                   ',
     6                        'Epsilon                  '
C
      ENDIF
C
C 2.   Write function names for properties
C
      FUNNAME(1) = 'mu'
      FUNNAME(2) = 'mu_t'
      FUNNAME(3) = 'y+'
      FUNNAME(4) = 'y_normal'
      FUNNAME(5) = 'C_mu*'
C
      DO L = 1, NP
         WRITE (IPLT3FN,1000) FUNNAME(L)
      END DO
C
C Finished PLOT3DFN writing function name file
      RETURN
 1000 FORMAT (A25)
      END
      SUBROUTINE RCENTR (IDIM, JDIM, KDIM, R, RC, IBCDAT, NBCS)
C
C Routine to average the positions of the vertices to get a cell centered
C value of the grid for output purposes.
C
C This routine is organized as follows:
C      1. Calculate cell centers for (1:dim+1) in all directions
C         a. Corners
C         b. Edges
C         c. Faces
C         d. Interior
C      2. For wall functions, loop over all boundary conditions and
C         correct the cell center calculated above to account for
C         wall function spacing
C
C IDIM,JDIM,KDIM : Dimensions of current block
C R              : Position vector of grid vertices (x,y,z)
C RC             : Calculated position of grid at cell centers
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C NBCS           : Number of boundary conditions for current block
C
      include 'common.inc'
C
      DIMENSION R     (0:JDIM+1,0:KDIM+1,0:IDIM+1,3),
     1          RC    (JDIM+1,KDIM+1,IDIM+1,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C R  is the grid input at vertices
C RC is the grid at cell centers to be sent to PLOT3D
C
C 1. Calculate cell-centered grid
C
C 1-a. Corners
C
      DO 10 IDIR = 1, 3
         RC(1,1,1,IDIR)                = R(1,1,1,IDIR)
         RC(JDIM+1,1,1,IDIR)           = R(JDIM,1,1,IDIR)
         RC(1,1,IDIM+1,IDIR)           = R(1,1,IDIM,IDIR)
         RC(JDIM+1,1,IDIM+1,IDIR)      = R(JDIM,1,IDIM,IDIR)
         RC(1,KDIM+1,1,IDIR)           = R(1,KDIM,1,IDIR)
         RC(JDIM+1,KDIM+1,1,IDIR)      = R(JDIM,KDIM,1,IDIR)
         RC(1,KDIM+1,IDIM+1,IDIR)      = R(1,KDIM,IDIM,IDIR)
         RC(JDIM+1,KDIM+1,IDIM+1,IDIR) = R(JDIM,KDIM,IDIM,IDIR)
   10 CONTINUE
C
C 1-b. Edges
C
      DO 60 IDIR = 1, 3
         DO 30 I = 2, IDIM
            RC(1,1,I,IDIR)           = 0.5E0 * ( R(1,1,I-1,IDIR)
     1                                         + R(1,1,I,IDIR) )
            RC(JDIM+1,1,I,IDIR)      = 0.5E0 * ( R(JDIM,1,I-1,IDIR)
     1                                         + R(JDIM,1,I,IDIR) )
            RC(1,KDIM+1,I,IDIR)      = 0.5E0 * ( R(1,KDIM,I-1,IDIR)
     1                                         + R(1,KDIM,I,IDIR) )
            RC(JDIM+1,KDIM+1,I,IDIR) = 0.5E0 * ( R(JDIM,KDIM,I-1,IDIR)
     1                                         + R(JDIM,KDIM,I,IDIR) )
   30    CONTINUE
         DO 40 J = 2, JDIM
            RC(J,1,1,IDIR)           = 0.5E0 * ( R(J-1,1,1,IDIR)
     1                                         + R(J,1,1,IDIR) )
            RC(J,1,IDIM+1,IDIR)      = 0.5E0 * ( R(J-1,1,IDIM,IDIR)
     1                                         + R(J,1,IDIM,IDIR) )
            RC(J,KDIM+1,1,IDIR)      = 0.5E0 * ( R(J-1,KDIM,1,IDIR)
     1                                         + R(J,KDIM,1,IDIR) )
            RC(J,KDIM+1,IDIM+1,IDIR) = 0.5E0 * ( R(J-1,KDIM,IDIM,IDIR)
     1                                         + R(J,KDIM,IDIM,IDIR) )
   40    CONTINUE
         DO 50 K = 2, KDIM
            RC(1,K,1,IDIR)           = 0.5E0 * ( R(1,K-1,1,IDIR)
     1                                         + R(1,K,1,IDIR) )
            RC(1,K,IDIM+1,IDIR)      = 0.5E0 * ( R(1,K-1,IDIM,IDIR)
     1                                         + R(1,K,IDIM,IDIR) )
            RC(JDIM+1,K,1,IDIR)      = 0.5E0 * ( R(JDIM,K-1,1,IDIR)
     1                                         + R(JDIM,K,1,IDIR) )
            RC(JDIM+1,K,IDIM+1,IDIR) = 0.5E0 * ( R(JDIM,K-1,IDIM,IDIR)
     1                                         + R(JDIM,K,IDIM,IDIR) )
   50    CONTINUE
   60 CONTINUE
C
C 1-c. J = 1, J = JDIM+1 Planes
C
      DO 120 IDIR = 1, 3
         DO 110 I = 2, IDIM
            DO 100 K = 2, KDIM
               RC(1,K,I,IDIR)      = 0.25E0*
     1                  ( R(1,K,I,IDIR)   + R(1,K,I-1,IDIR)
     2                  + R(1,K-1,I,IDIR) + R(1,K-1,I-1,IDIR) )
               RC(JDIM+1,K,I,IDIR) = 0.25E0*
     1                  ( R(JDIM,K,I,IDIR)   + R(JDIM,K,I-1,IDIR)
     2                  + R(JDIM,K-1,I,IDIR) + R(JDIM,K-1,I-1,IDIR) )
  100       CONTINUE
  110    CONTINUE
  120 CONTINUE
C
C      K = 1, K = KDIM+1 Planes
C
      DO 150 IDIR = 1, 3
         DO 140 I = 2, IDIM
            DO 130 J = 2, JDIM
               RC(J,1,I,IDIR)      = 0.25E0*
     1                  ( R(J,1,I,IDIR)   + R(J,1,I-1,IDIR)
     2                  + R(J-1,1,I,IDIR) + R(J-1,1,I-1,IDIR) )
               RC(J,KDIM+1,I,IDIR) = 0.25E0*
     1                  ( R(J,KDIM,I,IDIR)   + R(J,KDIM,I-1,IDIR)
     2                  + R(J-1,KDIM,I,IDIR) + R(J-1,KDIM,I-1,IDIR) )
  130       CONTINUE
  140    CONTINUE
  150 CONTINUE
C
C      I = 1, I = IDIM+1 Planes
C
      DO 180 IDIR = 1, 3
         DO 170 K = 2, KDIM
            DO 160 J = 2, JDIM
               RC(J,K,1,IDIR)      = 0.25E0*
     1                  ( R(J,K,1,IDIR)   + R(J-1,K,1,IDIR)
     2                  + R(J,K-1,1,IDIR) + R(J-1,K-1,1,IDIR) )
               RC(J,K,IDIM+1,IDIR) = 0.25E0*
     1                  ( R(J,K,IDIM,IDIR)   + R(J-1,K,IDIM,IDIR)
     2                  + R(J,K-1,IDIM,IDIR) + R(J-1,K-1,IDIM,IDIR) )
  160       CONTINUE
  170    CONTINUE
  180 CONTINUE
C
C 1-d. The interior of the domain
C
      DO 240 IDIR = 1, 3
         DO 230 I = 2, IDIM
            DO 220 K = 2, KDIM
               DO 210 J = 2, JDIM
                  RC(J,K,I,IDIR) = 0.125E0*
     1                     (  R(J,K,I,IDIR)     + R(J,K,I-1,IDIR)
     2                      + R(J-1,K,I,IDIR)   + R(J-1,K,I-1,IDIR)
     3                      + R(J,K-1,I,IDIR)   + R(J,K-1,I-1,IDIR)
     4                      + R(J-1,K-1,I,IDIR) + R(J-1,K-1,I-1,IDIR) )
  210          CONTINUE
  220       CONTINUE
  230    CONTINUE
  240 CONTINUE
C
C 2. Modify cell centers of wall function points to reflect proper location
C
      IF (IFWALF) THEN
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
         IJKDIM(1) = IDIM
         IJKDIM(2) = JDIM
         IJKDIM(3) = KDIM
C
C Loop over all bcs
C
         DO 400 IBC = 1, NBCS
            IBCTYP   = IBCDAT(1,IBC)
            IF (IBCTYP .EQ. IWALFN) THEN
C
C Store boundary condition data in mnemonic names
C
               IDIR     = IBCDAT(2,IBC)
               INROUT   = IBCDAT(3,IBC)
               ISTRT(1) = IBCDAT(4,IBC)
               IEND (1) = IBCDAT(5,IBC)
               ISTRT(2) = IBCDAT(6,IBC)
               IEND (2) = IBCDAT(7,IBC)
               ISTRT(3) = IBCDAT(8,IBC)
               IEND (3) = IBCDAT(9,IBC)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
               DO 300 L = 1, 3
                  IF (L .NE. IDIR) THEN
                     IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
                     IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L)+1
                  END IF
  300          CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
               IF (INROUT .EQ. 1) THEN
                  IBCPT  = 1
                  IBCN   = 2
                  IBCN2  = 3
                  SGNM   = 1.E0
               ELSE
                  IBCPT  = IJKDIM(IDIR) + 1
                  IBCN   = IJKDIM(IDIR)
                  IBCN2  = IJKDIM(IDIR) - 1
                  SGNM   = - 1.E0
               ENDIF
C
               IC1 = ICY (IDIR, 1)
               IC2 = ICY (IDIR, 2)
               IC3 = ICY (IDIR, 3)
C
C Reset solution point location for wall functions
C
               DO 320 I3 = ISTRT(IC3), IEND(IC3)
                  DO 310 I2 = ISTRT(IC2), IEND(IC2)
C
                     IW   = IBCPT*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JW   = IBCPT*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KW   = IBCPT*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                     IN   = IBCN *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JN   = IBCN *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KN   = IBCN *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                     IN2  = IBCN2*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JN2  = IBCN2*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KN2  = IBCN2*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
C Calculate distance from 2 to wall, 3 to 2, 3 to interface
C
                     DS2TOW =SQRT((RC(JN ,KN ,IN ,1)-RC(JW,KW,IW,1))**2
     1                           +(RC(JN ,KN ,IN ,2)-RC(JW,KW,IW,2))**2
     2                           +(RC(JN ,KN ,IN ,3)-RC(JW,KW,IW,3))**2)
                     DS3TO2 =SQRT((RC(JN2,KN2,IN2,1)-RC(JN,KN,IN,1))**2
     1                           +(RC(JN2,KN2,IN2,2)-RC(JN,KN,IN,2))**2
     2                           +(RC(JN2,KN2,IN2,3)-RC(JN,KN,IN,3))**2)
                     DS3TOI = (DS2TOW + DS3TO2) - 2.E0 * DS2TOW
C
C Linearly interpolate cell center of first cell to new location
C
                     FACT   = 2.E0 * DS3TOI / DS3TO2
                     OMFACT = 1.E0 - FACT
                     XC     = RC(JN,KN,IN,1)
                     YC     = RC(JN,KN,IN,2)
                     ZC     = RC(JN,KN,IN,3)
                     RC(JN,KN,IN,1) = FACT   * XC
     1                              + OMFACT * RC(JN2,KN2,IN2,1)
                     RC(JN,KN,IN,2) = FACT   * YC
     1                              + OMFACT * RC(JN2,KN2,IN2,2)
                     RC(JN,KN,IN,3) = FACT   * ZC
     1                              + OMFACT * RC(JN2,KN2,IN2,3)
  310             CONTINUE
  320          CONTINUE
            ENDIF
  400    CONTINUE
      ENDIF
C
C Finished with grid averaging
      RETURN
      END
      SUBROUTINE RCCOPY (IDIM, JDIM, KDIM, RCIN, RCOUT)
C
C Routine to copy the input cell centered grid (RCIN) to the output cell
C centered grid (RCOUT).
C
C IDIM,JDIM,KDIM : Dimensions of current block
C RCIN           : Input  position vector of grid vertices at cell centers
C RCOUT          : Output position vector of grid vertices at cell centers
C RC             : Calculated position of grid at cell centers
C
      include 'common.inc'
C
      DIMENSION RCIN  (JDIM+1,KDIM+1,IDIM+1,3),
     1          RCOUT (JDIM+1,KDIM+1,IDIM+1,3)
C
C Loop and copy
C
      DO 130 K = 1, KDIM+1
         DO 120 I = 1, IDIM+1
            DO 110 J = 1, JDIM+1
               RCOUT(J,K,I,1) = RCIN (J,K,I,1)
               RCOUT(J,K,I,2) = RCIN (J,K,I,2)
               RCOUT(J,K,I,3) = RCIN (J,K,I,3)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C Finished copying
      RETURN
      END
      SUBROUTINE RDDATA (NXQ, NXCFS, NXLVLS, NXBLKS, NXBCS,NXCUTS,NXPRT,
     1                   NCFS, MGLVLS, NBLKS,  IDIM, JDIM, KDIM,
     2                   NBCS, IBCDAT, NCUTS, ICUTS, CUTNAM,
     3                   NPRINT, IPRINT, NPRMON, IPRMON, NITMON,
     4                   ITUPJ, ITSLVL,NITS,NSUBIT,NITFO,NITBBC,NITALG,
     5                   NITRST, NXSTAG, NSTAGE, RKALPH,
     6                   RESTRT, FRDRST, FWRRST, GRDFIL, IGRDTP, GRDBIN,
     7                   NXPROF, NPROFL, FPROFL,
     8                   IFPLT3, BINPLT, FPLT3G, FPLT3Q, FPLT3F,FPLT3FN,
     9                   IORDER, LIMIT, RKAP, IFLUX, VISCOS,DIAG,IMODEL,
     A                   IMSTRT, IMEND, TOLER, VGNRN, SIGMA, IFDELQ,
     B                   CONTRB, IMODLX, QMIN, ITRSMX, IFFORC, IFRCPR,
     C                   YNCALC, NXTRSG, NTRSEG, ITRSEG, RCNTR)
C
C Routine to set default values and read input data controlling run.
C
C This routine is organized as follows:
C     1. Set defaults
C     2. Read input deck
C     3. Set values based on input
C     4. Error handling section
C        a. End-Of-File Handler
C        b. Error Handler
C
C NXQ    : Maximum number of Q variables
C NXCFS  :
C NXLVLS :
C NXBLKS :
C NXBCS  :
C NXCUTS :
C NXPRT  :
C NCFS   :
C MGLVLS :
C NBLKS  :
C IDIM   :
C JDIM   :
C KDIM   :
C NBCS   :
C IBCDAT :
C NCUTS  :
C ICUTS  :
C NPRINT :
C IPRINT :
C NPRMON :
C IPRMON :
C NITMON :
C ITUPJ  :
C ITSLVL :
C NITS   : Number of iterations to perform this run.
C NSUBIT : Number of sub-iterations per time step.
C NITFO  : Number of iterations first order.  First order in all directions
C          for time dependent calculations.  First order in the streamwise
C          (marching) direction for marching calculations.
C NITBBC : Number of iterations of the blunt body condition - NOT USED.
C NITALG : Number of iterations to update the eddy viscosity using the
C          algebraic model.  Used for the initial iterations of higher
C          order models to assist convergence.  The higher order models
C          continue to be updated - but the eddy viscosity used for the
C          flow equations is calculated from the algebraic model.
C NITRST : Number of iterations to save intermediate restart file.
C NXSTAG : Maximum number of stages
C NSTAGE : Number of stages for temporal integration scheme
C          RK : Multistage scheme   NSTAGE = 3 (default or typical value)
C          AF : Single stage scheme NSTAGE = 1
C RKALPH : Coefficients for multistage scheme
C RESTRT :
C FRDRST :
C FWRRST :
C GRDFIL :
C IGRDTP :
C GRDBIN :
C NXPROF : Maximum number of profile boundary condition segments
C NPROFL : Number of profile boundary condition segments
C FPROFL : Array of filenames for profile boundary condition segments
C IFPLT3 :
C BINPLT :
C FPLTSG : File name for PLOT3D grid     file
C FPLT3Q : File name for PLOT3D solution file
C FPLT3F : File name for PLOT3D function file
C FPLT3FN: File name for PLOT3D function name file
C IORDER :
C LIMIT  :
C RKAP   :
C IFLUX  :
C VISCOS :
C DIAG   : Control of diagonalized scheme
C IMODEL : Turbulence model array
C IMSTRT :
C IMEND  :
C TOLER  :
C VGNRN  :
C SIGMA  :
C IFDELQ : Array controlling calculation of delq
C CONTRB : Logical.  If true then convert from one turbulence model to
C          another when do restart.
C IMODLX : Turbulence model array defining model to convert FROM if
C          CONTRB is true.
C QMIN   : Control array for minimum value of Q
C ITRSMX : Number of iterations between output of maximum residual
C IFFORC : Control of calculation on forces
C IFRCPR : Control of output of forces
C YNCALC : Logical to force recalculation of Y_normal
C NXTRSG : Maximum number of transition specification segments
C NTRSEG : Actual  number of transition specification segments
C ITRSEG : Data for transition specification segments
C RCNTR  : Location of point vortex for 2D farfield bc. Also location to
C          calculate moments about.
C
      include 'common.inc'
      include 'histry.inc'
C
      CHARACTER*80 FRDRST, FWRRST, GRDFIL(NXBLKS),
     1             FPLT3G, FPLT3Q, FPLT3F, FPLT3FN, FPROFL(NXPROF)
      CHARACTER*80 FNAME
      CHARACTER*25 VAR, VAR1, BCTYP, SOLVER
C
      LOGICAL RESTRT, IFPLT3, GRDBIN, BINPLT, VGNRN, CONTRB, YNCALC
C
      DIMENSION IDIM   (NXBLKS,NXLVLS),
     1          JDIM   (NXBLKS,NXLVLS),
     2          KDIM   (NXBLKS,NXLVLS)
      DIMENSION IBCDAT (10,NXBCS,NXBLKS,NXLVLS),
     1          NBCS   (NXBLKS)
      DIMENSION ICUTS  (21,NXCUTS,NXLVLS)
      INTEGER   NCUTS
      CHARACTER*20 CUTNAM(NXCUTS)
      DIMENSION IPRINT (10,NXPRT,NXBLKS),
     1          NPRINT (NXBLKS),
     2          IPRMON (10,NXPRT,NXBLKS),
     3          NPRMON (NXBLKS)
      DIMENSION NITS   (NXCFS),
     1          MGLVLS (NXCFS),
     2          ITSLVL (NXLVLS,NXCFS)
      DIMENSION RKALPH (NXSTAG)
      DIMENSION IORDER (3,NXBLKS,NXLVLS,NXCFS),
     1          LIMIT  (3,NXBLKS),
     2          RKAP   (3,NXBLKS),
     3          IFLUX  (NXBLKS)
      DIMENSION IMODEL (NMDL),
     1          IMODLX (NMDL)
      LOGICAL   VISCOS (3,NXBLKS),
     1          DIAG   (3,NXBLKS)
      DIMENSION IFDELQ (NXQ)
      DIMENSION QMIN   (NXQ)
C
C     Transition specification
C
      DIMENSION ITRSEG (7,NXTRSG)
C
      DIMENSION RCNTR  (3)
C
C     Local variables
C
      DIMENSION ISTRT (3), IEND(3), IORD(3)
      DIMENSION IDUM  (3)
      DIMENSION ITORDR(3)
C
C     Temporary storage to read print data into to avoid overwriting memory
C
      DIMENSION IDUMPR(10)
C
C 1.  Set defaults
C     Initialize INPERR to be 0.  This is incremented if there is an error
C     in the input dek so that the entire input deck is scanned for potential
C     errors without running an incorrect case.  INPERR counts the number
C     of errors.
C
      INPERR  = 0
C
C     Freestream Quantities
C
      RHOINF = 1.E0
      AINF   = 1.E0
C
C     Initialize variables to default values
C
      NQ     = 5
      NF     = 5
      NP     = 5
      NRANK  = 5
      NTIME  = 1
      NTMTAU = 0
C
      RESTRT = .FALSE.
      INITTD = .FALSE.
      VGNRN  = .FALSE.
      SIGMA  = 0.95E0
C
      IFPLT3 = .FALSE.
      BINPLT = .TRUE.
C
      FOURTH = .FALSE.
      NITBBC = 0
      THNLYR = .FALSE.
      GLOBAL = .TRUE.
      THREED = .TRUE.
      AXISYM = .FALSE.
      TWSPE  = .FALSE.
      SIUNIT = .FALSE.
      YNCALC = .FALSE.
C
      AXIDTH = 1.E0
C
C     Initialize number of profile boundary condition segments to zero
C
      NPROFL = 0
C
C     Grid type
C
      IGRDTP = IGTSEP
      GRDBIN = .TRUE.
C-DJB CHANGE DEFAULT GRID FILE TO NOT BINARY!
      GRDBIN = .FALSE.
C
C     Flow Variables
C
      GAMMA  = 1.4E0
      FSMACH = 0.8E0
      ALPHA  = 0.E0
      BETA   = 0.E0
      RE     = 1.E06
      PR     = 0.7E0
      TINF   = 450.E0
      TWALL  = 1060.E0
      AREARF = 1.E0
C
C     Location of point vortex boundary condition and location for moments
C
      RCNTR(1) = 0.25E0
      RCNTR(2) = 0.E0
      RCNTR(3) = 0.E0
C
C     Subsonic inflow/outflow bc conditions.  Initialize to zero.  If input
C     does not reset to non-zero value, then set based on input freestream.
C     Input T_total as Kelvins or degrees R,
C           P_back, P_total as p/p_inf
C     and non-dimensionalize correctly at end of routine.
C
      PBAKBC = 0.E0
      PTOTBC = 0.E0
      TTOTBC = 0.E0
C
C     Jet conditions
C     Velocities are input non-dimensionalized by ainf
C     Pressure is input as p(jet)/pinf
C        - this is later converted to p(jet)/rhoinf*ainf**2
C     Temperature is input as T(jet)/Tinf
C
      UJET   = 0.E0
      VJET   = 0.E0
      WJET   = 0.E0
      PJET   = 1.E0
      TJET   = 1.E0
C
      TKEJET = 1.E-04
      EPSJET = 1.E-04
      OMEJET = 1.E-04
C
      TAUJET(1) = 2.E0 / 3.E0 * TKEJET
      TAUJET(2) = 2.E0 / 3.E0 * TKEJET
      TAUJET(3) = 2.E0 / 3.E0 * TKEJET
      TAUJET(4) = 0.E0
      TAUJET(5) = 0.E0
      TAUJET(6) = 0.E0
C
C     MUSCL Variables, diagonalized control
C
      DO 3 IBLK = 1, NXBLKS
         RKAP  (1,IBLK) = 0.E0
         RKAP  (2,IBLK) = 0.E0
         RKAP  (3,IBLK) = 0.E0
         LIMIT (1,IBLK) = ILMNMD
         LIMIT (2,IBLK) = ILMNMD
         LIMIT (3,IBLK) = ILMNMD
         IFLUX (IBLK)   = IFROE
         DIAG  (1,IBLK) = .TRUE.
         DIAG  (2,IBLK) = .TRUE.
         DIAG  (3,IBLK) = .TRUE.
    3 CONTINUE
C
C     Entropy Fix
C
      CNTRPY = 0.E0
C
C     Artificial dissipation for central difference scheme
C
      ADKP46 = 1.E0 / 64.E0
C
C     Constants for dQ/dt difference formula - default to first-order
C
      TDTHET = 1.E0
      TDPHI  = 0.E0
      TDPHIP = 0.E0
      ITMTYP = ITTS
C
C     Viscous/Inviscid
C
      DO 6 IBLK = 1, NXBLKS
         VISCOS(1,IBLK) = .FALSE.
         VISCOS(2,IBLK) = .FALSE.
         VISCOS(3,IBLK) = .FALSE.
    6 CONTINUE
C
C     Turn off all calculations of delq
C
      DO 7 L = 1, NXQ
         IFDELQ(L) = 0
    7 CONTINUE
C
C     Turbulence model - set to inviscid flow, no wall functions
C                        turbulence production limit = 100
C
      ITURB     = ITNVSD
      PRT       = 0.9E0
      CONTRB    = .FALSE.
      IFWALF    = .FALSE.
      IDAMP     = 0
      IEPSEQ    = 0
      IEPSLN    = 0
      ISRCW     = INO
      IADRM     = IADRNO
      IASM      = IASMBU
      IEPSC     = IECNO
      IPDIL     = IPDNO
      ICMUST    = 0
      PRDLIM    = 100.E0
C
C     Set default to no transition specification
C
      NTRSEG    = 0
C
C     Set default to limit the production on the epsilon/omega equation also
C
      PRDE      = 1.E0
      PRDEM1    = 1.E0 - PRDE
C
C     Set default to higher order advection on turbulence equations
C
      FOTURB    = .FALSE.
C
C     Set default to not enforce positivity of production
C
      POSPRD    = .FALSE.
C
C     Set default convert turbulence model to default turbulence model
C
      ITURBX    = ITURB
      IDAMPX    = IDAMP
      IASMX     = IASM
C
C     Storage locations for wall shear stress and heat transfer
C
      ITQTAU    = 3
      ITQDOT    = 4
C
C     Run Control Variables
C          NITS   <= MXHIST (maximum size of history array)
C          ITDFNL >= 2 to avoid divide by zero when evaluate (ITDFNL - 1)
C          NITRST  = MXHIST + 1 to turn off intermediate restart file output
C
C     Multigrid control
C
      NCFS      = 1
      DO 8 ICFS = 1, NXCFS
         MGLVLS(ICFS) = 1
         NITS  (ICFS) = MIN (200, MXHIST)
    8 CONTINUE
      CSMTH     = 0.25E0
      CMXCHG    = 0.25E0
C
      NITRST    = MXHIST + 1
      NSUBIT    = 1
      NSTAGE    = 1
      NITFO     = 0
      NITALG    = 0
      ISRCE     = .TRUE.
      ISOLVR    = IAF3F
      IMPSRC    = ISDIAG
      ITIMED    = ISTDY
      NBLKS     = 0
      NCUTS     = 0
      ITUPDT    = 1
      ITUPJ     = 1
      CFL       = 1.E0
      DT        = 0.E0
      CFLFNL    = 0.E0
      TIMEDT    = - 1.E0
      ITDFNL    = MAX (NITS(1), 2)
      ITRSMX    = MXHIST + 1
      IFFORC    = INO
      IFRCPR    = IYES
C
C     Control of FIX routines for positivity preservation
C
      IFIXQ     = IFIXMN
C
      QMIN( 1)  =   1.E-12
      QMIN( 2)  = - 1.E0
      QMIN( 3)  = - 1.E0
      QMIN( 4)  = - 1.E0
      QMIN( 5)  =   1.E-12
C
C     Output Control Variables
C
      NITMON    = 999999
      DO 9 IBLK = 1, NXBLKS
         NPRINT(IBLK) = 0
         NPRMON(IBLK) = 0
    9 CONTINUE
C
      FWRRST    = 'isaac.rst'
C
      DO 20 ICFS = 1, NXCFS
         DO 10 ILVL = 1, NXLVLS
            ITSLVL(ILVL,ICFS) = 1
   10    CONTINUE
   20 CONTINUE
C
C 2.  Read input deck
C     This is the beginning of the loop to read in and process the input
C
      WRITE (IOUT,1001)
C
C     Read card, set variable based on input
C
   50 CONTINUE
      READ (INPUT,*,END=990,ERR=995) VAR, VALUE
      WRITE (IOUT,1000) VAR, VALUE
      IF (VAR .EQ. 'END') THEN
         GO TO 900
C
C     Restart Control
C
      ELSE IF (VAR .EQ. 'RESTART IN') THEN
         RESTRT = .TRUE.
         READ (INPUT,*,END=990,ERR=995) FRDRST
         WRITE (IOUT,1025) FRDRST
      ELSE IF (VAR .EQ. 'RESTART OUT') THEN
         READ (INPUT,*,END=990,ERR=995) FWRRST
         WRITE (IOUT,1005) FWRRST
      ELSE IF (VAR .EQ. 'SAVE RESTART') THEN
         NITRST = INT(VALUE)
C
C     Plot Output
C
      ELSE IF (VAR .EQ. 'PLOT3D') THEN
         IFPLT3 = .TRUE.
         READ (INPUT,*,END=990,ERR=995) VAR
         WRITE (IOUT,1227) VAR
         IF (VAR .EQ. 'BINARY') THEN
            BINPLT = .TRUE.
         ELSE IF (VAR .EQ. 'FORMATTED') THEN
            BINPLT = .FALSE.
         ELSE
            WRITE (IOUT,1010) VAR
            INPERR = INPERR + 1
         ENDIF
         READ (INPUT,*,END=990,ERR=995) FNAME
         FPLT3G  = FNAME
         FPLT3Q  = FNAME
         FPLT3F  = FNAME
         FPLT3FN = FNAME
         CALL CHAPND (FPLT3G,  '.g')
         CALL CHAPND (FPLT3Q,  '.q')
         CALL CHAPND (FPLT3F,  '.qt')
         CALL CHAPND (FPLT3FN, '.qt.nam')
         IF (BINPLT) THEN
            CALL CHAPND (FPLT3G, '.unf')
            CALL CHAPND (FPLT3Q, '.unf')
            CALL CHAPND (FPLT3F, '.unf')
         ELSE
            CALL CHAPND (FPLT3G, '.fmt')
            CALL CHAPND (FPLT3Q, '.fmt')
            CALL CHAPND (FPLT3F, '.fmt')
         ENDIF
         WRITE (IOUT,1015) FPLT3G, FPLT3Q, FPLT3F
C
C     Solution Procedure
C
      ELSE IF (VAR .EQ. 'SOLVER') THEN
         READ (INPUT,*,END=990,ERR=995) SOLVER
         IF (SOLVER .EQ. 'RK') THEN
            ISOLVR    = IRKN
            NSTAGE    = INT (VALUE)
            IF (NSTAGE .LE. 1) THEN
C
C     Default coefficients from Rick Gaffney optimized for kappa = 1/3 scheme
C     give maximum CFL = 1.76
C
               NSTAGE    = 3
               RKALPH(1) = 0.27E0
               RKALPH(2) = 0.50E0
               RKALPH(3) = 1.0E0
            ELSE
C
C     Read input coefficients
C
               DO 96 ISTAGE = 1, NSTAGE
                  READ (INPUT,*,END=990,ERR=995) RKALPH(ISTAGE)
   96          CONTINUE
            ENDIF
            IF (NSTAGE .GT. NXSTAG) THEN
               WRITE (IOUT,1020) NSTAGE, NXSTAG
               INPERR = INPERR + 1
            ENDIF
            WRITE (IOUT,1021) NSTAGE, (RKALPH(ISTAGE),ISTAGE=1,NSTAGE)
         ELSE IF (SOLVER .EQ. 'AF3F') THEN
            ISOLVR = IAF3F
            DO 98 IBLK = 1, NXBLKS
               DIAG(1,IBLK) = .FALSE.
               DIAG(2,IBLK) = .FALSE.
               DIAG(3,IBLK) = .FALSE.
   98       CONTINUE
         ELSE IF (SOLVER .EQ. 'DIAGONAL AF3F') THEN
            ISOLVR = IAF3F
            DO 99 IBLK = 1, NXBLKS
               DIAG(1,IBLK) = .TRUE.
               DIAG(2,IBLK) = .TRUE.
               DIAG(3,IBLK) = .TRUE.
   99       CONTINUE
         ELSE IF (SOLVER .EQ. 'LGS') THEN
            ISOLVR = ILGS
         ELSE IF (SOLVER .EQ. 'MARCH') THEN
            ISOLVR = IMARCH
            READ (INPUT,*,END=990,ERR=995) IMSTRT, IMEND
            WRITE (IOUT,1022) IMSTRT, IMEND
         ELSE
            WRITE (IOUT,1023) SOLVER
            INPERR = INPERR + 1
         ENDIF
      ELSE IF (VAR .EQ. 'INITIALIZE TIME DEPENDENT') THEN
         INITTD = .TRUE.
      ELSE IF (VAR .EQ. 'IMPLICIT TIME DEPENDENT') THEN
         ITIMED = IUNSTD
         TDTHET = 1.0E0
         TDPHI  = 0.5E0
         TDPHIP = 0.E0
         NTIME  = 2
         NSUBIT = 2
         DO 53 IIMP = 1, INT(VALUE)
            READ (INPUT,*,END=990,ERR=995) VAR, VALUE
            WRITE (IOUT,1061) VAR, VALUE
            IF (VAR .EQ. 'TIME STEP') THEN
               TIMEDT = VALUE
            ELSE IF (VAR .EQ. 'SUB ITERATIONS') THEN
               NSUBIT = INT(VALUE)
            ELSE IF (VAR .EQ. 'T-TS') THEN
               ITMTYP = ITTS
            ELSE IF (VAR .EQ. 'TAU-TS') THEN
               ITMTYP = ITAUTS
               TDPHIP = 0.E0
               NTMTAU = 0
            ELSE IF (VAR .EQ. 'TAU-TS 2ND ORDER') THEN
               ITMTYP = ITAUTS
               TDPHIP = 0.5E0
               NTMTAU = 1
            ELSE
               WRITE (IOUT,1029) VAR
               INPERR = INPERR + 1
            ENDIF
   53    CONTINUE
      ELSE IF (VAR .EQ. 'CFL') THEN
         CFL = VALUE
      ELSE IF (VAR .EQ. 'DT') THEN
         DT  = VALUE
      ELSE IF (VAR .EQ. 'CFLFNL') THEN
         CFLFNL = VALUE
      ELSE IF (VAR .EQ. 'ITUPDT') THEN
         ITUPDT = INT(VALUE)
      ELSE IF (VAR .EQ. 'ITDFNL') THEN
         ITDFNL = MAX (INT(VALUE), 2)
      ELSE IF (VAR .EQ. 'ITUPJ') THEN
         ITUPJ = INT(VALUE)
      ELSE IF (VAR .EQ. 'NITS') THEN
         NITS(1) = INT(VALUE)
         IF (NITS(1) .GT. MXHIST) THEN
            WRITE (IOUT,1024) NITS(1), MXHIST
            NITS(1) = MXHIST
         ENDIF
      ELSE IF (VAR .EQ. 'ENTROPY FIX') THEN
         CNTRPY = VALUE
         IF (CNTRPY .LT. 0.E0 .OR. CNTRPY .GT. 1.E0) THEN
            WRITE (IOUT,1124)
            INPERR = INPERR + 1
         ENDIF
      ELSE IF (VAR .EQ. 'PRINT MAX RESIDUAL') THEN
         ITRSMX = INT(VALUE)
      ELSE IF (VAR .EQ. 'RECALCULATE YNORMAL') THEN
         ITEMP  = INT(VALUE)
         IF (ITEMP .EQ. 0) THEN
            YNCALC = .FALSE.
         ELSE
            YNCALC = .TRUE.
         ENDIF
      ELSE IF (VAR .EQ. 'PRINT FORCES') THEN
         ITEMP  = INT(VALUE)
         IF (ITEMP .EQ. 0) THEN
            IFRCPR = INO
         ELSE IF (ITEMP .EQ. 1) THEN
            IFRCPR = IYES
         ELSE
            WRITE (IOUT,1026) ITEMP
            INPERR = INPERR + 1
         ENDIF
      ELSE IF (VAR .EQ. 'REFERENCE AREA') THEN
         AREARF = VALUE
      ELSE IF (VAR .EQ. 'MULTIGRID LEVELS') THEN
         DO 54 ICFS = 1, NXCFS
            MGLVLS(ICFS) = MAX ((INT(VALUE) + 1 - ICFS), 1)
   54    CONTINUE
      ELSE IF (VAR .EQ. 'IMPLICIT SMOOTHING') THEN
         CSMTH  = VALUE
      ELSE IF (VAR .EQ. 'MESH SEQUENCE') THEN
         NCFS    = INT(VALUE) + 1
         IF (NCFS .GT. NXCFS) THEN
            WRITE (IOUT,1210) NCFS, NXCFS, NCFS-1
            INPERR = INPERR + 1
C     Skip input lines if error
            DO 55 ICFS = NCFS, 2, -1
               READ (INPUT,*,END=990,ERR=995)
   55       CONTINUE
         ELSE
            DO 60 ICFS = NCFS, 2, -1
               READ (INPUT,*,END=990,ERR=995) VALUE
               NITS  (ICFS) = INT(VALUE)
               WRITE (IOUT,1220) ICFS, NITS(ICFS)
               IF (NITS(ICFS) .GT. MXHIST) THEN
                  WRITE (IOUT,1024) NITS(ICFS), MXHIST
                  NITS(ICFS) = MXHIST
               ENDIF
   60       CONTINUE
         ENDIF
      ELSE IF (VAR .EQ. 'NITFO') THEN
         NITFO  = INT(VALUE)
      ELSE IF (VAR .EQ. 'FIRST ORDER TURBULENCE') THEN
         FOTURB = .TRUE.
      ELSE IF (VAR .EQ. 'ENFORCE POSITIVE PROD.') THEN
         POSPRD = .TRUE.
      ELSE IF (VAR .EQ. 'NITALG') THEN
         NITALG = INT(VALUE)
      ELSE IF (VAR .EQ. 'SOURCE') THEN
         ITEMP = INT(VALUE)
         IF (ITEMP .EQ. 0) THEN
            ISRCE = .FALSE.
         ELSE IF (ITEMP .EQ. 1) THEN
            ISRCE = .TRUE.
         ELSE
            WRITE (IOUT,1027) ITEMP
            INPERR = INPERR + 1
         ENDIF
      ELSE IF (VAR .EQ. 'IMPLICIT SOURCE') THEN
         READ (INPUT,*,END=990,ERR=995) VAR
         WRITE (IOUT,1065) VAR
         IF (VAR .EQ. 'NONE') THEN
            IMPSRC = INO
         ELSE IF (VAR .EQ. 'DIAGONAL') THEN
            IMPSRC = ISDIAG
         ELSE IF (VAR .EQ. 'BLOCK') THEN
            IMPSRC = ISBLOC
         ELSE
            INPERR = INPERR + 1
            WRITE (IOUT,1028) VAR
         ENDIF
C
C     Control of FIX positivity routines
C
      ELSE IF (VAR .EQ. 'FIXQ') THEN
         READ (INPUT,*,END=990,ERR=995) VAR
         WRITE (IOUT,1227) VAR
         IF (VAR .EQ. 'NONE') THEN
            IFIXQ  = INO
         ELSE IF (VAR .EQ. 'MINIMUM') THEN
            IFIXQ  = IFIXMN
         ELSE IF (VAR .EQ. 'AVERAGE') THEN
            IFIXQ  = IFIXAV
         ELSE
            WRITE (IOUT,1229) VAR
            INPERR = INPERR + 1
         ENDIF
C
C     Input transition specification segments
C
      ELSE IF (VAR .EQ. 'ENFORCE LAMINAR FLOW') THEN
         NTRSEG = INT (VALUE)
         IF (NTRSEG .GT. NXTRSG) THEN
            WRITE (IOUT,1545) NTRSEG, NXTRSG
            INPERR = INPERR + 1
            GO TO 900
         ENDIF
C
C      Input each segment specification; Check that ending index is >=
C      beginning index; Switch from cell node to cell center.
C
         DO ISEG = 1, NTRSEG
            READ (INPUT,*,END=990,ERR=995) IBLOCK, (ISTRT(L),L=1,3),
     1                                             (IEND (M),M=1,3)
            WRITE (IOUT,1580) IBLOCK, (ISTRT(L),L=1,3),
     1                                (IEND (M),M=1,3)
            DO L = 1, 3
               IF (IEND(L) .LT. ISTRT(L)) THEN
                  WRITE (IOUT,1590) L, IBLOCK, (ISTRT(LL),LL=1,3),
     1                                         (IEND (MM),MM=1,3)
                  INPERR = INPERR + 1
               ENDIF
            END DO
            ITRSEG(1,ISEG) = IBLOCK
            ITRSEG(2,ISEG) = ISTRT(1) + 1
            ITRSEG(3,ISEG) = ISTRT(2) + 1
            ITRSEG(4,ISEG) = ISTRT(3) + 1
            ITRSEG(5,ISEG) = IEND (1)
            ITRSEG(6,ISEG) = IEND (2)
            ITRSEG(7,ISEG) = IEND (3)
         END DO
C
C     Control of Marching Algorithm
C
      ELSE IF (VAR .EQ. 'VIGNERON') THEN
         VGNRN  = .TRUE.
      ELSE IF (VAR .EQ. 'TOLER') THEN
         TOLER = VALUE
      ELSE IF (VAR .EQ. 'SIGMA') THEN
         SIGMA = VALUE
C     ELSE IF (VAR .EQ. 'BLUNT BODY') THEN
C        BLUNT  = .TRUE.
C        NITBBC = INT(VALUE)
C
C     Viscous Terms
C
      ELSE IF (VAR .EQ. 'THIN LAYER') THEN
         THNLYR = .TRUE.
      ELSE IF (VAR .EQ. 'NAVIER STOKES') THEN
         THNLYR = .FALSE.
C
C     Turbulence Models
C
      ELSE IF (VAR .EQ. 'BALDWIN LOMAX') THEN
         ITURB  = ITBLMX
C
C     SIGK and SIGT2 are defined as the inverse of sigma(k) and sigma(epsilon)
C
      ELSE IF (VAR .EQ. 'K EPSILON') THEN
C
C     Set default k-epsilon model to be Zhang, So, Gatski, and Speziale
C
C     SAA : Set k-epsilon turbulence constants from Speziale, Abid
C          and Anderson AIAA 90-1481 as
C             sigma k       = 1.36
C             sigma k       = 1.00 - CORRECTED TO THIS
C                             (Abid had recommended 0.75 for supersonic flows)
C             sigma epsilon = 1.36
C             C2 epsilon    = 1.83
C        ICASE 90-9
C             alf1 kepsilon = 1.0 without pressure dilatation
C             alf1 kepsilon = 0.6    with pressure dilatation (Rick Gaffney)
C        ICASE 90-42
C             alf2 kepsilon = 0.4
C             alf3 kepsilon = 0.2
C        CPDFRO,CPDFT = 0 as these models are not good
C     ZSGS: Zhang, So, Gatski, Speziale in Near-Wall Turbulent Flows (1993)
C     RNG : Yakhot, Orszag, Thangam, Gatski, Speziale in Phys. Fluids A
C
C     Default values
C
         ITURB  = ITKE
         IEPSEQ = IEEZSG
         IDAMP  = IFMZSG
         IADRM  = IADRNO
         IASM   = IASMBU
         IEPSC  = IECNO
         IPDIL  = IPDNO
         ICMUST = 0
         IEPSLN = 7
         IFDL2K = 1
         NQ     = 7
         NP     = 5
         NF     = 7
         NRANK  = 7
         SIGK   = 1.0E0 / 1.00E0
         SIGT2  = 1.0E0 / 1.45E0
         SIGRHO = 1.0E0 / 0.95E0
         CMU    = 0.096E0
         CEPS1  = 1.50E0
         CEPS2  = 1.83E0
         A2KE   = 4.9E0
         ALF1   = 0.0E0
         ALF2   = 0.0E0
         ALF3   = 0.0E0
C--->    CPDFRO = SIGRHO
C--->    CPDFT  = 1.E0 / PRT
         CPDFRO = 0.E0
         CPDFT  = 0.E0
         CPVELK = 0.E0
C
         PRDLIM = 100.E0
C
C     Freestream levels
C     Set TKEINF to (turbulence intensity=u'/U)^2; Non-dimensionalize later
C         RMUTNF to mu_T / mu
C
         TKEINF = 1.0E-04
         RMUTNF = 1.0E0
C
         QMIN( 1)  =   1.E-8
         QMIN( 2)  = - 1.E0
         QMIN( 3)  = - 1.E0
         QMIN( 4)  = - 1.E0
         QMIN( 5)  =   1.E-8
         QMIN( 6)  =   1.E-8
         QMIN( 7)  =   1.E-8
C
C     Turn on dui/dxj calculation
C
         IFDELQ(2) = 1
         IFDELQ(3) = 1
         IFDELQ(4) = 1
C
C     Read in values of constants
C
         NCON   = INT (VALUE)
         DO 101 ICON = 1, NCON
            READ (INPUT,*,END=990,ERR=995) VAR, VALUE
            WRITE (IOUT,1061) VAR, VALUE
            IF (VAR .EQ. 'SAA') THEN
               IEPSEQ = IEESAA
               IDAMP  = IFMSAA
               IFDL2K = 0
               SIGK   = 1.0E0 / 1.00E0
               SIGT2  = 1.0E0 / 1.36E0
               SIGRHO = 1.0E0 / 0.95E0
               CMU    = 0.09E0
               CEPS1  = 1.44E0
               CEPS2  = 1.83E0
               A2KE   = 4.9E0
               ALF1   = 0.6E0
               ALF2   = 0.4E0
               ALF3   = 0.2E0
               CPDFRO = 0.E0
               CPDFT  = 0.E0
               CPVELK = 0.E0
            ELSE IF (VAR .EQ. 'ZSGS') THEN
               IEPSEQ = IEEZSG
               IDAMP  = IFMZSG
               IFDL2K = 1
               SIGK   = 1.0E0 / 1.00E0
               SIGT2  = 1.0E0 / 1.45E0
               SIGRHO = 1.0E0 / 0.95E0
               CMU    = 0.096E0
               CEPS1  = 1.50E0
               CEPS2  = 1.83E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               CPDFRO = 0.E0
               CPDFT  = 0.E0
               CPVELK = 0.E0
            ELSE IF (VAR .EQ. 'ZSSL') THEN
               IEPSEQ = IEEZSL
               IDAMP  = IFMZSG
               IFDL2K = 1
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.45E0
               SIGRHO = 1.0E0 / 0.50E0
               CMU    = 0.096E0
               CEPS1  = 1.50E0
               CEPS2  = 1.83E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               CPDFRO = 0.E0
               CPDFT  = 0.E0
               CPVELK = 0.E0
            ELSE IF (VAR .EQ. 'HIGH RE') THEN
               IEPSEQ = IEEHR
               IDAMP  = IFMHR
               IFDL2K = 0
               SIGK   = 1.0E0 / 1.00E0
               SIGT2  = 1.0E0 / 1.30E0
               SIGRHO = 1.0E0 / 0.95E0
               CMU    = 0.09E0
               CEPS1  = 1.44E0
               CEPS2  = 1.92E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               CPDFRO = 0.E0
               CPDFT  = 0.E0
               CPVELK = 0.E0
            ELSE IF (VAR .EQ. 'RNG') THEN
               IEPSEQ = IEERNG
               IDAMP  = IFMHR
               IFDL2K = 0
               SIGK   = 1.39E0
               SIGT2  = 1.39E0
               SIGRHO = 1.0E0 / 0.95E0
               CMU    = 0.085E0
               CEPS1  = 1.42E0
               CEPS2  = 1.68E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               CPDFRO = 0.E0
               CPDFT  = 0.E0
               CPVELK = 0.E0
            ELSE IF (VAR .EQ. 'ASM') THEN
               IASM   = IASMGS
               ICMUST = 5
               IEPSEQ = IEEABD
               IDAMP  = IFMHR
               IFDL2K = 0
               SIGK   = 1.0E0 / 1.00E0
               SIGRHO = 0.0E0
               CMU    = 0.081E0
               CEPS1  = 1.44E0
               CEPS2  = 1.83E0
               A2KE   = 5.5E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               CPDFRO = 0.E0
               CPDFT  = 0.E0
               CPVELK = 0.E0
               SIGT2  = 1.0E0 / ( 0.41e0**2/((CEPS2-CEPS1)*SQRT(CMU)) )
            ELSE IF (VAR .EQ. 'ADRM') THEN
               IADRM  = IADRGS
               IEPSEQ = IEEHR
               IDAMP  = IFMHR
               IFDL2K = 0
               SIGK   = 1.0E0 / 1.00E0
               SIGT2  = 1.0E0 / 1.87E0
               SIGRHO = 0.0E0
               CMU    = 0.094E0
               CEPS1  = 1.20E0
               CEPS2  = 1.83E0
               A2KE   = 0.0E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               CPDFRO = 0.E0
               CPDFT  = 0.E0
               CPVELK = 0.E0
            ELSE IF (VAR .EQ. 'SIGMAK') THEN
               SIGK   = 1.0E0 / VALUE
            ELSE IF (VAR .EQ. 'SIGMAE') THEN
               SIGT2  = 1.0E0 / VALUE
            ELSE IF (VAR .EQ. 'SIGMARHO') THEN
               SIGRHO = 1.0E0 / VALUE
               CPDFRO = SIGRHO
            ELSE IF (VAR .EQ. 'CMU') THEN
               CMU    = VALUE
            ELSE IF (VAR .EQ. 'CEPS1') THEN
               CEPS1  = VALUE
            ELSE IF (VAR .EQ. 'CEPS2') THEN
               CEPS2  = VALUE
            ELSE IF (VAR .EQ. 'A2KE') THEN
               A2KE   = VALUE
            ELSE IF (VAR .EQ. 'ALF1') THEN
               ALF1   = VALUE
            ELSE IF (VAR .EQ. 'ALF2') THEN
               ALF2   = VALUE
            ELSE IF (VAR .EQ. 'ALF3') THEN
               ALF3   = VALUE
            ELSE IF (VAR .EQ. 'PRT') THEN
               PRT    = VALUE
               CPDFT  = 1.E0 / PRT
            ELSE IF (VAR .EQ. 'CPDFRO') THEN
               CPDFRO = VALUE
            ELSE IF (VAR .EQ. 'CPDFT') THEN
               CPDFT  = VALUE
            ELSE IF (VAR .EQ. 'CPVELK') THEN
               CPVELK = VALUE
            ELSE IF (VAR .EQ. 'PRDLIM') THEN
               PRDLIM = VALUE
            ELSE IF (VAR .EQ. 'FULL EPSILON PROD') THEN
               PRDE   = 0.E0
               PRDEM1 = 1.E0 - PRDE
            ELSE IF (VAR .EQ. 'TKEINF') THEN
               TKEINF = VALUE
            ELSE IF (VAR .EQ. 'RMUTNF') THEN
               RMUTNF = VALUE
            ELSE IF (VAR .EQ. 'MINIMUM TKE') THEN
               QMIN(6) = VALUE
            ELSE IF (VAR .EQ. 'MINIMUM EPSILON') THEN
               QMIN(7) = VALUE
            ELSE IF (VAR .EQ. 'COMPRESSIBLE DISS') THEN
               READ (INPUT,*,END=990,ERR=995) VAR
               WRITE (IOUT,1065) VAR
               IF (VAR .EQ. 'NONE') THEN
                  IEPSC  = IECNO
               ELSE IF (VAR .EQ. 'SARKAR') THEN
                  IEPSC  = IECSAR
               ELSE IF (VAR .EQ. 'RISTORCELLI') THEN
                  IEPSC  = IECRIS
               ELSE
                  INPERR = INPERR + 1
                  WRITE (IOUT,1068) VAR
               ENDIF
            ELSE IF (VAR .EQ. 'PRESSURE DILATATION') THEN
               READ (INPUT,*,END=990,ERR=995) VAR
               WRITE (IOUT,1065) VAR
               IF (VAR .EQ. 'NONE') THEN
                  IPDIL  = IPDNO
               ELSE IF (VAR .EQ. 'SARKAR') THEN
                  IPDIL  = IPDSAR
               ELSE IF (VAR .EQ. 'RISTORCELLI') THEN
                  IPDIL  = IPDRIS
               ELSE
                  INPERR = INPERR + 1
                  WRITE (IOUT,1069) VAR
               ENDIF
            ELSE
               WRITE (IOUT,1029) VAR
               INPERR = INPERR + 1
            ENDIF
  101    CONTINUE
C
C     These variables are used only for output
C
         IF (IEPSEQ .EQ. IEESAA) THEN
            WRITE (IOUT,1070) 'Speziale-Abid-Anderson        '
         ELSE IF (IEPSEQ .EQ. IEEHR ) THEN
            WRITE (IOUT,1070) 'High Reynolds Number          '
         ELSE IF (IEPSEQ .EQ. IEEZSG) THEN
            WRITE (IOUT,1070) 'Zhang-So-Gatski-Speziale      '
         ELSE IF (IEPSEQ .EQ. IEEZSL) THEN
            WRITE (IOUT,1070) 'Zhang-So-Speziale-Lai         '
         ELSE IF (IEPSEQ .EQ. IEERNG) THEN
            WRITE (IOUT,1070) 'RNG (Yak-Ors-Than-Gat-Spez)   '
         ELSE IF (IEPSEQ .EQ. IEEABD) THEN
            WRITE (IOUT,1070) 'Abid ASM (Abid-Morr-Gat-Spez) '
         ENDIF
         SK     = 1.E0 / SIGK
         ST2    = 1.E0 / SIGT2
         WRITE (IOUT,1075) CEPS1, CEPS2, CMU, SK, ST2, SIGRHO, A2KE,
     1                     ALF1, ALF2, ALF3, CPDFRO, CPDFT, CPVELK,
     2                     TKEINF, RMUTNF
C
C     k-omega constants from Wilcox, AIAA Journal, Vol. 26, No. 11
C
      ELSE IF (VAR .EQ. 'K OMEGA') THEN
C
C     Default values
C
         ITURB  = ITKW
         IEPSEQ = 0
         IDAMP  = IFMHR
         IADRM  = IADRNO
         IASM   = IASMBU
         IEPSC  = IECNO
         IPDIL  = IPDNO
         ICMUST = 0
         IEPSLN = 7
         IFDL2K = 0
         NQ     = 7
         NP     = 5
         NF     = 7
         NRANK  = 7
         SIGK   = 0.5E0
         SIGT2  = 0.5E0
         SIGRHO = 0.0E0
         BSTRKW = 0.09E0
         BKW    = 3.0E0 / 40.0E0
         CMU    = 1.0E0
         GKW    = 5.0E0 / 9.0E0
         ROUGHK = 0.0E0
         CPDFRO = 0.0E0
         CPDFT  = 0.0E0
         CPVELK = 0.0E0
C
         PRDLIM = 100.E0
C
C     Freestream levels
C     Set TKEINF to (turbulence intensity=u'/U)^2; Non-dimensionalize later
C         RMUTNF to mu_T / mu
C
         TKEINF = 1.0E-06
         RMUTNF = 1.0E-01
C
         QMIN( 1)  =   1.E-8
         QMIN( 2)  = - 1.E0
         QMIN( 3)  = - 1.E0
         QMIN( 4)  = - 1.E0
         QMIN( 5)  =   1.E-8
         QMIN( 6)  =   1.E-12
         QMIN( 7)  =   1.E-8
C
C     Turn on dui/dxj calculation
C
         IFDELQ(2) = 1
         IFDELQ(3) = 1
         IFDELQ(4) = 1
C
C     Read in values of constants
C
         NCON   = INT (VALUE)
         DO 102 ICON = 1, NCON
            READ (INPUT,*,END=990,ERR=995) VAR, VALUE
            WRITE (IOUT,1061) VAR, VALUE
            IF (VAR .EQ. 'ASM') THEN
               IASM   = IASMGS
               ICMUST = 5
               BSTRKW = 1.0E0
               CMU    = 0.088E0
               SIGK   = 1.E0 / 1.4E0
               SIGT2  = 1.E0 / 2.0E0
               BKW    = 0.83E0
               GKW    = BKW - (0.41E0)**2 / (SQRT(CMU) / SIGT2)
            ELSE IF (VAR .EQ. 'SIGMAK') THEN
               SIGK   = VALUE
            ELSE IF (VAR .EQ. 'SIGMAW') THEN
               SIGT2  = VALUE
            ELSE IF (VAR .EQ. 'SIGMARHO') THEN
               SIGRHO = 1.0E0 / VALUE
               CPDFRO = SIGRHO
            ELSE IF (VAR .EQ. 'CMU') THEN
               CMU    = VALUE
            ELSE IF (VAR .EQ. 'BSTRKW') THEN
               BSTRKW = VALUE
            ELSE IF (VAR .EQ. 'BKW') THEN
               BKW    = VALUE
            ELSE IF (VAR .EQ. 'GKW') THEN
               GKW    = VALUE
            ELSE IF (VAR .EQ. 'ROUGHK') THEN
               ROUGHK = VALUE
            ELSE IF (VAR .EQ. 'PRT') THEN
               PRT    = VALUE
               CPDFT  = 1.E0 / PRT
            ELSE IF (VAR .EQ. 'CPDFRO') THEN
               CPDFRO = VALUE
            ELSE IF (VAR .EQ. 'CPDFT') THEN
               CPDFT  = VALUE
            ELSE IF (VAR .EQ. 'CPVELK') THEN
               CPVELK = VALUE
            ELSE IF (VAR .EQ. 'PRDLIM') THEN
               PRDLIM = VALUE
            ELSE IF (VAR .EQ. 'FULL OMEGA PROD') THEN
               PRDE   = 0.E0
               PRDEM1 = 1.E0 - PRDE
            ELSE IF (VAR .EQ. 'TKEINF') THEN
               TKEINF = VALUE
            ELSE IF (VAR .EQ. 'RMUTNF') THEN
               RMUTNF = VALUE
            ELSE IF (VAR .EQ. 'MINIMUM TKE') THEN
               QMIN(6) = VALUE
            ELSE IF (VAR .EQ. 'MINIMUM OMEGA') THEN
               QMIN(7) = VALUE
            ELSE
               WRITE (IOUT,1029) VAR
               INPERR = INPERR + 1
            ENDIF
  102    CONTINUE
C
C     These variables are used only for output
C
         WRITE (IOUT,1080) SIGK, SIGT2, BSTRKW, BKW, CMU, GKW, ROUGHK,
     1                     SIGRHO, CPDFRO, CPDFT, CPVELK,
     2                     TKEINF, RMUTNF
C
C     Reynolds stress model
C
      ELSE IF (VAR .EQ. 'REYNOLDS STRESS') THEN
C
C     Set Reynolds Stress turbulence constants
C     AIAA 90-1481 as
C          sigma k       =  1.36
C          sigma k       =  0.75 CORRECTED TO THIS
C          sigma epsilon =  1.36
C          C  epsilon    =  0.10
C          C1 epsilon    =  1.50
C          C2 epsilon    =  1.83
C          C3 epsilon    = -2.00
C          C4 epsilon    = -1.50
C     ICASE 90-9
C          alf1 kepsilon = 1.0 without pressure dilatation
C          alf1 kepsilon = 0.6    with pressure dilatation (Rick Gaffney)
C          alf1          = 0   for Lai-So
C     ICASE 90-42
C          alf2          = 0   for Lai-So
C          alf3          = 0   for Lai-So
C          alf2 kepsilon = 0.4
C          alf3 kepsilon = 0.2
C     CPDFRO,CPDFT = 0 as these models are not good
C     Pressure-Strain Correlation
C       Lai-So
C          cpi1 = 3.0
C          cpi2 = 0.6
C
C     Default values
C
         ITURB  = ITRS
         IADRM  = IADRNO
         IASM   = IASMBU
         IEPSC  = IECNO
         IPDIL  = IPDNO
         ICMUST = 0
         IEPSLN = 12
         IFDL2K = 1
         NQ     = 12
         NP     =  5
         NF     = 12
         NRANK  = 12
         SIGK   = 1.0E0 / 0.75E0
         SIGT2  = 1.0E0 / 1.36E0
         SIGRHO = 1.0E0 / 0.50E0
         CMU    = 0.09E0
         CEPSLN = 0.10E0
         CEPS1  = 1.50E0
         CEPS2  = 1.83E0
         CEPS3  = - 2.0E0
         CEPS4  = - 1.5E0
         CEPS5  = 0.0E0
         CSUBS  = 0.11E0
         A2KE   = 4.9E0
         ALF1   = 0.0E0
         ALF2   = 0.0E0
         ALF3   = 0.0E0
C--->    CPDFRO = SIGRHO
C--->    CPDFT  = 1.E0 / PRT
         CPDFRO = 0.E0
         CPDFT  = 0.E0
         CPVELK = 0.E0
C
         PRDLIM = 100.E0
C
C     Freestream levels
C     Set TKEINF to (turbulence intensity=u'/U)^2; Non-dimensionalize later
C         RMUTNF to mu_T / mu
C
         TKEINF = 1.0E-04 * SQRT(10.E0)
         RMUTNF = 1.0E0 * 10.E0
C
         QMIN( 1)  =   1.E-8
         QMIN( 2)  = - 1.E0
         QMIN( 3)  = - 1.E0
         QMIN( 4)  = - 1.E0
         QMIN( 5)  =   1.E-8
         QMIN( 6)  =   1.E-8
         QMIN( 7)  =   1.E-8
         QMIN( 8)  =   1.E-8
         QMIN( 9)  = - 1.E0
         QMIN(10)  = - 1.E0
         QMIN(11)  = - 1.E0
         QMIN(12)  =   1.E-8
C
C     Pressure-Strain Correlation
C
C     Lai-So form (Zhang's) Model
C
         IDMMDL = IDMSO
         IDTMDL = IDTHL
         IPSMDL = IPLS
         CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
C
C     Turn on dui/dxj calculation
C
         IFDELQ(2) = 1
         IFDELQ(3) = 1
         IFDELQ(4) = 1
C
C     Read in values of constants
C
         NCON   = INT (VALUE)
         DO 103 ICON = 1, NCON
            READ (INPUT,*,END=990,ERR=995) VAR, VALUE
            WRITE (IOUT,1061) VAR, VALUE
            IF (VAR .EQ. 'LRR') THEN
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.36E0
               CMU    = 0.09E0
               CEPSLN = 0.15E0
               CEPS1  = 1.44E0
               CEPS2  = 1.90E0
               CEPS3  = 0.0E0
               CEPS4  = 0.0E0
               CEPS5  = 0.0E0
               CSUBS  = 0.11E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               IDMMDL = IDMSO
               IDTMDL = IDTHL
               IPSMDL = IPLRR1
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
            ELSE IF (VAR .EQ. 'SSG') THEN
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.36E0
               CMU    = 0.09E0
               CEPSLN = 0.1842E0
               CEPS1  = 1.44E0
               CEPS2  = 1.83E0
               CEPS3  = 0.0E0
               CEPS4  = 0.0E0
               CEPS5  = 0.0E0
               CSUBS  = 0.11E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               IDMMDL = IDMSO
               IDTMDL = IDTHL
               IPSMDL = IPSSG
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
            ELSE IF (VAR .EQ. 'SSG-ADRM') THEN
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.36E0
               CMU    = 0.094E0
               CEPSLN = 0.217E0
               CEPS1  = 1.00E0
               CEPS2  = 1.83E0
               CEPS3  = 0.0E0
               CEPS4  = 0.0E0
               CEPS5  = 0.0E0
               CSUBS  = 0.11E0
               A2KE   = 0.0E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               IDMMDL = IDMSO
               IDTMDL = IDTHL
               IPSMDL = IPSSG
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
               IEPSIJ = IEADGS
            ELSE IF (VAR .EQ. 'FLT') THEN
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.36E0
               CMU    = 0.09E0
               CEPSLN = 0.15E0
               CEPS1  = 1.45E0
               CEPS2  = 1.90E0
               CEPS3  = 0.0E0
               CEPS4  = 0.0E0
               CEPS5  = 0.0E0
               CSUBS  = 0.11E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               IDMMDL = IDMSO
               IDTMDL = IDTHL
               IPSMDL = IPFLT
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
            ELSE IF (VAR .EQ. 'ZSGS') THEN
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.36E0
               CMU    = 0.09E0
               CEPSLN = 0.10E0
               CEPS1  = 1.50E0
               CEPS2  = 1.83E0
               CEPS3  = - 2.0E0
               CEPS4  = - 1.5E0
               CEPS5  = 0.0E0
               CSUBS  = 0.11E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               IDMMDL = IDMSO
               IDTMDL = IDTHL
               IPSMDL = IPLS
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
            ELSE IF (VAR .EQ. 'SO 95') THEN
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.36E0
               CMU    = 0.09E0
               CEPSLN = 0.12E0
               CEPS1  = 1.50E0
               CEPS2  = 1.90E0
               CEPS3  = 7.E0/(3.E0*SQRT(15.E0)) * 0.0066E0
               CEPS4  = 2.95E0
               CEPS5  = 0.0E0
               CSUBS  = 0.11E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               IDMMDL = IDMSO
               IDTMDL = IDTHL
               IPSMDL = IPSO95
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
            ELSE IF (VAR .EQ. 'GIBSON LAUNDER') THEN
               SIGK   = 1.0E0 / 0.75E0
               SIGT2  = 1.0E0 / 1.36E0
               CMU    = 0.09E0
               CEPSLN = 0.16E0
               CEPS1  = 1.44E0
               CEPS2  = 1.92E0
               CEPS3  = 0.0E0
               CEPS4  = 0.0E0
               CEPS5  = 0.0E0
               CSUBS  = 0.11E0
               A2KE   = 4.9E0
               ALF1   = 0.0E0
               ALF2   = 0.0E0
               ALF3   = 0.0E0
               IDMMDL = IDMSO
               IDTMDL = IDTHL
               IPSMDL = IPGL
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
            ELSE IF (VAR .EQ. 'SIGMAK') THEN
               SIGK   = 1.0E0 / VALUE
            ELSE IF (VAR .EQ. 'SIGMAE') THEN
               SIGT2  = 1.0E0 / VALUE
            ELSE IF (VAR .EQ. 'SIGMARHO') THEN
               SIGRHO = 1.0E0 / VALUE
               CPDFRO = SIGRHO
            ELSE IF (VAR .EQ. 'CMU') THEN
               CMU    = VALUE
            ELSE IF (VAR .EQ. 'CEPSLN') THEN
               CEPSLN = VALUE
            ELSE IF (VAR .EQ. 'CEPS1') THEN
               CEPS1  = VALUE
            ELSE IF (VAR .EQ. 'CEPS2') THEN
               CEPS2  = VALUE
            ELSE IF (VAR .EQ. 'CEPS3') THEN
               CEPS3  = VALUE
            ELSE IF (VAR .EQ. 'CEPS4') THEN
               CEPS4  = VALUE
            ELSE IF (VAR .EQ. 'CEPS5') THEN
               CEPS5  = VALUE
            ELSE IF (VAR .EQ. 'CSUBS') THEN
               CSUBS  = VALUE
            ELSE IF (VAR .EQ. 'A2KE') THEN
               A2KE   = VALUE
            ELSE IF (VAR .EQ. 'ALF1') THEN
               ALF1   = VALUE
            ELSE IF (VAR .EQ. 'ALF2') THEN
               ALF2   = VALUE
            ELSE IF (VAR .EQ. 'ALF3') THEN
               ALF3   = VALUE
            ELSE IF (VAR .EQ. 'PRT') THEN
               PRT    = VALUE
               CPDFT  = 1.E0 / PRT
            ELSE IF (VAR .EQ. 'CPDFRO') THEN
               CPDFRO = VALUE
            ELSE IF (VAR .EQ. 'CPDFT') THEN
               CPDFT  = VALUE
            ELSE IF (VAR .EQ. 'CPVELK') THEN
               CPVELK = VALUE
            ELSE IF (VAR .EQ. 'PRDLIM') THEN
               PRDLIM = VALUE
            ELSE IF (VAR .EQ. 'FULL EPSILON PROD') THEN
               PRDE   = 0.E0
               PRDEM1 = 1.E0 - PRDE
            ELSE IF (VAR .EQ. 'PSC1') THEN
               PSC1   = VALUE
            ELSE IF (VAR .EQ. 'PSC2') THEN
               PSC2   = VALUE
            ELSE IF (VAR .EQ. 'PSCW') THEN
               PSCW   = VALUE
            ELSE IF (VAR .EQ. 'PSALFA') THEN
               PSALFA = VALUE
            ELSE IF (VAR .EQ. 'PSBETA') THEN
               PSBETA = VALUE
            ELSE IF (VAR .EQ. 'PSGAMA') THEN
               PSGAMA = VALUE
            ELSE IF (VAR .EQ. 'TKEINF') THEN
               TKEINF = VALUE
            ELSE IF (VAR .EQ. 'RMUTNF') THEN
               RMUTNF = VALUE
            ELSE IF (VAR .EQ. 'MINIMUM TKE') THEN
               QMIN( 6) = 2.E0 / 3.E0 * VALUE
               QMIN( 7) = 2.E0 / 3.E0 * VALUE
               QMIN( 8) = 2.E0 / 3.E0 * VALUE
            ELSE IF (VAR .EQ. 'MINIMUM EPSILON') THEN
               QMIN(12) = VALUE
            ELSE IF (VAR .EQ. 'TURBULENT DIFFUSION') THEN
               READ (INPUT,*,END=990,ERR=995) VAR
               WRITE (IOUT,1065) VAR
               IF (VAR .EQ. 'DH') THEN
                  IDTMDL = IDTDH
               ELSE IF (VAR .EQ. 'HL') THEN
                  IDTMDL = IDTHL
               ELSE IF (VAR .EQ. 'MH') THEN
                  IDTMDL = IDTMH
               ELSE
                  INPERR = INPERR + 1
                  WRITE (IOUT,1066) VAR
               ENDIF
            ELSE IF (VAR .EQ. 'PRESSURE STRAIN') THEN
               READ (INPUT,*,END=990,ERR=995) VAR
               WRITE (IOUT,1065) VAR
               IF (VAR .EQ. 'LRR1') THEN
                  IPSMDL = IPLRR1
               ELSE IF (VAR .EQ. 'LRR2') THEN
                  IPSMDL = IPLRR2
               ELSE IF (VAR .EQ. 'SSG') THEN
                  IPSMDL = IPSSG
               ELSE IF (VAR .EQ. 'FLT') THEN
                  IPSMDL = IPFLT
               ELSE IF (VAR .EQ. 'LAI SO') THEN
                  IPSMDL = IPLS
               ELSE IF (VAR .EQ. 'GIBSON LAUNDER') THEN
                  IPSMDL = IPGL
               ELSE
                  INPERR = INPERR + 1
                  WRITE (IOUT,1067) VAR
               ENDIF
               CALL SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
            ELSE IF (VAR .EQ. 'COMPRESSIBLE DISS') THEN
               READ (INPUT,*,END=990,ERR=995) VAR
               WRITE (IOUT,1065) VAR
               IF (VAR .EQ. 'NONE') THEN
                  IEPSC  = IECNO
               ELSE IF (VAR .EQ. 'SARKAR') THEN
                  IEPSC  = IECSAR
               ELSE IF (VAR .EQ. 'RISTORCELLI') THEN
                  IEPSC  = IECRIS
               ELSE
                  INPERR = INPERR + 1
                  WRITE (IOUT,1068) VAR
               ENDIF
            ELSE IF (VAR .EQ. 'PRESSURE DILATATION') THEN
               READ (INPUT,*,END=990,ERR=995) VAR
               WRITE (IOUT,1227) VAR
               IF (VAR .EQ. 'NONE') THEN
                  IPDIL  = IPDNO
               ELSE IF (VAR .EQ. 'SARKAR') THEN
                  IPDIL  = IPDSAR
               ELSE IF (VAR .EQ. 'RISTORCELLI') THEN
                  IPDIL  = IPDRIS
               ELSE
                  INPERR = INPERR + 1
                  WRITE (IOUT,1069) VAR
               ENDIF
            ELSE
               WRITE (IOUT,1029) VAR
               INPERR = INPERR + 1
            ENDIF
  103    CONTINUE
C
C     These variables are used only for output
C
         SK     = 1.E0 / SIGK
         ST2    = 1.E0 / SIGT2
         WRITE (IOUT,1090) CEPSLN, CEPS1, CEPS2, CEPS3, CEPS4, CEPS5,
     1                     CSUBS, CMU, SK, ST2, SIGRHO, A2KE,
     2                     ALF1, ALF2, ALF3, CPDFRO, CPDFT, CPVELK,
     3                     TKEINF, RMUTNF
         IF (IPSMDL .EQ. IPLRR1) THEN
            WRITE (IOUT,1095) 'LRR (Launder-Reece-Rodi)      '
         ELSE IF (IPSMDL .EQ. IPLRR2) THEN
            WRITE (IOUT,1095) 'LRR2 (Launder-Reece-Rodi 2)   '
         ELSE IF (IPSMDL .EQ. IPSSG ) THEN
            WRITE (IOUT,1095) 'SSG (Speziale-Sarkar-Gatski)  '
         ELSE IF (IPSMDL .EQ. IPFLT ) THEN
            WRITE (IOUT,1095) 'FLT (Fu-Launder-Tselepidakis) '
         ELSE IF (IPSMDL .EQ. IPLS  ) THEN
            WRITE (IOUT,1095) 'LS (LAI-SO)                   '
         ELSE IF (IPSMDL .EQ. IPGL  ) THEN
            WRITE (IOUT,1095) 'GL (Gibson-Launder)           '
         ENDIF
         WRITE (IOUT,1097) PSC1, PSC2, PSCW, PSALFA, PSBETA, PSGAMA
C
C     Large-Eddy Simulation (LES)
C
      ELSE IF (VAR .EQ. 'LES') THEN
C
C     Set default LES model to Smagorinsky high Reynolds number
C
         ITURB = ITLES
         ISGS  = ISGSMG
         IDAMP = IFMHR
         NQ    = 5
         NP    = 5
         NF    = 5
         NRANK = 5
         CMU   = 0.2E0
C
C     Turn on dui/dxj calculation
C
         IFDELQ(2) = 1
         IFDELQ(3) = 1
         IFDELQ(4) = 1
C
C     Read additional input lines
C
         NCON   = INT (VALUE)
         DO 203 ICON = 1, NCON
            READ (INPUT,*,END=990,ERR=995) VAR, VALUE
            WRITE (IOUT,1061) VAR, VALUE
            IF (VAR .EQ. 'SMAGORINSKY') THEN
               ISGS  = ISGSMG
               IDAMP = IFMHR
               CMU   = 0.2E0
            ELSE IF (VAR .EQ. 'STRUCTURE FUNCTION MODEL') THEN
               ISGS  = ISGSFM
               IDAMP = IFMHR
               CKSFM = 1.4E0
               CMU   = 0.105E0 * CKSFM**(-3.E0/2.E0)
            ELSE
               WRITE (IOUT,1029) VAR
               INPERR = INPERR + 1
            ENDIF
  203    CONTINUE
C
         IF (ISGS .EQ. ISGSMG) THEN
            WRITE (IOUT,1098) 'Smagorinsky                   '
         ELSE IF (ISGS .EQ. ISGSFM) THEN
            WRITE (IOUT,1098) 'Structure Function Model      '
         ENDIF
         WRITE (IOUT,1099) CMU
C
C     Convert turbulence model on restart
C
      ELSE IF (VAR .EQ. 'CONVERT') THEN
         CONTRB = .TRUE.
         READ (INPUT,*,END=990,ERR=995) VAR, VALUE
         WRITE (IOUT,1227) VAR
         IF (VAR .EQ. 'LAMINAR') THEN
            ITURBX = ITLMNR
            WRITE (IOUT,1110) VAR
         ELSE IF (VAR .EQ. 'BALDWIN LOMAX') THEN
            ITURBX = ITBLMX
            WRITE (IOUT,1110) VAR
         ELSE IF (VAR .EQ. 'K EPSILON') THEN
            WRITE (IOUT,1110) VAR
            ITURBX = ITKE
            IDAMPX = IFMZSG
            IASMX  = IASMBU
            NCON   = INT(VALUE)
            DO 104 ICON = 1, NCON
               READ (INPUT,*,END=990,ERR=995) VAR
               WRITE (IOUT,1065) VAR
               IF (VAR .EQ. 'SAA') THEN
                  IDAMPX = IFMSAA
               ELSE IF (VAR .EQ. 'ZSGS') THEN
                  IDAMPX = IFMZSG
               ELSE IF (VAR .EQ. 'ZSSL') THEN
                  IDAMPX = IFMZSG
               ELSE IF (VAR .EQ. 'HIGH RE') THEN
                  IDAMPX = IFMHR
               ELSE IF (VAR .EQ. 'RNG') THEN
                  IDAMPX = IFMHR
               ELSE IF (VAR .EQ. 'ASM') THEN
                  ICMUST = 5
                  IASMX  = IASMGS
               ELSE
                  WRITE (IOUT,1105) VAR
                  INPERR = INPERR + 1
               END IF
  104       CONTINUE
         ELSE IF (VAR .EQ. 'K OMEGA') THEN
            WRITE (IOUT,1110) VAR
            ITURBX = ITKW
            IDAMPX = IFMHR
            IASMX  = IASMBU
            NCON   = INT(VALUE)
            DO 105 ICON = 1, NCON
               READ (INPUT,*,END=990,ERR=995) VAR
               IF (VAR .EQ. 'ASM') THEN
                  ICMUST = 5
                  IASMX  = IASMGS
               ELSE
                  WRITE (IOUT,1105) VAR
                  INPERR = INPERR + 1
               END IF
  105       CONTINUE
         ELSE IF (VAR .EQ. 'REYNOLDS STRESS') THEN
            WRITE (IOUT,1110) VAR
            ITURBX = ITRS
            IDAMPX = IFMZSG
            IASMX  = IASMBU
         ELSE
            WRITE (IOUT,1100) VAR
            INPERR = INPERR + 1
         ENDIF
C
C        Set up IMODLX to control conversion model
C        Only require ITURBX, IDAMPX, and IASMX set all else to error code
C
         DO 106 IM = 1, NMDL
            IMODLX(IM) = - 1
  106    CONTINUE
         IMODLX( 1) = ITURBX
         IMODLX( 3) = IDAMPX
         IMODLX(10) = IASMX
C
C     End of Turbulence Models
C
C     Metric/English units
C
      ELSE IF (VAR .EQ. 'SIUNIT') THEN
         SIUNIT = .TRUE.
      ELSE IF (VAR .EQ. 'ENGLISH') THEN
         SIUNIT = .FALSE.
C
C     Two/Three-Dimensional
C
      ELSE IF (VAR .EQ. 'TWOD') THEN
         THREED = .FALSE.
         AXISYM = .FALSE.
      ELSE IF (VAR .EQ. 'THREED') THEN
         THREED = .TRUE.
         AXISYM = .FALSE.
      ELSE IF (VAR .EQ. 'AXISYMMETRIC') THEN
         THREED = .FALSE.
         AXISYM = .TRUE.
      ELSE IF (VAR .EQ. 'GRID') THEN
         READ (INPUT,*,END=990,ERR=995) GRDFIL(1)
         WRITE (IOUT,1040) GRDFIL(1)
         IGRDTP = IGTP3D
      ELSE IF (VAR .EQ. 'GRID BINARY') THEN
         GRDBIN = .TRUE.
      ELSE IF (VAR .EQ. 'GRID FORMATTED') THEN
         GRDBIN = .FALSE.
C
C     Flow Quantities
C
      ELSE IF (VAR .EQ. 'GAMMA') THEN
         GAMMA  = VALUE
      ELSE IF (VAR .EQ. 'MACH') THEN
         FSMACH = VALUE
      ELSE IF (VAR .EQ. 'ALPHA') THEN
         ALPHA = VALUE
      ELSE IF (VAR .EQ. 'BETA') THEN
         BETA = VALUE
      ELSE IF (VAR .EQ. 'RE') THEN
         RE = VALUE
      ELSE IF (VAR .EQ. 'PR') THEN
         PR = VALUE
      ELSE IF (VAR .EQ. 'PRT') THEN
         PRT = VALUE
      ELSE IF (VAR .EQ. 'TINF') THEN
         TINF = VALUE
      ELSE IF (VAR .EQ. 'TWALL') THEN
         TWSPE = .TRUE.
         TWALL = VALUE
C
C     MUSCL Control
C
      ELSE IF (VAR .EQ. 'KAPPA') THEN
         DO 108 IBLK = 1, NXBLKS
            RKAP(1,IBLK) = VALUE
            RKAP(2,IBLK) = VALUE
            RKAP(3,IBLK) = VALUE
  108    CONTINUE
      ELSE IF (VAR .EQ. 'LIMIT') THEN
         LIM  = INT(VALUE)
         LIMX = INT(VALUE)
         IF (LIMX .EQ. ILNONE) THEN
            LIM = ILNONE
         ELSE IF (LIMX .EQ. ILSMTH) THEN
            LIM = ILSMTH
         ELSE IF (LIMX .EQ. ILMNMD) THEN
            LIM = ILMNMD
         ELSE IF (LIMX .EQ. ILVNKT) THEN
            LIM = ILVNKT
         ELSE
            WRITE (IOUT,1058) VAR, VALUE
            INPERR = INPERR + 1
         ENDIF
         DO 110 IBLK = 1, NXBLKS
            LIMIT(1,IBLK) = LIM
            LIMIT(2,IBLK) = LIM
            LIMIT(3,IBLK) = LIM
  110    CONTINUE
C
C     Fourth order
C
      ELSE IF (VAR .EQ. 'CENTRAL DIFFERENCE') THEN
  114    READ (INPUT,*,END=990,ERR=995) VAR, VALUE
         WRITE (IOUT,2010) VAR, VALUE
         IF (VAR .EQ. 'FOURTH ORDER') THEN
            FOURTH = .TRUE.
         ELSE IF (VAR .EQ. 'ARTIFICIAL DISSIPATION') THEN
            ADKP46 = VALUE
         ELSE IF (VAR .EQ. 'END CENTRAL DIFFERENCE') THEN
            GO TO 118
         ELSE
            WRITE (IOUT,1059) VAR, VALUE
            INPERR = INPERR + 1
         ENDIF
C
C     Loop for next control of central difference
C
         GO TO 114
C
C     Finished with central difference control
C
  118    CONTINUE
C
C     Subsonic Inflow/Outflow BC conditions
C
      ELSE IF (VAR .EQ. 'BACK PRESSURE') THEN
         PBAKBC = VALUE
      ELSE IF (VAR .EQ. 'INFLOW PTOTAL') THEN
         PTOTBC = VALUE
      ELSE IF (VAR .EQ. 'INFLOW TTOTAL') THEN
         TTOTBC = VALUE
C
C     Jet Conditions
C
      ELSE IF (VAR .EQ. 'JET CONDITIONS') THEN
         JET  = INT(VALUE)
C
C     Read in Jet conditions
C
  120    READ (INPUT,*,END=990,ERR=995) VAR, VALUE
         WRITE (IOUT,2010) VAR, VALUE
         IF (VAR .EQ. 'U') THEN
            UJET = VALUE
         ELSE IF (VAR .EQ. 'V') THEN
            VJET = VALUE
         ELSE IF (VAR .EQ. 'W') THEN
            WJET = VALUE
         ELSE IF (VAR .EQ. 'P') THEN
            PJET = VALUE
         ELSE IF (VAR .EQ. 'T') THEN
            TJET = VALUE
         ELSE IF (VAR .EQ. 'K') THEN
            TKEJET = VALUE
         ELSE IF (VAR .EQ. 'EPSILON') THEN
            EPSJET = VALUE
         ELSE IF (VAR .EQ. 'OMEGA') THEN
            OMEJET = VALUE
         ELSE IF (VAR .EQ. 'TAUXX') THEN
            TAUJET(1) = VALUE
         ELSE IF (VAR .EQ. 'TAUYY') THEN
            TAUJET(2) = VALUE
         ELSE IF (VAR .EQ. 'TAUZZ') THEN
            TAUJET(3) = VALUE
         ELSE IF (VAR .EQ. 'TAUXY') THEN
            TAUJET(4) = VALUE
         ELSE IF (VAR .EQ. 'TAUXZ') THEN
            TAUJET(5) = VALUE
         ELSE IF (VAR .EQ. 'TAUYZ') THEN
            TAUJET(6) = VALUE
         ELSE IF (VAR .EQ. 'END JET') THEN
            GO TO 129
         ELSE
            WRITE (IOUT,1060) VAR, VALUE
            INPERR = INPERR + 1
         ENDIF
C
C     Loop for next Jet condition
C
         GO TO 120
C
C     Finished inputing Jet conditions
C
  129    CONTINUE
C
C     Printout control
C
      ELSE IF (VAR .EQ. 'PRINT') THEN
         NPRT = INT(VALUE)
         DO 300 IPRT = 1, NPRT
            READ (INPUT,*,END=990,ERR=995) IBLOCK, (IDUMPR(LL),LL=1,10)
            WRITE (IOUT,2005)              IBLOCK, (IDUMPR(LL),LL=1,10)
            NPRINT(IBLOCK) = NPRINT(IBLOCK) + 1
            IF (NPRINT(IBLOCK) .GT. NXPRT) THEN
               WRITE (IOUT,1540) NPRINT(IBLOCK), IBLOCK, NXPRT
               GO TO 900
            ENDIF
            DO 299 LL = 1, 10
               IPRINT(LL,NPRINT(IBLOCK),IBLOCK) = IDUMPR(LL)
 299        CONTINUE
 300     CONTINUE
      ELSE IF (VAR .EQ. 'MONITOR') THEN
         NPRT = INT(VALUE)
         READ (INPUT,*,END=990,ERR=995) NITMON
         DO 310 IPRT = 1, NPRT
            READ (INPUT,*,END=990,ERR=995) IBLOCK,
     1                (IPRMON(LL,NPRMON(IBLOCK)+1,IBLOCK),LL=1,10)
            WRITE (IOUT,2005) IBLOCK,
     1                (IPRMON(LL,NPRMON(IBLOCK)+1,IBLOCK),LL=1,10)
            NPRMON(IBLOCK) = NPRMON(IBLOCK) + 1
 310     CONTINUE
C
C     CUT boundary condition data
C
      ELSE IF (VAR .EQ. 'CUT') THEN
         NCUTS = INT(VALUE)
         IF (NCUTS*2 .GT. NXCUTS) THEN
            WRITE (IOUT,1530) NCUTS*2, NXCUTS
            GO TO 900
         ENDIF
         DO 329 ICUT = 1, NCUTS
            IC1 = 2 * ICUT - 1
            IC2 = 2 * ICUT
C           READ (INPUT,*,END=990,ERR=995) VAR, IBLK, (ISTRT(L),L=1,3),
C    1                                        (IEND(M),M=1,3)
            read (input,*,END=990,ERR=995) var, iblk,istrt(1),istrt(2),
     1           istrt(3), iend(1), iend(2), iend(3)
            WRITE (IOUT,1600) VAR, IBLK, (ISTRT(L),L=1,3),
     1                                   (IEND(M),M=1,3)
C
C     Determine CUT face. This is defined by constant index on that face.
C     Note that this will fail for the pathological case where have two
C     or more indices equal for a cut. In case an error occurs, set the
C     face direction to 1 to finish checking the CUT data.
C
            IDIR = 0
            DO 320 L = 1, 3
               IF (ISTRT(L) .EQ. IEND(L)) IDIR = L
  320       CONTINUE
            IF (IDIR .LT. 1 .OR. IDIR .GT. 3) THEN
               WRITE (IOUT,1630)
               INPERR = INPERR + 1
               IDIR   = 1
            ENDIF
C
C     Modify start or end appropriately to account for cut input as grid
C     points but cut to be cell-centers.  Do this only for the indices that
C     the cut loops over, not the idir direction.
C
            DO 321 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (IEND(L) .GT. ISTRT(L)) THEN
                     ISTRT(L) = ISTRT(L) + 1
                  ELSE
                     IEND(L)  = IEND(L)  + 1
                  ENDIF
               ENDIF
  321       CONTINUE
C
            CUTNAM(IC1) = VAR
            CUTNAM(IC2) = VAR
C
            ICUTS( 1,IC1,1) = IBLK
            ICUTS( 2,IC1,1) = IDIR
            ICUTS( 3,IC1,1) = ISTRT(IDIR)
            ICUTS( 4,IC1,1) = ISTRT(1)
            ICUTS( 5,IC1,1) = IEND (1)
            ICUTS( 6,IC1,1) = ISTRT(2)
            ICUTS( 7,IC1,1) = IEND (2)
            ICUTS( 8,IC1,1) = ISTRT(3)
            ICUTS( 9,IC1,1) = IEND (3)
C
            ICUTS(10,IC2,1) = IBLK
            ICUTS(11,IC2,1) = IDIR
            ICUTS(12,IC2,1) = ISTRT(IDIR)
            ICUTS(13,IC2,1) = ISTRT(1)
            ICUTS(14,IC2,1) = IEND (1)
            ICUTS(15,IC2,1) = ISTRT(2)
            ICUTS(16,IC2,1) = IEND (2)
            ICUTS(17,IC2,1) = ISTRT(3)
            ICUTS(18,IC2,1) = IEND (3)
C
            READ (INPUT,*,END=990,ERR=995) VAR1, IBLK, (ISTRT(L),L=1,3),
     1                             (IEND(M),M=1,3), (IORD(N),N=1,3)
C           read (input,*,END=990,ERR=995) var1, iblk,istrt(1),istrt(2),
C    1           istrt(3), iend(1), iend(2), iend(3)
            WRITE (IOUT,1605) VAR1, IBLK, (ISTRT(L),L=1,3),
     1                             (IEND(M),M=1,3), (IORD(N),N=1,3)
            IF (VAR .NE. VAR1) THEN
               INPERR = INPERR + 1
               WRITE (IOUT,1610)
            ENDIF
C
            DO 324 L = 1, 3
               IF (IORD(L) .LT. 1 .OR. IORD(L) .GT. 3) THEN
                  INPERR = INPERR + 1
                  WRITE (IOUT,1620) L, IORD(L)
               ENDIF
  324       CONTINUE
C
C     Determine CUT face. This is defined by constant index on that face.
C     Note that this will fail for the pathological case where have two
C     or more indices equal for a cut. In case an error occurs, set the
C     face direction to 1 to finish checking the CUT data.
C
            IDIR = 0
            DO 330 L = 1, 3
               IF (ISTRT(L) .EQ. IEND(L)) IDIR = L
  330       CONTINUE
            IF (IDIR .LT. 1 .OR. IDIR .GT. 3) THEN
               WRITE (IOUT,1630)
               INPERR = INPERR + 1
               IDIR   = 1
            ENDIF
C
C     Modify start or end appropriately to account for cut input as grid
C     points but cut to be cell-centers.  Do this only for the indices that
C     the cut loops over, not the idir direction.
C
            DO 331 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (IEND(L) .GT. ISTRT(L)) THEN
                     ISTRT(L) = ISTRT(L) + 1
                  ELSE
                     IEND(L)  = IEND(L)  + 1
                  ENDIF
               ENDIF
  331       CONTINUE
C
            ICUTS(10,IC1,1) = IBLK
            ICUTS(11,IC1,1) = IDIR
            ICUTS(12,IC1,1) = ISTRT(IDIR)
            ICUTS(13,IC1,1) = ISTRT(1)
            ICUTS(14,IC1,1) = IEND (1)
            ICUTS(15,IC1,1) = ISTRT(2)
            ICUTS(16,IC1,1) = IEND (2)
            ICUTS(17,IC1,1) = ISTRT(3)
            ICUTS(18,IC1,1) = IEND (3)
            ICUTS(19,IC1,1) = IORD (1)
            ICUTS(20,IC1,1) = IORD (2)
            ICUTS(21,IC1,1) = IORD (3)
C
            ICUTS( 1,IC2,1) = IBLK
            ICUTS( 2,IC2,1) = IDIR
            ICUTS( 3,IC2,1) = ISTRT(IDIR)
            ICUTS( 4,IC2,1) = ISTRT(1)
            ICUTS( 5,IC2,1) = IEND (1)
            ICUTS( 6,IC2,1) = ISTRT(2)
            ICUTS( 7,IC2,1) = IEND (2)
            ICUTS( 8,IC2,1) = ISTRT(3)
            ICUTS( 9,IC2,1) = IEND (3)
            ICUTS(19,IC2,1) = ICY(IORD(1),1)
            ICUTS(20,IC2,1) = ICY(IORD(2),1)
            ICUTS(21,IC2,1) = ICY(IORD(3),1)
  329    CONTINUE
         NCUTS = NCUTS * 2
C
C     Data for each grid block/zone
C
      ELSE IF (VAR .EQ. 'BLOCK') THEN
         IBLOCK = INT(VALUE)
         NBLKS  = NBLKS + 1
         IF (NBLKS .GT. NXBLKS) THEN
            WRITE (IOUT,1525) NBLKS, NXBLKS
            GO TO 900
         ENDIF
  500    CONTINUE
         READ (INPUT,*,END=990,ERR=995) VAR, VALUE
         WRITE (IOUT,2010) VAR, VALUE
         IF (VAR .EQ. 'DIMENSIONS') THEN
            READ (INPUT,*,END=990,ERR=995) IDIM(IBLOCK,1),
     1                             JDIM(IBLOCK,1), KDIM(IBLOCK,1)
            WRITE (IOUT,1035) IDIM(IBLOCK,1),
     1                             JDIM(IBLOCK,1), KDIM(IBLOCK,1)
         ELSE IF (VAR .EQ. 'KAPPA') THEN
            READ (INPUT,*,END=990,ERR=995) (RKAP(LL,IBLOCK),LL=1,3)
            WRITE (IOUT,2000) ' Kappa ', (RKAP(LL,IBLOCK),LL=1,3)
C
C N.B. this input needs modified to use the limiter mnemonics
C
         ELSE IF (VAR .EQ. 'LIMIT') THEN
            READ (INPUT,*,END=990,ERR=995) (LIMIT(LL,IBLOCK),LL=1,3)
            WRITE (IOUT,2002) ' Limit ', (LIMIT(LL,IBLOCK),LL=1,3)
C-       ELSE IF (VAR .EQ. 'ORDER') THEN
C-          READ (INPUT,*,END=990,ERR=995) (ITORDR(LL),LL=1,3)
C-          WRITE (IOUT,2002) ' Order ', (ITORDR(LL),LL=1,3)
C-          DO 509 ILVL = 1, NXLVLS
C-             IORDER(1,IBLOCK,ILVL,ILVL) = ITORDR(1)
C-             IORDER(2,IBLOCK,ILVL,ILVL) = ITORDR(2)
C-             IORDER(3,IBLOCK,ILVL,ILVL) = ITORDR(3)
C-509       CONTINUE
         ELSE IF (VAR .EQ. 'FLUX') THEN
            READ (INPUT,*,END=990,ERR=995) VAR
            WRITE (IOUT,2010) VAR
            IF (VAR .EQ. 'ROE') THEN
               IFLUX(IBLOCK) = IFROE
            ELSE
               WRITE (IOUT,1030)
               INPERR = INPERR + 1
            ENDIF
         ELSE IF (VAR .EQ. 'VISCOUS') THEN
            IV = INT(VALUE)
            READ (INPUT,*,END=990,ERR=995) (IDUM(LL),LL=1,IV)
            WRITE (IOUT,1035) (IDUM(LL),LL=1,IV)
            DO 90 LL = 1, IV
               VISCOS(IDUM(LL),IBLOCK) = .TRUE.
 90         CONTINUE
            ITURB = MAX (ITURB, ITLMNR)
         ELSE IF (VAR .EQ. 'DIAGONAL') THEN
            IV = INT(VALUE)
            READ (INPUT,*,END=990,ERR=995) (IDUM(LL),LL=1,IV)
            WRITE (IOUT,1035) (IDUM(LL),LL=1,IV)
            DO 91 LL = 1, IV
               DIAG  (IDUM(LL),IBLOCK) = .TRUE.
 91         CONTINUE
         ELSE IF (VAR .EQ. 'INVISCID') THEN
            DO 95 LL = 1, 3
               VISCOS(LL,IBLOCK) = .FALSE.
 95         CONTINUE
         ELSE IF (VAR .EQ. 'GRID') THEN
            READ (INPUT,*,END=990,ERR=995) GRDFIL(IBLOCK)
            WRITE (IOUT,1040) GRDFIL(IBLOCK)
            IGRDTP = IGTSEP
C
C     Boundary Condition Data
C
         ELSE IF (VAR .EQ. 'BC') THEN
            NBCS(IBLOCK) = INT (VALUE)
            IF (NBCS(IBLOCK) .GT. NXBCS) THEN
               INPERR = INPERR + 1
               WRITE (IOUT,1535) NBCS(IBLOCK), IBLOCK, NXBCS
               GO TO 900
            ENDIF
            DO 200 I = 1, NBCS(IBLOCK)
C              READ (INPUT,*,END=990,ERR=995) VAR, (ISTRT(L),L=1,3),
C    1                                (IEND(M),M=1,3), BCTYP
               read (input,*,END=990,ERR=995) var, istrt(1), istrt(2),
     1              istrt(3), iend(1), iend(2), iend(3), bctyp
               WRITE (IOUT,1045) VAR, (ISTRT(L),L=1,3),
     1                                (IEND(M),M=1,3), BCTYP
C
C     Determine BC face. This is defined by constant index on that face.
C     Note that this will fail for the pathological case where have two
C     or more indices equal for a bc. In case an error occurs, set the
C     face direction to 1 to finish checking the BC data.
C
               IDIR = 0
               DO 150 L = 1, 3
                  IF (ISTRT(L) .EQ. IEND(L)) IDIR = L
 150           CONTINUE
               IF (IDIR .LT. 1 .OR. IDIR .GT. 3) THEN
                  WRITE (IOUT,1049)
                  INPERR = INPERR + 1
                  IDIR   = 1
               ENDIF
C
C     Set profile boundary segment identifier to zero for all other cases
C
               INPROF = 0
C
               IF (BCTYP .EQ. 'WALL') THEN
                  IBCDAT(1,I,IBLOCK,1) = IWALL
               ELSE IF (BCTYP .EQ. 'WALL FUNCTIONS') THEN
                  IBCDAT(1,I,IBLOCK,1) = IWALFN
                  IFWALF = .TRUE.
               ELSE IF (BCTYP .EQ. 'TANGENCY') THEN
                  IBCDAT(1,I,IBLOCK,1) = ITAN
               ELSE IF (BCTYP .EQ. 'FARFIELD') THEN
                  IBCDAT(1,I,IBLOCK,1) = IFAR
               ELSE IF (BCTYP .EQ. '2D FARFIELD VORTEX') THEN
                  IFFORC               = IYES
                  IBCDAT(1,I,IBLOCK,1) = IFAR2D
               ELSE IF (BCTYP .EQ. 'SYMMETRY XY') THEN
                  IBCDAT(1,I,IBLOCK,1) = ISYMXY
               ELSE IF (BCTYP .EQ. 'SYMMETRY XZ') THEN
                  IBCDAT(1,I,IBLOCK,1) = ISYMXZ
               ELSE IF (BCTYP .EQ. 'SYMMETRY YZ') THEN
                  IBCDAT(1,I,IBLOCK,1) = ISYMYZ
               ELSE IF (BCTYP .EQ. 'EXTRAPOLATE') THEN
                  IBCDAT(1,I,IBLOCK,1) = IEXT
               ELSE IF (BCTYP .EQ. 'FIX') THEN
                  IBCDAT(1,I,IBLOCK,1) = IFIX
               ELSE IF (BCTYP .EQ. 'JET') THEN
                  IBCDAT(1,I,IBLOCK,1) = IJET
               ELSE IF (BCTYP .EQ. 'PERIODIC') THEN
                  IBCDAT(1,I,IBLOCK,1) = IPERD
               ELSE IF (BCTYP .EQ. 'HOMOGENEOUS SHEAR') THEN
                  IBCDAT(1,I,IBLOCK,1) = IHSHR
               ELSE IF (BCTYP .EQ. 'SUBSONIC INFLOW') THEN
                  IBCDAT(1,I,IBLOCK,1) = IINFLO
               ELSE IF (BCTYP .EQ. 'SUBSONIC OUTFLOW') THEN
                  IBCDAT(1,I,IBLOCK,1) = IOUTFL
               ELSE IF (BCTYP .EQ. 'AXISYMMETRIC') THEN
                  IBCDAT(1,I,IBLOCK,1) = IAXISM
               ELSE IF (BCTYP .EQ. 'AXISYMMETRIC CENTERLINE') THEN
                  IBCDAT(1,I,IBLOCK,1) = IAXICL
               ELSE IF (BCTYP .EQ. 'PROFILE CELL CENTER') THEN
                  IBCDAT(1,I,IBLOCK,1)  = IPROFL
                  NPROFL                = NPROFL + 1
                  INPROF                = NPROFL
                  READ (INPUT,*,END=990,ERR=995) FPROFL(NPROFL)
                  WRITE (IOUT,1047) FPROFL(NPROFL)
               ELSE IF (BCTYP .EQ. 'SUBSONIC PROFILE CC') THEN
                  IBCDAT(1,I,IBLOCK,1)  = IPROSB
                  NPROFL                = NPROFL + 1
                  INPROF                = NPROFL
                  READ (INPUT,*,END=990,ERR=995) FPROFL(NPROFL)
                  WRITE (IOUT,1048) FPROFL(NPROFL)
               ELSE
                  WRITE (IOUT,1050) BCTYP
                  INPERR = INPERR + 1
               ENDIF
C
C     Modify starting point appropriately to account for bc input as grid
C     points but bc to be cell-centers.  Do this only for the indices that
C     the bc loops over, not the idir direction.  BCs must be input with
C     indices in increasing order.
C     The starts are the max of the input starting point and 2 for the
C     looping directions on a given boundary so that only loop over the
C     interior boundary points to fit with the dimensioning of Q(+/-) etc
C     as used in the MUSCL and FVSTL routines.
C
               DO 151 L = 1, 3
                  IF (L .NE. IDIR) THEN
                     ISTRT(L) = ISTRT(L) + 1
                  ENDIF
  151          CONTINUE
C
               IBCDAT( 2,I,IBLOCK,1) = IDIR
               IBCDAT( 3,I,IBLOCK,1) = ISTRT(IDIR)
               IBCDAT( 4,I,IBLOCK,1) = ISTRT(1)
               IBCDAT( 5,I,IBLOCK,1) = IEND (1)
               IBCDAT( 6,I,IBLOCK,1) = ISTRT(2)
               IBCDAT( 7,I,IBLOCK,1) = IEND (2)
               IBCDAT( 8,I,IBLOCK,1) = ISTRT(3)
               IBCDAT( 9,I,IBLOCK,1) = IEND (3)
               IBCDAT(10,I,IBLOCK,1) = INPROF
C
  200       CONTINUE
C
C     If read an END BLOCK, then have reached the end of the data for
C     the grid block/zone and are back in the main loop
C
         ELSE IF (VAR .EQ. 'END BLOCK') THEN
            GO TO 50
         ELSE
            WRITE (IOUT,1055) VAR, VALUE
            INPERR = INPERR + 1
         ENDIF
C
C     Go back and get the next line of input from the block/zone data
C
         GO TO 500
C
C     End of data for grid block/zone
C
      ELSE
C
C     Error in main loop
C
         WRITE (IOUT,1060) VAR, VALUE
         INPERR = INPERR + 1
      ENDIF
C
C     Go back and read the next line
C
      GO TO 50
C
C     End of input file
C
  900 CONTINUE
      WRITE (IOUT,1002)
C
C 3.  Set values based on input
C
C     Iterative, implicit items
C     Total additional levels of time storage
C
      NTMLVL = NTIME + NTMTAU
C
C     Set calculation of forces: if output of forces is requested or the
C                                2D farfield vortex bc is used then calculate
C
      IF (IFRCPR .EQ. IYES) IFFORC = IYES
C
C     If unsteady, then verify using AF3F or DIAGONAL AF3F scheme.
C     Set TIMEDT to DT if not previously set; if DT not set then output error.
C     t-ts scheme must have DT = TIMEDT.
C
      IF (ITIMED .EQ. IUNSTD) THEN
         IF ( .NOT. (ISOLVR .EQ. IAF3F) ) THEN
            WRITE (IOUT,2015)
            INPERR = INPERR + 1
         ENDIF
C
         IF (TIMEDT .LE. 0.E0) THEN
            IF (DT .GT. 0.E0) THEN
               TIMEDT = DT
               WRITE (IOUT,2020) DT
            ELSE
               WRITE (IOUT,2030)
               INPERR = INPERR + 1
            ENDIF
         ENDIF
C
         IF (ITMTYP .EQ. ITTS) THEN
            IF (DT .NE. TIMEDT) THEN
               WRITE (IOUT,2040)
               INPERR = INPERR + 1
            ENDIF
         ENDIF
      ENDIF
C
C     Check for errors in the input deck
C
      IF (INPERR .GT. 0) THEN
         WRITE (IOUT,2050) INPERR
         STOP
      ENDIF
C
C     Set-up unit normal to use for collapsed cell faces
C     SHAT = (1,1,1) / sqrt(3) for 3D
C            (1,1,0) / sqrt(2) for 3D
C
      IF (THREED) THEN
         DENOM = SQRT (3.E0)
         SHATX = 1.E0 / DENOM
         SHATY = 1.E0 / DENOM
         SHATZ = 1.E0 / DENOM
      ELSE
         DENOM = SQRT (2.E0)
         SHATX = 1.E0 / DENOM
         SHATY = 1.E0 / DENOM
         SHATZ = 0.E0
      ENDIF
C
C     Set-up IMODEL
C
      IMODEL( 1) = ITURB
      IMODEL( 2) = IEPSEQ
      IMODEL( 3) = IDAMP
      IMODEL( 4) = IADRM
      IMODEL( 5) = IFDL2K
      IF (ITURB .EQ. ITRS) THEN
         IMODEL( 6) = IPSMDL
         IMODEL( 7) = IEPSIJ
         IMODEL( 8) = IDMMDL
         IMODEL( 9) = IDTMDL
      ELSE IF (ITURB .EQ. ITLES) THEN
         IMODEL( 6) = ISGS
      ENDIF
      IMODEL(10) = IASM
      IMODEL(11) = IEPSC
      IMODEL(12) = IPDIL
      IMODEL(13) = ISRCW
C
C     Set values that depend on the entire range of input
C
      IF (ITURB .EQ. ITKE) THEN
         TKEINF = TKEINF * FSMACH * FSMACH
         EPSINF = CMU * RHOINF * TKEINF * TKEINF / RMUTNF * RE / FSMACH
      ELSE IF (ITURB .EQ. ITKW) THEN
         TKEINF = TKEINF * FSMACH * FSMACH
         OMEINF = CMU * RHOINF * TKEINF / RMUTNF * RE / FSMACH
      ELSE IF (ITURB .EQ. ITRS) THEN
         TKEINF = TKEINF * FSMACH * FSMACH
         EPSINF = CMU * RHOINF * TKEINF * TKEINF / RMUTNF * RE / FSMACH
C
C Isotropic turbulence
C
         TAUINF(1) = 2.E0 / 3.E0 * TKEINF
         TAUINF(2) = 2.E0 / 3.E0 * TKEINF
         TAUINF(3) = 2.E0 / 3.E0 * TKEINF
         TAUINF(4) = 0.E0
         TAUINF(5) = 0.E0
         TAUINF(6) = 0.E0
      ENDIF
C
C     Set PBAKBC, PTOTBC, TTOTBC if not input.
C     Convert PBAKBC, PTOTBC, TTOTBC from dimensional to non-dimensional.
C
      ARG    = 1.E0 + 0.5E0 * (GAMMA-1.E0) * FSMACH * FSMACH
      IF (PBAKBC .LE. 0.E0) PBAKBC = 1.E0
      IF (PTOTBC .LE. 0.E0) PTOTBC = ARG ** (GAMMA/(GAMMA-1.E0))
      IF (TTOTBC .LE. 0.E0) TTOTBC = TINF * ARG
C
      PBAKBC = PBAKBC / GAMMA
      PTOTBC = PTOTBC / GAMMA
      TTOTBC = TTOTBC / TINF
C
C     Convert PJET from P(jet) / Pinf to P(jet) / (rhoinf*ainf**2)
C     Set the value of the Jet density
C
      PJET   = PJET / GAMMA
      RHOJET = GAMMA * PJET / TJET
C
C     Set TDPDTJ, TDPDEL for t-ts or tau-ts time stepping.
C
      IF (ITMTYP .EQ. ITTS) THEN
         TDPDTJ = TDPHI  + 1.E0
         TDPDEL = 0.E0
      ELSE
         TDPDTJ = TDPHIP + 1.E0
         TDPDEL = TDPHI  + 1.E0
      ENDIF
C
C     Sort the BCs into ascending order based on BC type
C
      WRITE (IOUT,2100)
      DO 980 IBLOCK = 1, NBLKS
         DO 970 I = 1, NBCS(IBLOCK)
            IBCTYP = IBCDAT(1,I,IBLOCK,1)
            DO 960 J = I+1, NBCS(IBLOCK)
               IBCTST = IBCDAT(1,J,IBLOCK,1)
               IF (IBCTST .LT. IBCTYP) THEN
                  IBCTYP = IBCTST
                  DO 950 L = 1, 10
                     IBCTMP               = IBCDAT(L,I,IBLOCK,1)
                     IBCDAT(L,I,IBLOCK,1) = IBCDAT(L,J,IBLOCK,1)
                     IBCDAT(L,J,IBLOCK,1) = IBCTMP
  950             CONTINUE
               ENDIF
  960       CONTINUE
  970    CONTINUE
  980 CONTINUE
C
C     Finished
      RETURN
C
C 4.   Error handling section
C 4-a. End-Of-File Handler
C
  990 CONTINUE
      WRITE (IOUT,9990)
      STOP
C
C 4-b. Error Handler
C
  995 CONTINUE
      WRITE (IOUT,9995)
      STOP
C
 1001 FORMAT (' ','RDDATA: Begin Input Echo')
 1002 FORMAT (' ','RDDATA: End Input Echo')
 1000 FORMAT (5X,A25,5X,E14.7)
 1005 FORMAT (' ',4X,'Restart being written to file:',
     1       /' ',9X,A70)
 1010 FORMAT (' ','Illegal PLOT3D format option = ',A25,
     1       /' ','Please specify either BINARY or FORMATTED ')
 1015 FORMAT (' ',4X,'Output PLOT3D Grid    : ',A50
     1       /' ',4X,'              Solution: ',A50,
     2       /' ',4X,'              Function: ',A50)
 1020 FORMAT (' ','Specified number of stages, NSTAGE ',I2,
     1        ' ','greater than allowed, MXSTAG ',I2,
     2       /' ','Reset MXSTAG in main and recompile.')
 1021 FORMAT (' ',4X,'Runge-Kutta: Number of Stages = ',I2,
     1       /' ',4X,'             Coefficients     = ',6F10.6)
 1022 FORMAT (5X,'IMSTRT = ',I5,' IMEND = ',I5)
 1023 FORMAT (' ','Illegal solution procedure specified ',A25)
 1024 FORMAT (' ','Specified number of iterations, NITS ',I10,
     1        ' ','greater than allowed, MXHIST ',I10,
     2       /' ','Reset to MXHIST and continue.')
 1124 FORMAT (' ','RDDATA: Error-> Invalid coefficient for entropy fix',
     1       /' ','                CNTRPY must be 0 <= CNTRPY <= 1.')
 1025 FORMAT (' ',4X,'Restarting from file:',
     1       /' ',9X,A70)
 1026 FORMAT (' ','Illegal specification of force calculation = ',I10,
     1       /' ','     PRINT FORCES = 0 DO NOT calculate forces ',
     2       /' ','     PRINT FORCES = 1 Calculate forces ')
 1027 FORMAT (' ','Illegal specification of source term control = ',I10,
     1       /' ','     SOURCE = 0 DO NOT calculate source terms ',
     2       /' ','     SOURCE = 1 Calculate source terms ')
 1028 FORMAT (10X,'Invalid Implicit Source Term treatment ',A25)
 1210 FORMAT (' ','Required mesh levels ',I3,' exceed maximum ',I3,
     1       /' ','     Increase MXCFS in MAIN or decrease mesh ',
     2            'sequencing.'
     3       /' ','     Skipping next ',I3,' input lines.')
 1220 FORMAT (10X,'Mesh Sequence Level:',I4,' Number of Iterations:',I6)
 1227 FORMAT (10X,A25)
 1229 FORMAT (' ','Illegal specification of FIXQ  pos. control = ',I10,
     1       /' ','     FIXQ   = NONE    -> DO NOT call FIXQ ',
     2       /' ','     FIXQ   = MINIMUM -> Call FIXQ with Minimum ',
     3       /' ','     FIXQ   = AVERAGE -> Call FIXQ with Average ')
 1029 FORMAT (' ','Illegal turbulent constant specified ',A25)
 1030 FORMAT (///' ','***** ILLEGAL FLUX EVALUATION ROUTINE ****')
 1035 FORMAT (20X,3I5)
 1040 FORMAT (10X,'Grid File ',5X,A80)
 1045 FORMAT (10X,A25,6(1X,I4),2X,A25)
 1047 FORMAT (15X,'Profile File: ',5X,A80)
 1048 FORMAT (15X,'Subsonic Profile File: ',5X,A80)
 1049 FORMAT (' ','RDDATA: ERROR-> BC Face not specified. One pair of ',
     1            'BC indices must match',
     2       /' ','                to define the BC Face.')
 1050 FORMAT (' ','INVALID BOUNDARY CONDITION TYPE ',5X,A25)
 1055 FORMAT (10X,'Invalid Option in Block/Zone input ',A25,5X,E14.7)
 1058 FORMAT (' ','Invalid Limiter Specified ',5X,A25,5X,E14.7)
 1059 FORMAT (' ','Invalid Central Difference Option ',5X,A25,5X,E14.7)
 1060 FORMAT (' ','INVALID COMMAND',5X,A25,5X,E14.7)
 1061 FORMAT (10X,A25,5X,E14.7)
 1065 FORMAT (15X,A25)
 1066 FORMAT (10X,'Invalid Turbulent-DIffusion model ',A25)
 1067 FORMAT (10X,'Invalid Pressure-Strain model ',A25)
 1068 FORMAT (10X,'Invalid Compressible Dissipation model ',A25)
 1069 FORMAT (10X,'Invalid Pressure-Dilatation  model ',A25)
 1070 FORMAT (' ',5X,' K-Epsilon Model: ',A30)
 1075 FORMAT (' ',5X,' K-Epsilon Modelling Constants ',
     1       /' ',5X,'      CEPS1        = ',F12.8,
     2       /' ',5X,'      CEPS2        = ',F12.8,
     3       /' ',5X,'      CMU          = ',F12.8,
     4       /' ',5X,'      SIGMAK       = ',F12.8,
     5       /' ',5X,'      SIGMAE       = ',F12.8,
     6       /' ',5X,'      SIGMARHO[-1] = ',F12.8,
     7       /' ',5X,'      A2KE         = ',F12.8,
     8       /' ',5X,'      ALF1         = ',F12.8,
     9       /' ',5X,'      ALF2         = ',F12.8,
     A       /' ',5X,'      ALF3         = ',F12.8,
     B       /' ',5X,'      CPDFRO       = ',F12.8,
     C       /' ',5X,'      CPDFT        = ',F12.8,
     D       /' ',5X,'      CPVELK       = ',F12.8,
     E       /' ',5X,'      TKEINF       = ',F12.8,' * Mach^2',
     F       /' ',5X,'      RMUTNF       = ',F12.8)
 1080 FORMAT (' ',5X,' K-Omega Modelling Constants ',
     1       /' ',5X,'      SIGMAK       = ',F12.8,
     2       /' ',5X,'      SIGMAW       = ',F12.8,
     3       /' ',5X,'      BSTRKW       = ',F12.8,
     4       /' ',5X,'      BKW          = ',F12.8,
     5       /' ',5X,'      CMU          = ',F12.8,
     6       /' ',5X,'      GKW          = ',F12.8,
     7       /' ',5X,'      ROUGHK       = ',F12.8,
     8       /' ',5X,'      SIGMARHO[-1] = ',F12.8,
     9       /' ',5X,'      CPDFRO       = ',F12.8,
     A       /' ',5X,'      CPDFT        = ',F12.8,
     B       /' ',5X,'      CPVELK       = ',F12.8,
     C       /' ',5X,'      TKEINF       = ',F12.8,' * Mach^2',
     D       /' ',5X,'      RMUTNF       = ',F12.8)
 1090 FORMAT (' ',5X,' Reynolds Stress Modelling Constants ',
     1       /' ',5X,'      CEPSLN       = ',F12.8,
     2       /' ',5X,'      CEPS1        = ',F12.8,
     3       /' ',5X,'      CEPS2        = ',F12.8,
     4       /' ',5X,'      CEPS3        = ',F12.8,
     5       /' ',5X,'      CEPS4        = ',F12.8,
     6       /' ',5X,'      CEPS5        = ',F12.8,
     7       /' ',5X,'      CSUBS        = ',F12.8,
     8       /' ',5X,'      CMU          = ',F12.8,
     9       /' ',5X,'      SIGMAK       = ',F12.8,
     A       /' ',5X,'      SIGMAE       = ',F12.8,
     B       /' ',5X,'      SIGMARHO[-1] = ',F12.8,
     C       /' ',5X,'      A2KE         = ',F12.8,
     D       /' ',5X,'      ALF1         = ',F12.8,
     E       /' ',5X,'      ALF2         = ',F12.8,
     F       /' ',5X,'      ALF3         = ',F12.8,
     G       /' ',5X,'      CPDFRO       = ',F12.8,
     H       /' ',5X,'      CPDFT        = ',F12.8,
     I       /' ',5X,'      CPVELK       = ',F12.8,
     J       /' ',5X,'      TKEINF       = ',F12.8,' * Mach^2',
     K       /' ',5X,'      RMUTNF       = ',F12.8)
 1095 FORMAT (' ',10X,' Pressure-Strain Correlation: ',A25)
 1097 FORMAT (' ',10X,'      PSC1         = ',F12.8,
     1       /' ',10X,'      PSC2         = ',F12.8,
     2       /' ',10X,'      PSCW         = ',F12.8,
     3       /' ',10X,'      PSALFA       = ',F12.8,
     4       /' ',10X,'      PSBETA       = ',F12.8,
     5       /' ',10X,'      PSGAMA       = ',F12.8)
 1098 FORMAT (' ',5X,' LES Subgrid-Scale Stress Model: ',A30)
 1099 FORMAT (' ',5X,' Large-Eddy Simulation Model Constants ',
     1       /' ',5X,'      C_s          = ',F12.8)
C
 1100 FORMAT (' ',5X,'Invalid conversion turbulence model specified',
     1               ' = ',A25)
 1105 FORMAT (' ',10X,'Invalid model specified for conversion ',A25)
 1110 FORMAT (' ',5X,'Convert on Restart From ',A25)
C
 1525 FORMAT (/' ','RDDATA: Number of blocks required ',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MXBLKS in MAIN and re-submit.',
     3        /' ', 8X,'   Unable to continue reading input.',
     4        /' ', 8X,'   RUN ABORTING!')
 1530 FORMAT (/' ','RDDATA: Number of cuts   required ',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MXCUTS in MAIN and re-submit.',
     3        /' ', 8X,'   (Storage requires 2*number of cuts)',
     4        /' ', 8X,'   Unable to continue reading input.',
     5        /' ', 8X,'   RUN ABORTING!')
 1535 FORMAT (/' ','RDDATA: Number of BCs    required ',I5,
     1             ' for block ',I3,' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MXBCS  in MAIN and re-submit.',
     3        /' ', 8X,'   Unable to continue reading input.',
     4        /' ', 8X,'   RUN ABORTING!')
 1540 FORMAT (/' ','RDDATA: Number of print  required ',I5,
     1             ' for block ',I3,' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MXPRT  in MAIN and re-submit.',
     3        /' ', 8X,'   Unable to continue reading input.',
     4        /' ', 8X,'   RUN ABORTING!')
 1545 FORMAT (/' ','RDDATA: Number of transition segments required ',I5,
     1             ' exceeds allocated ',I5,
     2        /' ', 8X,'=> Increase MXTRSG in MAIN and re-submit.',
     3        /' ', 8X,'   Unable to continue reading input.',
     4        /' ', 8X,'   RUN ABORTING!')
C
 1580 FORMAT (10X,'Block = ',I5,5X,'Start = ',3I4,5X,'End = ',3I4)
 1590 FORMAT (' ','RDDATA: ERROR-> Starting index is greater than ',
     1            'ending index for transition at:'
     2       /' ','IDIR = ',I2,'Block = ',I5,5X,'Start = ',3I4,5X,
     3            'End = ',3I4)
C
 1600 FORMAT (10X,A25,I5,6(1X,I4))
 1605 FORMAT (10X,A25,I5,9(1X,I4))
 1610 FORMAT (' ','CUT names do not match')
 1620 FORMAT (' ','IORD(',I1,') =',I5,' does not equal 1, 2, or 3.')
 1630 FORMAT (' ','RDDATA: ERROR-> CUT Face not specified. One pair ',
     1            'of CUT indices must match',
     2       /' ','                to define the CUT Face.')
 2000 FORMAT (10X,A25,3E16.7)
 2002 FORMAT (10X,A25,3I5)
 2005 FORMAT (5X,'   Block = ',I4,'  IDIR = ',I4,'  Start = ',3I4,
     1           '  End = ',3I4,'  Increment = ',3I4)
 2010 FORMAT (10X,A25,5X,E14.7)
 2015 FORMAT (/' ','RDDATA: ERROR-> Iterative, implicit time ',
     1             'dependent currently only supports the',
     2        /' ','                AF3F or DIAGONAL AF3F solvers.',
     3        /' ','                Please switch to one of these and ',
     4             'resubmit.')
 2020 FORMAT (/' ','RDDATA: WARNING-> Iterative, implicit time ',
     1             'dependent time step set to DT ',1PE14.7)
 2030 FORMAT (/' ','RDDATA: ERROR-> Iterative, implicit time dependent',
     1             ' requires time step.',
     2        /' ',8X,'Input time step with TIME STEP or DT.')
 2040 FORMAT (/' ','RDDATA: ERROR-> t-ts Iterative, implicit time ',
     1             'dependent requires DT = TIME STEP',
     2        /' ',8X,'Check input TIME STEP and DT.')
 2050 FORMAT (/' ','RDDATA: ERROR-> There were ',I5,' errors in the ',
     1             'input deck.',
     2        /' ', 8X,'RUN ABORTING!')
 2100 FORMAT (//' ','RDDATA: Sorting boundary conditions into ',
     1              'ascending order based on type',//)
 9990 FORMAT (' ','RDDATA: ERROR-> Unexpected End-Of-File encountered.',
     1       /' ', 8X,'RUN ABORTING!')
 9995 FORMAT (' ','RDDATA: ERROR-> Syntax error in input line.'
     1       /' ', 8X,'RUN ABORTING!')
C
      END
      SUBROUTINE SETPIJ (IPSMDL, IEPSIJ, IEPSEQ, IDAMP, ISRCW)
C
C This routine sets the following constants for the various pressure-strain
C correlations:
C      IEPSIJ, IEPSEQ, IDAMP, ISRCW, PSC1, PSC2, PSCW, PSALFA, PSBETA, PSGAMA
C
C IPSMDL         : Input pressure strain model to set constants for
C IEPSIJ         : Epsilon_ij model
C IEPSEQ         : Epsilon equation model
C IDAMP          : Damping used for mu_turbulent
C ISRCW          : Control of additional wall normal dependent source routines
C
      include 'common.inc'
C
      IF (IPSMDL .EQ. IPLRR1) THEN
         IEPSIJ = IEISO
         IEPSEQ = IEEHR
         IDAMP  = IFMHR
         ISRCW  = INO
         PSC1   = 3.0E0
         PSC2   = 0.4E0
         PSCW   = 1.0E0
         PSALFA = 0.E0
         PSBETA = 0.E0
         PSGAMA = 0.E0
      ELSE IF (IPSMDL .EQ. IPLRR2) THEN
         IEPSIJ = IEISO
         IEPSEQ = IEEHR
         IDAMP  = IFMHR
         ISRCW  = INO
         PSC1   = 3.0E0
         PSC2   = 0.4E0
         PSCW   = 0.E0
         PSALFA = 0.E0
         PSBETA = 0.E0
         PSGAMA = 0.E0
      ELSE IF (IPSMDL .EQ. IPSSG ) THEN
         IEPSIJ = IEISO
         IEPSEQ = IEEHR
         IDAMP  = IFMHR
         ISRCW  = INO
         PSALFA = 0.E0
         PSBETA = 0.E0
         PSGAMA = 0.E0
      ELSE IF (IPSMDL .EQ. IPFLT ) THEN
         IEPSIJ = IEFLT
         IEPSEQ = IEEHR
         IDAMP  = IFMHR
         ISRCW  = INO
         PSALFA = 0.E0
         PSBETA = 0.E0
         PSGAMA = 0.E0
      ELSE IF (IPSMDL .EQ. IPLS  ) THEN
         IEPSIJ = IELAIS
         IEPSEQ = IEEZSG
         IDAMP  = IFMZSG
         ISRCW  = IYES
         PSC1   = 3.0E0
         PSC2   = 0.4E0
         PSCW   = 0.01363540E0
         PSALFA = 0.45E0
         PSBETA = 0.E0
         PSGAMA = 0.E0
      ELSE IF (IPSMDL .EQ. IPSO95) THEN
         IEPSIJ = IESO95
         IEPSEQ = IEES95
         IDAMP  = IFMZSG
         ISRCW  = INO
         PSC1   = 3.0E0
         PSC2   = 0.4E0
         PSCW   = 0.0E0
         PSALFA = - 0.36E0
         PSBETA =   0.0005E0
         PSGAMA =   0.075E0
      ELSE IF (IPSMDL .EQ. IPGL  ) THEN
         IEPSIJ = IEISO
         IEPSEQ = IEEHR
         IDAMP  = IFMHR
         ISRCW  = INO
         PSC1   = 3.6E0
         PSC2   = 0.6E0
         PSCW   = 0.E0
         PSALFA = 0.E0
         PSBETA = 0.E0
         PSGAMA = 0.E0
      ELSE
         WRITE (IOUT,1000) IPSMDL
      ENDIF
C
C Finished
      RETURN
 1000 FORMAT (' ','SETPIJ: ERROR-> Invalid pressure-strain model: ',
     1            'IPSMDL = ',I5)
      END
      SUBROUTINE RDGRID (NBLKS, IDIM, JDIM, KDIM, IOFFS, GRDFIL, R,
     1                   IDIMIN, JDIMIN, KDIMIN, IGRDTP, GRDBIN,
     2                   IEOF, IERRCD)
C
C Routine to read in the complete grid data.  This routine will either read
C the grid for each block from a separate file (IGRDTP = IGTSEP) or
C will read the entire grid from a single PLOT3D file in single or multiblock
C format as appropriate (IGRDTP = IGTP3D).
C
C This routine is organized as follows:
C     1. Read Grid
C        a. Read Separate File (IGRDTP = IGTSEP) [formatted or binary]
C           For each block {
C           i.   Open file
C           ii.  Read header information
C           iii. Read block grid
C           iv.  Close file
C           }
C        b. Read PLOT3D File   (IGRDTP = IGTP3D) [formatted or binary]
C           i.   Open file
C           ii.  Read header information for all blocks
C           iii. Verify dimensions
C           iv.  Loop over all blocks and read grids
C           v.   Close file
C        c. Error: Invalid type
C     2. Error handling section
C        a. End-Of-File Handler
C        b. Error Handler
C
C NBLKS          : Number of blocks
C IDIM,JDIM,KDIM : Dimensions of all blocks on finest level
C IOFFS          : Offset pointer to each block
C GRDFIL         : Grid file name(s)
C R              : Position vector of grid vertices (x,y,z)
C IDIMIN,JDIMIN,
C KDIMIN         : Dimensions of all blocks read in the grid
C IGRDTP         : Grid type (separate files or Plot3D multiblock)
C GRDBIN         : Logical for binary (.TRUE.) or formatted (.FALSE.) file
C IEOF           : End-of-file switch
C                  IEOF   = INO  if End-of-file NOT reached
C                  IEOF   = IYES if End-of-file WAS reached
C IERRCD         : Error Code
C                  IERRCD = INO  if NO error reading file
C                  IERRCD = IYES if    error reading file
C
      include 'common.inc'
C
      DIMENSION IDIM  (NBLKS),
     1          JDIM  (NBLKS),
     2          KDIM  (NBLKS),
     3          IOFFS (NBLKS)
C
      DIMENSION IDIMIN(NBLKS),
     1          JDIMIN(NBLKS),
     2          KDIMIN(NBLKS)
C
      CHARACTER*80 GRDFIL(NBLKS),
     1             FERROR
C
      DIMENSION R     (*)
C
      LOGICAL GRDBIN
C
      CHARACTER*80 FILTYP
C
C Initialize error handling
C
      IEOF   = INO
      IERRCD = INO
C
C Initialize file type
C
      IF (GRDBIN) THEN
         FILTYP = 'UNFORMATTED'
      ELSE
         FILTYP = 'FORMATTED'
      ENDIF
C
C 1.   Read Grid
C 1-a. Read Separate Files (IGRDTP = IGTSEP) [formatted or binary]
C
      IF (IGRDTP .EQ. IGTSEP) THEN
         DO 190 IBLK = 1, NBLKS
            FERROR = GRDFIL(IBLK)
            OPEN (IGRID,FILE=GRDFIL(IBLK),STATUS='OLD',FORM=FILTYP,
     1                  ERR=920)
            REWIND (IGRID)
            WRITE (IOUT,1000) IBLK, GRDFIL(IBLK)
            IR   = IOFFS(IBLK) * 3     + 1
C
C      Binary  files
C
            IF (GRDBIN) THEN
               IF (THREED) THEN
                  READ (IGRID,END=900,ERR=910) IDIM1, JDIM1, KDIM1
                  IF (IDIM1 .NE. IDIM(IBLK) .OR.
     1                JDIM1 .NE. JDIM(IBLK) .OR.
     2                KDIM1 .NE. KDIM(IBLK)) THEN
                     WRITE (IOUT,1100) IBLK,
     1                                 IDIM(IBLK),JDIM(IBLK),KDIM(IBLK),
     2                                 IDIM1,     JDIM1,     KDIM1
                     IERRCD = IYES
                     RETURN
                  ENDIF
                  CALL RDP3D  (GRDBIN, IDIM(IBLK), JDIM(IBLK),
     1                         KDIM(IBLK), R(IR), IEOF, IERRCD)
               ELSE
                  READ (IGRID,END=900,ERR=910) IDIM1, JDIM1
                  IF (IDIM1 .NE. IDIM(IBLK) .OR.
     1                JDIM1 .NE. JDIM(IBLK)) THEN
                     WRITE (IOUT,1105) IBLK, IDIM(IBLK), JDIM(IBLK),
     1                                       IDIM1,      JDIM1
                     IERRCD = IYES
                     RETURN
                  ENDIF
                  CALL RDP3D  (GRDBIN, IDIM(IBLK), JDIM(IBLK),
     1                         KDIM(IBLK), R(IR), IEOF, IERRCD)
               ENDIF
C
C      Formatted files
C
            ELSE
               IF (THREED) THEN
                  READ (IGRID,*,END=900,ERR=910) IDIM1, JDIM1, KDIM1
                  IF (IDIM1 .NE. IDIM(IBLK) .OR.
     1                JDIM1 .NE. JDIM(IBLK) .OR.
     2                KDIM1 .NE. KDIM(IBLK)) THEN
                     WRITE (IOUT,1100) IBLK,
     1                                 IDIM(IBLK),JDIM(IBLK),KDIM(IBLK),
     2                                 IDIM1,     JDIM1,     KDIM1
                     IERRCD = IYES
                     RETURN
                  ENDIF
                  CALL RDP3D  (GRDBIN, IDIM(IBLK), JDIM(IBLK),
     1                         KDIM(IBLK), R(IR), IEOF, IERRCD)
               ELSE
                  READ (IGRID,*,END=900,ERR=910) IDIM1, JDIM1
                  IF (IDIM1 .NE. IDIM(IBLK) .OR.
     1                JDIM1 .NE. JDIM(IBLK)) THEN
                     WRITE (IOUT,1105) IBLK, IDIM(IBLK), JDIM(IBLK),
     1                                       IDIM1,      JDIM1
                     IERRCD = IYES
                     RETURN
                  ENDIF
                  CALL RDP3D  (GRDBIN, IDIM(IBLK), JDIM(IBLK),
     1                         KDIM(IBLK), R(IR), IEOF, IERRCD)
               ENDIF
            ENDIF
            CLOSE (IGRID)
            IF (IERRCD .NE. INO .OR. IEOF .NE. INO) RETURN
  190    CONTINUE
C
C 1-b. Read PLOT3D File   (IGRDTP = IGTP3D) [formatted or binary]
C 1-b-i.   Open file
C
      ELSE IF (IGRDTP .EQ. IGTP3D) THEN
         FERROR = GRDFIL(1)
         OPEN (IGRID,FILE=GRDFIL(1),STATUS='OLD',FORM=FILTYP,
     1               ERR=920)
         REWIND (IGRID)
C
C 1-b-ii.  Read grid header file
C
C      Binary
C
         IF (GRDBIN) THEN
C
C      Read multiblock data if more than 1 block
C
            IF (NBLKS .GT. 1) THEN
               READ (IGRID,END=900,ERR=910) NBLKIN
               IF (NBLKIN .NE. NBLKS) THEN
                  IERRCD = IYES
                  WRITE (IOUT,1110) NBLKS, NBLKIN
                  RETURN
               ENDIF
            ENDIF
C
C      3D or 2D
C
            IF (THREED) THEN
               READ (IGRID,END=900,ERR=910) (IDIMIN(L), JDIMIN(L),
     1                                       KDIMIN(L), L=1,NBLKS)
            ELSE
               READ (IGRID,END=900,ERR=910) (IDIMIN(L), JDIMIN(L),
     1                                       L=1,NBLKS)
            ENDIF
C
C      Formatted
C
         ELSE
C
C      Read multiblock data if more than 1 block
C
            IF (NBLKS .GT. 1) THEN
               READ (IGRID,*,END=900,ERR=910) NBLKIN
               IF (NBLKIN .NE. NBLKS) THEN
                  IERRCD = IYES
                  WRITE (IOUT,1110) NBLKS, NBLKIN
                  RETURN
               ENDIF
            ENDIF
C
C      3D or 2D
C
            IF (THREED) THEN
               READ (IGRID,*,END=900,ERR=910) (IDIMIN(L), JDIMIN(L),
     1                                         KDIMIN(L), L=1,NBLKS)
            ELSE
               READ (IGRID,*,END=900,ERR=910) (IDIMIN(L), JDIMIN(L),
     1                                         L=1,NBLKS)
            ENDIF
         ENDIF
C
C 1-b-iii. Verify dimensions
C
         IF (THREED) THEN
            DO 210 IBLK = 1, NBLKS
               IF (IDIM(IBLK) .NE. IDIMIN(IBLK) .OR.
     1             JDIM(IBLK) .NE. JDIMIN(IBLK) .OR.
     2             KDIM(IBLK) .NE. KDIMIN(IBLK) ) THEN
                  IERRCD = IYES
                  WRITE (IOUT,1100) IBLK,
     1                           IDIM  (IBLK),JDIM  (IBLK),KDIM  (IBLK),
     2                           IDIMIN(IBLK),JDIMIN(IBLK),KDIMIN(IBLK)
               ENDIF
  210       CONTINUE
         ELSE
            DO 220 IBLK = 1, NBLKS
               IF (IDIM(IBLK) .NE. IDIMIN(IBLK) .OR.
     1             JDIM(IBLK) .NE. JDIMIN(IBLK) ) THEN
                  IERRCD = IYES
                  WRITE (IOUT,1105) IBLK,
     1                              IDIM  (IBLK),JDIM  (IBLK),
     2                              IDIMIN(IBLK),JDIMIN(IBLK)
               ENDIF
  220       CONTINUE
         ENDIF
         IF (IERRCD .NE. INO .OR. IEOF .NE. INO) RETURN
C
C 1-b-iv.  Loop over all blocks reading grid
C
         DO 290 IBLK = 1, NBLKS
            WRITE (IOUT,1000) IBLK, GRDFIL(1)
            IR   = IOFFS(IBLK) * 3     + 1
            CALL RDP3D  (GRDBIN, IDIM(IBLK), JDIM(IBLK),
     1                   KDIM(IBLK), R(IR), IEOF, IERRCD)
            IF (IERRCD .NE. INO .OR. IEOF .NE. INO) RETURN
  290    CONTINUE
C
C 1-b-v.   Close file
C
         CLOSE (IGRID)
C
C 1-c. Error
C
      ELSE
         IERRCD = IYES
         WRITE (IOUT,1120) IGRDTP
         RETURN
      ENDIF
C
C     Succesful completion reading grid - return
      RETURN
C
C 2.   Error handling section
C 2-a. End-Of-File Handler
C
  900 CONTINUE
      IEOF   = IYES
      WRITE (IOUT,1200)
      RETURN
C
C 2-b. Error Handler
C
  910 CONTINUE
      IERRCD = IYES
      WRITE (IOUT,1210)
      RETURN
C
C 2-c. Open Error Handler
C
  920 CONTINUE
      IERRCD = IYES
      WRITE (IOUT,1220) FERROR
      RETURN
C
 1000 FORMAT (' ','RDGRID: Reading grid for block ',I3,' from file ',
     1            A80)
 1100 FORMAT (' ','RDGRID: ERROR-> Reading input 3D grid for Block ',I3,
     1       /' ','                     IDIM, JDIM, KDIM = ',3I6,
     2       /' ','                Grid IDIM, JDIM, KDIM = ',3I6,
     3       /' ', 8X,'RUN ABORTING!')
 1105 FORMAT (' ','RDGRID: ERROR-> Reading input 2D grid for Block ',I3,
     1       /' ','                     IDIM, JDIM = ',2I6,
     2       /' ','                Grid IDIM, JDIM = ',2I6,
     3       /' ', 8X,'RUN ABORTING!')
 1110 FORMAT (' ','RDGRID: ERROR-> Reading input grid number of blocks',
     1       /' ','                     NBLKS = ',I6,
     2       /' ','                Grid NBLKS = ',I6,
     3       /' ', 8X,'RUN ABORTING!')
 1120 FORMAT (' ','RDGRID: ERROR-> Invalid grid type specified ',
     1            'IGRDTP = ',I6,
     2       /' ', 8X,'RUN ABORTING!')
C
 1200 FORMAT (' ','RDGRID: ERROR-> Unexpected End-Of-File Encountered ',
     1       /' ', 8X,'RUN ABORTING!')
 1210 FORMAT (' ','RDGRID: ERROR-> Unknown Error Encountered ',
     1       /' ', 8X,'RUN ABORTING!')
 1220 FORMAT (' ','RDGRID: ERROR-> Error opening file ',A80,
     1       /' ', 8X,'RUN ABORTING!')
C
      END
      SUBROUTINE RDP3D  (GRDBIN, IDIM, JDIM, KDIM, R, IEOF, IERRCD)
C
C Routine to read in one block of the grid in PLOT3D format (either formatted
C or binary).  The loops run over kdim ( jdim ( idim ) ) ).
C
C This routine is organized as follows:
C     1. Read grid
C        a. Binary    (3D or 2D grid)
C        b. Formatted (3D or 2D grid)
C     2. If two-dimensional grid then copy input plane to plane 2
C     3. Error handling section
C        a. End-Of-File Handler
C        b. Error Handler
C
C GRDBIN         : Logical for binary (.TRUE.) or formatted (.FALSE.) file
C IDIM,JDIM,KDIM : Dimensions of current block
C R              : Position vector of grid vertices (x,y,z)
C IEOF           : End-of-file switch
C                  IEOF   = INO  if End-of-file NOT reached
C                  IEOF   = IYES if End-of-file WAS reached
C IERRCD         : Error Code
C                  IERRCD = INO  if NO error reading file
C                  IERRCD = IYES if    error reading file
C
      include 'common.inc'
C
      DIMENSION R     (0:JDIM+1,0:KDIM+1,0:IDIM+1,3)
C
      LOGICAL GRDBIN
C
C 1.   Read grid
C 1-a. Binary   PLOT3D grid
C
      IF (GRDBIN) THEN
         IF (THREED) THEN
            READ (IGRID,END=900,ERR=910)
     1              ((((R(J,K,I,L),I=1,IDIM),J=1,JDIM),K=1,KDIM),L=1,3)
         ELSE
            READ (IGRID,END=900,ERR=910)
     1               (((R(J,1,I,L),I=1,IDIM),J=1,JDIM),L=1,2)
         ENDIF
C
C 1-b. Formatted PLOT3D grid
C
      ELSE
         IF (THREED) THEN
            READ (IGRID,*,END=900,ERR=910)
     1              ((((R(J,K,I,L),I=1,IDIM),J=1,JDIM),K=1,KDIM),L=1,3)
         ELSE
            READ (IGRID,*,END=900,ERR=910)
     1               (((R(J,1,I,L),I=1,IDIM),J=1,JDIM),L=1,2)
         ENDIF
      ENDIF
C
C 2.   Axisymmetric or Two-Dimensional Grid Modifications
C 2-a. Axisymmetric: Rotate K=1, K=2 grid planes by AXIDTH degrees
C
      IF (AXISYM) THEN
         PI     = ACOS(-1.E0)
         STHETA = SIN (AXIDTH * PI / 180.E0)
         DO 220 I = 1, IDIM
            DO 210 J = 1, JDIM
               Z          =   R(J,1,I,2) * STHETA
               R(J,1,I,3) = - Z
               R(J,2,I,3) =   Z
               R(J,2,I,1) =   R(J,1,I,1)
               R(J,2,I,2) =   R(J,1,I,2)
 210        CONTINUE
 220     CONTINUE
C
C 2-b. Two-Dimensional: Copy input plane to plane 2
C
      ELSE IF (.NOT. THREED) THEN
         DO 240 I = 1, IDIM
            DO 230 J = 1, JDIM
               R(J,1,I,3) = 0.E0
               R(J,2,I,3) = 1.E0
               R(J,2,I,1) = R(J,1,I,1)
               R(J,2,I,2) = R(J,1,I,2)
 230        CONTINUE
 240     CONTINUE
      ENDIF
C
C     Succesful completion reading block grid - return
      RETURN
C
C 3.   Error handling section
C 3-a. End-Of-File Handler
C
  900 CONTINUE
      IEOF   = IYES
      WRITE (IOUT,1000)
      RETURN
C
C 3-b. Error Handler
C
  910 CONTINUE
      IERRCD = IYES
      WRITE (IOUT,1005)
      RETURN
C
 1000 FORMAT (' ','RDP3D : ERROR-> Unexpected End-Of-File Encountered ',
     1       /' ', 8X,'RUN ABORTING!')
 1005 FORMAT (' ','RDP3D : ERROR-> Unknown Error Encountered ',
     1       /' ', 8X,'RUN ABORTING!')
C
      END
      SUBROUTINE RDPRFL (NPTS, QBC, IBCDAT, IERRCD)
C
C Routine to read in a profile and store it into the QBC array to
C be used in the boundary condition routine BCPROF.
C
C NPTS           : Number of points in the QBC array for current segment
C QBC            : Primitive variables read from a file
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT( 1,ibc) = Boundary Condition Type
C                          2      = Direction (1=i, 2=j, 3=k)
C                          3      = i(1 or idim)
C                          4      = istrt
C                          5      = iend
C                          6      = jstrt
C                          7      = jend
C                          8      = kstrt
C                          9      = kend
C                         10      = profile identifier
C IERRCD         : Error Code
C                  IERRCD = INO  if NO storage error or error reading file
C                  IERRCD = IYES if    storage error or error reading file
C
      include 'common.inc'
C
      DIMENSION QBC   (NPTS,NQ)
C
      DIMENSION IBCDAT(10)
C
C     Store boundary condition data in mnemonic names
C
      IBCTYP = IBCDAT(1)
      IDIR   = IBCDAT(2)
      INROUT = IBCDAT(3)
      ISTRT  = IBCDAT(4)
      IEND   = IBCDAT(5)
      JSTRT  = IBCDAT(6)
      JEND   = IBCDAT(7)
      KSTRT  = IBCDAT(8)
      KEND   = IBCDAT(9)
C
C     I Direction
C
      IF (IDIR .EQ. 1) THEN
         WRITE (IOUT,1010) 'K', KSTRT, KEND
         WRITE (IOUT,1010) 'J', JSTRT, JEND
         DO 120 K = KSTRT, KEND
            DO 110 J = JSTRT, JEND
               JKBCPT = (J-JSTRT+1) + (K-KSTRT)*(JEND-JSTRT+1)
               READ (IRDBC,*,END=900,ERR=910) (QBC(JKBCPT,L),L=1,NQ)
  110       CONTINUE
  120    CONTINUE
C
C     J Direction
C
      ELSE IF (IDIR .EQ. 2) THEN
         WRITE (IOUT,1010) 'I', ISTRT, IEND
         WRITE (IOUT,1010) 'K', KSTRT, KEND
         DO 220 I = ISTRT, IEND
            DO 210 K = KSTRT, KEND
               IKBCPT = (K-KSTRT+1) + (I-ISTRT)*(KEND-KSTRT+1)
               READ (IRDBC,*,END=900,ERR=910) (QBC(IKBCPT,L),L=1,NQ)
  210       CONTINUE
  220    CONTINUE
C
C     K Direction
C
      ELSE IF (IDIR .EQ. 3) THEN
         WRITE (IOUT,1010) 'I', ISTRT, IEND
         WRITE (IOUT,1010) 'J', JSTRT, JEND
         DO 320 I = ISTRT, IEND
            DO 310 J = JSTRT, JEND
               IJBCPT = (J-JSTRT+1) + (I-ISTRT)*(JEND-JSTRT+1)
               READ (IRDBC,*,END=900,ERR=910) (QBC(IJBCPT,L),L=1,NQ)
  310       CONTINUE
  320    CONTINUE
      ELSE
         IERRCD = IYES
         WRITE (IOUT,1200) IDIR
         RETURN
      ENDIF
C
C     Finished reading profile boundary data
      RETURN
C
C 2.   Error handling section
C 2-a. End-Of-File Handler
C
  900 CONTINUE
      IERRCD = IYES
      WRITE (IOUT,1205)
      RETURN
C
C 2-b. Error Handler
C
  910 CONTINUE
      IERRCD = IYES
      WRITE (IOUT,1210)
      RETURN
C
 1010 FORMAT (' ','RDPRFL: Looping over ',A1,' from ',I4,' to ',I4)
 1200 FORMAT (' ','RDPRFL: ERROR-> Invalid direction specified ',I4,
     1       /' ', 8X,'RUN ABORTING!')
 1205 FORMAT (' ','RDPRFL: ERROR-> Unexpected End-Of-File Encountered ',
     1       /' ', 8X,'RUN ABORTING!')
 1210 FORMAT (' ','RDPRFL: ERROR-> Unknown Error Encountered ',
     1       /' ', 8X,'RUN ABORTING!')
C
      END
      SUBROUTINE RDREST (ITURB, IBLOCK, ILVL, IDIM, JDIM, KDIM,
     1                   Q, QN, PROPS, IEOF,  IERRCD)
C
C Routine to read in the restart file for a block.
C
C Note: To read a restart file from ISAAC versions earlier than 3.5.15,
C       set RDPROP = FALSE.
C
C N.B.  QN is converted to PRIMITIVE variables for restart file.
C
C This routine is organized as follows:
C     If (IBLOCK = 1 AND ILVL = 1)
C     {
C        1. Read Residual History Data
C           a. Read input residual history data
C           b. Copy residual history data to output restart file
C           c. Echo residual history to listing
C        2. Read Restart File Header Information
C           a. Number of variables
C           b. Number of properties
C           c. Number of additional time levels and time for unsteady
C     }
C     3. Read Flow Variables and Properties
C        a. Read Flow Variables
C        b. Read Properties
C        c. Read flow variables at additional time levels for unsteady flow
C     4. Error handling section
C        a. End-Of-File Handler
C        b. Error Handler
C
C ITURB          : Turbulence model
C IBLOCK         : Block number
C ILVL           : Grid level
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables stored at cell centers
C QN             : Primitive variables at time levels n, n-1, etc.
C                  N.B. Only NTIME-1 time levels are written/read on restart
C PROPS          : Properties at cell centers
C IEOF           : End-of-file switch
C                  IEOF   = INO  if End-of-file NOT reached
C                  IEOF   = IYES if End-of-file WAS reached
C IERRCD         : Error Code
C                  IERRCD = INO  if NO error reading file
C                  IERRCD = IYES if    error reading file
C
      include 'common.inc'
      include 'histry.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN    (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ,NTIME-1),
     2          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
C Control of whether or not to read properties data and additional time levels
C
      LOGICAL   RDPROP, RDUNST
C
C Initialize error switches
C
      IEOF   = INO
      IERRCD = INO
C
      IF (ITURB  .GE. ITLMNR) THEN
         RDPROP = .TRUE.
      ELSE
         RDPROP = .FALSE.
      ENDIF
C
      IF (ITIMED .EQ. IUNSTD .AND. .NOT.(INITTD)) THEN
         RDUNST = .TRUE.
      ELSE
         RDUNST = .FALSE.
      ENDIF
C
C 1.  Read residual history and file header only for the first block
C
      IF (IBLOCK .EQ. 1 .AND. ILVL .EQ. 1) THEN
C
C     Initial residual output increment
C
         INC   = 1
C
C     Initialize variables in case restart with no residual history data
C
         ITOLD = 0
         R2OLD = 0.E0
         R2ONE = 1.E0
C
C 1-a. Read Residual History Data
C 1-b. Copy Residual History Data to output restart file
C
  100    CONTINUE
         READ (IRDRST,END=900,ERR=910)  IT, R2T
         IF (IT .LE. 0) GO TO 190
         ITOLD  = IT
         R2OLD  = R2T
         IF (IT .LT. MXHIST) THEN
            R2(IT) = R2T
         ELSE
            IERRCD = IYES
         ENDIF
         IF (IT/INC*INC .EQ. IT) THEN
            WRITE (IOUT,1000) IT, R2T
         ENDIF
         IF (IT .GT. 10)  INC = 10
         IF (IT .GT. 100) INC = 100
         GO TO 100
C
C 1-c. Echo the last residual to listing
C
  190    CONTINUE
         ITTOT = ITOLD
         WRITE (IOUT,1000) ITOLD, R2OLD
C
         IF (IERRCD .NE. INO) THEN
            WRITE (IOUT,1010) ITTOT, MXHIST
            RETURN
         ENDIF
C
         R2ONE = R2(1)
C
C 2.   Read Restart File Header Information
C 2-a. NQ
C
         READ (IRDRST,END=900,ERR=910) NQIN
C
         IF (NQIN .NE. NQ) THEN
            WRITE (IOUT,1100) NQIN, NQ
            STOP
         ENDIF
C
C 2-b. NP (not if inviscid)
C
         IF (RDPROP) THEN
            READ (IRDRST,END=900,ERR=910) NPIN
C
            IF (NPIN .NE. NP) THEN
               WRITE (IOUT,1105) NPIN, NP
               STOP
            ENDIF
         ENDIF
C
C 2-c. Number of additional time levels and time for unsteady
C
         IF (RDUNST) THEN
            READ (IRDRST,END=900,ERR=910) NTIMIN
            READ (IRDRST,END=900,ERR=910) TIME
C
            IF (NTIMIN .NE. (NTIME-1)) THEN
               WRITE (IOUT,1110) NTIMIN, NTIME-1
               STOP
            ENDIF
         ENDIF
C
C     End of history and file header section
C
      ENDIF
C
C 3.   Read Flow Variables and Properties
C 3-a. Flow Variables (Q)
C
      READ (IRDRST,END=900,ERR=910) Q
C
C 3-b. Properites (PROPS)
C
      IF (RDPROP) THEN
         READ (IRDRST,END=900,ERR=910) PROPS
      ENDIF
C
C 3-c. Read flow variables at additional time levels for unsteady flow
C
      IF (RDUNST) THEN
         READ (IRDRST,END=900,ERR=910) QN
      ENDIF
C
C     Succesful completion reading restart - return
      RETURN
C
C 4.   Error handling section
C 4-a. End-Of-File Handler
C
  900 CONTINUE
      IEOF   = IYES
      RETURN
C
C 4-b. Error Handler
C
  910 CONTINUE
      IERRCD = IYES
      WRITE (IOUT,1900)
      RETURN
C
 1000 FORMAT (' ','   ITER = ',I5,'   R2 = ',E15.8)
 1010 FORMAT (' ','RDREST: ERROR-> Length of residual history in ',
     1            'restart file (ITTOT) ',I6,
     2       /' ',15X,' exceeds maximum allocated      (MXHIST ',
     3            'in hstry.h) ',I6,
     4       /' ',15X,' Increase MXHIST to be greater than ',
     5                'ITTOT + NITS and recompile.',
     6       /' ', 8X,'RUN ABORTING!')
 1100 FORMAT (' ','RDREST: ERROR-> Number of variables  (NQ) in ',
     1            'restart file',I5,
     2       /' ',15X,' does not match number specified for run  ',I5,
     3       /' ', 8X,'Check input for incorrect model and resubmit.',
     4       /' ', 8X,'RUN ABORTING!')
 1105 FORMAT (' ','RDREST: ERROR-> Number of properties (NP) in ',
     1            'restart file',I5,
     2       /' ',15X,' does not match number specified for run  ',I5,
     3       /' ', 8X,'Check input for incorrect model and resubmit.',
     4       /' ', 8X,'RUN ABORTING!')
 1110 FORMAT (' ','RDREST: ERROR-> Number of additional time levels ',
     1            '(NTIME-1) in restart file',I5,
     2       /' ',15X,' does not match number specified for run  ',I5,
     3       /' ', 8X,'This may be caused by attempting to read a ',
     4                'steady restart file',
     5       /' ', 8X,'without specifying the INITIALIZE TIME ',
     6                'DEPENDENT input option to ',
     7       /' ', 8X,'convert to an unsteady solution.',
     7      //' ', 8X,'Check input for incorrect scheme and resubmit.',
     8       /' ', 8X,'RUN ABORTING!')
 1900 FORMAT (' ','RDREST: ERROR-> Unclassifiable error reading ',
     1            'restart file.',
     2       /' ', 8X,'Check specified restart file and retry.',
     3       /' ', 8X,'RUN ABORTING!')
      END
      SUBROUTINE SFHT  (IDIM, JDIM, KDIM, IPSTRT, IPEND, ITURB,
     1                  Q, PROPS, S, VOL, IBCDAT, RC, IBLOCK)
C
C Routine to output the skin friction, heat transfer, and boundary layer
C quantities.
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C ITURB          : Turbulence model
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C S              : Metrics
C VOL            : Cell volumes
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C RC             : Cell center grid
C IBLOCK         : Block number to identify output
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          RC    (JDIM+1,KDIM+1,IDIM+1,3)
C
      DIMENSION IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C Set control for higher order evaluation of du/dn and dT/dn
C     IHIORD = 0 for first  order
C     IHIORD = 1 for second order
C
      IHIORD = 1
C
C Output headers
C
      IF (IHIORD .EQ. 0) THEN
         WRITE (IOUT,1000) IBLOCK, '1st'
      ELSE
         WRITE (IOUT,1000) IBLOCK, '2nd'
      ENDIF
      WRITE (IOUT,1005)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = MAX (IBCDAT(4), IPSTRT)
      IEND (1) = MIN (IBCDAT(5), IPEND)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCN2  = 3
         IBCM   = 1
         IBCEND = IJKDIM(IDIR) + 1
         IBCINC = 1
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
         IBCM   = IJKDIM(IDIR)
         IBCEND = 1
         IBCINC = - 1
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2. Loop over all points on the boundary surface and calculate skin friction,
C    heat transfer, and boundary layer quantities for output.
C
      DO 220 I2 = ISTRT(IC2), IEND(IC2)
         DO 210 I3 = ISTRT(IC3), IEND(IC3)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IBC2 = IBCPT2*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC2 = IBCPT2*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC2 = IBCPT2*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN   = IBCN  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN   = IBCN  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN   = IBCN  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IN2  = IBCN2 *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JN2  = IBCN2 *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KN2  = IBCN2 *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            RHOW = Q(JBC,KBC,IBC,1)
            RHON = Q(JN ,KN ,IN ,1)
            RHON2= Q(JN2,KN2,IN2,1)
C
            PW   = Q(JBC,KBC,IBC,5)
            PN   = Q(JN ,KN ,IN ,5)
            PN2  = Q(JN2,KN2,IN2,5)
C
C Calculate T = T / TINF  at the wall and cell center off the wall
C
            TBC  = GAMMA * PW  / RHOW
            TN   = GAMMA * PN  / RHON
            TN2  = GAMMA * PN2 / RHON2
C
C Calculate the velocity parallel to the wall at the two cell centers off
C the wall (to allow for second order accurate expressions).
C UBAR = U(parallel) = U - UDOTN where U is the total velocity vector
C and UDOTN is the velocity at the cell center normal to the wall.
C (Velocity on the wall should be identically zero)
C
            UDOTN  = S(JM,KM,IM,1,IDIR) * Q(JN ,KN ,IN ,2)
     1             + S(JM,KM,IM,2,IDIR) * Q(JN ,KN ,IN ,3)
     2             + S(JM,KM,IM,3,IDIR) * Q(JN ,KN ,IN ,4)
            UBARN  = SQRT (
     1               (Q(JN ,KN ,IN ,2) - UDOTN *S(JM,KM,IM,1,IDIR))**2
     2             + (Q(JN ,KN ,IN ,3) - UDOTN *S(JM,KM,IM,2,IDIR))**2
     3             + (Q(JN ,KN ,IN ,4) - UDOTN *S(JM,KM,IM,3,IDIR))**2 )
C
            UDOTN2 = S(JM,KM,IM,1,IDIR) * Q(JN2,KN2,IN2,2)
     1             + S(JM,KM,IM,2,IDIR) * Q(JN2,KN2,IN2,3)
     2             + S(JM,KM,IM,3,IDIR) * Q(JN2,KN2,IN2,4)
            UBARN2 = SQRT (
     1               (Q(JN2,KN2,IN2,2) - UDOTN2*S(JM,KM,IM,1,IDIR))**2
     2             + (Q(JN2,KN2,IN2,3) - UDOTN2*S(JM,KM,IM,2,IDIR))**2
     3             + (Q(JN2,KN2,IN2,4) - UDOTN2*S(JM,KM,IM,3,IDIR))**2 )
C
C Viscosity (RMUW) at the wall and the cell center
C
            RMUW   = PROPS(JBC,KBC,IBC,1)
            RMUN   = PROPS(JN, KN ,IN ,1)
C
C Distances
C
            DN     = SQRT ( (RC(JN ,KN ,IN ,1) - RC(JBC,KBC,IBC,1))**2
     1                    + (RC(JN ,KN ,IN ,2) - RC(JBC,KBC,IBC,2))**2
     2                    + (RC(JN ,KN ,IN ,3) - RC(JBC,KBC,IBC,3))**2 )
C
            DN2    = SQRT ( (RC(JN2,KN2,IN2,1) - RC(JN ,KN ,IN ,1))**2
     1                    + (RC(JN2,KN2,IN2,2) - RC(JN ,KN ,IN ,2))**2
     2                    + (RC(JN2,KN2,IN2,3) - RC(JN ,KN ,IN ,3))**2 )
C
C Calculate first derivative terms using first or second order differencing
C
            DUDN   = (1-IHIORD) * (UBARN      / DN)
     1               +  IHIORD  * (- DN*DN*UBARN2 + (DN+DN2)**2*UBARN)
     2                            / (DN*DN2*(DN+DN2))
            DTDN   = (1-IHIORD) * ((TN - TBC) / DN)
     1               +  IHIORD  * (- DN*DN*TN2 + (DN+DN2)**2*TN
     2                             - DN2*(2.E0*DN+DN2)*TBC)
     3                            / (DN*DN2*(DN+DN2))
C
C Pressure Coefficients Pw/Qinf =  P_w          / ( 1/2 * rhoinf * uinf ** 2 )
C                       Cp      = (P_w - P_inf) / ( 1/2 * rhoinf * uinf ** 2 )
C
            PWQINF =  PW         * 2.E0 / ( FSMACH * FSMACH )
            CP     = (PW - PREF) * 2.E0 / ( FSMACH * FSMACH )
C
C Find the maximum velocity magnitude in the profile
C
            UMAX   = 0.E0
CDIR$ IVDEP
            DO 100 I1 = IBCPT, IBCEND, IBCINC
C
               II   = I1    *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JJ   = I1    *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KK   = I1    *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               UMAG = SQRT ( Q(JJ,KK,II,2) * Q(JJ,KK,II,2) +
     1                       Q(JJ,KK,II,3) * Q(JJ,KK,II,3) +
     2                       Q(JJ,KK,II,4) * Q(JJ,KK,II,4) )
               UMAX = MAX  ( UMAX, UMAG )
  100       CONTINUE
C
C Calculate the edge velocity.  Based on Chris Rumsey's notes with the
C following assumptions:
C      1. H   = H_inf
C      2. P   = P_wall
C      3. Isentropic from edge to wall to get density
C      4. TKE = TKE_inf
C If these assumptions result in imaginary UE, then set UE to UMAX
C
            HEDGE  = EINF + PREF / RHOINF
            PEDGE  = PW
            RHOEDG = RHOINF * (PEDGE / PREF)**(1.E0/GAMMA)
            TKEDGE = TKEINF
C
            ARGUE  = 2.E0*(HEDGE - GAMMA/GAMM1*PEDGE/RHOEDG - TKEDGE)
            IF (ARGUE .LE. 0.E0) THEN
               UE  = UMAX
            ELSE
               UE  = SQRT (ARGUE)
            ENDIF
C
C Make sure that UE is bounded by UMAX
C
            UE     = MIN (UE, UMAX)
C
C Skin Friction Cf      = Tau_wall / ( 1/2 * rho_inf  * u_inf  ** 2 )
C               Cf_edge = Tau_wall / ( 1/2 * rho_edge * u_edge ** 2 )
C
            IF ( IFWALF ) THEN
               TAUW   = PROPS (JBC2,KBC2,IBC2,ITQTAU)
            ELSE
               TAUW   = RMUW * DUDN
            ENDIF
            CF     = 2.E0 * TAUW / ( RE * FSMACH )
            CFEDGE = CF * (RHOINF/RHOEDG) * (FSMACH/UE)**2
C
C Heat Transfer Ch      = Qdot_wall / ( rho_inf  * u_inf  * (H_inf  - H_wall) )
C               Ch_edge = Qdot_wall / ( rho_edge * u_edge * (H_edge - H_wall) )
C
            IF ( IFWALF ) THEN
               QW     = PROPS (JBC2,KBC2,IBC2,ITQDOT)
            ELSE
               QW     = RMUW * DTDN / PR
            ENDIF
            DENOM = RE*(1.E0-TWALL/TINF+0.5E0*GAMM1*FSMACH*FSMACH)
C
C Check to see if can be non-dimensionalized this way
C
            IF (DENOM .EQ. 0.E0) THEN
               CH     = RMAX
               CHEDGE = RMAX
            ELSE
               CH     = QW / DENOM
               CHEDGE = CH * (RHOINF/RHOEDG) * (FSMACH/UE)**2
            ENDIF
C
C Ustar / ainf = sqrt (Tauwall / rho) * sqrt (Minf / Re)
C
            USTAR = SQRT (ABS(TAUW) / RHOW) * SQRT (FSMACH / RE)
C
C Yplus = y ustar / nu : ustar = sqrt (Tauwall / rho)
C
            YPLUS = PROPS(JN ,KN ,IN ,3)
C
C Calculate boundary layer data:
C 1. Find the boundary layer edge defined as:
C    i.   location where U = .995 U_edge
C 2. Integrate using trapezoidal rule to find:
C    i.   boundary layer thickness (DELTA)
C    ii.  displacement thickness   (DSTAR)
C    iii. momentum thickness       (THETA)
C Formulas for DELTA, DSTAR, THETA from White, 'Viscous Fluid Flow', p.606
C
C JEDGE is the last cell-center before the boundary layer edge
C
            UEDGE  = .995E0 * UE
            DELTA  = 0.E0
            DSTAR  = 0.E0
            THETA  = 0.E0
CDIR$ IVDEP
            DO 110 I1 = IBCPT, IBCEND, IBCINC
C
               II    = I1    *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
               JJ    = I1    *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
               KK    = I1    *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
               IP    = II + IBCINC*IKD(IC1,1)
               JP    = JJ + IBCINC*IKD(IC1,2)
               KP    = KK + IBCINC*IKD(IC1,3)
C
               U     = SQRT ( Q(JJ,KK,II,2) * Q(JJ,KK,II,2) +
     1                        Q(JJ,KK,II,3) * Q(JJ,KK,II,3) +
     2                        Q(JJ,KK,II,4) * Q(JJ,KK,II,4) )
               UP    = SQRT ( Q(JP,KP,IP,2) * Q(JP,KP,IP,2) +
     1                        Q(JP,KP,IP,3) * Q(JP,KP,IP,3) +
     2                        Q(JP,KP,IP,4) * Q(JP,KP,IP,4) )
               IF (U  .LT. UEDGE .AND. UP .GE. UEDGE) THEN
                  I1EDGE = I1
                  GO TO 119
               ENDIF
C
               DY    = SQRT ( (RC(JP,KP,IP,1)-RC(JJ,KK,II,1))**2
     1                      + (RC(JP,KP,IP,2)-RC(JJ,KK,II,2))**2
     2                      + (RC(JP,KP,IP,3)-RC(JJ,KK,II,3))**2 )
C
               U     = U  / FSMACH
               UP    = UP / FSMACH
               RHOU  = Q(JJ,KK,II,1) * U
               RHOUP = Q(JP,KP,IP,1) * UP
C
               DELTA = DELTA + DY
               DSTAR = DSTAR + 0.5E0 * ( (1.E0 - RHOU)
     1                                 + (1.E0 - RHOUP) )*DY
               THETA = THETA + 0.5E0 * ( (1.E0 - U) * RHOU
     1                                 + (1.E0 - UP)* RHOUP )*DY
  110       CONTINUE
C
C Could not find bl edge.  Output error.
C
            DELTA  = - RMAX
            DSTAR  = - RMAX
            THETA  = - RMAX
C
  119       CONTINUE
C
C Output Cf, Ch, Cp, Delta, Delta*, Theta
C
  209       CONTINUE
            WRITE (IOUT,1010) IBC, JBC, KBC, RC(JBC,KBC,IBC,1),
     1                        RC(JBC,KBC,IBC,2), RC(JBC,KBC,IBC,3),
     2                        PWQINF, CP, CF, CFEDGE, CH, CHEDGE, DN,
     3                        YPLUS, USTAR, DELTA, DSTAR, THETA, UE
  210    CONTINUE
  220 CONTINUE
C
C Finished with Skin Friction and Heat Transfer
      RETURN
 1000 FORMAT (//' ',' Surface Data for BLOCK ',I5,10X,'(',A,
     1              ' Order accurate derivatives)')
 1005 FORMAT ( /' ',3X,'I',3X,'J',3X,'K',6X,'X',12X,'Y',12X,'Z',9X,
     1              'Pw/Qinf',8X,'Cp',11X,'Cf',9X,'Cf_edge',8X,
     2              'Ch',9X,'Ch_edge',8X,'DN',10X,'Yplus',8X,'Ustar',8X,
     3              'Delta',8X,'Delta*',7X,'Theta',8X,'U_edge'/)
 1010 FORMAT (' ',3I4,16(1PE13.5))
      END
      SUBROUTINE xSFHTJ (IDIM, JDIM, KDIM, IPSTRT, IPEND, ITURB,
     1                  Q, PROPS, S, VOL, IBCDAT, RC, IBLOCK)
C
C Routine to calculate the skin friction and heat transfer using
C the thin layer Navier-Stokes assumption for the J direction.
C
C This routine is not presently suited for the multiblock
C approach.  It is close to being ready but is not.  The problem
C lies that the metrics for one cell into the adjacent block
C are needed to be completely general.  These are currently not available.
C The routine metbc needs to be completed.
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C ITURB          : Turbulence model
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C S              : Metrics
C VOL            : Cell volumes
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C RC             : Cell center grid
C IBLOCK         : Block number to identify output
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          RC    (JDIM+1,KDIM+1,IDIM+1,3)
C
      DIMENSION IBCDAT(10)
C
C Store boundary condition data in mnemonic names
C
      IBCTYP = IBCDAT(1)
      IDIR   = IBCDAT(2)
      INROUT = IBCDAT(3)
      ISTRT  = MAX (IBCDAT(4), IPSTRT)
      IEND   = MIN (IBCDAT(5), IPEND)
      JSTRT  = IBCDAT(6)
      JEND   = IBCDAT(7)
      KSTRT  = IBCDAT(8)
      KEND   = IBCDAT(9)
C
      WRITE (IOUT,1000) IBLOCK
      WRITE (IOUT,1005)
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBC  is the boundary condition location
C      IBC2 is the boundary condition location outside the block from IBC
C      IN   is the point to the inside of the block from IBC
C      IM   is the location of the metrics
C
C J Direction
C
      IF (IDIR .EQ. 2) THEN
         IF (INROUT .EQ. 1) THEN
            JBC  = 1
            JBC2 = 0
            JN   = 2
            JM   = 1
            JMP1 = 2
            JBEG = 1
            JEND = JDIM + 1
            JINC = 1
         ELSE
            JBC  = JDIM + 1
            JBC2 = JDIM + 2
            JN   = JDIM
            JM   = JDIM
            JMP1 = JDIM - 1
            JBEG = JDIM + 1
            JEND = 1
            JINC = -1
         ENDIF
C
C Loop over the J = JBC plane
C
         DO 220 I = ISTRT, IEND
            DO 210 K = KSTRT, KEND
C
C Calculate T = T / TINF  at the wall and cell center off the wall
C
               TBC = GAMMA * Q(JBC,K,I,5) / Q(JBC,K,I,1)
               TN  = GAMMA * Q(JN,K,I,5) / Q(JN,K,I,1)
C
C Calculate the velocity parallel to the wall at
C the cell center off the wall.
C U(parallel) = U - UBAR where U is the total velocity vector
C and UBAR is the velocity normal to the wall.
C (Velocity on the wall should be identically zero)
C
               UBARN = S(JM,K,I,1,2) * Q(JN,K,I,2)
     1               + S(JM,K,I,2,2) * Q(JN,K,I,3)
     2               + S(JM,K,I,3,2) * Q(JN,K,I,4)
               VELN  = SQRT ( (Q(JN,K,I,2) - UBARN*S(JM,K,I,1,2))**2
     1                      + (Q(JN,K,I,3) - UBARN*S(JM,K,I,2,2))**2
     2                      + (Q(JN,K,I,4) - UBARN*S(JM,K,I,3,2))**2 )
C
C Viscosity (RMUW) at the wall and the cell center
C
               RMUW = PROPS(JBC,K,I,1)
               RMUN = PROPS(JN, K,I,1)
C
C Average metrics and cell volume
C
               VOLAUX = 0.5E0 * VOL(JMP1,K,I)
               SPJ1   = 0.5E0 * ( S(JMP1,K,I,1,2)*S(JMP1,K,I,4,2)
     1                          + S(JM,K,I,1,2)*S(JM,K,I,4,2) )
               SPJ2   = 0.5E0 * ( S(JMP1,K,I,2,2)*S(JMP1,K,I,4,2)
     1                          + S(JM,K,I,2,2)*S(JM,K,I,4,2) )
               SPJ3   = 0.5E0 * ( S(JMP1,K,I,3,2)*S(JMP1,K,I,4,2)
     1                          + S(JM,K,I,3,2)*S(JM,K,I,4,2) )
               SMJ1   = S(JM,K,I,1,2)*S(JM,K,I,4,2)
               SMJ2   = S(JM,K,I,2,2)*S(JM,K,I,4,2)
               SMJ3   = S(JM,K,I,3,2)*S(JM,K,I,4,2)
C
C Calculate first derivative terms using Divergence Theorem
C
               DVELDX = VELN*SPJ1 / VOLAUX
               DVELDY = VELN*SPJ2 / VOLAUX
               DVELDZ = VELN*SPJ3 / VOLAUX
               DTDX   = (TN*SPJ1 - TBC*SMJ1) / VOLAUX
               DTDY   = (TN*SPJ2 - TBC*SMJ2) / VOLAUX
               DTDZ   = (TN*SPJ3 - TBC*SMJ3) / VOLAUX
C
C Pressure Coefficients Pw/Qinf =  P_w          / ( 1/2 * rhoinf * uinf ** 2 )
C                       Cp      = (P_w - P_inf) / ( 1/2 * rhoinf * uinf ** 2 )
C
               PW     = Q(JBC,K,I,5)
               PWQINF =  PW         * 2.E0 / ( FSMACH * FSMACH )
               CP     = (PW - PREF) * 2.E0 / ( FSMACH * FSMACH )
C
C Calculate the edge velocity.  Based on Chris Rumsey's notes with the
C following assumptions:
C      1. H   = H_inf
C      2. P   = P_wall
C      3. Isentropic from edge to wall to get density
C      4. TKE = TKE_inf
C
               HEDGE  = EINF + PREF / RHOINF
               PEDGE  = PW
               RHOEDG = RHOINF * (PEDGE / PREF)**(1.E0/GAMMA)
               TKEDGE = TKEINF
C
               ARGUE  = 2.E0*(HEDGE - GAMMA/GAMM1*PEDGE/RHOEDG - TKEDGE)
               IF (ARGUE .LE. 0.E0) THEN
                  UE     = FSMACH
               ELSE
                  UE     = SQRT (ARGUE)
               ENDIF
C
C Skin Friction Cf      = Tau_wall / ( 1/2 * rho_inf  * u_inf  ** 2 )
C               Cf_edge = Tau_wall / ( 1/2 * rho_edge * u_edge ** 2 )
C
               DVELDN = DVELDX * S(JM,K,I,1,2) + DVELDY * S(JM,K,I,2,2)
     1                + DVELDZ * S(JM,K,I,3,2)
               IF ( IFWALF ) THEN
                  TAUW   = PROPS (JBC2,K,I,ITQTAU)
               ELSE
                  TAUW   = RMUW * DVELDN
               ENDIF
               CF     = 2.E0 * TAUW / ( RE * FSMACH )
               CFEDGE = CF * (RHOINF/RHOEDG) * (FSMACH/UE)**2
C
C Heat Transfer Ch      = Qdot_wall / ( rho_inf  * u_inf  * (H_inf  - H_wall) )
C               Ch_edge = Qdot_wall / ( rho_edge * u_edge * (H_edge - H_wall) )
C
               DTDN  = DTDX * S(JM,K,I,1,2) + DTDY * S(JM,K,I,2,2)
     1               + DTDZ * S(JM,K,I,3,2)
               IF ( IFWALF ) THEN
                  QW     = PROPS (JBC2,K,I,ITQDOT)
               ELSE
                  QW     = RMUW * DTDN / PR
               ENDIF
               DENOM = RE*(1.E0-TWALL/TINF+0.5E0*GAMM1*FSMACH*FSMACH)
C
C Check to see if can be non-dimensionalized this way
C
               IF (DENOM .EQ. 0.E0) THEN
                  CH     = RMAX
                  CHEDGE = RMAX
               ELSE
                  CH     = QW / DENOM
                  CHEDGE = CH * (RHOINF/RHOEDG) * (FSMACH/UE)**2
               ENDIF
C
C Ustar / ainf = sqrt (Tauwall / rho) * sqrt (Minf / Re)
C
               USTAR = SQRT (TAUW / Q(JBC,K,I,1)) *
     1                 SQRT (FSMACH / RE)
C
C Yplus = y ustar / nu : ustar = sqrt (Tauwall / rho)
C
               DN    = VOLAUX / (0.5E0*(S(JMP1,K,I,4,2)+S(JM,K,I,4,2)))
               YPLUS = PROPS(JN,K,I,3)
C
C Find the boundary layer edge defined as:
C      1. Location where U = .995 U_edge
C JEDGE is the last cell-center before the boundary layer edge
C
               UE     = .995E0 * UE
               DO 110 J = JBEG, JEND-JINC, JINC
                  U  = SQRT ( Q(J     ,K,I,2)*Q(J     ,K,I,2) +
     1                        Q(J     ,K,I,3)*Q(J     ,K,I,3) +
     2                        Q(J     ,K,I,4)*Q(J     ,K,I,4) )
                  UP = SQRT ( Q(J+JINC,K,I,2)*Q(J+JINC,K,I,2) +
     1                        Q(J+JINC,K,I,3)*Q(J+JINC,K,I,3) +
     2                        Q(J+JINC,K,I,4)*Q(J+JINC,K,I,4) )
                  IF (U  .LT. UE .AND. UP .GE. UE) THEN
                     JEDGE = J
                     GO TO 119
                  ENDIF
  110          CONTINUE
C
C Could not find bl edge.  Output error.
C
               DELTA = - RMAX
               DSTAR = - RMAX
               THETA = - RMAX
               GO TO 209
C
C Integrate to find:
C    the boundary layer thickness (DELTA),
C    the displacement thickness (DSTAR),
C    the momentum thickness (THETA),
C using the trapezoidal rule.  Formulas for DELTA, DSTAR, THETA
C given on page 606 of White's 'Viscous Fluid Flow' for compressible fluids.
C
  119          CONTINUE
               DELTA = 0.E0
               DSTAR = 0.E0
               THETA = 0.E0
               DO 120 J = JBEG, JEDGE-JINC, JINC
                  DY    = SQRT ( (RC(J+JINC,K,I,1)-RC(J,K,I,1))**2
     1                         + (RC(J+JINC,K,I,2)-RC(J,K,I,2))**2
     2                         + (RC(J+JINC,K,I,3)-RC(J,K,I,3))**2 )
                  U     = SQRT (Q(J     ,K,I,2)*Q(J     ,K,I,2) +
     1                          Q(J     ,K,I,3)*Q(J     ,K,I,3) +
     2                          Q(J     ,K,I,4)*Q(J     ,K,I,4) )/FSMACH
                  RHOU  = Q(J,K,I,1) * U
                  UP    = SQRT (Q(J+JINC,K,I,2)*Q(J+JINC,K,I,2) +
     1                          Q(J+JINC,K,I,3)*Q(J+JINC,K,I,3) +
     2                          Q(J+JINC,K,I,4)*Q(J+JINC,K,I,4) )/FSMACH
                  RHOUP = Q(J+JINC,K,I,1) * UP
                  DELTA = DELTA + DY
                  DSTAR = DSTAR + 0.5E0 * ( (1.E0 - RHOU)
     1                                    + (1.E0 - RHOUP) )*DY
                  THETA = THETA + 0.5E0 * ( (1.E0 - U) * RHOU
     1                                    + (1.E0 - UP)* RHOUP )*DY
  120          CONTINUE
C
C Add contribution from JEDGE to DELTA to DELTA, DSTAR and THETA
C
               UJE   = SQRT ( Q(JEDGE     ,K,I,2)*Q(JEDGE     ,K,I,2) +
     1                        Q(JEDGE     ,K,I,3)*Q(JEDGE     ,K,I,3) +
     2                        Q(JEDGE     ,K,I,4)*Q(JEDGE     ,K,I,4) )
               UJEP  = SQRT ( Q(JEDGE+JINC,K,I,2)*Q(JEDGE+JINC,K,I,2) +
     1                        Q(JEDGE+JINC,K,I,3)*Q(JEDGE+JINC,K,I,3) +
     2                        Q(JEDGE+JINC,K,I,4)*Q(JEDGE+JINC,K,I,4) )
               FACT  = (UE - UJE) / (UJEP - UJE)
               DY    = FACT *
     1              SQRT ( (RC(JEDGE+JINC,K,I,1)-RC(JEDGE,K,I,1))**2
     2                   + (RC(JEDGE+JINC,K,I,2)-RC(JEDGE,K,I,2))**2
     3                   + (RC(JEDGE+JINC,K,I,3)-RC(JEDGE,K,I,3))**2 )
               RHOU  = Q(JEDGE,K,I,1) * UJE / FSMACH
               RHOE  = (1.E0 - FACT)*Q(JEDGE,K,I,1)
     1                 + FACT*Q(JEDGE+JINC,K,I,1)
               RHOUP = RHOE * UE / FSMACH
               DELTA = DELTA + DY
               DSTAR = DSTAR + 0.5E0 * ( (1.E0 - RHOU)
     1                                 + (1.E0 - RHOUP) )*DY
               THETA = THETA + 0.5E0 * ( (1.E0 - RHOU) * RHOU
     1                                 + (1.E0 - RHOUP)* RHOUP )*DY
C
C Print data
C
  209          CONTINUE
               WRITE (IOUT,1010) I, JBC, K, RC(JBC,K,I,1),
     1                           RC(JBC,K,I,2), RC(JBC,K,I,3),
     2                           PWQINF, CP, CF, CFEDGE, CH, CHEDGE, DN,
     3                           YPLUS, USTAR, DELTA, DSTAR, THETA
  210       CONTINUE
  220    CONTINUE
      ENDIF
C
C Finished with Skin Friction and Heat Transfer
      RETURN
 1000 FORMAT (//' ',' Surface Data for BLOCK ',I5)
 1005 FORMAT ( /' ',3X,'I',3X,'J',3X,'K',6X,'X',12X,'Y',12X,'Z',9X,
     1              'Pw/Qinf',8X,'Cp',11X,'Cf',9X,'Cf_edge',8X,
     2              'Ch',9X,'Ch_edge',8X,'DN',10X,'Yplus',8X,
     3              'Ustar',8X,'Delta',8X,'Delta*',7X,'Theta'/)
 1010 FORMAT (' ',3I4,15(1PE13.5))
      END
      SUBROUTINE WRREST (NXBLKS, NXLVLS, NXPTS,  NXQNPT, NXPPTS,
     1                   NXBCS,  NXSIZE, NXSECT,
     2                   IOFFS,  IOFFQ,  IOFFP,  IOFFQN,
     3                   NBLKS,  NLVLS,  IMODEL, IFDELQ, ITRUN,
     4                   IDIM,   JDIM,   KDIM,
     5                   Q, QN, PROPS, S, VOL, NBCS, IBCDAT,
     6                   RES, QP, QM, DQP, DQM, F, FM, WORKX, STEMP,
     7                   FWRRST, IERRCD)
C
C Routine to write in the restart file for a block.
C
C N.B.  QN is converted to PRIMITIVE variables in restart file.
C       QN is converted back to conserved variables before exiting this
C          routine to continue calculation.
C
C This routine is organized as follows:
C     0. Setup logicals to control additional output to restart file
C     1. Open restart file
C     2. Write (new) Residual History Data
C     3. Write Restart File Header Information
C        a. Number of variables
C        b. Number of properties
C        c. Number of additional time levels and time for unsteady
C     4. For each level and block Write Flow Variables and Properties
C     5. Close restart file
C     6. Error handling section
C
C NXBLKS         : Maximum number of blocks dimensioned in main
C NXLVLS         : Maximum number of grid levels dimensioned in main
C NXPTS          : Maximum number of grid points dimensioned in main
C NXQNPT         : Maximum number of additional time level grid points
C                  dimensioned in main
C NXPPTS         : Maximum number of property points dimensioned in main
C NXBCS          : Maximum number of boundary conditions dimensioned in main
C NXSIZE         : Maximum size of a single block as dimensioned in main
C NXSECT         : Maximum size of a cross section as dimensioned in main
C NBLKS          : Number of blocks
C NLVLS          : Number of grid levels
C IMODEL         : Data controlling turbulence model
C IFDELQ         : Array controlling calculation of delq
C ITRUN          : Number of iterations to write residual history
C IDIM,JDIM,KDIM : Dimensions of each block
C Q              : Primitive variables stored at cell centers
C QN             : Primitive variables at time levels n, n-1, etc.
C                  N.B. Only NTIME-1 time levels are written/read on restart
C PROPS          : Properties at cell centers
C S              : Metrics
C VOL            : Cell volumes
C NBCS           : Number of boundary conditions for each block
C IBCDAT         : Data controlling boundary conditions
C RES,QP,QM,DQP,DQM,F,FM,WORKX,STEMP
C                : Used for temporary space
C FWRRST         : Restart filename
C IERRCD         : Error code
C
      include 'common.inc'
      include 'histry.inc'
C
      DIMENSION IDIM  (NXBLKS,NXLVLS),
     1          JDIM  (NXBLKS,NXLVLS),
     2          KDIM  (NXBLKS,NXLVLS)
C
      DIMENSION IOFFS (NXBLKS,NXLVLS),
     1          IOFFQ (NXBLKS,NXLVLS),
     2          IOFFP (NXBLKS,NXLVLS),
     3          IOFFQN(NXBLKS,NXLVLS)
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NXPTS *NQ),
     1          QN    (NXQNPT*NQ*NTMLVL),
     2          PROPS (NXPPTS*NP),
     3          S     (NXPTS *4*3),
     4          VOL   (NXPTS)
C
      DIMENSION IBCDAT(10,NXBCS,NXBLKS,NXLVLS),
     1          NBCS  (NXBLKS)
C
      DIMENSION RES   (NXSIZE*NQ),
     1          QP    (NXSECT*NQ),
     2          QM    (NXSECT*NQ),
     3          DQP   (NXSECT*NQ),
     4          DQM   (NXSECT*NQ),
     5          F     (NXSECT*NQ),
     6          FM    (NXSECT*NQ),
     7          WORKX (NXSECT*NW),
     8          STEMP (NXSECT)
C
      DIMENSION IFDELQ(NQ)
C
      CHARACTER*80 FWRRST,
     1             FERROR
C
C Control of whether or not to write properties data and additional time levels
C
      LOGICAL   WRPROP, WRUNST
C
C 0.   Setup logicals to control additional output to restart file
C
      ITURB = IMODEL(1)
C
      IF (ITURB  .GE. ITLMNR) THEN
         WRPROP = .TRUE.
      ELSE
         WRPROP = .FALSE.
      ENDIF
C
      IF (ITIMED .EQ. IUNSTD) THEN
         WRUNST = .TRUE.
      ELSE
         WRUNST = .FALSE.
      ENDIF
C
C 1.   Open restart file
C
      IERRCD = INO
      FERROR = FWRRST
      OPEN (IWRRST,FILE=FWRRST,STATUS='UNKNOWN',FORM='UNFORMATTED',
     1             ERR=900)
      REWIND (IWRRST)
C
C 2.   Write (new) Residual History Data
C
      DO 200 IT = 1, ITRUN + ITTOT
         WRITE (IWRRST) IT, R2(IT)
  200 CONTINUE
      ITF = -999
      R2F = -999.99
      WRITE (IWRRST) ITF, R2F
C
C 3.   Write Restart File Header Information
C 3-a. Number of flow variables
C
      WRITE (IWRRST) NQ
C
C 3-b. Number of properties
C
      IF (WRPROP) THEN
         WRITE (IWRRST) NP
      ENDIF
C
C 3-c. Number of additional time levels and time for unsteady
C
      IF (WRUNST) THEN
         WRITE (IWRRST) NTIME-1
         WRITE (IWRRST) TIME
      ENDIF
C
C 4.   For each level and block Write Flow Variables and Properties
C
      WRITE (IOUT,1000)
      DO 420 ILVL = 1, NLVLS
         DO 410 IBLK = 1, NBLKS
            IQ  = IOFFQ (IBLK,ILVL) * NQ          + 1
            IQN = IOFFQN(IBLK,ILVL) * NQ * NTMLVL + 1
            IP  = IOFFP (IBLK,ILVL) * NP          + 1
            IS  = IOFFS (IBLK,ILVL) * 4 * 3       + 1
            IV  = IOFFS (IBLK,ILVL)               + 1
            IF (ITURB .GE. ITLMNR) THEN
               IPSTRT = 1
               IPEND  = IDIM(IBLK,ILVL) + 1
               CALL PRPRTY (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                      KDIM(IBLK,ILVL), IPSTRT, IPEND, NXSECT,
     2                      Q(IQ), PROPS(IP), S(IS), VOL(IV),
     3                      IBCDAT(1,1,IBLK,ILVL), NBCS(IBLK),
     4                      IMODEL, IFDELQ,
     5                      STEMP, QP, F, FM, QM, DQP, DQM, WORKX)
            ENDIF
            IF (ITIMED .EQ. IUNSTD) THEN
               NNPTS = (IDIM(IBLK,ILVL)+3) * (JDIM(IBLK,ILVL)+3) *
     1                 (KDIM(IBLK,ILVL)+3) * (NTIME-1)
               CALL CONC2P (ITURB, NNPTS, QN(IQN), RES)
            ENDIF
C
            WRITE (IOUT,1010) IBLK, ILVL
C
            CALL WRRSTB (ITURB, ITRUN, IBLK, ILVL, IDIM(IBLK,ILVL),
     1                  JDIM(IBLK,ILVL), KDIM(IBLK,ILVL),
     2                  Q(IQ), QN(IQN), PROPS(IP), WRPROP, WRUNST)
C
            IF (ITIMED .EQ. IUNSTD) THEN
               CALL CONP2C (ITURB, NNPTS, QN(IQN), RES)
            ENDIF
  410    CONTINUE
  420 CONTINUE
C
C 5.   Close restart file
C
      CLOSE (IWRRST)
C
C     Finished writing restart file
C
      WRITE (IOUT,1000)
      RETURN
C
C 6.   Error handling section
C
  900 CONTINUE
      IERRCD = IYES
      WRITE (IOUT,1100) FERROR
      RETURN
C
 1000 FORMAT (////' ')
 1010 FORMAT (' ','WRREST: Writing Restart File for Block ',I4,
     1            '    Level ',I4)
 1100 FORMAT (/' ','WRREST: ERROR-> Error opening file ',A80,
     1        /' ', 8X,'RUN ABORTING!')
C
      END
      SUBROUTINE WRRSTB (ITURB, ITER, IBLOCK, ILVL, IDIM, JDIM, KDIM,
     1                   Q, QN, PROPS, WRPROP, WRUNST)
C
C Routine to write the restart data for a block.
C
C N.B.  QN is converted to PRIMITIVE variables for restart file.
C
C This routine is organized as follows:
C     1. Write Flow Variables and Properties
C        a. Write Flow Variables
C        b. Write Properties
C        c. Write flow variables at additional time levels for unsteady flow
C
C ITURB          : Turbulence model
C ITER           : Number of iterations to write residual history
C IBLOCK         : Block number
C ILVL           : Grid level
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables stored at cell centers
C QN             : Primitive variables at time levels n, n-1, etc.
C                  N.B. Only NTIME-1 time levels are written/read on restart
C PROPS          : Properties at cell centers
C WRPROP         : Logical controlling whether to write property data to file
C                  WRPROP = .true.  Write property data
C                         = .false. Do not write property data
C WRUNST         : Logical controlling whether to write unsteady data to file
C                  WRUNST = .true.  Write unsteady data
C                         = .false. Do not write unsteady data
C
      include 'common.inc'
      include 'histry.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN    (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ,NTIME-1),
     2          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
C Control of whether or not to write properties data and additional time levels
C
      LOGICAL   WRPROP, WRUNST
C
C 1.   Write Flow Variables and Properties
C 1-a. Write Flow Variables
C
      WRITE (IWRRST) Q
C
C 1-b. Write Properties
C
      IF (WRPROP) THEN
         WRITE (IWRRST) PROPS
      ENDIF
C
C 1-c. Write flow variables at additional time levels for unsteady flow
C
      IF (WRUNST) THEN
         WRITE (IWRRST) QN
      ENDIF
      RETURN
      END
C
C     Revision 4.2  2001/06/08 04:56:16  jhmorr
C     Added notice
C
C     Revision 4.1  1998/04/14 20:34:58  jhmorr
C     Alpha 4.1.
C
      SUBROUTINE FDS (IFLUX, ITURB, NPTS, QP, QM, S, DQP, DQM, F)
C
C     Routine to calculate interface fluxes by calling the
C     appropriate Flux Difference Splitting scheme.
C
C     IFLUX          : Flux evaluation scheme
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate fluxes on.
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     S              : Metrics
C     DQP,DQM        : Used for temporary storage in FROE
C     F              : Flux at the interface
C
      include 'common.inc'
C
      DIMENSION QP    (NPTS,NQ),
     1          QM    (NPTS,NQ),
     2          S     (NPTS,3),
     3          DQP   (NPTS,NQ),
     4          DQM   (NPTS,NQ),
     5          F     (NPTS,NF)
C
C     Call the appropriate Flux Difference Splitting scheme
C     Temporary storage in FROE:
C        DQP(1)  => TKEP
C        DQP(2)  => TKEM
C        DQP(3)  => HP
C        DQP(4)  => HM
C        DQM     => WORK(1-4)
C
      IF (IFLUX .EQ. IFROE) THEN
         CALL FROE (ITURB, NPTS, QP, QM, S,
     1              DQP(1,1), DQP(1,2), DQP(1,3), DQP(1,4), DQM, F)
      ENDIF
C
C     Finished calculating flux at the interface
      RETURN
      END
      SUBROUTINE FLUX (ITURB, NPTS, Q, S, TKE, H, F)
C
C     Routine to calculate interface fluxes as the full advection flux.
C     This routine calculates the fluxes for the Favre averaged
C     Navier-Stokes equations for inviscid, laminar, algebraic turbulence
C     model, two-equation turbulence model or Reynolds stress turbulence
C     model.  It computes all of the inviscid fluxes for the above models.
C
C     The two-equation and Reynolds stress models need the turbulent kinetic
C     energy (K) in the mean flow equations.  Therefore, this routine is
C     organized into the following sections:
C          1. Calculate Turbulent Kinetic Energy (TKE)
C             a. Inviscid, laminar,
C                algebraic model       => K = 0
C             b. Two-Equation model    => K = K (Q(6))
C             c. Reynolds stress model => K = (Tau_xx+Tau_yy+Tau_zz)/2
C          2. Calculate Total Enthalpy (H)
C             a. Perfect gas    => H = gamma P / (RHO (GAMMA-1)) + (q^2)/2 + K
C          3. Calculate Advection Fluxes for Mean Flow Equations
C          4. Calculate additional Advection Fluxes
C             a. Inviscid, laminar,
C                algebraic model       => No additional fluxes
C             b. Two-Equation model    => Fluxes for K and T2 equations
C             c. Reynolds Stress model => Fluxes for Tau_ij and T2 equations
C
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate fluxes on.
C     Q              : Q at a cell interface to calculate fluxes at
C     S              : Metrics
C     TKE            : Turbulent kinetic energy
C     H              : Total enthalpy
C     F              : Flux at the interface
C
      include 'common.inc'
C
      DIMENSION Q   (NPTS,NQ),
     1          S   (NPTS,3),
     2          TKE (NPTS),
     3          H   (NPTS),
     4          F   (NPTS,NF)
C
C     1. Calculate the Turbulence Kinetic Energy (TKE)
C
C     1-b. Turbulence Kinetic Energy for Two Equation Turbulence models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 100 I = 1, NPTS
            TKE(I) = Q(I,6)
  100    CONTINUE
C
C     1-c. Turbulence Kinetic Energy for Reynolds Stress Turbulence model
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 110 I = 1, NPTS
C
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TKE(I) = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
  110    CONTINUE
C
C     1-a. Turbulence Kinetic Energy = 0 for Inviscid, Laminar and
C          Algebraic Turbulence models
C
      ELSE
         DO 120 I = 1, NPTS
            TKE(I) = 0.E0
  120    CONTINUE
      ENDIF
C
C     2. Calculate Total Enthalpy
C
C     2-a. Perfect Gas
C
      DO 200 I = 1, NPTS
C
         RHO   = Q(I,1)
         U     = Q(I,2)
         V     = Q(I,3)
         W     = Q(I,4)
         P     = Q(I,5)
         H(I)  = GAMMA * P / (RHO * GAMM1)
     1            + 0.5E0 * (U*U + V*V + W*W) + TKE(I)
  200 CONTINUE
C
C     3. Calculate F for Mean Flow Equations at the cell interfaces
C
      DO 300 I = 1, NPTS
C
         RHO   = Q(I,1)
         U     = Q(I,2)
         V     = Q(I,3)
         W     = Q(I,4)
         P     = Q(I,5)
C
         UBAR  = S(I,1)*U + S(I,2)*V + S(I,3)*W
C
C     Calculate F
C     Area term is included in the RESID routine.
C
         F(I,1)  = RHO * UBAR
         F(I,2)  = RHO * UBAR * U + S(I,1) * P
         F(I,3)  = RHO * UBAR * V + S(I,2) * P
         F(I,4)  = RHO * UBAR * W + S(I,3) * P
         F(I,5)  = RHO * UBAR * H(I)
 300  CONTINUE
C
C     4. Calculate Additional Advection Fluxes
C
C     4-a. Inviscid, Laminar, Algebraic Turbulence models => no additional flux
C
C     4-b. Two-Equation Turbulence models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 400 I = 1, NPTS
C
            RHO    = Q(I,1)
            U      = Q(I,2)
            V      = Q(I,3)
            W      = Q(I,4)
C
            T2     = Q(I,7)
C
            UBAR   = S(I,1)*U + S(I,2)*V + S(I,3)*W
C
            F(I,6)  = RHO * UBAR * TKE(I)
            F(I,7)  = RHO * UBAR * T2
  400    CONTINUE
C
C     4-c. Reynolds Stress Turbulence models
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 410 I = 1, NPTS
C
            RHO    = Q(I,1)
            U      = Q(I,2)
            V      = Q(I,3)
            W      = Q(I,4)
C
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            T2     = Q(I,12)
C
            UBAR   = S(I,1)*U + S(I,2)*V + S(I,3)*W
C
            F(I,6)  = RHO * UBAR * TAUXX
            F(I,7)  = RHO * UBAR * TAUYY
            F(I,8)  = RHO * UBAR * TAUZZ
            F(I,9)  = RHO * UBAR * TAUXY
            F(I,10) = RHO * UBAR * TAUXZ
            F(I,11) = RHO * UBAR * TAUYZ
            F(I,12) = RHO * UBAR * T2
  410    CONTINUE
      ENDIF
C
C     Finished calculating full flux at the interface
      RETURN
      END
      SUBROUTINE FDISS (ITURB, NPTS, Q, DQC, S, ALAM, F)
C
C Routine to calculate interface fluxes as the full advection flux.
C This routine calculates the fluxes for the Favre averaged
C Navier-Stokes equations for inviscid, laminar, algebraic turbulence
C model, two-equation turbulence model or Reynolds stress turbulence
C model.  It computes all of the inviscid fluxes for the above models.
C
C The two-equation and Reynolds stress models need the turbulent kinetic
C energy (K) in the mean flow equations.  Therefore, this routine is
C organized into the following sections:
C      1. Calculate artificial dissipation for 2nd or 4th order
C         a. Scalar dissipation
C            i.   Mean flow equations: Inviscid, laminar, algebraic model
C            ii.  Two-equation model
C            iii. Reynolds stress model
C
C ITURB          : Turbulence model
C NPTS           : Size of array to calculate fluxes on.
C Q              : Q at a cell interface to calculate fluxes at
C DQC            : Delta Q conserved at interfaces for dissipation
C                  = 2nd order -> third undivided difference
C                    4th order -> fifth undivided difference
C S              : Metrics
C ALAM           : Eigenvalues (Lambda)
C F              : Flux at the interface
C
      include 'common.inc'
C
      DIMENSION Q   (NPTS,NQ),
     1          DQC (NPTS,NQ),
     2          S   (NPTS,3),
     3          ALAM(NPTS),
     4          F   (NPTS,NF)
C
C 1.   Calculate artificial dissipation for 2nd or 4th order
C 1-a. Scalar dissipation
C 1-a-i.   Mean flow equations: Inviscid, laminar, algebraic model
C
C     IF () THEN
         DO 100 I = 1, NPTS
C
         RHO     = Q(I,1)
         U       = Q(I,2)
         V       = Q(I,3)
         W       = Q(I,4)
         P       = Q(I,5)
C
         UBAR    = S(I,1)*U + S(I,2)*V + S(I,3)*W
         A       = SQRT (GAMMA * P / RHO)
C
         ALAM(I) = ABS(UBAR) + A
C
C      Calculate F = F - F_diss
C      Area term is included in the RESID routine.
C
            F(I,1)  = F(I,1) - ADKP46 * ALAM(I) * DQC(I,1)
            F(I,2)  = F(I,2) - ADKP46 * ALAM(I) * DQC(I,2)
            F(I,3)  = F(I,3) - ADKP46 * ALAM(I) * DQC(I,3)
            F(I,4)  = F(I,4) - ADKP46 * ALAM(I) * DQC(I,4)
            F(I,5)  = F(I,5) - ADKP46 * ALAM(I) * DQC(I,5)
 100     CONTINUE
C
C 1-a-ii.  Two-equation model
C
         IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
            DO 110 I = 1, NPTS
               F(I,6)  = F(I,6) - ADKP46 * ALAM(I) * DQC(I,6)
               F(I,7)  = F(I,7) - ADKP46 * ALAM(I) * DQC(I,7)
 110        CONTINUE
C
C 1-a-iii. Reynolds stress model
C
         ELSE IF (ITURB .EQ. ITRS) THEN
            DO 120 I = 1, NPTS
               F(I, 6)  = F(I, 6) - ADKP46 * ALAM(I) * DQC(I, 6)
               F(I, 7)  = F(I, 7) - ADKP46 * ALAM(I) * DQC(I, 7)
               F(I, 8)  = F(I, 8) - ADKP46 * ALAM(I) * DQC(I, 8)
               F(I, 9)  = F(I, 9) - ADKP46 * ALAM(I) * DQC(I, 9)
               F(I,10)  = F(I,10) - ADKP46 * ALAM(I) * DQC(I,10)
               F(I,11)  = F(I,11) - ADKP46 * ALAM(I) * DQC(I,11)
               F(I,12)  = F(I,12) - ADKP46 * ALAM(I) * DQC(I,12)
 120        CONTINUE
         ENDIF
C     ELSE
C     ENDIF
C
C     Finished calculating artificial dissipation flux at interface
      RETURN
      END
      SUBROUTINE FROE (ITURB, NPTS, QP, QM, S, TKEP, TKEM, HP, HM,
     1                 WORK, F)
C
C     Routine to calculate interface fluxes using Roe's
C     approximate Riemann solver.  This routine calculates the
C     fluxes for the Favre averaged Navier-Stokes equations for inviscid,
C     laminar, algebraic turbulence model, two-equation turbulence model
C     or Reynolds stress turbulence model.  It computes all of the inviscid
C     fluxes for the above models.
C
C     The two-equation and Reynolds stress models need the turbulent kinetic
C     energy (K) in the mean flow equations.  Therefore, this routine is
C     organized into the following sections:
C          1. Calculate Turbulent Kinetic Energy (TKEP,TKEM)
C             a. Inviscid, laminar,
C                algebraic model       => K = 0
C             b. Two-Equation model    => K = K (Q(6))
C             c. Reynolds stress model => K = (Tau_xx+Tau_yy+Tau_zz)/2
C          2. Calculate Total Enthalpy (HP,HM)
C             a. Perfect gas    => H = gamma P / (RHO (GAMMA-1)) + (q^2)/2 + K
C          3. Calculate Advection Fluxes for Mean Flow Equations
C          4. Calculate additional Advection Fluxes
C             a. Inviscid, laminar,
C                algebraic model       => No additional fluxes
C             b. Two-Equation model    => Fluxes for K and T2 equations
C             c. Reynolds Stress model => Fluxes for Tau_ij and T2 equations
C
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate fluxes on.
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     S              : Metrics
C     TKEP,TKEM      : Turbulent kinetic energy for QP,QM
C     HP,HM          : Total enthalpy for QP,QM
C     WORK           : Temporary storage for the terms common to the
C                      T |Lambda| T[-1] DQ term
C     F              : Flux at the interface
C
      include 'common.inc'
C
      DIMENSION QP   (NPTS,NQ),
     1          QM   (NPTS,NQ),
     2          S    (NPTS,3),
     3          TKEP (NPTS),
     4          TKEM (NPTS),
     5          HP   (NPTS),
     6          HM   (NPTS),
     7          WORK (NPTS,4),
     8          F    (NPTS,NF)
C
C     1. Calculate the Turbulence Kinetic Energy (TKEP,TKEM)
C
C     1-b. Turbulence Kinetic Energy for Two Equation Turbulence models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 100 I = 1, NPTS
            TKEP(I) = QP(I,6)
            TKEM(I) = QM(I,6)
  100    CONTINUE
C
C     1-c. Turbulence Kinetic Energy for Reynolds Stress Turbulence model
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 110 I = 1, NPTS
C
            TAUXXP  = QP(I,6)
            TAUYYP  = QP(I,7)
            TAUZZP  = QP(I,8)
            TKEP(I) = 0.5E0 * (TAUXXP + TAUYYP + TAUZZP)
C
            TAUXXM  = QM(I,6)
            TAUYYM  = QM(I,7)
            TAUZZM  = QM(I,8)
            TKEM(I) = 0.5E0 * (TAUXXM + TAUYYM + TAUZZM)
  110    CONTINUE
C
C     1-a. Turbulence Kinetic Energy = 0 for Inviscid, Laminar and
C          Algebraic Turbulence models
C
      ELSE
         DO 120 I = 1, NPTS
            TKEP(I) = 0.E0
            TKEM(I) = 0.E0
  120    CONTINUE
      ENDIF
C
C     2. Calculate Total Enthalpy
C
C     2-a. Perfect Gas
C
      DO 200 I = 1, NPTS
C
         RHOP   = QP(I,1)
         UP     = QP(I,2)
         VP     = QP(I,3)
         WP     = QP(I,4)
         PP     = QP(I,5)
         HP(I)  = GAMMA * PP / (RHOP * GAMM1)
     1            + 0.5E0 * (UP*UP + VP*VP + WP*WP) + TKEP(I)
C
         RHOM   = QM(I,1)
         UM     = QM(I,2)
         VM     = QM(I,3)
         WM     = QM(I,4)
         PM     = QM(I,5)
         HM(I)  = GAMMA * PM / (RHOM * GAMM1)
     1            + 0.5E0 * (UM*UM + VM*VM + WM*WM) + TKEM(I)
  200 CONTINUE
C
C     3. Calculate F for Mean Flow Equations at the cell interfaces
C        using Roe's approximate Riemann Solver
C
      DO 300 I = 1, NPTS
C
C     Calculate F+
C
         RHOP   = QP(I,1)
         UP     = QP(I,2)
         VP     = QP(I,3)
         WP     = QP(I,4)
         PP     = QP(I,5)
C
         UBARP  = S(I,1)*UP + S(I,2)*VP + S(I,3)*WP
C
C     Calculate F-
C
         RHOM   = QM(I,1)
         UM     = QM(I,2)
         VM     = QM(I,3)
         WM     = QM(I,4)
         PM     = QM(I,5)
C
         UBARM  = S(I,1)*UM + S(I,2)*VM + S(I,3)*WM
C
C     Calculate T * ABS(LAMBDA) * T(-1) * DQ
C
         DRHO   = RHOP   - RHOM
         DU     = UP     - UM
         DV     = VP     - VM
         DW     = WP     - WM
         DUBAR  = UBARP  - UBARM
         DP     = PP     - PM
C
         DK     = TKEP(I) - TKEM(I)
C
         RHOMSR = SQRT (RHOM)
         RHOPSR = SQRT (RHOP)
         RHOAV  = RHOMSR + RHOPSR
         UR     = ( RHOMSR*UM + RHOPSR*UP ) / RHOAV
         VR     = ( RHOMSR*VM + RHOPSR*VP ) / RHOAV
         WR     = ( RHOMSR*WM + RHOPSR*WP ) / RHOAV
         UBARR  = S(I,1)*UR + S(I,2)*VR + S(I,3)*WR
         HR     = ( RHOMSR*HM(I)   + RHOPSR*HP(I) )   / RHOAV
C
         TKER   = ( RHOMSR*TKEM(I) + RHOPSR*TKEP(I) ) / RHOAV
C
         QSQR   = UR*UR + VR*VR + WR*WR
         ASQR   = GAMM1 * (HR - 0.5E0*QSQR - TKER)
         AR     = SQRT (ASQR)
         RHOR   = RHOMSR*RHOPSR
C
C     Calculate the eigenvalues.
C
         ALAM1  = ABS (UBARR)
         ALAM4  = ABS (UBARR + AR)
         ALAM5  = ABS (UBARR - AR)
C
C     Entropy Fix: Based on Yee, Warming, and Harten (1985) and Yee ()
C       Apply fix only to acoustic eigenvalues to preserve boundary layer
C       calculations. Avoidance of the carbuncle phenomena requires fix
C       applied to convective eigenvalue also. Details based on conversations
C       with Jeff White.
C       Begin {N.B. Comment out this section to remove the entropy fix
C
         TSTLAM = CNTRPY * (SQRT(QSQR) + AR)
         TSTLAM = MAX (TSTLAM, RSMALL)
         IF (ALAM4 .LT. TSTLAM) ALAM4=0.5E0*(ALAM4*ALAM4/TSTLAM+TSTLAM)
         IF (ALAM5 .LT. TSTLAM) ALAM5=0.5E0*(ALAM5*ALAM5/TSTLAM+TSTLAM)
C
C       End} Entropy Fix
C
C     Temporary constants used in T * ABS(LAMBDA) * T(-1) * DQ term
C
         WORK(I,1) = ALAM1 * (DRHO - DP/ASQR)
         WORK(I,2) = ALAM1 * RHOR
         WORK(I,3) = ALAM4 * 0.5E0 * (DP/ASQR + RHOR*DUBAR/AR)
         WORK(I,4) = ALAM5 * 0.5E0 * (DP/ASQR - RHOR*DUBAR/AR)
C
C     Calculate F = 0.5 * (F+ + F-) - 0.5 * T * ABS(LAMBDA) * T(-1) * DQ
C     Area term is included in the RESID routine.
C
         F(I,1)  = 0.5E0 *
     1             ( RHOP*UBARP
     2             + RHOM*UBARM
     3             - ( WORK(I,1)
     4               + WORK(I,3)
     5               + WORK(I,4) ) )
         F(I,2)  = 0.5E0 *
     1             ( (RHOP*UBARP*UP + S(I,1)*PP)
     2             + (RHOM*UBARM*UM + S(I,1)*PM)
     3             - ( UR * WORK(I,1)
     4               + (DU - S(I,1)*DUBAR) * WORK(I,2)
     5               + (UR + AR*S(I,1))    * WORK(I,3)
     6               + (UR - AR*S(I,1))    * WORK(I,4) ) )
         F(I,3)  = 0.5E0 *
     1             ( (RHOP*UBARP*VP + S(I,2)*PP)
     2             + (RHOM*UBARM*VM + S(I,2)*PM)
     3             - ( VR * WORK(I,1)
     4               + (DV - S(I,2)*DUBAR) * WORK(I,2)
     5               + (VR + AR*S(I,2))    * WORK(I,3)
     6               + (VR - AR*S(I,2))    * WORK(I,4) ) )
         F(I,4)  = 0.5E0 *
     1             ( (RHOP*UBARP*WP + S(I,3)*PP)
     2             + (RHOM*UBARM*WM + S(I,3)*PM)
     3             - ( WR * WORK(I,1)
     4               + (DW - S(I,3)*DUBAR) * WORK(I,2)
     5               + (WR + AR*S(I,3))    * WORK(I,3)
     6               + (WR - AR*S(I,3))    * WORK(I,4) ) )
         F(I,5)  = 0.5E0 *
     1             ( RHOP*UBARP*HP(I)
     2             + RHOM*UBARM*HM(I)
     3             - ( (0.5E0*QSQR + TKER) * WORK(I,1)
     4               + (UR*DU+VR*DV+WR*DW-UBARR*DUBAR+DK)*WORK(I,2)
     5               + (HR + AR*UBARR)    * WORK(I,3)
     6               + (HR - AR*UBARR)    * WORK(I,4) ) )
 300  CONTINUE
C
C     4. Calculate Additional Advection Fluxes
C
C     4-a. Inviscid, Laminar, Algebraic Turbulence models => no additional flux
C
C     4-b. Two-Equation Turbulence models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 400 I = 1, NPTS
C
            RHOP    = QP(I,1)
            UP      = QP(I,2)
            VP      = QP(I,3)
            WP      = QP(I,4)
C
            T2P     = QP(I,7)
C
            UBARP   = S(I,1)*UP + S(I,2)*VP + S(I,3)*WP
C
            RHOM    = QM(I,1)
            UM      = QM(I,2)
            VM      = QM(I,3)
            WM      = QM(I,4)
C
            T2M     = QM(I,7)
C
            UBARM   = S(I,1)*UM + S(I,2)*VM + S(I,3)*WM
C
            DK      = TKEP(I) - TKEM(I)
            DT2     = T2P     - T2M
C
            RHOMSR  = SQRT (RHOM)
            RHOPSR  = SQRT (RHOP)
            RHOAV   = RHOMSR + RHOPSR
            TKER    = ( RHOMSR*TKEM(I) + RHOPSR*TKEP(I) ) / RHOAV
            T2R     = ( RHOMSR*T2M     + RHOPSR*T2P )     / RHOAV
C
            F(I,6)  = 0.5E0 *
     1                ( RHOP*UBARP*TKEP(I)
     2                + RHOM*UBARM*TKEM(I)
     3                - ( TKER * WORK(I,1)
     4                  + DK   * WORK(I,2)
     5                  + TKER * WORK(I,3)
     6                  + TKER * WORK(I,4) ) )
            F(I,7)  = 0.5E0 *
     1                ( RHOP*UBARP*T2P
     2                + RHOM*UBARM*T2M
     3                - ( T2R * WORK(I,1)
     4                  + DT2 * WORK(I,2)
     5                  + T2R * WORK(I,3)
     6                  + T2R * WORK(I,4) ) )
  400    CONTINUE
C
C     4-c. Reynolds Stress Turbulence models
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 410 I = 1, NPTS
C
            RHOP    = QP(I,1)
            UP      = QP(I,2)
            VP      = QP(I,3)
            WP      = QP(I,4)
C
            TAUXXP  = QP(I,6)
            TAUYYP  = QP(I,7)
            TAUZZP  = QP(I,8)
            TAUXYP  = QP(I,9)
            TAUXZP  = QP(I,10)
            TAUYZP  = QP(I,11)
            T2P     = QP(I,12)
C
            UBARP   = S(I,1)*UP + S(I,2)*VP + S(I,3)*WP
C
            RHOM    = QM(I,1)
            UM      = QM(I,2)
            VM      = QM(I,3)
            WM      = QM(I,4)
C
            TAUXXM  = QM(I,6)
            TAUYYM  = QM(I,7)
            TAUZZM  = QM(I,8)
            TAUXYM  = QM(I,9)
            TAUXZM  = QM(I,10)
            TAUYZM  = QM(I,11)
            T2M     = QM(I,12)
C
            UBARM   = S(I,1)*UM + S(I,2)*VM + S(I,3)*WM
C
            DTAUXX  = TAUXXP - TAUXXM
            DTAUYY  = TAUYYP - TAUYYM
            DTAUZZ  = TAUZZP - TAUZZM
            DTAUXY  = TAUXYP - TAUXYM
            DTAUXZ  = TAUXZP - TAUXZM
            DTAUYZ  = TAUYZP - TAUYZM
            DT2     = T2P    - T2M
C
            RHOMSR  = SQRT (RHOM)
            RHOPSR  = SQRT (RHOP)
            RHOAV   = RHOMSR + RHOPSR
            TAUXXR  = ( RHOMSR*TAUXXM + RHOPSR*TAUXXP ) / RHOAV
            TAUYYR  = ( RHOMSR*TAUYYM + RHOPSR*TAUYYP ) / RHOAV
            TAUZZR  = ( RHOMSR*TAUZZM + RHOPSR*TAUZZP ) / RHOAV
            TAUXYR  = ( RHOMSR*TAUXYM + RHOPSR*TAUXYP ) / RHOAV
            TAUXZR  = ( RHOMSR*TAUXZM + RHOPSR*TAUXZP ) / RHOAV
            TAUYZR  = ( RHOMSR*TAUYZM + RHOPSR*TAUYZP ) / RHOAV
            T2R     = ( RHOMSR*T2M    + RHOPSR*T2P )    / RHOAV
C
            F(I,6)  = 0.5E0 *
     1                ( RHOP*UBARP*TAUXXP
     2                + RHOM*UBARM*TAUXXM
     3                - ( TAUXXR * WORK(I,1)
     4                  + DTAUXX * WORK(I,2)
     5                  + TAUXXR * WORK(I,3)
     6                  + TAUXXR * WORK(I,4) ) )
            F(I,7)  = 0.5E0 *
     1                ( RHOP*UBARP*TAUYYP
     2                + RHOM*UBARM*TAUYYM
     3                - ( TAUYYR * WORK(I,1)
     4                  + DTAUYY * WORK(I,2)
     5                  + TAUYYR * WORK(I,3)
     6                  + TAUYYR * WORK(I,4) ) )
            F(I,8)  = 0.5E0 *
     1                ( RHOP*UBARP*TAUZZP
     2                + RHOM*UBARM*TAUZZM
     3                - ( TAUZZR * WORK(I,1)
     4                  + DTAUZZ * WORK(I,2)
     5                  + TAUZZR * WORK(I,3)
     6                  + TAUZZR * WORK(I,4) ) )
            F(I,9)  = 0.5E0 *
     1                ( RHOP*UBARP*TAUXYP
     2                + RHOM*UBARM*TAUXYM
     3                - ( TAUXYR * WORK(I,1)
     4                  + DTAUXY * WORK(I,2)
     5                  + TAUXYR * WORK(I,3)
     6                  + TAUXYR * WORK(I,4) ) )
            F(I,10) = 0.5E0 *
     1                ( RHOP*UBARP*TAUXZP
     2                + RHOM*UBARM*TAUXZM
     3                - ( TAUXZR * WORK(I,1)
     4                  + DTAUXZ * WORK(I,2)
     5                  + TAUXZR * WORK(I,3)
     6                  + TAUXZR * WORK(I,4) ) )
            F(I,11) = 0.5E0 *
     1                ( RHOP*UBARP*TAUYZP
     2                + RHOM*UBARM*TAUYZM
     3                - ( TAUYZR * WORK(I,1)
     4                  + DTAUYZ * WORK(I,2)
     5                  + TAUYZR * WORK(I,3)
     6                  + TAUYZR * WORK(I,4) ) )
            F(I,12) = 0.5E0 *
     1                ( RHOP*UBARP*T2P
     2                + RHOM*UBARM*T2M
     3                - ( T2R * WORK(I,1)
     4                  + DT2 * WORK(I,2)
     5                  + T2R * WORK(I,3)
     6                  + T2R * WORK(I,4) ) )
  410    CONTINUE
C
      ENDIF
C
C     Finished calculating flux at the interface with Roe's scheme
      RETURN
      END
      SUBROUTINE LIMITR (NPTS, DQP, DQM, LIMIT, RKAP, LBEG, LEND,
     1                   IERROR)
C
C The second order limited correction to the first order interpolation
C is calculated by this routine and stored in DQP for the q(+) term and
C DQM for the q(-) term.  Delta(q(i)) = q(i+1) - q(i) is stored in DQP(i)
C on entry.
C
C N.B. The values of DQP(NPTS) and DQM(1) are not defined properly on exit
C as this leads to better vectorization and they are unnecessary.
C
C This routine is organized as follows:
C     0. Set constants for the interpolation
C     1. Venkatakrishnan's limiter
C     2. MinMod limiter
C     3. Smooth limiter
C     4. Unlimited scheme
C     5. Error
C
C NPTS           : Length of array to limit successive values of delta(q)
C DQP,DQM        : Storage for delta q = q(i) - q(i-1) on entry.
C                  Storage of the higher order correction to the
C                  first order scheme on exit
C LIMIT          : Limiter to use for MUSCL interpolation
C                  ILNONE [0] => Unlimited Scheme
C                  ILSMTH [1] => Smooth Limiter
C                  ILMNMD [2] => Minmod Limiter
C                  ILVNKT [3] => Smooth limiter (fixed at kappa = 1/3)
C                           from Venkatakrishnan, AIAA J. Vol. 29 No. 7
C                           also Thomas, J. L., 5th Copper Mtn. Multigrid
C RKAP           : Kappa to use in MUSCL interpolation
C LBEG,LEND      : Starting,stopping equation index for limiting
C IERROR         : Error code
C
      include 'common.inc'
C
      DIMENSION DQP   (NPTS,NQ),
     1          DQM   (NPTS,NQ)
C
C     Functions defining the limiters.
C
      SMOOTH(D1, D2, EP, EPSQ) = ( 2.E0*D1*D2 + EP )
     1                           / ( D1*D1 + D2*D2 + EPSQ )
      RMINMD(D1, D2, B) = 0.5E0 * ( SIGN(1.E0,D1) + SIGN(1.E0,D2) )
     1                          * MIN ( ABS(D1), ABS(B*D2) )
C     RMINMD(D1, D2, B) = SIGN(1.E0, D1) *
C    1      MAX( 0.E0, MIN( D1*SIGN(1.E0,D2), B*D2*SIGN(1.E0,D1) ) )
      SMI(D1, D2, EPSQ) = ( D1*(D2*D2+2.E0*EPSQ)
     1                    + D2*(2.E0*D1*D1+EPSQ) )
     2                / ( 2.E0*D1*D1 - D1*D2 + 2.E0*D2*D2 + 3.E0*EPSQ )
C
C     Initialize error
C
      IERROR = INO
C
C 0.  Set constants for the interpolation.
C
      OMKAP = 1.E0 - RKAP
      OPKAP = 1.E0 + RKAP
C
C 1.  Venkat's Smooth Limiter
C
      IF (LIMIT .EQ. ILVNKT) THEN
C        EPSQ = 1.E-12
         EPSQ = 1.E-8
         DO L = LBEG, LEND
            DO I = 2, NPTS
               XP = SMI( DQP(I-1,L), DQP(I,L),   EPSQ )
               XM = SMI( DQP(I,L),   DQP(I-1,L), EPSQ )
               DQP(I-1,L) = - 0.5E0 * XP
               DQM(I,L)   =   0.5E0 * XM
            END DO
         END DO
C
C 2.  MinMod Limiter
C
      ELSE IF (LIMIT .EQ. ILMNMD) THEN
         B = (3.E0 - RKAP) / (1.E0 - RKAP)
         DO L = LBEG, LEND
            DO I = 2, NPTS
               XM = RMINMD( DQP(I-1,L), DQP(I,L),   B )
               XP = RMINMD( DQP(I,L),   DQP(I-1,L), B )
               DQP(I-1,L) = - 0.25E0 * ( OMKAP*XP + OPKAP*XM )
               DQM(I,L)   =   0.25E0 * ( OMKAP*XM + OPKAP*XP )
            END DO
         END DO
C
C 3.  Smooth Limiter
C
      ELSE IF (LIMIT .EQ. ILSMTH) THEN
      write (iout,'(a)') ' WARNING - THE SMOOTH LIMITER IS UNTESTED '
         EPS   = 1.E-06
         EPSSQ = EPS*EPS
         DO L = LBEG, LEND
            DO I = 2, NPTS
               XP         = DQP(I,L)
               XM         = DQP(I-1,L)
               SM         = SMOOTH (XM, XP, EPS, EPSSQ)
               DQP(I-1,L) = - 0.25E0 * SM *
     1               ( (1.E0 - SM*RKAP)*XP
     2               + (1.E0 + SM*RKAP)*XM )
               DQM(I,L) =     0.25E0 * SM *
     1               ( (1.E0 - SM*RKAP)*XM
     2               + (1.E0 + SM*RKAP)*XP )
            END DO
         END DO
C
C 4.  Unlimited Scheme
C
      ELSE IF (LIMIT .EQ. ILNONE) THEN
         DO L = LBEG, LEND
            DO I = 2, NPTS
               XP         = DQP(I,L)
               XM         = DQP(I-1,L)
               DQP(I-1,L) = - 0.25E0*(OMKAP*XP + OPKAP*XM)
               DQM(I,L)   =   0.25E0*(OMKAP*XM + OPKAP*XP)
            END DO
         END DO
C
C 5.  Error
C
      ELSE
         WRITE (IOUT,1000) LIMIT
         IERROR = IYES
         STOP
      ENDIF
C
C Finished with limiting routine.
      RETURN
 1000 FORMAT(' ','LIMITR  : Invalid value of LIMIT = ',I10,
     1      /' ','Run Aborting.')
      END
      SUBROUTINE MUSCLI (IDIM, JDIM, KDIM, K, IPSTRT, IPEND,
     1                   Q, DQP, DQM, QP, QM,
     2                   IBCDAT, NBCS, IORDER, LIMIT, RKAP)
C
C Routine to do MUSCL interpolation in the I direction. This routine
C interpolates for Q(+,-) on the I faces for i = ipstrt-1, ipend by
C j = 2, jdim on the current K plane.  (IPSTRT and IPEND refer to cell centers,
C therefore the interfaces are from IPSTRT-1 to IPEND.) This allows for greater
C vectorization and also minimizes intermediate storage to a cross section.
C
C Note the beginning and ending indices of the arrays.
C
C This routine is organized as follows:
C     0. Set up beginning/ending indices for first and second order sections
C     1. Calculate Q(+,-)
C        a. First order
C        b. Second order
C           i.   Calculate delta(Q)
C           ii.  Limit delta(Q)
C           iii. Construct Q(+,-)
C     2. Correct wall values of Q(+,-)
C
C IDIM,JDIM,KDIM : Dimensions of current block
C K              : K Plane to do interpolation on
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C Q              : Primitive variables at cell centers
C DQP,DQM        : Storage for delta q = q(i) - q(i-1) and
C                  for the higher order interpolant to be added
C                  to the first order scheme to create QP,QM
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C NBCS           : Number of boundary conditions for current block
C IORDER         : Order of MUSCL interpolation for I direction
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          DQP   (IPSTRT-2:IPEND+1,2:JDIM,NQ),
     2          DQM   (IPSTRT-2:IPEND+1,2:JDIM,NQ),
     3          QP    (IPSTRT-1:IPEND,2:JDIM,NQ),
     4          QM    (IPSTRT-1:IPEND,2:JDIM,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local Storage
C
      LOGICAL   DOFRST,
     1          DOSCND
C
C 0.  Set up beginning/ending indices for first and second order sections
C
      LFOBEG = 0
      LFOEND = -1
      LSOBEG = 1
      LSOEND = NQ
      DOFRST = .FALSE.
      DOSCND = .TRUE.
C
      IF (IORDER .EQ. 1) THEN
         LFOBEG = 1
         LFOEND = NQ
         LSOBEG = 0
         LSOEND = -1
         DOFRST = .TRUE.
         DOSCND = .FALSE.
      ELSE IF (FOTURB) THEN
         LFOBEG = 6
         LFOEND = NQ
         LSOBEG = 1
         LSOEND = 5
         DOFRST = .TRUE.
         DOSCND = .TRUE.
      END IF
C
C 1.  Calculate Q(+,-)
C     Loop over j,i formulating q(extrapolated) - inner loop is over j for
C     maximum vectorization for 2d and planar oriented algorithms. This also
C     results in unit stride. I is stored first so that successive values of
C     i (i = 1,2,3...) are stored together for limiting.
C
C 1-a. First Order
C
      IF (DOFRST) THEN
         DO 130 L = LFOBEG, LFOEND
            DO 120 I = IPSTRT - 1, IPEND
               DO 110 J = 2, JDIM
                  QP(I,J,L) = Q(J,K,I+1,L)
                  QM(I,J,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
      END IF
C
C 1-b. Second Order or Third Order
C 1-b-i. Calculate delta(Q)
C        Calculate delta(q(i)) = q(i+1) - q(i) to formulate q(extrapolated)
C        using limiting.
C
      IF (DOSCND) THEN
         DO 230 L = LSOBEG, LSOEND
            DO 220 I = IPSTRT - 2, IPEND + 1
               DO 200 J = 2, JDIM
                  DQP(I,J,L) = Q(J,K,I+1,L) - Q(J,K,I,L)
  200          CONTINUE
  220       CONTINUE
  230    CONTINUE
C
C     Set delta(q) to 2*delta(q) to adjust for the wall boundary condition
C     being on the wall rather than at a cell center.
C     Set delta(q) = 0 on wall for wall function to adjust for grid spacing.
C
         DO 300 IBC = 1, NBCS
            IBCTYP = IBCDAT(1,IBC)
            IDIR   = IBCDAT(2,IBC)
            IF ( IDIR .EQ. 1 .AND.
     1           ( IBCTYP .EQ. ITAN  .OR. IBCTYP .EQ. IWALL .OR.
     2             IBCTYP .EQ. IWALFN ) ) THEN
               INROUT = IBCDAT(3,IBC)
               JSTRT  = IBCDAT(6,IBC)
               JEND   = IBCDAT(7,IBC)
               KSTRT  = IBCDAT(8,IBC)
               KEND   = IBCDAT(9,IBC)
               IF (INROUT .EQ. 1) THEN
                  IBCPT = 1
               ELSE
                  IBCPT = IDIM
               ENDIF
               FACTR  = 2.E0
               IF (IBCTYP .EQ. IWALFN) FACTR = 0.E0
               IF (IBCPT .GE. IPSTRT-1 .AND. IBCPT .LE. IPEND .AND.
     1                 K .GE. KSTRT    .AND.     K .LE. KEND      ) THEN
                  DO 290 L = LSOBEG, LSOEND
                     DO 280 J = JSTRT, JEND
                        DQP(IBCPT,J,L) = FACTR * DQP(IBCPT,J,L)
  280                CONTINUE
  290             CONTINUE
               ENDIF
            ENDIF
  300    CONTINUE
C
C 1-b-ii.  Limit delta(Q)
C     Limit from i = ipstrt-2 to i = ipend+1 by j = 2 to j = jdim times.
C     DQP is used to pass in the values of delta q.
C     The values of the limited deltas are stored in DQP and DQM.
C     These values not valid at the endpoints of each i line, but are
C     calculated here to maximize vectorization on a ixj plane.
C
         NPTS = ( IPEND - IPSTRT + 4 ) * ( JDIM - 1 )
         CALL LIMITR (NPTS, DQP, DQM, LIMIT, RKAP, LSOBEG, LSOEND,
     1                IERROR)
C
C 1-b-iii. Construct Q(+,-)
C     Calculate q(extrapolated,i+1/2) from q and the limited values of delta(q)
C
         DO 380 L = LSOBEG, LSOEND
            DO 370 I = IPSTRT - 1, IPEND
               DO 360 J = 2, JDIM
                  QP(I,J,L) = Q(J,K,I+1,L) + DQP(I,J,L)
                  QM(I,J,L) = Q(J,K,I,L)   + DQM(I,J,L)
  360          CONTINUE
  370       CONTINUE
  380    CONTINUE
      ENDIF
C
C 2.  Correct wall values of Q(+,-)
C     Fix boundary values of q(extrapolated) due to boundary conditions
C     for either the first order or higher order scheme.
C     WALL boundary condition.  Reset QP(wall)=QM(wall)=Q(wall)
C
      DO 800 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IDIR   = IBCDAT(2,IBC)
         IF ( IDIR .EQ. 1 .AND.
     1        ( IBCTYP .EQ. ITAN  .OR. IBCTYP .EQ. IWALL .OR.
     2          IBCTYP .EQ. IWALFN ) ) THEN
            INROUT = IBCDAT(3,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
            IF (INROUT .EQ. 1) THEN
               IQPM  = 1
               IBCPT = 1
            ELSE
               IQPM  = IDIM
               IBCPT = IDIM + 1
            ENDIF
            IF (IBCPT .GE. IPSTRT-1 .AND. IBCPT .LE. IPEND .AND.
     1              K .GE. KSTRT    .AND.     K .LE. KEND        ) THEN
               DO 790 L = 1, NQ
                  DO 780 J = JSTRT, JEND
                     QP(IQPM,J,L) = Q(J,K,IBCPT,L)
                     QM(IQPM,J,L) = Q(J,K,IBCPT,L)
  780             CONTINUE
  790          CONTINUE
            ENDIF
         ENDIF
  800 CONTINUE
C
C Finished with Q(+/-) calculation for MUSCL scheme in i.
      RETURN
      END
      SUBROUTINE MUSCLJ (IDIM, JDIM, KDIM, I,
     1                   Q, DQP, DQM, QP, QM,
     2                   IBCDAT, NBCS, IORDER, LIMIT, RKAP)
C
C Routine to do MUSCL interpolation in the J direction. This routine
C interpolates for Q(+,-) on the J faces for j = 1, jdim by k = 2, kdim
C on the current I plane. This allows for greater vectorization and also
C minimizes intermediate storage to a cross section.
C
C This routine is organized as follows:
C     0. Set up beginning/ending indices for first and second order sections
C     1. Calculate Q(+,-)
C        a. First order
C        b. Second order
C           i.   Calculate delta(Q)
C           ii.  Limit delta(Q)
C           iii. Construct Q(+,-)
C     2. Correct wall values of Q(+,-)
C
C IDIM,JDIM,KDIM : Dimensions of current block
C I              : I Plane to do interpolation on
C Q              : Primitive variables at cell centers
C DQP,DQM        : Storage for delta q = q(j) - q(j-1) and
C                  for the higher order interpolant to be added
C                  to the first order scheme to create QP,QM
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = j(1 or jdim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C NBCS           : Number of boundary conditions for current block
C IORDER         : Order of MUSCL interpolation for I direction
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION DQP   (0:JDIM+1,2:KDIM,NQ),
     1          DQM   (0:JDIM+1,2:KDIM,NQ),
     2          QP    (JDIM,2:KDIM,NQ),
     3          QM    (JDIM,2:KDIM,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local Storage
C
      LOGICAL   DOFRST,
     1          DOSCND
C
C 0.  Set up beginning/ending indices for first and second order sections
C
      LFOBEG = 0
      LFOEND = -1
      LSOBEG = 1
      LSOEND = NQ
      DOFRST = .FALSE.
      DOSCND = .TRUE.
C
      IF (IORDER .EQ. 1) THEN
         LFOBEG = 1
         LFOEND = NQ
         LSOBEG = 0
         LSOEND = -1
         DOFRST = .TRUE.
         DOSCND = .FALSE.
      ELSE IF (FOTURB) THEN
         LFOBEG = 6
         LFOEND = NQ
         LSOBEG = 1
         LSOEND = 5
         DOFRST = .TRUE.
         DOSCND = .TRUE.
      END IF
C
C 1.  Calculate Q(+,-)
C     Loop over j,k formulating q(extrapolated). J is stored first so that
C     successive values of j (j=1,2,3...) are stored together for limiting.
C
C 1-a. First Order
C
      IF (DOFRST) THEN
         DO 130 L = LFOBEG, LFOEND
            DO 120 K = 2, KDIM
               DO 110 J = 1, JDIM
                  QP(J,K,L) = Q(J+1,K,I,L)
                  QM(J,K,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
      END IF
C
C 1-b. Second Order or Third Order
C 1-b-i. Calculate delta(Q)
C        Calculate delta(q(j)) = q(j+1) - q(j) to formulate q(extrapolated)
C        using limiting.
C
      IF (DOSCND) THEN
         DO 230 L = LSOBEG, LSOEND
            DO 220 K = 2, KDIM
               DO 200 J = 0, JDIM + 1
                  DQP(J,K,L) = Q(J+1,K,I,L) - Q(J,K,I,L)
  200          CONTINUE
  220       CONTINUE
  230    CONTINUE
C
C     Set delta(q) to 2*delta(q) to adjust for the wall boundary condition
C     being on the wall rather than at a cell center.
C     Set delta(q) = 0 on wall for wall function to adjust for grid spacing.
C
         DO 300 IBC = 1, NBCS
            IBCTYP = IBCDAT(1,IBC)
            IDIR   = IBCDAT(2,IBC)
            IF ( IDIR .EQ. 2 .AND.
     1           ( IBCTYP .EQ. ITAN  .OR. IBCTYP .EQ. IWALL .OR.
     2             IBCTYP .EQ. IWALFN ) ) THEN
               INROUT = IBCDAT(3,IBC)
               ISTRT  = IBCDAT(4,IBC)
               IEND   = IBCDAT(5,IBC)
               KSTRT  = IBCDAT(8,IBC)
               KEND   = IBCDAT(9,IBC)
               IF (INROUT .EQ. 1) THEN
                  JBCPT = 1
               ELSE
                  JBCPT = JDIM
               ENDIF
               FACTR  = 2.E0
               IF (IBCTYP .EQ. IWALFN) FACTR = 0.E0
               IF ( I .GE. ISTRT .AND. I .LE. IEND ) THEN
                  DO 290 L = LSOBEG, LSOEND
                     DO 280 K = KSTRT, KEND
                        DQP(JBCPT,K,L) = FACTR * DQP(JBCPT,K,L)
  280                CONTINUE
  290             CONTINUE
               ENDIF
            ENDIF
  300    CONTINUE
C
C 1-b-ii.  Limit delta(Q)
C     Limit from j = 0 to j = jdim+1 by k = 2 to k = kdim times.
C     DQP is used to pass in the values of delta q.
C     The values of the limited deltas are stored in DQP and DQM.
C     These values not valid at the endpoints of each j line, but are
C     calculated here to maximize vectorization on a jxk plane.
C
         NPTS = ( JDIM + 2 ) * ( KDIM - 1 )
         CALL LIMITR (NPTS, DQP, DQM, LIMIT, RKAP, LSOBEG, LSOEND,
     1                IERROR)
C
C     Calculate q(extrapolated,j+1/2) from q and the
C     limited values of delta(q).
C
         DO 380 L = LSOBEG, LSOEND
            DO 370 K = 2, KDIM
               DO 360 J = 1, JDIM
                  QP(J,K,L) = Q(J+1,K,I,L) + DQP(J,K,L)
                  QM(J,K,L) = Q(J,K,I,L)   + DQM(J,K,L)
  360          CONTINUE
  370       CONTINUE
  380    CONTINUE
      ENDIF
C
C 2.  Correct wall values of Q(+,-)
C     Fix boundary values of q(extrapolated) due to boundary conditions
C     for either the first order or higher order scheme.
C     WALL boundary condition.  Reset QP(wall)=QM(wall)=Q(wall)
C
      DO 800 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IDIR   = IBCDAT(2,IBC)
         IF ( IDIR .EQ. 2 .AND.
     1        ( IBCTYP .EQ. ITAN  .OR. IBCTYP .EQ. IWALL .OR.
     2          IBCTYP .EQ. IWALFN ) ) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
            IF (INROUT .EQ. 1) THEN
               JQPM  = 1
               JBCPT = 1
            ELSE
               JQPM  = JDIM
               JBCPT = JDIM + 1
            ENDIF
            IF ( I .GE. ISTRT .AND. I .LE. IEND ) THEN
               DO 790 L = 1, NQ
                  DO 780 K = KSTRT, KEND
                     QP(JQPM,K,L) = Q(JBCPT,K,I,L)
                     QM(JQPM,K,L) = Q(JBCPT,K,I,L)
  780             CONTINUE
  790          CONTINUE
            ENDIF
         ENDIF
  800 CONTINUE
C
C Finished with Q(+/-) calculation for MUSCL scheme in j.
      RETURN
      END
      SUBROUTINE MUSCLK (IDIM, JDIM, KDIM, I,
     1                   Q, DQP, DQM, QP, QM,
     2                   IBCDAT, NBCS, IORDER, LIMIT, RKAP)
C
C Routine to do MUSCL interpolation in the K direction. This routine
C interpolates for Q(+,-) on the K faces for k = 1, kdim by j = 2, jdim
C on the current I plane. This allows for greater vectorization and also
C minimizes intermediate storage to a cross section.
C
C This routine is organized as follows:
C     0. Set up beginning/ending indices for first and second order sections
C     1. Calculate Q(+,-)
C        a. First order
C        b. Second order
C           i.   Calculate delta(Q)
C           ii.  Limit delta(Q)
C           iii. Construct Q(+,-)
C     2. Correct wall values of Q(+,-)
C
C IDIM,JDIM,KDIM : Dimensions of current block
C I              : I Plane to do interpolation on
C Q              : Primitive variables at cell centers
C DQP,DQM        : Storage for delta q = q(k) - q(k-1) and
C                  for the higher order interpolant to be added
C                  to the first order scheme to create QP,QM
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = k(1 or kdim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C NBCS           : Number of boundary conditions for current block
C IORDER         : Order of MUSCL interpolation for I direction
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION DQP   (0:KDIM+1,2:JDIM,NQ),
     1          DQM   (0:KDIM+1,2:JDIM,NQ),
     2          QP    (KDIM,2:JDIM,NQ),
     3          QM    (KDIM,2:JDIM,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local Storage
C
      LOGICAL   DOFRST,
     1          DOSCND
C
C 0.  Set up beginning/ending indices for first and second order sections
C
      LFOBEG = 0
      LFOEND = -1
      LSOBEG = 1
      LSOEND = NQ
      DOFRST = .FALSE.
      DOSCND = .TRUE.
C
      IF (IORDER .EQ. 1) THEN
         LFOBEG = 1
         LFOEND = NQ
         LSOBEG = 0
         LSOEND = -1
         DOFRST = .TRUE.
         DOSCND = .FALSE.
      ELSE IF (FOTURB) THEN
         LFOBEG = 6
         LFOEND = NQ
         LSOBEG = 1
         LSOEND = 5
         DOFRST = .TRUE.
         DOSCND = .TRUE.
      END IF
C
C 1.  Calculate Q(+,-)
C     Loop over j,k formulating q(extrapolated). K is stored first so that
C     successive values of k (k = 1,2,3...) are stored together for limiting.
C
C 1-a. First Order
C
      IF (DOFRST) THEN
         DO 130 L = LFOBEG, LFOEND
            DO 120 J = 2, JDIM
               DO 110 K = 1, KDIM
                  QP(K,J,L) = Q(J,K+1,I,L)
                  QM(K,J,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
      END IF
C
C 1-b. Second Order or Third Order
C 1-b-i. Calculate delta(Q)
C        Calculate delta(q(k)) = q(k+1) - q(k) to formulate q(extrapolated)
C        using limiting.
C
      IF (DOSCND) THEN
         DO 230 L = LSOBEG, LSOEND
            DO 220 J = 2, JDIM
               DO 200 K = 0, KDIM + 1
                  DQP(K,J,L) = Q(J,K+1,I,L) - Q(J,K,I,L)
  200          CONTINUE
  220       CONTINUE
  230    CONTINUE
C
C     Set delta(q) to 2*delta(q) to adjust for the wall boundary condition
C     being on the wall rather than at a cell center.
C     Set delta(q) = 0 on wall for wall function to adjust for grid spacing.
C
         DO 300 IBC = 1, NBCS
            IBCTYP = IBCDAT(1,IBC)
            IDIR   = IBCDAT(2,IBC)
            IF ( IDIR .EQ. 3 .AND.
     1           ( IBCTYP .EQ. ITAN  .OR. IBCTYP .EQ. IWALL .OR.
     2             IBCTYP .EQ. IWALFN ) ) THEN
               INROUT = IBCDAT(3,IBC)
               ISTRT  = IBCDAT(4,IBC)
               IEND   = IBCDAT(5,IBC)
               JSTRT  = IBCDAT(6,IBC)
               JEND   = IBCDAT(7,IBC)
               IF (INROUT .EQ. 1) THEN
                  KBCPT = 1
               ELSE
                  KBCPT = KDIM
               ENDIF
               FACTR  = 2.E0
               IF (IBCTYP .EQ. IWALFN) FACTR = 0.E0
               IF ( I .GE. ISTRT .AND. I .LE. IEND ) THEN
                  DO 290 L = LSOBEG, LSOEND
                     DO 280 J = JSTRT, JEND
                        DQP(KBCPT,J,L) = FACTR * DQP(KBCPT,J,L)
  280                CONTINUE
  290             CONTINUE
               ENDIF
            ENDIF
  300    CONTINUE
C
C 1-b-ii.  Limit delta(Q)
C     Limit from k = 0 to k = kdim+1 by j = 2 to j = jdim times.
C     DQP is used to pass in the values of delta q.
C     The values of the limited deltas are stored in DQP and DQM.
C     These values not valid at the endpoints of each k line, but are
C     calculated here to maximize vectorization on a kxj plane.
C
         NPTS = ( KDIM + 2 ) * ( JDIM - 1 )
         CALL LIMITR (NPTS, DQP, DQM, LIMIT, RKAP, LSOBEG, LSOEND,
     1                IERROR)
C
C 1-b-iii. Construct Q(+,-)
C     Calculate q(extrapolated,k+1/2) from q and the limited values of delta(q)
C
         DO 380 L = LSOBEG, LSOEND
            DO 370 J = 2, JDIM
               DO 360 K = 1, KDIM
                  QP(K,J,L) = Q(J,K+1,I,L) + DQP(K,J,L)
                  QM(K,J,L) = Q(J,K,I,L)   + DQM(K,J,L)
  360          CONTINUE
  370       CONTINUE
  380    CONTINUE
      ENDIF
C
C 2.  Correct wall values of Q(+,-)
C     Fix boundary values of q(extrapolated) due to boundary conditions
C     for either the first order or higher order scheme.
C     WALL boundary condition.  Reset QP(wall)=QM(wall)=Q(wall)
C
      DO 800 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IDIR   = IBCDAT(2,IBC)
         IF ( IDIR .EQ. 3 .AND.
     1        ( IBCTYP .EQ. ITAN  .OR. IBCTYP .EQ. IWALL .OR.
     2          IBCTYP .EQ. IWALFN ) ) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            IF (INROUT .EQ. 1) THEN
               KQPM  = 1
               KBCPT = 1
            ELSE
               KQPM  = KDIM
               KBCPT = KDIM + 1
            ENDIF
            IF ( I .GE. ISTRT .AND. I .LE. IEND ) THEN
               DO 790 L = 1, NQ
                  DO 780 J = JSTRT, JEND
                     QP(KQPM,J,L) = Q(J,KBCPT,I,L)
                     QM(KQPM,J,L) = Q(J,KBCPT,I,L)
  780             CONTINUE
  790          CONTINUE
            ENDIF
         ENDIF
  800 CONTINUE
C
C Finished with Q(+/-) calculation for MUSCL scheme in k.
      RETURN
      END
C
C     Revision 4.2  2001/06/08 04:56:18  jhmorr
C     Added notice
C
C     Revision 4.1  1998/04/14 20:34:58  jhmorr
C     Alpha 4.1.
C
      SUBROUTINE COLQ2H (IDIMF, JDIMF, KDIMF, QF, VOLF,
     1                   IDIMC, JDIMC, KDIMC, QC, VOLC,
     2                   QS, ITURB, TKE)
C
C Routine to collect Q from h grid to 2h grid.  Collection is volume
C weighted summation of conserved variables:
C      QC = sum(QF * VOLF) / VOLC
C
C This routine is organized as follows:
C     1. Convert QF from primitive to conserved variables
C     2. Loop over coarse I and collect in plane to minimize temporary storage
C        a. Sum in the I direction
C        b. If three-dimensional case, sum in K direction (not for 2D or axi)
C        c. Sum in the J direction and calculate QC = sum(QF * VOLF) / VOLC
C     3. Convert QF and from conserved to primitive variables
C
C IDIMF,JDIMF,KDIMF : Fine   grid dimensions
C QF                : Fine   grid variables at cell centers
C VOLF              : Fine   grid volumes
C IDIMC,JDIMC,KDIMC : Coarse grid dimensions
C QC                : Coarse grid variables at cell centers
C VOLC              : Coarse grid volumes
C QS                : Temporary space for forming summation(QF * VOLF)
C ITURB             : Turbulence model
C TKE               : Temporary storage of TKE to convert from primitive to
C                     conserved variables
C
      include 'common.inc'
C
      INTEGER   IDIMF, JDIMF, KDIMF,
     1          IDIMC, JDIMC, KDIMC
C
      DIMENSION QF  (0:JDIMF+2,0:KDIMF+2,0:IDIMF+2,NQ),
     1          VOLF(0:JDIMF+1,0:KDIMF+1,0:IDIMF+1),
     2          QC  (0:JDIMC+2,0:KDIMC+2,0:IDIMC+2,NQ),
     3          VOLC(0:JDIMC+1,0:KDIMC+1,0:IDIMC+1)
C
      DIMENSION QS  (0:JDIMF+2,0:KDIMF+2,NQ),
     1          TKE (0:JDIMF+2,0:KDIMF+2,0:IDIMF+2)
C
C Local variables
C
      INTEGER   I , J , K , L,
     1          IC, JC, KC
C
C 1.   Convert QF from primitive to conserved variables
C
      NPTSF = (IDIMF + 3) * (JDIMF + 3) * (KDIMF + 3)
      CALL CONP2C (ITURB, NPTSF, QF, TKE)
      NPTSC = (IDIMC + 3) * (JDIMC + 3) * (KDIMC + 3)
      CALL CONP2C (ITURB, NPTSC, QC, TKE)
C
C 2.   Loop over coarse I and collect in plane to minimize temporary storage
C
      DO 290 IC = 2, IDIMC
         I = 2 * (IC - 1)
C
C 2-a. Sum in the I direction
C
         DO 215 L = 1, NQ
            DO 210 K = 2, KDIMF
               DO 205 J = 2, JDIMF
                  QS(J,K,L) = QF(J,K,I  ,L) * VOLF(J,K,I  ) +
     1                        QF(J,K,I+1,L) * VOLF(J,K,I+1)
  205          CONTINUE
  210       CONTINUE
  215    CONTINUE
C
C 2-b. If three-dimensional case, sum in K direction (not for 2D or axi)
C      The volume multiplication is handled in the I direction - now just sum.
C
         IF (THREED) THEN
            DO 240 L = 1, NQ
               DO 235 KC = 2, KDIMC
                  K = 2 * (KC - 1)
                  DO 230 J = 2, JDIMF
                     QS(J,KC,L) = QS(J,K,L) + QS(J,K+1,L)
  230             CONTINUE
  235          CONTINUE
  240       CONTINUE
         ENDIF
C
C 2-c. Sum in the J direction and calculate QC = sum(QF * VOLF) / sum(VOLF)
C
         DO 280 L = 1, NQ
            DO 275 KC = 2, KDIMC
               DO 270 JC = 2, JDIMC
                  J = 2 * (JC - 1)
                  QC(JC,KC,IC,L) = (QS(J,KC,L) + QS(J+1,KC,L))
     1                             / VOLC(JC,KC,IC)
  270          CONTINUE
  275       CONTINUE
  280    CONTINUE
C
  290 CONTINUE
C
C 3.   Convert QF and from conserved to primitive variables
C
      CALL CONC2P (ITURB, NPTSF, QF, TKE)
      NPTSC = (IDIMC + 3) * (JDIMC + 3) * (KDIMC + 3)
      CALL CONC2P (ITURB, NPTSC, QC, TKE)
C
C     Finished with collection of Q
      RETURN
      END
      SUBROUTINE COLR2H (IDIMF, JDIMF, KDIMF, RESF,
     1                   IDIMC, JDIMC, KDIMC, RESCRS, RESS)
C
C Routine to collect the residual from h grid to 2h grid to form the coarse
C grid forcing function.  Coarse grid forcing function is:
C      RESCRS = sum(RESF) - RESC
C
C This routine is organized as follows:
C     Loop over coarse I and collect in a plane to minimize temporary storage
C     1. Sum in the I direction
C     2. If three-dimensional case, sum in K direction (not for 2D or axi)
C     3. Sum in the J direction and form RESCRS = sum(RESF) - RESC
C
C IDIMF,JDIMF,KDIMF : Fine   grid dimensions
C RESF              : Fine   grid residual
C IDIMC,JDIMC,KDIMC : Coarse grid dimensions
C RESCRS            : Input  : RES on coarse grid
C                     Returns: coarse grid forcing function
C RESS              : Temporary space for forming summation(RESF)
C
      include 'common.inc'
C
      INTEGER   IDIMF, JDIMF, KDIMF,
     1          IDIMC, JDIMC, KDIMC
C
      DIMENSION RESF  (JDIMF+1,KDIMF+1,IDIMF+1,NF),
     1          RESCRS(JDIMC+1,KDIMC+1,IDIMC+1,NF)
C
      DIMENSION RESS  (JDIMF+1,KDIMF+1,NF)
C
C Local variables
C
      INTEGER   I , J , K , L,
     1          IC, JC, KC
C
C Loop over coarse I and collect in a plane to minimize temporary storage
C
      DO 900 IC = 2, IDIMC
         I = 2 * (IC - 1)
C
C 1.  Sum in the I direction
C
         DO 130 L = 1, NF
            DO 120 K = 2, KDIMF
               DO 110 J = 2, JDIMF
                  RESS(J,K,L) = RESF(J,K,I,L) + RESF(J,K,I+1,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
C
C 2.  If three-dimensional case, sum in K direction (not for 2D or axi)
C
         IF (THREED) THEN
            DO 230 L = 1, NF
               DO 230 KC = 2, KDIMC
                  K = 2 * (KC - 1)
                  DO 210 J = 2, JDIMF
                     RESS(J,KC,L) = RESS(J,K,L) + RESS(J,K+1,L)
  210             CONTINUE
  220          CONTINUE
  230       CONTINUE
         ENDIF
C
C 3.  Sum in the J direction and form RESCRS = sum(RESF) - RESC
C
         DO 330 L = 1, NF
            DO 320 KC = 2, KDIMC
               DO 310 JC = 2, JDIMC
                  J = 2 * (JC - 1)
                  RESCRS(JC,KC,IC,L) = RESS  (J  ,KC,L)
     1                               + RESS  (J+1,KC,L)
C**  2                               - RESCRS(JC ,KC,IC,L)
  310          CONTINUE
  320       CONTINUE
  330    CONTINUE
C
  900 CONTINUE
C
C     Finished with calculating coarse grid forcing function
      RETURN
      END
      SUBROUTINE COLV2H (IDIMF, JDIMF, KDIMF, VOLF,
     1                   IDIMC, JDIMC, KDIMC, VOLC, VOLP)
C
C Routine to collect VOL from h grid to 2h grid. N.B. It is important that
C the coarse grid volumes are calculated as the summation of the fine grid
C volumes so that the volume weighted collection generates a smooth and
C accurate coarse grid representation of the fine grid solution.
C
C This routine is organized as follows:
C     1. Loop over coarse I and collect in plane to minimize temporary storage
C        a. Sum in the I direction
C        b. If three-dimensional case, sum in K direction (not for 2D or axi)
C        c. Sum in the J direction and calculate VOLC = sum(VOLF)
C
C IDIMF,JDIMF,KDIMF : Fine   grid dimensions
C VOLF              : Fine   grid volumes
C IDIMC,JDIMC,KDIMC : Coarse grid dimensions
C VOLC              : Coarse grid volumes
C VOLP              : Temporary space for forming summation(VOLF) in a plane
C
      include 'common.inc'
C
      INTEGER   IDIMF, JDIMF, KDIMF,
     1          IDIMC, JDIMC, KDIMC
C
      DIMENSION VOLF(0:JDIMF+1,0:KDIMF+1,0:IDIMF+1),
     1          VOLC(0:JDIMC+1,0:KDIMC+1,0:IDIMC+1)
C
      DIMENSION VOLP(0:JDIMF+2,0:KDIMF+2)
C
C Local variables
C
      INTEGER   I , J , K ,
     1          IC, JC, KC
C
C 1.   Loop over coarse I and collect in plane to minimize temporary storage
C
      DO 190 IC = 2, IDIMC
         I = 2 * (IC - 1)
C
C 1-a. Sum in the I direction
C
         DO 110 K = 2, KDIMF
            DO 105 J = 2, JDIMF
               VOLP(J,K) = VOLF(J,K,I) + VOLF(J,K,I+1)
  105       CONTINUE
  110    CONTINUE
C
C 1-b. If three-dimensional case, sum in K direction (not for 2D or axi)
C      The volume multiplication is handled in the I direction - now just sum.
C
         IF (THREED) THEN
            DO 135 KC = 2, KDIMC
               K = 2 * (KC - 1)
               DO 130 J = 2, JDIMF
                  VOLP(J,KC) = VOLP(J,K) + VOLP(J,K+1)
  130          CONTINUE
  135       CONTINUE
         ENDIF
C
C 1-c. Sum in the J direction and calculate VOLC = sum(VOLF)
C
         DO 175 KC = 2, KDIMC
            DO 170 JC = 2, JDIMC
               J = 2 * (JC - 1)
               VOLC(JC,KC,IC) = VOLP(J,KC) + VOLP(J+1,KC)
  170       CONTINUE
  175    CONTINUE
C
  190 CONTINUE
C
C     Finished calculating coarse grid volumes
      RETURN
      END
      SUBROUTINE CRSGRD (IDIMF, JDIMF, KDIMF, RF,
     1                   IDIMC, JDIMC, KDIMC, RC)
C
C Routine to form the coarser grid (IDIMC ... RC) by eliminating alternate
C grid points in each direction of the fine grid (IDIMF ... RF)
C
C This routine is organized as follows:
C     1. Loop over the coarse grid, calculate fine grid location, set RC=RF
C
C IDIMF,JDIMF,KDIMF : Fine   grid dimensions
C RF                : Fine   grid postion vector
C IDIMC,JDIMC,KDIMC : Coarse grid dimensions
C RC                : Coarse grid postion vector
C
      include 'common.inc'
C
      DIMENSION RF    (0:JDIMF+1,0:KDIMF+1,0:IDIMF+1,3),
     1          RC    (0:JDIMC+1,0:KDIMC+1,0:IDIMC+1,3)
C
C 1.  Loop over the coarse mesh and set each grid point to be every other
C     grid point in the fine mesh.
C
      DO 130 IC = 1, IDIMC
         IF = 2 * IC - 1
         DO 120 KC = 1, KDIMC
            KF = 2 * KC - 1
            DO 110 JC = 1, JDIMC
               JF = 2 * JC - 1
               RC(JC,KC,IC,1) = RF(JF,KF,IF,1)
               RC(JC,KC,IC,2) = RF(JF,KF,IF,2)
               RC(JC,KC,IC,3) = RF(JF,KF,IF,3)
 110        CONTINUE
 120     CONTINUE
 130  CONTINUE
C
C Finished forming the coarser grid
      RETURN
      END
      SUBROUTINE CRSPRF (NPTSF, QBCF, IBCDTF,
     1                   NPTSC, QBCC, IBCDTC, IERRCD)
C
C Routine to calculate the coarse grid profile data from the fine grid data.
C
C NPTSF             : Number of points in the QBC array on fine grid
C QBCF              : Primitive variables on fine grid
C IBCDTF            : Data controlling boundary conditions on fine grid
C NPTSC             : Number of points in the QBC array on coarse grid
C QBCC              : Primitive variables on coarse grid
C IBCDTC            : Data controlling boundary conditions on coarse grid:
C                     IBCDAT( 1,ibc) = Boundary Condition Type
C                             2      = Direction (1=i, 2=j, 3=k)
C                             3      = i(1 or idim)
C                             4      = istrt
C                             5      = iend
C                             6      = jstrt
C                             7      = jend
C                             8      = kstrt
C                             9      = kend
C                            10      = profile identifier
C IERRCD         : Error Code
C                  IERRCD = INO  if NO storage error or error reading file
C                  IERRCD = IYES if    storage error or error reading file
C
      include 'common.inc'
C
      DIMENSION QBCF  (NPTSF,NQ),
     1          QBCC  (NPTSC,NQ)
C
      DIMENSION IBCDTF(10),
     1          IBCDTC(10)
C
C     Store boundary condition data in mnemonic names
C
      IBCTYP = IBCDTF(1)
      IDIR   = IBCDTF(2)
      INROUT = IBCDTF(3)
      ISTRTF = IBCDTF(4)
      IENDF  = IBCDTF(5)
      JSTRTF = IBCDTF(6)
      JENDF  = IBCDTF(7)
      KSTRTF = IBCDTF(8)
      KENDF  = IBCDTF(9)
C
      ISTRTC = IBCDTC(4)
      IENDC  = IBCDTC(5)
      JSTRTC = IBCDTC(6)
      JENDC  = IBCDTC(7)
      KSTRTC = IBCDTC(8)
      KENDC  = IBCDTC(9)
C
C     I Direction
C
      IF (IDIR .EQ. 1) THEN
         DO 120 KC = KSTRTC, KENDC
            KF = 2 * (KC - 1)
            DO 110 JC = JSTRTC, JENDC
               JF = 2 * (JC - 1)
               JKBCPC = (JC-JSTRTC+1) + (KC-KSTRTC)*(JENDC-JSTRTC+1)
               JKBCPF = (JF-JSTRTF+1) + (KF-KSTRTF)*(JENDF-JSTRTF+1)
               IF (THREED) THEN
                  DO 100 L = 1, NQ
                     QBCC(JKBCPC,L) = 0.25E0 *
     1                             ( QBCF(JKBCPF,L)
     2                             + QBCF(JKBCPF+1,L)
     3                             + QBCF(JKBCPF+(JENDF-JSTRTF+1),L)
     4                             + QBCF(JKBCPF+(JENDF-JSTRTF+1)+1,L) )
  100             CONTINUE
               ELSE
                  DO 105 L = 1, NQ
                     QBCC(JKBCPC,L) = 0.50E0 * (QBCF(JKBCPF,L) +
     1                                          QBCF(JKBCPF+1,L))
  105             CONTINUE
               ENDIF
  110       CONTINUE
  120    CONTINUE
C
C     J Direction
C
      ELSE IF (IDIR .EQ. 2) THEN
         DO 220 IC = ISTRTC, IENDC
            IF = 2 * (IC - 1)
            DO 210 KC = KSTRTC, KENDC
               KF = 2 * (KC - 1)
               IKBCPC = (KC-KSTRTC+1) + (IC-ISTRTC)*(KENDC-KSTRTC+1)
               IKBCPF = (KF-KSTRTF+1) + (IF-ISTRTF)*(KENDF-KSTRTF+1)
               IF (THREED) THEN
                  DO 200 L = 1, NQ
                     QBCC(IKBCPC,L) = 0.25E0 *
     1                             ( QBCF(IKBCPF,L)
     2                             + QBCF(IKBCPF+1,L)
     3                             + QBCF(IKBCPF+(KENDF-KSTRTF+1),L)
     4                             + QBCF(IKBCPF+(KENDF-KSTRTF+1)+1,L) )
  200             CONTINUE
               ELSE
                  DO 205 L = 1, NQ
                     QBCC(IKBCPC,L) = 0.50E0 * (QBCF(IKBCPF,L) +
     1                                          QBCF(IKBCPF+1,L))
  205             CONTINUE
               ENDIF
  210       CONTINUE
  220    CONTINUE
C
C     K Direction
C
      ELSE IF (IDIR .EQ. 3) THEN
         DO 320 IC = ISTRTC, IENDC
            IF = 2 * (IC - 1)
            DO 310 JC = JSTRTC, JENDC
               JF = 2 * (JC - 1)
               IJBCPC = (JC-JSTRTC+1) + (IC-ISTRTC)*(JENDC-JSTRTC+1)
               IJBCPF = (JF-JSTRTF+1) + (IF-ISTRTF)*(JENDF-JSTRTF+1)
               IF (THREED) THEN
                  DO 300 L = 1, NQ
                     QBCC(IJBCPC,L) = 0.25E0 *
     1                             ( QBCF(IJBCPF,L)
     2                             + QBCF(IJBCPF+1,L)
     3                             + QBCF(IJBCPF+(JENDF-JSTRTF+1),L)
     4                             + QBCF(IJBCPF+(JENDF-JSTRTF+1)+1,L) )
  300             CONTINUE
               ELSE
                  DO 305 L = 1, NQ
                     QBCC(IJBCPC,L) = 0.50E0 * (QBCF(IJBCPF,L) +
     1                                          QBCF(IJBCPF+1,L))
  305             CONTINUE
               ENDIF
  310       CONTINUE
  320    CONTINUE
      ELSE
         IERRCD = IYES
         WRITE (IOUT,1200) IDIR
         RETURN
      ENDIF
C
C     Finished reading profile boundary data
      RETURN
C
 1200 FORMAT (' ','CRSPRF: ERROR-> Invalid direction specified ',I4,
     1       /' ', 8X,'RUN ABORTING!')
C
      END
      SUBROUTINE INT2HQ (IDIMC, JDIMC, KDIMC, QC,
     1                   IDIMF, JDIMF, KDIMF, QF)
C
C Routine to interpolate (Prolong) from the coarse grid (IDIMC ... QC)
C to the fine grid (IDIMF ... QF).  Interpolate only the interior, use
C boundary condition routine to set boundaries.
C
C This routine is organized as follows:
C     1. Interpolate in the J direction
C     2. Interpolate in the I direction
C     3. If 3D, interpolate in the K direction
C
C IDIMC,JDIMC,KDIMC : Coarse grid dimensions
C QC                : Coarse grid primitive variables at cell centers
C IDIMF,JDIMF,KDIMF : Fine   grid dimensions
C QF                : Fine   grid primitive variables at cell centers
C
      include 'common.inc'
C
      DIMENSION QC    (0:JDIMC+2,0:KDIMC+2,0:IDIMC+2,NQ),
     1          QF    (0:JDIMF+2,0:KDIMF+2,0:IDIMF+2,NQ)
C
C 1.  Interpolate in the J direction.
C
      DO 140 L = 1, NQ
         DO 130 J = 1, JDIMC
            JF = 2 * J - 1
            DO 120 I = 1, IDIMC+1
               DO 110 K = 1, KDIMC+1
                  QF(JF  ,K,I,L) = .75E0*QC(J,K,I,L)+.25E0*QC(J+1,K,I,L)
                  QF(JF+1,K,I,L) = .25E0*QC(J,K,I,L)+.75E0*QC(J+1,K,I,L)
 110           CONTINUE
 120        CONTINUE
 130     CONTINUE
 140  CONTINUE
C
C 2.  Interpolate in the I direction.
C     Decrement I and interpolate information stored beginning in the IDIMC
C     location of QF into the IDIMF location of QF, repeat with IDIM-1, etc.
C     Use temporary variables to avoid overwriting data before it is used.
C
      DO 240 L = 1, NQ
         DO 230 I = IDIMC, 1, -1
            IF = 2 * I - 1
            DO 220 K = 1, KDIMC+1
               DO 210 J = 1, JDIMF+1
                  QI             = QF(J,K,I  ,L)
                  QIP1           = QF(J,K,I+1,L)
                  QF(J,K,IF  ,L) = 0.75E0 * QI + 0.25E0 * QIP1
                  QF(J,K,IF+1,L) = 0.25E0 * QI + 0.75E0 * QIP1
 210           CONTINUE
 220        CONTINUE
 230     CONTINUE
 240  CONTINUE
C
C 3.  If 3D, interpolate in the K direction.
C     Decrement K and interpolate information stored beginning in the KDIMC
C     location of QF into the KDIMF location of QF, repeat with KDIM-1, etc.
C     Use temporary variables to avoid overwriting data before it is used.
C
      IF (THREED) THEN
         DO 340 L = 1, NQ
            DO 330 K = KDIMC, 1, -1
               KF = 2 * K - 1
               DO 320 I = 1, IDIMF+1
                  DO 310 J = 1, JDIMF+1
                     QK             = QF(J,K  ,I,L)
                     QKP1           = QF(J,K+1,I,L)
                     QF(J,KF  ,I,L) = 0.75E0 * QK + 0.25E0 * QKP1
                     QF(J,KF+1,I,L) = 0.25E0 * QK + 0.75E0 * QKP1
 310              CONTINUE
 320           CONTINUE
 330        CONTINUE
 340     CONTINUE
      ENDIF
C
C Finished interpolating from coarse to fine grid
      RETURN
      END
      SUBROUTINE PROLNG (IDIMC, JDIMC, KDIMC, QC, QCRS, NBCS, IBCDTC,
     1                   IDIMF, JDIMF, KDIMF, QF, DQ, IBCDTF,
     2                   ITURB, QMIN, NFIXQ, NRELIZ,
     3                   MXSECT, ABC, RTEMP)
C
C Routine to Prolong from the coarse grid (IDIMC ... QC) to the
C fine grid (IDIMF ... QF).
C
C N.B. This routine must maintain the values of QC on the edges for
C      additional cycles.
C
C This routine is organized as follows:
C     1. Transfer boundary conditions for coarse grids to ghost cells
C     2. Calculate DQ = Q^(n+1) - Q^(n) on coarse grid
C     3. Transfer boundary conditions for QC back to surface to prepare for
C        next cycle.
C     4. Apply boundary conditions to delta q before prolonging
C     5. Interpolate DQ from coarse grid to fine grid
C     6. Smooth DQ
C     7. Constrain DQ
C     8. Update fine grid solution as Q^(n+1) = Q^(n) + DQ
C     9. Check for positivity of variables
C    10. Enforce realizability of Reynolds stresses for Reynolds stress models
C
C IDIMC,JDIMC,KDIMC : Coarse grid dimensions
C QC                : Coarse grid primitive variables at cell centers
C QCRS              : Restricted fine grid primitive variables
C NBCS              : Number of boundary conditions
C IBCDTC            : Data controlling boundary conditions for coarse grid
C IDIMF,JDIMF,KDIMF : Fine   grid dimensions
C QF                : Fine   grid primitive variables at cell centers
C DQ                : Storage for interpolated delta(Q)
C IBCDTF            : Data controlling boundary conditions for fine grid
C ITURB             : Turbulence model
C QMIN              : Control array for minimum value of Q
C NFIXQ             : Number of times reset Q
C NRELIZ            : Number of times violate realizability
C MXSECT            : Maximum size of any (ixj, jxk or ixk)
C                     (used in dimensioning of temporary space for solver)
C ABC               : Storage for coefficient matrices for tridiagonal system
C RTEMP             : Storage for right hand side of implicit system
C
      include 'common.inc'
C
      DIMENSION QC    (0:JDIMC+2,0:KDIMC+2,0:IDIMC+2,NQ),
     1          QCRS  (0:JDIMC+2,0:KDIMC+2,0:IDIMC+2,NQ),
     2          QF    (0:JDIMF+2,0:KDIMF+2,0:IDIMF+2,NQ),
     3          DQ    (0:JDIMF+2,0:KDIMF+2,0:IDIMF+2,NQ)
C
      DIMENSION IBCDTC(9,NBCS),
     1          IBCDTF(9,NBCS)
C
      DIMENSION QMIN  (NQ)
      DIMENSION NFIXQ (NQ),
     1          NRELIZ(NQ)
C
      DIMENSION ABC   (MXSECT,3),
     1          RTEMP (MXSECT)
C
C 1.  Transfer boundary conditions for coarse grids to ghost cells
C
      CALL QBCMOD (IDIMC, JDIMC, KDIMC, QC  , NBCS, IBCDTC)
      CALL QBCMOD (IDIMC, JDIMC, KDIMC, QCRS, NBCS, IBCDTC)
C
C 2.  Calculate DQ = Q^(n+1) - Q^(n) on coarse grid
C     Use QCRS to store DQ to maintain QC's values in the array edges for
C     additional cycles.
C
      DO 240 L = 1, NQ
         DO 230 I = 0, IDIMC+2
            DO 220 K = 0, KDIMC+2
               DO 210 J = 0, JDIMC+2
                  QCRS(J,K,I,L) = QC(J,K,I,L) - QCRS(J,K,I,L)
  210          CONTINUE
  220       CONTINUE
  230    CONTINUE
  240 CONTINUE
C
C 3.  Transfer boundary conditions for QC back to surface to prepare for
C     next cycle.
C
      CALL QBCFIX (IDIMC, JDIMC, KDIMC, QC  , NBCS, IBCDTC)
C
C 4.  Apply boundary conditions to delta q before prolonging
C
      CALL DQBC   (IDIMC, JDIMC, KDIMC, QCRS, NBCS, IBCDTC)
C
C 5.  Interpolate DQ from coarse grid to fine grid
C
      CALL INT2HQ (IDIMC, JDIMC, KDIMC, QCRS,
     1             IDIMF, JDIMF, KDIMF, DQ)
C
C 6.  Smooth DQ
C
      CALL SMOOTH (IDIMF, JDIMF, KDIMF, DQ,
     1             MXSECT, ABC(1,1), ABC(1,2), ABC(1,3), RTEMP)
C
C 7.  Constrain DQ
C
      NPTS = (IDIMF + 3) * (JDIMF + 3) * (KDIMF + 3)
C     CALL DQLIMT (NPTS, QF, DQ)
      CALL xDQLIMT (idimf, jdimf, kdimf, QF, DQ)
C
C 8.  Update fine grid solution as Q^(n+1) = Q^(n) + DQ
C
      DO 840 L = 1, NQ
         DO 830 I = 2, IDIMF
            DO 820 K = 2, KDIMF
               DO 810 J = 2, JDIMF
                  QF(J,K,I,L) = QF(J,K,I,L) + DQ(J,K,I,L)
  810          CONTINUE
  820       CONTINUE
  830    CONTINUE
  840 CONTINUE
C
C 9.  Check for positivity of flow variables
C
      IPSTRT = 1
      IPEND  = IDIMF
      IF (IFIXQ .NE. INO) THEN
         CALL FIXQ   (ITURB, IDIMF, JDIMF, KDIMF, IPSTRT, IPEND, QF,
     1                QMIN,  NFIXQ, IERRCD)
      ENDIF
C
C 10. Enforce realizability of Reynolds stresses for Reynolds stress models
C
      IF (ITURB .EQ. ITRS) THEN
         CALL REALIZ (ITURB, IDIMF, JDIMF, KDIMF, IPSTRT, IPEND, QF,
     1                NRELIZ)
      ENDIF
C
C     Finished prolongation
      RETURN
      END
      SUBROUTINE DQBC   (IDIM, JDIM, KDIM, DQ, NBCS, IBCDAT)
C
C Routine to calculate delta Q on the boundary data for use in the multigrid
C prolongation operator.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Loop over all boundary conditions
C        If boundary condition then
C        a. Set delta(Q) boundary = 0
C
C IDIM,JDIM,KDIM : Dimensions of current block
C DQ             : Delta Q
C NBCS           : Number of boundary conditions for current block
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION DQ    (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C 2. Loop over boundary conditions
C
      DO 200 IBCS = 1, NBCS
         IBCTYP   = IBCDAT(1,IBCS)
C
         IF (IBCTYP .EQ. ITAN .OR. IBCTYP .EQ. IWALFN) THEN
C
C Store boundary condition data in mnemonic names
C
            IDIR     = IBCDAT(2,IBCS)
            INROUT   = IBCDAT(3,IBCS)
            ISTRT(1) = IBCDAT(4,IBCS)
            IEND (1) = IBCDAT(5,IBCS)
            ISTRT(2) = IBCDAT(6,IBCS)
            IEND (2) = IBCDAT(7,IBCS)
            ISTRT(3) = IBCDAT(8,IBCS)
            IEND (3) = IBCDAT(9,IBCS)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
            DO 10 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
                  IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
               END IF
   10       CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCN   is the point to the inside of the block from IBCPT
C
            IF (INROUT .EQ. 1) THEN
               IBCPT  = 1
               IBCN   = 2
            ELSE
               IBCPT  = IJKDIM(IDIR) + 1
               IBCN   = IJKDIM(IDIR)
            ENDIF
C
            IC1 = ICY (IDIR, 1)
            IC2 = ICY (IDIR, 2)
            IC3 = ICY (IDIR, 3)
C
C 2-a. Replace cell face data with equivalent ghostcell data
C
            DO 130 L = 1, NQ
               DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
                  DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
                     IBC  = IBCPT*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JBC  = IBCPT*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KBC  = IBCPT*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                     IN   = IBCN *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JN   = IBCN *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KN   = IBCN *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
C--                  DQ(JBC,KBC,IBC,L) = DQ(JN,KN,IN,L)
                     DQ(JBC,KBC,IBC,L) = 0.E0
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
         ENDIF
  200 CONTINUE
C
C Finished modifying the boundary conditions for interpolation (prolongation)
      RETURN
      END
      SUBROUTINE QBCMOD (IDIM, JDIM, KDIM, Q, NBCS, IBCDAT)
C
C Routine to replace boundary condition data on a computational cell face
C with equivalent data at the ghost cell center to then use in the
C interpolation (prolongation) operator.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Loop over all boundary conditions
C        If boundary condition is a half cell, then
C        a. Replace cell face data with equivalent ghostcell data
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at cell centers
C NBCS           : Number of boundary conditions for current block
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C 2. Loop over boundary conditions
C
      DO 200 IBCS = 1, NBCS
         IBCTYP   = IBCDAT(1,IBCS)
C
         IF (IBCTYP .EQ. ITAN .OR. IBCTYP .EQ. IWALL .OR.
     1       IBCTYP .EQ. IWALFN) THEN
C
C Store boundary condition data in mnemonic names
C
            IDIR     = IBCDAT(2,IBCS)
            INROUT   = IBCDAT(3,IBCS)
            ISTRT(1) = IBCDAT(4,IBCS)
            IEND (1) = IBCDAT(5,IBCS)
            ISTRT(2) = IBCDAT(6,IBCS)
            IEND (2) = IBCDAT(7,IBCS)
            ISTRT(3) = IBCDAT(8,IBCS)
            IEND (3) = IBCDAT(9,IBCS)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
            DO 10 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
                  IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
               END IF
   10       CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCN   is the point to the inside of the block from IBCPT
C
            IF (INROUT .EQ. 1) THEN
               IBCPT  = 1
               IBCN   = 2
            ELSE
               IBCPT  = IJKDIM(IDIR) + 1
               IBCN   = IJKDIM(IDIR)
            ENDIF
C
            IC1 = ICY (IDIR, 1)
            IC2 = ICY (IDIR, 2)
            IC3 = ICY (IDIR, 3)
C
C 2-a. Replace cell face data with equivalent ghostcell data
C
            DO 130 L = 1, NQ
               DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
                  DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
                     IBC  = IBCPT*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JBC  = IBCPT*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KBC  = IBCPT*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                     IN   = IBCN *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JN   = IBCN *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KN   = IBCN *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                     DELTAQ = Q(JBC,KBC,IBC,L) - Q(JN ,KN ,IN ,L)
                     Q(JBC,KBC,IBC,L) = Q(JBC,KBC,IBC,L) + DELTAQ
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
         ENDIF
  200 CONTINUE
C
C Finished modifying the boundary conditions for interpolation (prolongation)
      RETURN
      END
      SUBROUTINE QBCFIX (IDIM, JDIM, KDIM, Q, NBCS, IBCDAT)
C
C Routine to undo QBCMOD modifications moving ghost cells back to faces
C after interpolation (prolongation) operator.
C
C This routine is organized as follows:
C     1. Setup variables for looping
C     2. Loop over all boundary conditions
C        If boundary condition is a half cell, then
C        a. Replace ghostcell data with equivalent cell face data
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at cell centers
C NBCS           : Number of boundary conditions for current block
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C 1. Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C 2. Loop over boundary conditions
C
      DO 200 IBCS = 1, NBCS
         IBCTYP   = IBCDAT(1,IBCS)
C
         IF (IBCTYP .EQ. ITAN .OR. IBCTYP .EQ. IWALL .OR.
     1       IBCTYP .EQ. IWALFN) THEN
C
C Store boundary condition data in mnemonic names
C
            IDIR     = IBCDAT(2,IBCS)
            INROUT   = IBCDAT(3,IBCS)
            ISTRT(1) = IBCDAT(4,IBCS)
            IEND (1) = IBCDAT(5,IBCS)
            ISTRT(2) = IBCDAT(6,IBCS)
            IEND (2) = IBCDAT(7,IBCS)
            ISTRT(3) = IBCDAT(8,IBCS)
            IEND (3) = IBCDAT(9,IBCS)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
            DO 10 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
                  IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
               END IF
   10       CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCN   is the point to the inside of the block from IBCPT
C
            IF (INROUT .EQ. 1) THEN
               IBCPT  = 1
               IBCN   = 2
            ELSE
               IBCPT  = IJKDIM(IDIR) + 1
               IBCN   = IJKDIM(IDIR)
            ENDIF
C
            IC1 = ICY (IDIR, 1)
            IC2 = ICY (IDIR, 2)
            IC3 = ICY (IDIR, 3)
C
C 2-a. Replace cell face data with equivalent ghostcell data
C
            DO 130 L = 1, NQ
               DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
                  DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
                     IBC  = IBCPT*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JBC  = IBCPT*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KBC  = IBCPT*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                     IN   = IBCN *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                     JN   = IBCN *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                     KN   = IBCN *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                     DELTAQ = Q(JBC,KBC,IBC,L) - Q(JN ,KN ,IN ,L)
                     Q(JBC,KBC,IBC,L) = Q(JBC,KBC,IBC,L) - 0.5E0*DELTAQ
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
         ENDIF
  200 CONTINUE
C
C Finished modifying the boundary conditions for interpolation (prolongation)
      RETURN
      END
      SUBROUTINE SMOOTH (IDIM, JDIM, KDIM, PHI, MXSECT, A, B, C, RHS)
C
C Routine to perform the implicit smoothing on the variable phi.
C
C This routine is organized as follows:
C     0. Set up constants
C     1. Implicit operator in I direction
C     2. Implicit operator in J direction
C     3. Implicit operator in K direction
C
C IDIM,JDIM,KDIM : Dimensions of current block
C PHI            : Variable to be smoothed
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning of temporary space for solver)
C A, B, C        : Storage for coefficient matrices for tridiagonal system
C RHS            : Storage for right hand side of implicit system
C
      include 'common.inc'
C
      DIMENSION PHI   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION A     (MXSECT),
     1          B     (MXSECT),
     2          C     (MXSECT),
     3          RHS   (MXSECT)
C
C 0.  Set up constants
C
      CSMTHI = CSMTH
      CSMTHJ = CSMTH
      CSMTHK = CSMTH
C
C 1.  Implicit operator in I direction
C
      CALL SMTHI  (IDIM, JDIM, KDIM, PHI, CSMTHI, A, B, C, RHS)
C
C 2.  Implicit operator in J direction
C
      CALL SMTHJ  (IDIM, JDIM, KDIM, PHI, CSMTHI, A, B, C, RHS)
C
C 3.  Implicit operator in K direction
C
      IF (THREED) THEN
         CALL SMTHK  (IDIM, JDIM, KDIM, PHI, CSMTHI, A, B, C, RHS)
      ENDIF
C
C Finished
      RETURN
      END
      SUBROUTINE SMTHI  (IDIM, JDIM, KDIM, PHI, CSMTHI, A, B, C, RHS)
C
C Routine to perform the I-direction implicit smoothing on the variable phi.
C
C This routine is organized as follows:
C     0. Set up constants
C     1. Constant coefficient implicit smoothing
C        a. Set up implicit operator
C           i.  Interior stencil for implicit operator
C           ii. Boundary conditions for implicit operator
C        b. Solve system
C        c. Update smoothed solution
C
C IDIM,JDIM,KDIM : Dimensions of current block
C PHI            : Variable to be smoothed
C CSMTHI         : Coefficient for I direction smoothing
C A, B, C        : Storage for coefficient matrices for tridiagonal system
C RHS            : Storage for right hand side of implicit system
C
      include 'common.inc'
C
      DIMENSION PHI   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION A     (2:JDIM,2:IDIM),
     1          B     (2:JDIM,2:IDIM),
     2          C     (2:JDIM,2:IDIM),
     3          RHS   (2:JDIM,2:IDIM)
C
C 0.   Set up constants
C
      NSIM = JDIM - 1
      NPTS = IDIM - 1
C
C 1.   Constant coefficient implicit smoothing
C
      DO L = 1, NQ
         DO K = 2, KDIM
C
C 1-a. Set up implicit operator
C 1-a-i.  Interior stencil for implicit operator
C
            DO J = 2, JDIM
               DO I = 2, IDIM
                  A  (J,I) = - CSMTHI
                  B  (J,I) = 1.E0 + 2.E0 * CSMTHI
                  C  (J,I) = - CSMTHI
                  RHS(J,I) = PHI(J,K,I,L)
               END DO
C
C 1-a-ii. Boundary conditions for implicit operator
C
            END DO
C
C 1-b. Solve system
C
            CALL VSTRI (NPTS, NSIM, A, B, C, RHS)
C
C 1-c. Update smoothed solution
C
            DO J = 2, JDIM
               DO I = 2, IDIM
                  PHI(J,K,I,L) = RHS(J,I)
               END DO
            END DO
C
C      Next K
C
         END DO
      END DO
C
C Finished
      RETURN
      END
      SUBROUTINE SMTHJ  (IDIM, JDIM, KDIM, PHI, CSMTHJ, A, B, C, RHS)
C
C Routine to perform the J-direction implicit smoothing on the variable phi.
C
C This routine is organized as follows:
C     0. Set up constants
C     1. Constant coefficient implicit smoothing
C        a. Set up implicit operator
C           i.  Interior stencil for implicit operator
C           ii. Boundary conditions for implicit operator
C        b. Solve system
C        c. Update smoothed solution
C
C IDIM,JDIM,KDIM : Dimensions of current block
C PHI            : Variable to be smoothed
C CSMTHJ         : Coefficient for J direction smoothing
C A, B, C        : Storage for coefficient matrices for tridiagonal system
C RHS            : Storage for right hand side of implicit system
C
      include 'common.inc'
C
      DIMENSION PHI   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION A     (2:IDIM,2:JDIM),
     1          B     (2:IDIM,2:JDIM),
     2          C     (2:IDIM,2:JDIM),
     3          RHS   (2:IDIM,2:JDIM)
C
C 0.   Set up constants
C
      NSIM = IDIM - 1
      NPTS = JDIM - 1
C
C 1.   Constant coefficient implicit smoothing
C
      DO L = 1, NQ
         DO K = 2, KDIM
C
C 1-a. Set up implicit operator
C 1-a-i.  Interior stencil for implicit operator
C
            DO I = 2, IDIM
               DO J = 2, JDIM
                  A  (I,J) = - CSMTHJ
                  B  (I,J) = 1.E0 + 2.E0 * CSMTHJ
                  C  (I,J) = - CSMTHJ
                  RHS(I,J) = PHI(J,K,I,L)
               END DO
C
C 1-a-ii. Boundary conditions for implicit operator
C
            END DO
C
C 1-b. Solve system
C
            CALL VSTRI (NPTS, NSIM, A, B, C, RHS)
C
C 1-c. Update smoothed solution
C
            DO I = 2, IDIM
               DO J = 2, JDIM
                  PHI(J,K,I,L) = RHS(I,J)
               END DO
            END DO
C
C      Next K
C
         END DO
      END DO
C
C Finished
      RETURN
      END
      SUBROUTINE SMTHK  (IDIM, JDIM, KDIM, PHI, CSMTHK, A, B, C, RHS)
C
C Routine to perform the K-direction implicit smoothing on the variable phi.
C
C This routine is organized as follows:
C     0. Set up constants
C     1. Constant coefficient implicit smoothing
C        a. Set up implicit operator
C           i.  Interior stencil for implicit operator
C           ii. Boundary conditions for implicit operator
C        b. Solve system
C        c. Update smoothed solution
C
C IDIM,JDIM,KDIM : Dimensions of current block
C PHI            : Variable to be smoothed
C CSMTHK         : Coefficient for K direction smoothing
C A, B, C        : Storage for coefficient matrices for tridiagonal system
C RHS            : Storage for right hand side of implicit system
C
      include 'common.inc'
C
      DIMENSION PHI   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION A     (2:JDIM,2:KDIM),
     1          B     (2:JDIM,2:KDIM),
     2          C     (2:JDIM,2:KDIM),
     3          RHS   (2:JDIM,2:KDIM)
C
C 0.   Set up constants
C
      NSIM = JDIM - 1
      NPTS = KDIM - 1
C
C 1.   Constant coefficient implicit smoothing
C
      DO L = 1, NQ
         DO I = 2, IDIM
C
C 1-a. Set up implicit operator
C 1-a-i.  Interior stencil for implicit operator
C
            DO J = 2, JDIM
               DO K = 2, KDIM
                  A  (J,K) = - CSMTHK
                  B  (J,K) = 1.E0 + 2.E0 * CSMTHK
                  C  (J,K) = - CSMTHK
                  RHS(J,K) = PHI(J,K,I,L)
               END DO
C
C 1-a-ii. Boundary conditions for implicit operator
C
            END DO
C
C 1-b. Solve system
C
            CALL VSTRI (NPTS, NSIM, A, B, C, RHS)
C
C 1-c. Update smoothed solution
C
            DO J = 2, JDIM
               DO K = 2, KDIM
                  PHI(J,K,I,L) = RHS(J,K)
               END DO
            END DO
C
C      Next I
C
         END DO
      END DO
C
C Finished
      RETURN
      END
      SUBROUTINE DQLIMT (NPTS, Q, DQ)
C
C Routine to perform limiting of the coarse grid correction.
C
C This routine is organized as follows:
C     1. Limit mean flow coarse grid correction
C     2. Limit turbulent equations coarse grid correction
C
C NPTS           : Number of points to limit
C Q              : Solution vector
C DQ             : Coarse grid corrections to be limited
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          DQ    (NPTS,NQ)
C
C 1.  Limit mean flow coarse grid correction
C     If coarse grid update for DENSITY exceeds CMXCHG*DENSITY, then
C     set the coarse grid correction for all mean flow variables to zero.
C
      DO I = 1, NPTS
         IF (ABS(DQ(I,1)) .GT. CMXCHG*Q(I,1)) THEN
            DQ(I,1) = 0.E0
            DQ(I,2) = 0.E0
            DQ(I,3) = 0.E0
            DQ(I,4) = 0.E0
            DQ(I,5) = 0.E0
         ENDIF
      END DO
C
C 2.  Limit turbulent equations coarse grid correction
C
C-N.B. Temporary for testing: set DQ for turbulence to zero
      DO L = 6, NQ
         DO I = 1, NPTS
            DQ(I,L) = 0.E0
         END DO
      END DO
C
C Finished
      RETURN
      END
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      SUBROUTINE xDQLIMT (idim, jdim, kdim, Q, DQ)
C
C Routine to perform limiting of the coarse grid correction.
C
C This routine is organized as follows:
C     1. Limit mean flow coarse grid correction
C     2. Limit turbulent equations coarse grid correction
C
C NPTS           : Number of points to limit
C Q              : Solution vector
C DQ             : Coarse grid corrections to be limited
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          DQ    (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
C 1.  Limit mean flow coarse grid correction
C     If coarse grid update for DENSITY exceeds CMXCHG*DENSITY, then
C     set the coarse grid correction for all mean flow variables to zero.
C
      do k = 2, kdim
      DO I = 2, idim
      do j = 2, jdim
         IF (ABS(DQ(J,K,I,1)) .GT. CMXCHG*Q(J,K,I,1)) THEN
            DQ(J,K,I,1) = 0.E0
            DQ(J,K,I,2) = 0.E0
            DQ(J,K,I,3) = 0.E0
            DQ(J,K,I,4) = 0.E0
            DQ(J,K,I,5) = 0.E0
         ENDIF
      END DO
      END DO
      END DO
C
C 2.  Limit turbulent equations coarse grid correction
C
C-N.B. Temporary for testing: set DQ for turbulence to zero
      DO L = 6, NQ
         do k = 2, kdim
         DO I = 2, idim
         do j = 2, jdim
            DQ(J,K,I,L) = 0.E0
         END DO
         END DO
         END DO
      END DO
C
C Finished
      RETURN
      END
      SUBROUTINE CMGFF  (NPTS, RESCRS, RES)
C
C Routine to calculate the coarse grid forcing function as
C       RESCRS = sum RES(fine) - RES(coarse)
C RESCRS contains sum RES(fine) on entry.
C
C NPTS   : Number of points in array
C RESCRS : MG forcing function
C RES    : Coarse grid residual
C
      include 'common.inc'
C
      INTEGER   NPTS
C
      DIMENSION RESCRS(NPTS),
     1          RES   (NPTS)
C
C Local variables
C
      INTEGER   I
C
C Calculate RESCRS =  sum RES(fine) - RES(coarse)
C
      DO I = 1, NPTS
         RESCRS(I) = RESCRS(I) - RES(I)
      END DO
      RETURN
C
C Finished
C
      END
      SUBROUTINE CRESFF (NPTS, RESCRS, RES)
C
C Routine to calculate the residual plus forcing function for the
C coarse grid update
C       RES = [sum RES(fine) - RES(coarse)] + RES(coarse)
C RESCRS contains [sum RES(fine) - RES(coarse)] on entry.
C
C NPTS   : Number of points in array
C RESCRS : MG forcing function
C RES    : Coarse grid residual
C
      include 'common.inc'
C
      INTEGER   NPTS
C
      DIMENSION RESCRS(NPTS),
     1          RES   (NPTS)
C
C Local variables
C
      INTEGER   I
C
C Calculate RESCRS =  sum RES(fine) - RES(coarse)
C
      DO I = 1, NPTS
         RES(I) = RES(I) + RESCRS(I)
      END DO
      RETURN
C
C Finished
C
      END
      SUBROUTINE xCMGFF  (idim, jdim, kdim, RESCRS, RES)
C
C Routine to calculate the coarse grid forcing function as
C       RESCRS = sum RES(fine) - RES(coarse)
C RESCRS contains sum RES(fine) on entry.
C
C NPTS   : Number of points in array
C RESCRS : MG forcing function
C RES    : Coarse grid residual
C
      include 'common.inc'
C
      INTEGER   NPTS
C
      DIMENSION RESCRS(jdim+1,kdim+1,idim+1,nf),
     1          RES   (jdim+1,kdim+1,idim+1,nf)
C
C Local variables
C
      INTEGER   I, j, k, l
C
C Calculate RESCRS =  sum RES(fine) - RES(coarse)
C
      do l = 1, nf
      do k = 2, kdim
      do i = 2, idim
      do j = 2, jdim
         RESCRS(j,k,I,l) = RESCRS(j,k,i,l) - RES(j,k,i,l)
      END DO
      END DO
      END DO
      END DO
      RETURN
C
C Finished
C
      END
      SUBROUTINE xCRESFF (idim, jdim, kdim, RESCRS, RES)
C
C Routine to calculate the residual plus forcing function for the
C coarse grid update
C       RES = [sum RES(fine) - RES(coarse)] + RES(coarse)
C RESCRS contains [sum RES(fine) - RES(coarse)] on entry.
C
C NPTS   : Number of points in array
C RESCRS : MG forcing function
C RES    : Coarse grid residual
C
      include 'common.inc'
C
      INTEGER   NPTS
C
      DIMENSION RESCRS(jdim+1,kdim+1,idim+1,nf),
     1          RES   (jdim+1,kdim+1,idim+1,nf)
C
C Local variables
C
      INTEGER   I, j, k, l
C
C Calculate RESCRS =  sum RES(fine) - RES(coarse)
C
      do l = 1, nf
      do k = 2, kdim
      do i = 2, idim
      do j = 2, jdim
         RES(j,k,i,l) = RES(j,k,i,l) + RESCRS(j,k,i,l)
      END DO
      END DO
      END DO
      END DO
      RETURN
C
C Finished
C
      END
C
      BLOCK DATA COMMNS
C
C     Block Data routine to initialize the common data.
C
      include 'common.inc'
C
C     Data statements for no and yes
C
      DATA INO    /0/,
     1     IYES   /1/
C
C     Data statements for constants
C
      DATA RMAX   /9.99E+20/,
     1     RSMALL /1.00E-12/,
     2     RSMASQ /1.00E-24/
C
C     Data statements to set up the units for input and output.
C
      DATA INPUT   /5/,
     1     IOUT    /6/,
     2     IRDRST  /8/,
     3     IWRRST  /9/,
     4     IGRID  /10/,
     5     IPLT3G /11/,
     6     IPLT3Q /12/,
     7     IPLT3F /13/,
     8     IPLT3FN/14/,
     9     IRDBC  /15/,
     A     ISTOPFL/16/
C
C     Data statements to set up the file types supported for grids
C
      DATA IGTSEP  /1/,
     1     IGTP3D  /2/
C
C     Data statements to set up the available boundary conditions.
C     Boundary conditions are sorted based on increasing value of this
C     variable, therefore walls are done near last, etc.
C
      DATA ITAN   /22/,
     1     IWALL  /23/,
     2     IWALFN /21/,
     3     IFAR    /4/,
     4     IFAR2D  /5/,
     5     IEXT    /6/,
     6     IFIX    /7/,
     7     ISING   /8/,
     8     IJET    /9/,
     9     IPERD  /11/,
     A     IPROFL  /1/,
     B     IPROSB  /2/,
     C     ISYMYZ /12/,
     D     ISYMXZ /13/,
     E     ISYMXY /14/,
     F     IINFLO /15/,
     G     IOUTFL /16/,
     H     IAXISM /17/,
     I     IAXICL /18/,
     J     IHSHR  /10/
C
C     Data statements to set up the global constants defining the
C     available flux evaluation schemes.  The schemes should be
C     numbered from 1 to the maximum number to work correctly with
C     the IFCHAR array.
C
      DATA IFROE  /1/
C
C     Data statements to set the available types of flux evaluation
C     schemes.
C
      DATA IFDS   /1/,
     1     IFVS   /2/,
     2     IFCD   /0/
C
C     Data statements to set up available limiters
C
      DATA ILNONE /0/,
     1     ILSMTH /1/,
     2     ILMNMD /2/,
     3     ILVNKT /3/
C
C     Data statements to set up the global constants defining the
C     available turbulence models.
C
      DATA ITNVSD     /0/,
     1     ITLMNR    /10/,
     2     ITBLMX   /500/,
     3     ITKE    /2100/,
     4     ITKW    /2200/,
     5     ITRS   /10000/,
     6     ITLES    /100/
C
C     Data statements for Fmu models
C
      DATA IFMHR     /0/,
     1     IFMSAA    /1/,
     2     IFMZSG    /2/,
     3     IFMVD     /3/
C
C     Data statements for epsilon equation models
C
      DATA IEEHR     /0/,
     1     IEESAA    /1/,
     2     IEEZSG    /2/,
     3     IEEZSL    /3/,
     4     IEERNG    /4/,
     5     IEES95    /5/,
     6     IEEABD    /6/
C
C     Data statements for compressible dissipation models
C
      DATA IECNO     /0/,
     1     IECSAR    /1/,
     2     IECRIS    /2/
C
C     Data statements for Pressure-Dilatation models
C
      DATA IPDNO     /0/,
     1     IPDSAR    /1/,
     2     IPDRIS    /2/
C
C     Data statements for Anisotropic Dissipation Rate Models
C
      DATA IADRNO    /0/,
     1     IADRGS    /1/
C
C     Data statements for Algebraic stress models
C
      DATA IASMBU    /0/,
     1     IASMGS    /1/
C
C     Data statements to set up pressure-strain correlation models.
C
      DATA IPLRR1    /1/,
     1     IPLRR2    /2/,
     2     IPSSG     /3/,
     3     IPGL      /4/,
     4     IPLS      /5/,
     5     IPFLT     /6/,
     6     IPSO95    /7/
C
C     Data statements for Epsilon_ij models
C
      DATA IEISO     /0/,
     1     IELAIS    /1/,
     2     IEFLT     /2/,
     3     IEADGS    /3/,
     4     IESO95    /4/
C
C     Data statements to set molecular diffusion models
C
      DATA IDMSO     /1/,
     1     IDMSPZ    /2/
C
C     Data statements to set turbulent diffusion models
C
      DATA IDTDH     /0/,
     1     IDTHL     /1/,
     2     IDTMH     /2/
C
C     Data statements to set SGS models
C
      DATA ISGSMG    /1/,
     1     ISGSFM    /2/
C
C     Data statements to set the FIX routines for positivity preservation
C     IFIXMN, IFIXAV cannot equal INO
C
      DATA IFIXMN    /1/,
     1     IFIXAV    /2/
C
C     Data statements to set the available types of solution procedure.
C
      DATA IRKN    /1/,
     1     IAF3F   /2/,
     2     ILGS    /3/,
     3     IMARCH /10/
C
      DATA ISDIAG  /1/,
     1     ISBLOC  /2/
C
      DATA ISTDY   /1/,
     1     IUNSTD  /2/
C
      DATA ITTS    /1/,
     1     ITAUTS  /2/
C
C     Data statements to set the Kronecker Delta array and Cyclic array
C
      DATA IKD / 1, 0, 0,
     1           0, 1, 0,
     2           0, 0, 1 /
      DATA ICY / 1, 2, 3,
     1           2, 3, 1,
     2           3, 1, 2 /
C
      END
      SUBROUTINE CHKDAT (NBLKS,  IDIM, JDIM, KDIM, VISCOS,
     1                   NXBCS, NBCS, IBCDAT, NCUTS, ICUTS, CUTNAM,
     2                   NXPRT, NPRINT, IPRINT, IERRCD)
C
C Routine to check input data for boundary conditions, cuts, and print output.
C This routine looks at the finest grid level only.  All other data will be
C derived from the fine grid level.  The approach is to output an error, then
C correct the data (the best that can be done), and then pass this back to
C the main routine so that it can continue checking additional data.  This
C routine can only be called after NBLKS, NCUTS, and NPRINT have been tested
C and corrected to fit in memory.  If NBLKS, NCUTS, or NPRINT exceeded their
C dimensions, the output from this routine could be corrupt as RDDATA may have
C overwritten key data.
C
C This routine is organized as follows:
C     0. Verify KDIM for non-3D cases
C     1. Verify Boundary Condition (BC) data
C     2. Verify Cut data
C        a. Dimensions
C        b. Cut lengths
C     3. Verify Print data
C
C NBLKS          : Number of blocks
C IDIM,JDIM,KDIM : Dimensions of blocks
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow in block
C NXBCS          : Maximum number of bcs    per block as dimensioned in main
C NBCS           : Number of boundary conditions in each block
C IBCDAT         : Boundary condition data
C NCUTS          : Number of cuts
C ICUTS          : Cut data
C NXPRT          : Maximum number of prints per block as dimensioned in main
C NPRINT         : Number of print statements in each block
C IPRINT         : Print data
C IERRCD         : Error code
C
      include 'common.inc'
C
      DIMENSION IDIM   (NBLKS),
     1          JDIM   (NBLKS),
     2          KDIM   (NBLKS)
C
      LOGICAL   VISCOS (3,NBLKS)
C
      DIMENSION IBCDAT (10,NXBCS,NBLKS),
     1          NBCS   (NBLKS)
C
      DIMENSION ICUTS  (21,NCUTS)
      CHARACTER*20 CUTNAM(NCUTS)
C
      DIMENSION IPRINT (10,NXPRT,NBLKS),
     1          NPRINT (NBLKS)
C
C Local storage used to test indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3),
     3          IORD  (3),
     4          ISTRT2(3),
     5          IEND2 (3),
     6          INC   (3),
     7          ICOUNT(3)
C
C Output data
C
      CHARACTER*20 BCNAME
      CHARACTER*1  DIR (3)
      DATA         DIR /'I', 'J', 'K'/
C
C Initialize error code
C
      IERRCD = INO
C
      WRITE (IOUT,1000)
C
C 0.   Verify KDIM for non-3D cases
C
      IF (.NOT. THREED) THEN
         DO 10 IBLK = 1, NBLKS
            IF (KDIM(IBLK) .NE. 2) THEN
               IERRCD = IYES
               WRITE (IOUT,1010) IBLK, IDIM(IBLK), JDIM(IBLK),
     1                           KDIM(IBLK)
            ENDIF
   10    CONTINUE
      ENDIF
C
C 1.   Verify Boundary Condition (BC) data
C
      DO 190 IBLK = 1, NBLKS
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
         IJKDIM(1) = IDIM (IBLK)
         IJKDIM(2) = JDIM (IBLK)
         IJKDIM(3) = KDIM (IBLK)
C
         DO 170 IBC = 1, NBCS(IBLK)
C
C Store boundary condition data in mnemonic names
C
            IBCTYP   = IBCDAT(1,IBC,IBLK)
            IDIR     = IBCDAT(2,IBC,IBLK)
            INROUT   = IBCDAT(3,IBC,IBLK)
            ISTRT(1) = IBCDAT(4,IBC,IBLK)
            IEND (1) = IBCDAT(5,IBC,IBLK)
            ISTRT(2) = IBCDAT(6,IBC,IBLK)
            IEND (2) = IBCDAT(7,IBC,IBLK)
            ISTRT(3) = IBCDAT(8,IBC,IBLK)
            IEND (3) = IBCDAT(9,IBC,IBLK)
C
C Modify starting point to switch back to input form for testing
C
            DO 140 L = 1, 3
               IF (L .NE. IDIR) THEN
                  ISTRT(L) = ISTRT(L) - 1
               ENDIF
  140       CONTINUE
C
            DO 150 L = 1, 3
               IF (ISTRT(L) .LT. 1 .OR. IEND(L) .GT. IJKDIM(L)) THEN
                  IERRCD = IYES
                  CALL GETNAM (IBCTYP, BCNAME)
                  WRITE (IOUT,1110) IBLK, DIR(L), IJKDIM(L),
     1                     (ISTRT(L1),L1=1,3), (IEND(L2),L2=1,3), BCNAME
               ENDIF
  150       CONTINUE
C
C Verify that viscous terms are enabled in direction normal to all wall or
C wall function boundary conditions.
C
            IF (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN) THEN
               IF (.NOT. VISCOS(IDIR,IBLK)) THEN
                  IERRCD = IYES
                  CALL GETNAM (IBCTYP, BCNAME)
                  WRITE (IOUT,1120) IBLK, DIR(IDIR),
     1                     (ISTRT(L1),L1=1,3), (IEND(L2),L2=1,3), BCNAME
               ENDIF
            ENDIF
C
C Verify that the TWOD  option is     set for 2D farfield point vortex bc
C Verify that the MARCH option is not set for 2D farfield point vortex bc
C
            IF (IBCTYP .EQ. IFAR2D) THEN
               IF (THREED .OR. AXISYM) THEN
                  IERRCD = IYES
                  CALL GETNAM (IBCTYP, BCNAME)
                  WRITE (IOUT,1130) IBLK, DIR(IDIR),
     1                     (ISTRT(L1),L1=1,3), (IEND(L2),L2=1,3), BCNAME
               ENDIF
               IF (ISOLVR .EQ. IMARCH) THEN
                  IERRCD = IYES
                  CALL GETNAM (IBCTYP, BCNAME)
                  WRITE (IOUT,1140) IBLK, DIR(IDIR),
     1                     (ISTRT(L1),L1=1,3), (IEND(L2),L2=1,3), BCNAME
               ENDIF
            ENDIF
C
  170    CONTINUE
  190 CONTINUE
C
C 2.   Verify Cut data
C 2-a. Dimensions
C
      DO 240 ICUT = 1, NCUTS
         IBLK     = ICUTS ( 1,ICUT)
         IDIR     = ICUTS ( 2,ICUT)
         INROUT   = ICUTS ( 3,ICUT)
         ISTRT(1) = ICUTS ( 4,ICUT)
         IEND (1) = ICUTS ( 5,ICUT)
         ISTRT(2) = ICUTS ( 6,ICUT)
         IEND (2) = ICUTS ( 7,ICUT)
         ISTRT(3) = ICUTS ( 8,ICUT)
         IEND (3) = ICUTS ( 9,ICUT)
C
C Modify starting/ending point to switch back to input form for testing
C
         DO 220 L = 1, 3
            IF (L .NE. IDIR) THEN
               IF (IEND(L) .GT. ISTRT(L)) THEN
                  ISTRT(L) = ISTRT(L) - 1
               ELSE
                  IEND (L) = IEND (L) - 1
               ENDIF
            ENDIF
  220    CONTINUE
C
C Check the block specified - if invalid, bypass next test
C
         IF (IBLK .GT. NBLKS) THEN
            IERRCD = IYES
            WRITE (IOUT,1200) IBLK, NBLKS, CUTNAM(ICUT),
     1                  (ISTRT(L1),L1=1,3), (IEND(L2),L2=1,3)
            GO TO 239
         ENDIF
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
         IJKDIM(1) = IDIM (IBLK)
         IJKDIM(2) = JDIM (IBLK)
         IJKDIM(3) = KDIM (IBLK)
C
C Test indices
C
         DO 230 L = 1, 3
            IF (ISTRT(L) .LT. 1 .OR. IEND(L) .GT. IJKDIM(L)) THEN
               IERRCD = IYES
               WRITE (IOUT,1210) IBLK, DIR(L), IJKDIM(L), CUTNAM(ICUT),
     1                  (ISTRT(L1),L1=1,3), (IEND(L2),L2=1,3)
            ENDIF
  230    CONTINUE
  239    CONTINUE
  240 CONTINUE
C
C 2-b. Cut lengths
C
      DO 290 ICUT = 1, NCUTS, 2
         IBLK      = ICUTS ( 1,ICUT)
         IDIR      = ICUTS ( 2,ICUT)
         INROUT    = ICUTS ( 3,ICUT)
         ISTRT (1) = ICUTS ( 4,ICUT)
         IEND  (1) = ICUTS ( 5,ICUT)
         ISTRT (2) = ICUTS ( 6,ICUT)
         IEND  (2) = ICUTS ( 7,ICUT)
         ISTRT (3) = ICUTS ( 8,ICUT)
         IEND  (3) = ICUTS ( 9,ICUT)
C
         IBLK2     = ICUTS (10,ICUT)
         IDIR2     = ICUTS (11,ICUT)
         INROUT2   = ICUTS (12,ICUT)
         ISTRT2(1) = ICUTS (13,ICUT)
         IEND2 (1) = ICUTS (14,ICUT)
         ISTRT2(2) = ICUTS (15,ICUT)
         IEND2 (2) = ICUTS (16,ICUT)
         ISTRT2(3) = ICUTS (17,ICUT)
         IEND2 (3) = ICUTS (18,ICUT)
C
         IORD  (1) = ICUTS (19,ICUT)
         IORD  (2) = ICUTS (20,ICUT)
         IORD  (3) = ICUTS (21,ICUT)
C
C Verify order array contains one each of 1, 2, 3
C
         DO 245 L = 1, 3
            ICOUNT(L) = 0
  245    CONTINUE
         DO 250 L = 1, 3
            ICOUNT(IORD(L)) = ICOUNT(IORD(L)) + 1
  250    CONTINUE
C
C If IORD is invalid, bypass next test
C
         IF (ICOUNT(1) .NE. 1 .OR. ICOUNT(2) .NE. 1 .OR.
     1       ICOUNT(3) .NE. 1) THEN
            IERRCD = IYES
            WRITE (IOUT,1220) (IORD  (L0),L0=1,3),
     1               CUTNAM(ICUT), IBLK,
     2               (ISTRT (L1),L1=1,3), (IEND (L2),L2=1,3),
     3               CUTNAM(ICUT), IBLK2,
     4               (ISTRT2(L3),L3=1,3), (IEND2(L4),L4=1,3)
            GO TO 289
         ENDIF
C
C Modify starting/ending point to switch back to input form for testing
C
         DO 270 L = 1, 3
            IF (L .NE. IDIR) THEN
               IF (IEND(L) .GT. ISTRT(L)) THEN
                  ISTRT(L) = ISTRT(L) - 1
               ELSE
                  IEND (L) = IEND (L) - 1
               ENDIF
            ENDIF
            IF (L .NE. IDIR2) THEN
               IF (IEND2(L) .GT. ISTRT2(L)) THEN
                  ISTRT2(L) = ISTRT2(L) - 1
               ELSE
                  IEND2 (L) = IEND2 (L) - 1
               ENDIF
            ENDIF
  270    CONTINUE
C
C Check the block specified - if invalid, bypass test
C
         IF (IBLK .GT. NBLKS .OR. IBLK2 .GT. NBLKS) THEN
            GO TO 289
         ENDIF
C
C Check length
C
         DO 280 L = 1, 3
            LEN1 = ABS (IEND(L)        - ISTRT(L)       )
            LEN2 = ABS (IEND2(IORD(L)) - ISTRT2(IORD(L)))
            IF (LEN1 .NE. LEN2) THEN
               IERRCD = IYES
               WRITE (IOUT,1230) IBLK, DIR(L), IBLK2, DIR(IORD(L)),
     1                  CUTNAM(ICUT),
     2                  (ISTRT (L1),L1=1,3), (IEND (L2),L2=1,3),
     3                  CUTNAM(ICUT),
     4                  (ISTRT2(L3),L3=1,3), (IEND2(L4),L4=1,3),
     5                  (IORD  (L5),L5=1,3)
            ENDIF
  280    CONTINUE
C
  289    CONTINUE
  290 CONTINUE
C
C 3.   Verify Print data
C
      DO 390 IBLK = 1, NBLKS
C
C Store IDIM, JDIM, KDIM in IJKDIM
C Increment IJKDIM since it is allowed to print out the boundary data
C
         IJKDIM(1) = IDIM (IBLK) + 1
         IJKDIM(2) = JDIM (IBLK) + 1
         IJKDIM(3) = KDIM (IBLK) + 1
C
         DO 380 IPR = 1, NPRINT(IBLK)
C
C Store print data in mnemonic names
C
            IDIR     = IPRINT( 1,IPR,IBLK)
            ISTRT(1) = IPRINT( 2,IPR,IBLK)
            ISTRT(2) = IPRINT( 3,IPR,IBLK)
            ISTRT(3) = IPRINT( 4,IPR,IBLK)
            IEND (1) = IPRINT( 5,IPR,IBLK)
            IEND (2) = IPRINT( 6,IPR,IBLK)
            IEND (3) = IPRINT( 7,IPR,IBLK)
            INC  (1) = IPRINT( 8,IPR,IBLK)
            INC  (2) = IPRINT( 9,IPR,IBLK)
            INC  (3) = IPRINT(10,IPR,IBLK)
C
            DO 350 L = 1, 3
               IF (ISTRT(L) .LT. 1 .OR. IEND(L) .GT. IJKDIM(L)) THEN
                  IERRCD = IYES
                  WRITE (IOUT,1300) IBLK, DIR(L), IJKDIM(L), IDIR,
     1                     (ISTRT(L1),L1=1,3), (IEND(L2),L2=1,3),
     2                     (INC  (L3),L3=1,3)
               ENDIF
  350       CONTINUE
  380    CONTINUE
  390 CONTINUE
C
C Finished
C
      WRITE (IOUT,1900)
      RETURN
C
 1000 FORMAT (' ','CHKDAT: Begin    checking BC, CUT, PRINT data')
 1010 FORMAT (' ','CHKDAT: BC    ERROR-> Two-Dimensional option (TWOD)',
     1            ' requires KDIM = 2',
     2       /' ',13X,' Block =',I3,' Dimensions ',3I5)
 1110 FORMAT (' ','CHKDAT: BC    ERROR-> Block =',I3,' Index ',A1,
     1            ' outside allowable range [1:',I4,']',
     2       /' ',13X,' BC Data ',3I4,3X,3I4,3X,A20)
 1120 FORMAT (' ','CHKDAT: BC    ERROR-> Block =',I3,' Index ',A1,
     1            ' Wall normal viscous terms not enabled',
     2       /' ',13X,' BC Data ',3I4,3X,3I4,3X,A20)
 1130 FORMAT (' ','CHKDAT: BC    ERROR-> Block =',I3,' Index ',A1,
     1            ' 2D FARFIELD VORTEX BC must be used',
     2       /' ',22X,'with the TWOD option',
     3       /' ',13X,' BC Data ',3I4,3X,3I4,3X,A20)
 1140 FORMAT (' ','CHKDAT: BC    ERROR-> Block =',I3,' Index ',A1,
     1            ' 2D FARFIELD VORTEX BC cannot be used',
     2       /' ',22X,'with the MARCH option',
     3       /' ',13X,' BC Data ',3I4,3X,3I4,3X,A20)
 1200 FORMAT (' ','CHKDAT: CUT   ERROR-> Invalid Block =',I3,
     1            ' Number of blocks specified is ',I4,
     2       /' ',13X,' CUT Data ',A20,1X,3I4,3X,3I4)
 1210 FORMAT (' ','CHKDAT: CUT   ERROR-> Block =',I3,' Index ',A1,
     1            ' outside allowable range [1:',I4,']',
     2       /' ',13X,' CUT Data ',A20,1X,3I4,3X,3I4)
 1220 FORMAT (' ','CHKDAT: CUT   ERROR-> IORD = ',3I2,
     1            ' has duplicate directions specified',
     2       /' ',13X,' CUT Data ',A20,1X,I3,1X,3I4,3X,3I4,
     3       /' ',13X,'          ',A20,1X,I3,1X,3I4,3X,3I4)
 1230 FORMAT (' ','CHKDAT: CUT   ERROR-> Block',I3,' Index ',A1,
     1            ' different length from Block',I3,' Index ',A1,
     2       /' ',13X,' CUT Data ',A20,1X,3I4,3X,3I4,
     3       /' ',13X,'          ',A20,1X,3I4,3X,3I4,2X,3I2)
 1300 FORMAT (' ','CHKDAT: PRINT ERROR-> Block =',I3,' Index ',A1,
     1            ' outside allowable range [1:',I4,']',
     2       /' ',13X,' Print Data ',I2,3X,3I4,3X,3I4,3X,3I4)
 1900 FORMAT (' ','CHKDAT: Finished checking BC, CUT, PRINT data')
C
      END
      SUBROUTINE CHKCRS (NLVLS,  NXBLKS, NBLKS,  IDIM, JDIM, KDIM,
     1                   NXBCS,  NBCS,   IBCDAT,
     2                   NXCUTS, NCUTS,  ICUTS,  CUTNAM, IERRCD)
C
C Routine to check coarsened boundary conditions and cuts for consistency.
C An error is returned in IERRCD.
C
C This routine is organized as follows:
C     1. Verify Boundary Condition (BC) data
C     2. Verify Cut data
C
C NLVLS          : Number of grid levels
C NXBLKS         : Maximum number of blocks as dimensioned in main
C NBLKS          : Number of blocks
C IDIM,JDIM,KDIM : Dimensions of blocks
C NXBCS          : Maximum number of bcs    per block as dimensioned in main
C NBCS           : Number of boundary conditions in each block
C IBCDAT         : Boundary condition data
C NXCUTS         : Maximum number of cuts as dimensioned in main
C NCUTS          : Number of cuts
C ICUTS          : Cut data
C IERRCD         : Error code
C
      include 'common.inc'
C
      DIMENSION IDIM   (NXBLKS,NLVLS),
     1          JDIM   (NXBLKS,NLVLS),
     2          KDIM   (NXBLKS,NLVLS)
C
      DIMENSION IBCDAT (10,NXBCS,NXBLKS,NLVLS),
     1          NBCS   (NXBLKS)
C
      DIMENSION ICUTS  (21,NXCUTS,NLVLS)
      CHARACTER*20 CUTNAM(NXCUTS)
C
C Local storage used to test indices
C
      DIMENSION IJKDIM(3),
     1          ISTRTC(3),
     2          IENDC (3),
     3          ISTRTF(3),
     4          IENDF (3),
     5          IORD  (3),
     6          ISTR2C(3),
     7          IEND2C(3),
     8          ISTR2F(3),
     9          IEND2F(3)
C
C Output data
C
      CHARACTER*20 BCNAME
      CHARACTER*1  DIR (3)
      DATA         DIR /'I', 'J', 'K'/
C
C Initialize error code
C
      IERRCD = INO
C
      IF (THREED) THEN
         NDIM = 3
      ELSE
         NDIM = 2
      ENDIF
C
      WRITE (IOUT,1000)
C
C 1.   Verify Boundary Condition (BC) data
C
      DO 190 IBLK = 1, NBLKS
C
         DO 170 IBC = 1, NBCS(IBLK)
C
            DO 160 ILVL = 2, NLVLS
               LVLF = ILVL - 1
               LVLC = ILVL
C
C Store boundary condition data in mnemonic names
C
               ISTRTF(1) = IBCDAT(4,IBC,IBLK,LVLF)
               IENDF (1) = IBCDAT(5,IBC,IBLK,LVLF)
               ISTRTF(2) = IBCDAT(6,IBC,IBLK,LVLF)
               IENDF (2) = IBCDAT(7,IBC,IBLK,LVLF)
               ISTRTF(3) = IBCDAT(8,IBC,IBLK,LVLF)
               IENDF (3) = IBCDAT(9,IBC,IBLK,LVLF)
C
               IBCTYP    = IBCDAT(1,IBC,IBLK,LVLC)
               IDIR      = IBCDAT(2,IBC,IBLK,LVLC)
               INROUT    = IBCDAT(3,IBC,IBLK,LVLC)
               ISTRTC(1) = IBCDAT(4,IBC,IBLK,LVLC)
               IENDC (1) = IBCDAT(5,IBC,IBLK,LVLC)
               ISTRTC(2) = IBCDAT(6,IBC,IBLK,LVLC)
               IENDC (2) = IBCDAT(7,IBC,IBLK,LVLC)
               ISTRTC(3) = IBCDAT(8,IBC,IBLK,LVLC)
               IENDC (3) = IBCDAT(9,IBC,IBLK,LVLC)
C
C Modify starting point to switch back to input form for testing
C
               DO 140 L = 1, 3
                  IF (L .NE. IDIR) THEN
                     ISTRTF(L) = ISTRTF(L) - 1
                     ISTRTC(L) = ISTRTC(L) - 1
                  ENDIF
  140          CONTINUE
C
               DO 150 L = 1, NDIM
                  ISTEST = 2 * (ISTRTC(L) - 1) + 1
                  IETEST = 2 * (IENDC (L) - 1) + 1
                  IF (ISTRTF(L) .NE. ISTEST  .OR.
     1                IENDF (L) .NE. IETEST) THEN
                     IERRCD = IYES
                     CALL GETNAM (IBCTYP, BCNAME)
                     WRITE (IOUT,1100) IBLK, LVLC, LVLF, DIR(L),
     1                  (ISTRTC(L1),L1=1,3), (IENDC(L2),L2=1,3), BCNAME,
     2                  (ISTRTF(L3),L3=1,3), (IENDF(L4),L4=1,3), BCNAME
                  ENDIF
  150          CONTINUE
C
  160       CONTINUE
  170    CONTINUE
  190 CONTINUE
C
C 2.   Verify Cut data
C
      DO 250 ICUT = 1, NCUTS
         DO 240 ILVL = 2, NLVLS
            LVLF = ILVL - 1
            LVLC = ILVL
C
            ISTRTF(1) = ICUTS ( 4,ICUT,LVLF)
            IENDF (1) = ICUTS ( 5,ICUT,LVLF)
            ISTRTF(2) = ICUTS ( 6,ICUT,LVLF)
            IENDF (2) = ICUTS ( 7,ICUT,LVLF)
            ISTRTF(3) = ICUTS ( 8,ICUT,LVLF)
            IENDF (3) = ICUTS ( 9,ICUT,LVLF)
C
            ISTR2F(1) = ICUTS (13,ICUT,LVLF)
            IEND2F(1) = ICUTS (14,ICUT,LVLF)
            ISTR2F(2) = ICUTS (15,ICUT,LVLF)
            IEND2F(2) = ICUTS (16,ICUT,LVLF)
            ISTR2F(3) = ICUTS (17,ICUT,LVLF)
            IEND2F(3) = ICUTS (18,ICUT,LVLF)
C
            IBLK      = ICUTS ( 1,ICUT,LVLC)
            IDIR      = ICUTS ( 2,ICUT,LVLC)
            INROUT    = ICUTS ( 3,ICUT,LVLC)
            ISTRTC(1) = ICUTS ( 4,ICUT,LVLC)
            IENDC (1) = ICUTS ( 5,ICUT,LVLC)
            ISTRTC(2) = ICUTS ( 6,ICUT,LVLC)
            IENDC (2) = ICUTS ( 7,ICUT,LVLC)
            ISTRTC(3) = ICUTS ( 8,ICUT,LVLC)
            IENDC (3) = ICUTS ( 9,ICUT,LVLC)
C
            IBLK2     = ICUTS (10,ICUT,LVLC)
            IDIR2     = ICUTS (11,ICUT,LVLC)
            INROUT2   = ICUTS (12,ICUT,LVLC)
            ISTR2C(1) = ICUTS (13,ICUT,LVLC)
            IEND2C(1) = ICUTS (14,ICUT,LVLC)
            ISTR2C(2) = ICUTS (15,ICUT,LVLC)
            IEND2C(2) = ICUTS (16,ICUT,LVLC)
            ISTR2C(3) = ICUTS (17,ICUT,LVLC)
            IEND2C(3) = ICUTS (18,ICUT,LVLC)
C
            IORD  (1) = ICUTS (19,ICUT,LVLC)
            IORD  (2) = ICUTS (20,ICUT,LVLC)
            IORD  (3) = ICUTS (21,ICUT,LVLC)
C
C Modify starting/ending point to switch back to input form for testing
C
            DO 220 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (IENDC(L) .GT. ISTRTC(L)) THEN
                     ISTRTF(L) = ISTRTF(L) - 1
                     ISTRTC(L) = ISTRTC(L) - 1
                  ELSE
                     IENDF (L) = IENDF (L) - 1
                     IENDC (L) = IENDC (L) - 1
                  ENDIF
               ENDIF
               IF (L .NE. IDIR2) THEN
                  IF (IEND2C(L) .GT. ISTR2C(L)) THEN
                     ISTR2F(L) = ISTR2F(L) - 1
                     ISTR2C(L) = ISTR2C(L) - 1
                  ELSE
                     IEND2F(L) = IEND2F(L) - 1
                     IEND2C(L) = IEND2C(L) - 1
                  ENDIF
               ENDIF
  220       CONTINUE
C
C Test indices
C
            DO 230 L = 1, NDIM
               ISTEST = 2 * (ISTRTC(L) - 1) + 1
               IETEST = 2 * (IENDC (L) - 1) + 1
               IS2TST = 2 * (ISTR2C(L) - 1) + 1
               IE2TST = 2 * (IEND2C(L) - 1) + 1
               IF (ISTRTF(L) .NE. ISTEST .OR.
     1             IENDF (L) .NE. IETEST .OR.
     2             ISTR2F(L) .NE. IS2TST .OR.
     3             IEND2F(L) .NE. IE2TST ) THEN
                  IERRCD = IYES
                  WRITE (IOUT,1200) ICUT, LVLC, LVLF, DIR(L),
     1                  CUTNAM(ICUT), IBLK,
     2                  (ISTRTC(L1),L1=1,3), (IENDC (L2),L2=1,3),
     3                  CUTNAM(ICUT), IBLK2,
     4                  (ISTR2C(L3),L3=1,3), (IEND2C(L4),L4=1,3),
     5                  (IORD  (L5),L5=1,3),
     6                  CUTNAM(ICUT), IBLK,
     7                  (ISTRTF(L1),L1=1,3), (IENDF (L2),L2=1,3),
     8                  CUTNAM(ICUT), IBLK2,
     9                  (ISTR2F(L3),L3=1,3), (IEND2F(L4),L4=1,3),
     A                  (IORD  (L5),L5=1,3)
               ENDIF
  230       CONTINUE
  240    CONTINUE
  250 CONTINUE
C
C Finished
C
      WRITE (IOUT,1900)
      RETURN
C
 1000 FORMAT (' ','CHKCRS: Begin    checking coarsened BC and CUT data')
 1100 FORMAT (' ','CHKCRS: BC    ERROR-> Block =',I3,' Coarse grid ',
     1            'boundary points (Level = ',I2,')',
     2       /' ',22X,'do not correspond to fine grid (Level = ',I2,')',
     3       /' ',22X,'in the ',A1,' direction:',
     4       /' ',13X,' Coarse BC  Data ',3I4,3X,3I4,3X,A20,
     5       /' ',13X,' Fine   BC  Data ',3I4,3X,3I4,3X,A20)
 1200 FORMAT (' ','CHKCRS: CUT   ERROR-> Cut   =',I3,' Coarse grid ',
     1            'cut points (Level = ',I2,')',
     2       /' ',22X,'do not correspond to fine grid (Level = ',I2,')',
     3       /' ',22X,'in the ',A1,' direction:',
     4       /' ',13X,' Coarse CUT Data ',A20,I2,3X,3I4,3X,3I4,
     5       /' ',13X,'                 ',A20,I2,3X,3I4,3X,3I4,3X,3I2,
     6       /' ',13X,' Fine   CUT Data ',A20,I2,3X,3I4,3X,3I4,
     7       /' ',13X,'                 ',A20,I2,3X,3I4,3X,3I4,3X,3I2)
 1900 FORMAT (' ','CHKCRS: Finished checking coarsened BC and CUT data')
C
      END
      SUBROUTINE CONC2P (ITURB, NPTS, Q, TKE)
C
C Routine to convert Conserved variables to Primitive variables.
C
C This routine is organized as follows:
C     1. Divide conserved variables by density
C     2. Calculate turbulent kinetic energy
C     3. Convert total energy to pressure
C
C ITURB          : Turbulence model
C NPTS           : Number of points to convert
C Q              : Flow variables (Input - conserved; Output - primitive)
C TKE            : Turbulent kinetic energy
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          TKE   (NPTS)
C
      INTEGER   I, L
C
C 1.  Multiply primitive variables by density
C
      DO 110 L = 2, NQ
         IF (L .NE. 5) THEN
            DO 100 I = 1, NPTS
               Q(I,L) = Q(I,L) / Q(I,1)
  100       CONTINUE
         ENDIF
  110 CONTINUE
C
C 2.  Calculate turbulent kinetic energy
C
      CALL GETTKE (ITURB, NPTS, Q, TKE)
C
C 3.  Convert from (rho*Etotal) to pressure
C
      DO 300 I = 1, NPTS
         RHO    = Q(I,1)
         U      = Q(I,2)
         V      = Q(I,3)
         W      = Q(I,4)
         RHOE   = Q(I,5)
         Q(I,5) = GAMM1 * ( RHOE
     1          - 0.5E0 * RHO * (U*U + V*V + W*W)
     2          - RHO * TKE(I) )
  300 CONTINUE
C
C     Finished converting conserved variables to primitive variables
      RETURN
      END
      SUBROUTINE CONP2C (ITURB, NPTS, Q, TKE)
C
C Routine to convert Primitive variables to Conserved variables.
C
C This routine is organized as follows:
C     1. Calculate turbulent kinetic energy
C     2. Multiply primitive variables by density
C     3. Convert pressure to total energy
C
C ITURB          : Turbulence model
C NPTS           : Number of points to convert
C Q              : Flow variables (Input - conserved; Output - primitive)
C TKE            : Turbulent kinetic energy
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          TKE   (NPTS)
C
      INTEGER   I, L
C
C 1.  Calculate turbulent kinetic energy
C
      CALL GETTKE (ITURB, NPTS, Q, TKE)
C
C 2.  Multiply primitive variables by density
C
      DO 210 L = 2, NQ
         IF (L .NE. 5) THEN
            DO 200 I = 1, NPTS
               Q(I,L) = Q(I,L) * Q(I,1)
  200       CONTINUE
         ENDIF
  210 CONTINUE
C
C 3.  Convert from pressure to (rho*Etotal)
C
      DO 300 I = 1, NPTS
         RHO    = Q(I,1)
         RHOU   = Q(I,2)
         RHOV   = Q(I,3)
         RHOW   = Q(I,4)
         P      = Q(I,5)
         Q(I,5) = P / GAMM1
     1          + 0.5E0 * (RHOU*RHOU + RHOV*RHOV + RHOW*RHOW) / RHO
     2          + RHO * TKE(I)
  300 CONTINUE
C
C     Finished converting primitive variables to conserved variables
      RETURN
      END
      SUBROUTINE CPVCTR (NPTS, VIN, VOUT)
C
C Routine to copy a vector from one array to another.
C
C NPTS  : Number of points in array
C VIN   : Input vector to copy
C VOUT  : Output for copy
C
      include 'common.inc'
C
      INTEGER   NPTS
C
      DIMENSION VIN   (NPTS),
     1          VOUT  (NPTS)
C
C Local variables
C
      INTEGER   I
C
C Copy
C
      DO 100 I = 1, NPTS
         VOUT(I) = VIN(I)
  100 CONTINUE
      RETURN
C
C Finished
C
      END
      SUBROUTINE GETNAM (IBCTYP, BCNAME)
C
C Function to give boundary condition name given the type
C
      include 'common.inc'
C
      CHARACTER*20 BCNAME
C
      IF (IBCTYP .EQ. IWALL  ) THEN
         BCNAME = 'WALL'
      ELSE IF (IBCTYP .EQ. IWALFN) THEN
         BCNAME = 'WALL FUNCTIONS'
      ELSE IF (IBCTYP .EQ. ITAN  ) THEN
         BCNAME = 'TANGENCY'
      ELSE IF (IBCTYP .EQ. IFAR  ) THEN
         BCNAME = 'FARFIELD'
      ELSE IF (IBCTYP .EQ. IFAR2D) THEN
         BCNAME = '2D FARFIELD VORTEX'
      ELSE IF (IBCTYP .EQ. ISYMXY) THEN
         BCNAME = 'SYMMETRY XY'
      ELSE IF (IBCTYP .EQ. ISYMXZ) THEN
         BCNAME = 'SYMMETRY XZ'
      ELSE IF (IBCTYP .EQ. ISYMYZ) THEN
         BCNAME = 'SYMMETRY YZ'
      ELSE IF (IBCTYP .EQ. IEXT  ) THEN
         BCNAME = 'EXTRAPOLATE'
      ELSE IF (IBCTYP .EQ. IFIX  ) THEN
         BCNAME = 'FIX'
      ELSE IF (IBCTYP .EQ. IJET  ) THEN
         BCNAME = 'JET'
      ELSE IF (IBCTYP .EQ. IPERD ) THEN
         BCNAME = 'PERIODIC'
      ELSE IF (IBCTYP .EQ. IHSHR ) THEN
         BCNAME = 'HOMOGENEOUS SHEAR'
      ELSE IF (IBCTYP .EQ. IPROFL) THEN
         BCNAME = 'PROFILE CELL CENTER'
      ELSE IF (IBCTYP .EQ. IPROSB) THEN
         BCNAME = 'SUBSONIC PROFILE CC'
      ELSE
         BCNAME = '** UNKNOWN **'
      ENDIF
      RETURN
      END
      SUBROUTINE CHCKBC (ILVL, IBLK, IDIM, JDIM, KDIM, Q, NERRBC)
C
C     Routine to asure that all faces of each computational zone are
C     set with a boundary condition.
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      LOGICAL   ERRFAC
C
C     Set constant for maximum errors to print out
C
      MAXERR = 25
      ERRFAC = .FALSE.
C
C     I = 0 Face Boundary Conditions
C
      NERFAC = 0
      DO 140 I = 0, 1
         DO 130 K = 2, KDIM
            DO 120 J = 2, JDIM
               DO 110 L = 1, NQ
                  IF (Q(J,K,I,L) .GE. RMAX) THEN
                     ERRFAC = .TRUE.
                  ENDIF
  110          CONTINUE
               IF (ERRFAC) THEN
                  IF (NERFAC .LE. MAXERR) THEN
                     WRITE (IOUT,1000) ILVL, IBLK, I, J, K
                  ENDIF
                  ERRFAC = .FALSE.
                  NERRBC = NERRBC + 1
                  NERFAC = NERFAC + 1
               ENDIF
  120       CONTINUE
  130    CONTINUE
  140 CONTINUE
C
C     Output total number of errors on current face
C
      IF (NERFAC .GT. 0) THEN
         WRITE (IOUT,1010) NERFAC, ILVL, IBLK, 'I = 0 Face    '
      ENDIF
C
C     I = IDIM Face Boundary Conditions
C
      NERFAC = 0
      DO 180 I = IDIM+1, IDIM+2
         DO 170 K = 2, KDIM
            DO 160 J = 2, JDIM
               DO 150 L = 1, NQ
                  IF (Q(J,K,I,L) .GE. RMAX) THEN
                     ERRFAC = .TRUE.
                  ENDIF
  150          CONTINUE
               IF (ERRFAC) THEN
                  IF (NERFAC .LE. MAXERR) THEN
                     WRITE (IOUT,1000) ILVL, IBLK, I, J, K
                  ENDIF
                  ERRFAC = .FALSE.
                  NERRBC = NERRBC + 1
                  NERFAC = NERFAC + 1
               ENDIF
  160       CONTINUE
  170    CONTINUE
  180 CONTINUE
C
C     Output total number of errors on current face
C
      IF (NERFAC .GT. 0) THEN
         WRITE (IOUT,1010) NERFAC, ILVL, IBLK, 'I = IDIM Face '
      ENDIF
C
C     J = 0 Face Boundary Conditions
C
      NERFAC = 0
      DO 240 J = 0, 1
         DO 230 I = 2, IDIM
            DO 220 K = 2, KDIM
               DO 210 L = 1, NQ
                  IF (Q(J,K,I,L) .GE. RMAX) THEN
                     ERRFAC = .TRUE.
                  ENDIF
  210          CONTINUE
               IF (ERRFAC) THEN
                  IF (NERFAC .LE. MAXERR) THEN
                     WRITE (IOUT,1000) ILVL, IBLK, I, J, K
                  ENDIF
                  ERRFAC = .FALSE.
                  NERRBC = NERRBC + 1
                  NERFAC = NERFAC + 1
               ENDIF
  220       CONTINUE
  230    CONTINUE
  240 CONTINUE
C
C     Output total number of errors on current face
C
      IF (NERFAC .GT. 0) THEN
         WRITE (IOUT,1010) NERFAC, ILVL, IBLK, 'J = 0 Face    '
      ENDIF
C
C     J = JDIM Face Boundary Conditions
C
      NERFAC = 0
      DO 280 J = JDIM+1, JDIM+2
         DO 270 I = 2, IDIM
            DO 260 K = 2, KDIM
               DO 250 L = 1, NQ
                  IF (Q(J,K,I,L) .GE. RMAX) THEN
                     ERRFAC = .TRUE.
                  ENDIF
  250          CONTINUE
               IF (ERRFAC) THEN
                  IF (NERFAC .LE. MAXERR) THEN
                     WRITE (IOUT,1000) ILVL, IBLK, I, J, K
                  ENDIF
                  ERRFAC = .FALSE.
                  NERRBC = NERRBC + 1
                  NERFAC = NERFAC + 1
               ENDIF
  260       CONTINUE
  270    CONTINUE
  280 CONTINUE
C
C     Output total number of errors on current face
C
      IF (NERFAC .GT. 0) THEN
         WRITE (IOUT,1010) NERFAC, ILVL, IBLK, 'J = JDIM Face '
      ENDIF
C
C     Check K = 0 and K = KDIM boundary conditions for 3D or axisymmetric
C
      IF (THREED .OR. AXISYM) THEN
C
C     K = 0 Face Boundary Conditions
C
         NERFAC = 0
         DO 340 K = 0, 1
            DO 330 I = 2, IDIM
               DO 320 J = 2, JDIM
                  DO 310 L = 1, NQ
                     IF (Q(J,K,I,L) .GE. RMAX) THEN
                        ERRFAC = .TRUE.
                     ENDIF
  310             CONTINUE
                  IF (ERRFAC) THEN
                     IF (NERFAC .LE. MAXERR) THEN
                        WRITE (IOUT,1000) ILVL, IBLK, I, J, K
                     ENDIF
                     ERRFAC = .FALSE.
                     NERRBC = NERRBC + 1
                     NERFAC = NERFAC + 1
                  ENDIF
  320          CONTINUE
  330       CONTINUE
  340    CONTINUE
C
C     Output total number of errors on current face
C
         IF (NERFAC .GT. 0) THEN
            WRITE (IOUT,1010) NERFAC, ILVL, IBLK, 'K = 0 Face    '
         ENDIF
C
C     K = KDIM Face Boundary Conditions
C
         NERFAC = 0
         DO 380 K = KDIM+1, KDIM+2
            DO 370 I = 2, IDIM
               DO 360 J = 2, JDIM
                  DO 350 L = 1, NQ
                     IF (Q(J,K,I,L) .GE. RMAX) THEN
                        ERRFAC = .TRUE.
                     ENDIF
  350             CONTINUE
                  IF (ERRFAC) THEN
                     IF (NERFAC .LE. MAXERR) THEN
                        WRITE (IOUT,1000) ILVL, IBLK, I, J, K
                     ENDIF
                     ERRFAC = .FALSE.
                     NERRBC = NERRBC + 1
                     NERFAC = NERFAC + 1
                  ENDIF
  360          CONTINUE
  370       CONTINUE
  380    CONTINUE
C
C     Output total number of errors on current face
C
         IF (NERFAC .GT. 0) THEN
            WRITE (IOUT,1010) NERFAC, ILVL, IBLK, 'K = KDIM Face '
         ENDIF
      ENDIF
      RETURN
 1000 FORMAT (' ','CHCKBC: ERROR-> Boundary data not set at ',
     1            '(lvl,block,i,j,k)',I3,':',I3,':',3I4)
 1010 FORMAT (' ','CHCKBC: ERROR-> ',I8,' BC Errors for level =',I3,
     1            ', block =',I3,', ',A//)
      END
      SUBROUTINE CHKCUT (IBLK1, IDIM1, JDIM1, KDIM1, R1,
     1                   IBLK2, IDIM2, JDIM2, KDIM2, R2, ICUTS,
     2                   CUTNAM, IERRCD)
C
C Routine to check cut boundary conditions.  Grid points in R1 are verified
C against grid points in R2 for each cut boundary condition.
C
C IBLK1             : Block 1
C IDIM1,JDIM1,KDIM1 : Dimensions of current block 1
C R1                : Position vector of grid vertices (x,y,z) for block 1
C IBLK2             : Block 2
C IDIM2,JDIM2,KDIM2 : Dimensions of current block 2
C R2                : Position vector of grid vertices (x,y,z) for block 2
C ICUTS             : Data controlling transfer from block 2 to block 1
C CUTNAM            : Name of cut
C IERRCD            : Error code
C
      include 'common.inc'
      DIMENSION R1   (0:JDIM1+1,0:KDIM1+1,0:IDIM1+1,3),
     1          R2   (0:JDIM2+1,0:KDIM2+1,0:IDIM2+1,3)
      DIMENSION ICUTS(21)
      CHARACTER*20 CUTNAM
C
      DIMENSION IJKDM1(3), IJKDM2(3)
      DIMENSION ISTR1 (3), IEND1 (3),
     1          ISTR2 (3), IEND2 (3),
     2          ISGN1 (3), ISGN2 (3),
     3          IORD  (3), LEN   (3)
C
C Control
C
      MAXPRT = 25
      GTOLER = 2.5E-05
C
C Store IDIM, JDIM, KDIM in IJKDIM for looping
C
      IJKDM1(1) = IDIM1
      IJKDM1(2) = JDIM1
      IJKDM1(3) = KDIM1
      IJKDM2(1) = IDIM2
      IJKDM2(2) = JDIM2
      IJKDM2(3) = KDIM2
C
C Store boundary condition data in mnemonic names
C
      IDIR1    = ICUTS( 2)
      INOUT1   = ICUTS( 3)
      ISTR1(1) = ICUTS( 4)
      IEND1(1) = ICUTS( 5)
      ISTR1(2) = ICUTS( 6)
      IEND1(2) = ICUTS( 7)
      ISTR1(3) = ICUTS( 8)
      IEND1(3) = ICUTS( 9)
C
      IBLK2    = ICUTS(10)
      IDIR2    = ICUTS(11)
      INOUT2   = ICUTS(12)
      ISTR2(1) = ICUTS(13)
      IEND2(1) = ICUTS(14)
      ISTR2(2) = ICUTS(15)
      IEND2(2) = ICUTS(16)
      ISTR2(3) = ICUTS(17)
      IEND2(3) = ICUTS(18)
C
      IORD(1)  = ICUTS(19)
      IORD(2)  = ICUTS(20)
      IORD(3)  = ICUTS(21)
C
C Translate ICUTS data from cell-centered storage to grid point storage.
C This requires decrementing the minimum ('starting') index. Do this only
C for the indices that the cut loops over, not the idir direction.
C
      DO 10 L = 1, 3
C
         IF (L .NE. IDIR1) THEN
            IF (IEND1(L) .GE. ISTR1(L)) THEN
               ISTR1(L) = ISTR1(L) - 1
            ELSE
               IEND1(L) = IEND1(L) - 1
            ENDIF
         ENDIF
C
         IF (L .NE. IDIR2) THEN
            IF (IEND2(L) .GE. ISTR2(L)) THEN
               ISTR2(L) = ISTR2(L) - 1
            ELSE
               IEND2(L) = IEND2(L) - 1
            ENDIF
         ENDIF
   10 CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INOUT1 = 1) or the outer boundary (INOUT1 > 1)
C      IBCPT1 = grid point on grid face of block 1
C      IBCPT2 = corresponding grid point on grid face of block 2
C
      IF (INOUT1 .EQ. 1) THEN
         IBCPT1 = 1
      ELSE
         IBCPT1 = IJKDM1(IDIR1)
      ENDIF
C
      IF (INOUT2 .EQ. 1) THEN
         IBCPT2 = 1
      ELSE
         IBCPT2 = IJKDM2(IDIR2)
      ENDIF
C
C Find the length of the two outer loops and loop over these using
C offsets and delta function to set the two cut data points to the
C two interior data points of block 2.
C
      DO 100 L = 1, 3
C
         LEN(L) = ABS ( IEND1(L) - ISTR1(L) )
C
C     Increment/Decrement
C
         IF ( IEND1(L) .GT. ISTR1(L) ) THEN
            ISGN1(L) =   1
         ELSE
            ISGN1(L) = - 1
         ENDIF
C
C     Increment/Decrement
C
         IF ( IEND2(L) .GT. ISTR2(L) ) THEN
            ISGN2(L) =   1
         ELSE
            ISGN2(L) = - 1
         ENDIF
  100 CONTINUE
C
C     II1,JJ1,KK1 grid point on boundary of block 1
C     II2,JJ2,KK2 corresponding grid point on boundary of block 2
C
      IC1 = ICY (IDIR1, 1)
      IC2 = ICY (IDIR1, 2)
      IC3 = ICY (IDIR1, 3)
C
      JC1 = IORD (IC1)
      JC2 = IORD (IC2)
      JC3 = IORD (IC3)
C
C Initialize counter
C
      ICOUNT = 0
C
      DO 120 I3 = 0, LEN(IC3)
         DO 110 I2 = 0, LEN(IC2)
            II1 = IBCPT1                       * IKD (IC1, 1) +
     1            (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 1) +
     2            (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 1)
            JJ1 = IBCPT1                       * IKD (IC1, 2) +
     1            (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 2) +
     2            (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 2)
            KK1 = IBCPT1                       * IKD (IC1, 3) +
     1            (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 3) +
     2            (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 3)
C
            II2 = IBCPT2                       * IKD (JC1, 1) +
     1            (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 1) +
     2            (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 1)
            JJ2 = IBCPT2                       * IKD (JC1, 2) +
     1            (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 2) +
     2            (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 2)
            KK2 = IBCPT2                       * IKD (JC1, 3) +
     1            (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 3) +
     2            (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 3)
C
            DX = R1(JJ1,KK1,II1,1) - R2(JJ2,KK2,II2,1)
            DY = R1(JJ1,KK1,II1,2) - R2(JJ2,KK2,II2,2)
            DZ = R1(JJ1,KK1,II1,3) - R2(JJ2,KK2,II2,3)
C
            DIST = SQRT (DX*DX + DY*DY + DZ*DZ)
C
C If the grid points don't match output an error.  Output the header on
C the first point that doesn't match and then output only the data up to
C a maximum number before a summary.
C
            IF (DIST .GT. GTOLER) THEN
               ICOUNT = ICOUNT + 1
               IF (ICOUNT .EQ. 1) THEN
                  WRITE (IOUT,1000) CUTNAM, IBLK1, IBLK2
               ENDIF
               IF (ICOUNT .LE. MAXPRT) THEN
                  WRITE (IOUT,1010)
     1              II1, JJ1, KK1, R1(JJ1,KK1,II1,1), R1(JJ1,KK1,II1,2),
     2                             R1(JJ1,KK1,II1,3),
     3              II2, JJ2, KK2, R2(JJ2,KK2,II2,1), R2(JJ2,KK2,II2,2),
     4                             R2(JJ2,KK2,II2,3)
               ENDIF
            ENDIF
 110     CONTINUE
 120  CONTINUE
C
C Output summary
C
      IF (ICOUNT .GT. 0) THEN
         IERRCD = IYES
         WRITE (IOUT,1020) CUTNAM, IBLK1, IBLK2, ICOUNT
      ENDIF
C
C Finished Checking Cut
      RETURN
 1000 FORMAT (' ','CHKCUT: ERROR-> Grid Points do not match on cut ',
     1            A20,
     2       /' ',20X,'Block = ',I3,28X,'Block = ',I3,
     3       /' ','  I   J   K     X        Y        Z    ',
     4            '  I   J   K     X        Y        Z    ')
 1010 FORMAT (' ',2(3I4,3(1PE9.2)))
 1020 FORMAT (' ','CHKCUT: ERROR-> Cut ',A20,' from Block ',I3,
     1            ' to Block ',I3,' had ',I10,' mismatched points.'/)
      END
      SUBROUTINE CONVRT (IDIM, JDIM, KDIM,
     1                   IMODLX, QFROM, PROPSF, NQFROM, NPFROM,
     2                   IMODEL, QTO,   PROPST, NQTO,   NPTO,   S, VOL,
     3                   QC, PROPSC, DQDX, DQDY, DQDZ, TAU, SRC,
     4                   IBCDAT, NBCS, IFDELQ)
C
C Routine to convert from one equation set to another.  Perform the conversion
C for the interior of the domain.  The call to the boundary condition routine
C will then set the boundaries accordingly.
C
C This routine converts the following data:
C      Part:   FROM:                    TO:
C        0.    Mean Flow Equations
C        1.a.  Laminar               -> K-Epsilon
C        1.b.  Laminar               -> K-Omega
C        1.c.  Laminar               -> Reynolds Stress
C        3.    K-Epsilon             -> K-Omega
C        4.    K-Omega               -> K-Epsilon
C        5.    K-Epsilon or K-Omega  -> Reynolds Stress
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IMODLX         : Turbulence model to be converted FROM
C QFROM          : Primitive variables at cell centers converted FROM
C PROPSF         : Properties at cell centers converted FROM
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = Ynorm
C                  PROPS(5) = C_mu
C NQFROM         : Number of variables  for the model converted FROM
C NPFROM         : Number of properties for the model converted FROM
C IMODEL         : Turbulence model to be converted TO
C QTO            : Primitive variables at cell centers converted TO
C PROPST         : Properties at cell centers converted TO
C NQTO           : Number of variables  for the model converted TO
C NPTO           : Number of properties for the model converted TO
C VOL            : Cell volume
C S              : Metrics
C VOL            : Cell volumes
C RES            : Residual
C QC             : Storage for Q in one-dimensional array
C PROPSC         : Storage for PROPS array in one-dimensional array
C DQDX,DQDY,DQDZ : Storage for derivatives of Q at cell centers
C TAU            : Storage for Reynolds stress terms
C SRC            : Source terms for cell (J,K)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C IFDELQ         : Array controlling calculation of delq
C
      include 'common.inc'
C
      DIMENSION IMODLX(NMDL),
     1          IMODEL(NMDL)
C
      DIMENSION QFROM (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQFROM),
     1          PROPSF(0:JDIM+2,0:KDIM+2,0:IDIM+2,NPFROM),
     2          QTO   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQTO),
     3          PROPST(0:JDIM+2,0:KDIM+2,0:IDIM+2,NPTO)
C
      DIMENSION S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     1          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION QC    (2:JDIM,2:KDIM,NQ),
     1          PROPSC(2:JDIM,2:KDIM,NP),
     2          DQDX  (2:JDIM,2:KDIM,NQ),
     3          DQDY  (2:JDIM,2:KDIM,NQ),
     4          DQDZ  (2:JDIM,2:KDIM,NQ),
     5          TAU   (2:JDIM,2:KDIM,6),
     6          SRC   (2:JDIM,2:KDIM,NF)
C
      DIMENSION IBCDAT(10,NBCS),
     1          IFDELQ(NQ)
C
      ITURBX = IMODLX( 1)
      ITURB  = IMODEL( 1)
C
C     Number of points in a cross-section to calculate Reynolds stresses at
C
      NPTS = (JDIM - 1) * (KDIM - 1)
C
C 0. Convert the Mean Flow Variables and Properties
C    The mean flow variables are identical for TO and FROM for all conversions
C    Properties 1-5 are the same for all models.
C
      DO 30 I = 0, IDIM+2
         DO 20 K = 0, KDIM+2
            DO 10 J = 0, JDIM+2
               QTO   (J,K,I,1) = QFROM (J,K,I,1)
               QTO   (J,K,I,2) = QFROM (J,K,I,2)
               QTO   (J,K,I,3) = QFROM (J,K,I,3)
               QTO   (J,K,I,4) = QFROM (J,K,I,4)
               QTO   (J,K,I,5) = QFROM (J,K,I,5)
               PROPST(J,K,I,1) = PROPSF(J,K,I,1)
               PROPST(J,K,I,2) = PROPSF(J,K,I,2)
               PROPST(J,K,I,3) = PROPSF(J,K,I,3)
               PROPST(J,K,I,4) = PROPSF(J,K,I,4)
               PROPST(J,K,I,5) = PROPSF(J,K,I,5)
   10       CONTINUE
   20    CONTINUE
   30 CONTINUE
C
C 1. Initialize additional turbulence variables to freestream values.
C
      IF (ITURBX .EQ. ITLMNR) THEN
C
C 1.a. K-Epsilon
C
         IF (ITURB .EQ. ITKE) THEN
            DO 130 I = 2, IDIM
               DO 120 K = 2, KDIM
                  DO 110 J = 2, JDIM
                     QTO(J,K,I,6) = TKEINF
                     QTO(J,K,I,7) = EPSINF
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
C
C 1.b. K-Omega
C
         ELSE IF (ITURB .EQ. ITKW) THEN
            DO 160 I = 2, IDIM
               DO 150 K = 2, KDIM
                  DO 140 J = 2, JDIM
                     QTO(J,K,I,6) = TKEINF
                     QTO(J,K,I,7) = OMEINF
  140             CONTINUE
  150          CONTINUE
  160       CONTINUE
C
C 1.c. Reynolds Stress
C
         ELSE IF (ITURB .EQ. ITRS) THEN
            TXXINF = 2.E0 / 3.E0 * TKEINF
            TYYINF = 2.E0 / 3.E0 * TKEINF
            TZZINF = 2.E0 / 3.E0 * TKEINF
            DO 190 I = 2, IDIM
               DO 180 K = 2, KDIM
                  DO 170 J = 2, JDIM
                     QTO(J,K,I, 6) = TXXINF
                     QTO(J,K,I, 7) = TYYINF
                     QTO(J,K,I, 8) = TZZINF
                     QTO(J,K,I, 9) = 0.E0
                     QTO(J,K,I,10) = 0.E0
                     QTO(J,K,I,11) = 0.E0
                     QTO(J,K,I,12) = EPSINF
  170             CONTINUE
  180          CONTINUE
  190       CONTINUE
         ENDIF
C
C Do conversion for additional turbulence variables.
C
C 3. Convert K-Epsilon to K-Omega
C
      ELSE IF (ITURBX .EQ. ITKE .AND. ITURB .EQ. ITKW) THEN
         DO 330 I = 2, IDIM
            DO 320 K = 2, KDIM
               DO 310 J = 2, JDIM
                  QTO(J,K,I,6) = QFROM(J,K,I,6)
                  QTO(J,K,I,7) = QFROM(J,K,I,7)/(CMU*QFROM(J,K,I,6))
  310          CONTINUE
  320       CONTINUE
  330    CONTINUE
C
C 4. Convert K-Omega to K-Epsilon
C
      ELSE IF (ITURBX .EQ. ITKW .AND. ITURB .EQ. ITKE) THEN
         DO 430 I = 2, IDIM
            DO 420 K = 2, KDIM
               DO 410 J = 2, JDIM
                  QTO(J,K,I,6) = QFROM(J,K,I,6)
                  QTO(J,K,I,7) = CMU*QFROM(J,K,I,6)*QFROM(J,K,I,7)
  410          CONTINUE
  420       CONTINUE
  430    CONTINUE
C
C 5.  Convert K-Epsilon or K-Omega to Reynolds Stress
C     For Each Cross Section I
C        a. Calculate derivatives at cell centers
C        b. Calculate (negative of) Reynolds Stresses from 2-equation model
C        c. Store Reynolds stresses into Q
C        d. Calculate epsilon from epsilon or omega
C     Next I
C
      ELSE IF ( (ITURBX.EQ.ITKE .OR. ITURBX.EQ.ITKW)
     1           .AND. ITURB.EQ.ITRS) THEN
C
C     Loop over I performing the conversion at each I station
C
         DO 590 I = 2, IDIM
C
C 5-a. Calculate derivatives of Q at cell centers.
C
C     Temporary variables used internally in DELQC:
C        TAU(1-3) for QJ
C        SRC(1-3) for QK
C        TAU(5->) for QPI
C        SRC(4-6) for QMI
C     QJ is dimensioned as JDIM,2:KDIM therefore need more room for it
C     than 1 plane of TAU. Similarly for QK.  QPI and QMI require only
C     one plane as they are dimensioned 2:JDIM,2:KDIM.
C     Use SRC for some of the temporary space to fix a memory allocation
C     problem.
C
C     Calculate derivatives at interior cell centers only.
C
            NBOUND = 0
            CALL DELQC (IDIM, JDIM, KDIM, I, IFDELQ, NBOUND,
     1                  QFROM, PROPSF, S, VOL, IBCDAT, NBCS,
     2                  TAU(2,2,1), SRC(2,2,1), TAU(2,2,5), SRC(2,2,4),
     3                  QC, PROPSC, DQDX, DQDY, DQDZ)
C
C 5-b.  Calculate the Reynold's stresses at the cell centers.
C                                      ~
C     The array TAU contains {- rho (u" u")}.
C                                     i  j
C     For laminar flow:            TAU_ij => zero.
C         algebraic models:        TAU_ij => modeled with Boussinesq approx.
C         two-equation models:     TAU_ij => modeled with Boussinesq approx.
C         Reynold's stress models: TAU_ij => computed from PDE.
C     Pass in RMUT and DUDX,DUDY,DUDZ for Boussinesq approximation.
C     Pass in QC for Q data at same location as DQDX,... derivative data.
C     The Reynold's stresses are stored as:
C         TAU(1) = TAUXX, TAU(2) = TAUYY, TAU(3) = TAUZZ,
C         TAU(4) = TAUXY, TAU(5) = TAUXZ, TAU(6) = TAUYZ
C
            CALL TAUIJ (IMODLX, NPTS, QC, PROPSC, DQDX, DQDY, DQDZ, TAU)
C
C 5-c.  Calculate the TO variables
C
            DO 520 K = 2, KDIM
               DO 510 J = 2, JDIM
                  QTO(J,K,I, 6) = - TAU(J,K,1) / QTO(J,K,I,1)
                  QTO(J,K,I, 7) = - TAU(J,K,2) / QTO(J,K,I,1)
                  QTO(J,K,I, 8) = - TAU(J,K,3) / QTO(J,K,I,1)
                  QTO(J,K,I, 9) = - TAU(J,K,4) / QTO(J,K,I,1)
                  QTO(J,K,I,10) = - TAU(J,K,5) / QTO(J,K,I,1)
                  QTO(J,K,I,11) = - TAU(J,K,6) / QTO(J,K,I,1)
  510          CONTINUE
  520       CONTINUE
C
C 5-d.  Calculate Epsilon
C
C ITURBX = K-Epsilon
C
            IF (ITURBX .EQ. ITKE) THEN
               DO 540 K = 2, KDIM
                  DO 530 J = 2, JDIM
                     QTO(J,K,I,12) = QFROM(J,K,I,7)
  530             CONTINUE
  540          CONTINUE
C
C ITURBX = K-Omega
C        epsilon = C_mu * K * omega
C
            ELSE IF (ITURBX .EQ. ITKW) THEN
               DO 560 K = 2, KDIM
                  DO 550 J = 2, JDIM
                     QTO(J,K,I,12) = CMU*QFROM(J,K,I,6)*QFROM(J,K,I,7)
  550             CONTINUE
  560          CONTINUE
C
C  Error
C
            ELSE
               WRITE (IOUT,1005) ITURBX
            ENDIF
C
  590    CONTINUE
C
C Error - Unsupported Conversion
C
      ELSE
         WRITE (IOUT,1000) ITURBX, ITURB
         STOP
      ENDIF
C
C Finished converting restart file
      RETURN
 1000 FORMAT (' ','CONVRT: ERROR-> Unsupported turbulence model ',
     1            'conversion specified.',
     2       /' ',15X,'Turbulence model FROM = ',I5,
     3        ' ',15X,'Turbulence model TO   = ',I5,
     4       /' ', 8X,'RUN ABORTING!')
 1005 FORMAT (' ','CONVRT: ERROR-> Unsupported two equation model to ',
     1            'convert to Reynolds Stress: ITURBX = ',I5)
      END
      SUBROUTINE DTFACT (IDIM, JDIM, KDIM, I, Q, PFACTR)
C
C     Routine to calculate time step factor to reduce time step at a shock.
C     Based on discussions and code of Jeff White.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : I Plane (cell center) to perform calculations at
C     Q              : Primitive variables at cell centers
C     PFACTR         : Factor to reduce CFL by based on pressure gradient
C                      PFACTR = 1 : Maintain time step
C                      PFACTR = 0 : Set time step to minimum value
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PFACTR(JDIM,KDIM)
C
C     Calculate factor based on pressure switch to reduce time step at a shock
C
      IF ( .true. ) THEN
         DO 120 K = 2, KDIM
            DO 110 J = 2, JDIM
               PDX  = 0.5E0 * (Q(J,K,I+1,5) - Q(J,K,I-1,5)) / Q(J,K,I,5)
               PDY  = 0.5E0 * (Q(J+1,K,I,5) - Q(J-1,K,I,5)) / Q(J,K,I,5)
               PDZ  = 0.5E0 * (Q(J,K+1,I,5) - Q(J,K-1,I,5)) / Q(J,K,I,5)
C
C     If marching scheme set pdx to zero and only look at shocks in crossflow
C
               IF (ISOLVR .EQ. IMARCH) THEN
                  PDX = 0.E0
               ENDIF
C
               PDEL = SQRT ( PDX*PDX + PDY*PDY + PDZ*PDZ )
               PFACTR(J,K) = (1.E0 - TANH(PDEL))**2
  110       CONTINUE
  120    CONTINUE
C
C     Set up to maintain time step
C
      ELSE
         DO 220 K = 2, KDIM
            DO 210 J = 2, JDIM
               PFACTR(J,K) = 1.E0
  210       CONTINUE
  220    CONTINUE
      ENDIF
C
C     Finished
      RETURN
      END
      SUBROUTINE DELTAT (IBLOCK, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, DTJ, VOL, S, PFACTR,
     2                   VISCOS, ITURB, ITER, DTCFLC,
     3                   DTMIN, IBLKMN, IDTMIN, JDTMIN, KDTMIN,
     4                   DTMAX, IBLKMX, IDTMAX, JDTMAX, KDTMAX)
C
C Routine to calculate time step divided by the cell volume and the
C minimum/maximum value and location of DT/CFL
C IF DTINPT > 0   DT = DTINPT             - CONSTANT TIME STEP
C    DTINPT < 0   DT = DT(CFL=ABS(DT))   - CONSTANT CFL
C
C Use average of metrics in calculation of the cfl number
C
C This routine is organized as follows:
C     1. Set up control of time step increment and viscous effects
C     2. Calculate time step and min/max location
C        a. Constant time step (Time Accurate)
C        b. Constant CFL
C     3. Scale time step by Jacobian (inverse of volume) DTJ = dt / vol
C
C IBLOCK         : Current block
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C DTJ            : Time step divided by cell volume DTJ = DT * J = DT / VOL.
C VOL            : Cell volume
C S              : Metrics
C PFACTR         : Factor to reduce time step by at a shock
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C ITURB          : Turbulence model
C ITER           : Current iteration used to vary time step
C DTCFLC         : Value of DT/CFL for current iteration
C DTMIN          : Minimum time step or CFL
C IBLKMN,IDTMIN, : Location of minimum time step or CFL (Block,I,J,K)
C  JDTMIN,KDTMIN
C DTMAX          : Maximum time step or CFL
C IBLKMX,IDTMAX, : Location of maximum time step or CFL (Block,I,J,K)
C  JDTMAX,KDTMAX
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          DTJ   (JDIM,KDIM,IDIM),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3)
C
      DIMENSION PFACTR(JDIM,KDIM)
C
      LOGICAL VISCOS(3)
C
C 1.  Set up control of time step increment and viscous effects
C
C     Set up factor to calculate new time step for ramping
C
      IF (CFLFNL .EQ. 0) THEN
         FACT = 0.E0
      ELSE
         IF (ITER .GT. ITDFNL) THEN
            FACT = 1.E0
         ELSE
            FACT = FLOAT(ITER-1)/FLOAT(ITDFNL-1)
         ENDIF
      ENDIF
C
C     Set up constants to include viscous effects and three-dimensional
C     effectsin the CFL
C
      IF ( VISCOS(1) ) THEN
         VISI = 1.E0
      ELSE
         VISI = 0.E0
      ENDIF
C
      IF ( VISCOS(2) ) THEN
         VISJ = 1.E0
      ELSE
         VISJ = 0.E0
      ENDIF
C
      IF ( VISCOS(3) ) THEN
         VISK = 1.E0
      ELSE
         VISK = 0.E0
      ENDIF
C
      IF (THREED .OR. AXISYM) THEN
         R3D = 1.E0
      ELSE
         R3D = 0.E0
      ENDIF
C
C 2.   Calculate time step and min/max location
C
C 2-a. Constant time step (Time Accurate)
C
      IF (DT .GT. 0.0E0) THEN
         DTCFLC  = DT + FACT*(CFLFNL-DT)
         DO 230 I = IPSTRT, IPEND
            DO 220 K = 2, KDIM
               DO 210 J = 2, JDIM
                  DTJ(J,K,I) = DTCFLC
C
                  RHO  = Q(J,K,I,1)
                  U    = Q(J,K,I,2)
                  V    = Q(J,K,I,3)
                  W    = Q(J,K,I,4)
                  P    = Q(J,K,I,5)
C
                  A    = SQRT (GAMMA*P/RHO)
C
                  RMU  = PROPS(J,K,I,1)
                  RMUT = PROPS(J,K,I,2)
C
C Calculate the average metric quantities at the cell center.
C
                  DXI = 0.5E0 * (S(J,K,I-1,1,1) + S(J,K,I,1,1))
                  DYI = 0.5E0 * (S(J,K,I-1,2,1) + S(J,K,I,2,1))
                  DZI = 0.5E0 * (S(J,K,I-1,3,1) + S(J,K,I,3,1))
                  DSI = 0.5E0 * (S(J,K,I-1,4,1) + S(J,K,I,4,1))
C
                  DXJ = 0.5E0 * (S(J-1,K,I,1,2) + S(J,K,I,1,2))
                  DYJ = 0.5E0 * (S(J-1,K,I,2,2) + S(J,K,I,2,2))
                  DZJ = 0.5E0 * (S(J-1,K,I,3,2) + S(J,K,I,3,2))
                  DSJ = 0.5E0 * (S(J-1,K,I,4,2) + S(J,K,I,4,2))
C
C Remove the three-dimensional influence in CFL if a 2D case
C
                  DXK = 0.5E0 * (S(J,K-1,I,1,3) + S(J,K,I,1,3)) * R3D
                  DYK = 0.5E0 * (S(J,K-1,I,2,3) + S(J,K,I,2,3)) * R3D
                  DZK = 0.5E0 * (S(J,K-1,I,3,3) + S(J,K,I,3,3)) * R3D
                  DSK = 0.5E0 * (S(J,K-1,I,4,3) + S(J,K,I,4,3)) * R3D
C
C Calculate the invscid and viscous eigenvalues in the three coordinates
C
                  RLAMII     = DSI * ( ABS(DXI*U + DYI*V + DZI*W) + A )
                  RLAMIJ     = DSJ * ( ABS(DXJ*U + DYJ*V + DZJ*W) + A )
                  RLAMIK     = DSK * ( ABS(DXK*U + DYK*V + DZK*W) + A )
C
                  RMUI       = 0.25E0 * (PROPS(J,K,I-1,1) + 2.E0*RMU  +
     1                                   PROPS(J,K,I+1,1))
                  RMUTI      = 0.25E0 * (PROPS(J,K,I-1,2) + 2.E0*RMUT +
     1                                   PROPS(J,K,I+1,2))
                  RLAMVI     = 4.E0 * VISI * DSI*DSI * GAMMA*FSMACH/RE*
     1                       (RMUI/PR + RMUTI/PRT) / (RHO * VOL(J,K,I))
C
                  RMUJ       = 0.25E0 * (PROPS(J-1,K,I,1) + 2.E0*RMU  +
     1                                   PROPS(J+1,K,I,1))
                  RMUTJ      = 0.25E0 * (PROPS(J-1,K,I,2) + 2.E0*RMUT +
     1                                   PROPS(J+1,K,I,2))
                  RLAMVJ     = 4.E0 * VISJ * DSJ*DSJ * GAMMA*FSMACH/RE*
     1                       (RMUJ/PR + RMUTJ/PRT) / (RHO * VOL(J,K,I))
C
                  RMUK       = 0.25E0 * (PROPS(J,K-1,I,1) + 2.E0*RMU  +
     1                                   PROPS(J,K+1,I,1))
                  RMUTK      = 0.25E0 * (PROPS(J,K-1,I,2) + 2.E0*RMUT +
     1                                   PROPS(J,K+1,I,2))
                  RLAMVK     = 4.E0 * VISK * DSK*DSK * GAMMA*FSMACH/RE*
     1                       (RMUK/PR + RMUTK/PRT) / (RHO * VOL(J,K,I))
C
C Calculate CFL as per Anderson, Thomas and van Leer for the inviscid
C portion (identical to Swanson et al) and include the viscous
C part due to Swanson et al.
C
                  CFLT       = DTCFLC * ( RLAMII + RLAMIJ + RLAMIK +
     1                                    RLAMVI + RLAMVJ + RLAMVK ) /
     2                                  VOL(J,K,I)
C
C Find minimum and maximum CFL
C
                  IF (CFLT .GT. DTMAX) THEN
                     DTMAX  = CFLT
                     IBLKMX = IBLOCK
                     IDTMAX = I
                     JDTMAX = J
                     KDTMAX = K
                  ENDIF
                  IF (CFLT .LT. DTMIN) THEN
                     DTMIN  = CFLT
                     IBLKMN = IBLOCK
                     IDTMIN = I
                     JDTMIN = J
                     KDTMIN = K
                  ENDIF
 210           CONTINUE
 220        CONTINUE
 230     CONTINUE
C
C 2-b. Constant CFL
C
      ELSE
         DTCFLC   = CFL + FACT*(CFLFNL-CFL)
         CFLSHK = MIN (1.E0, DTCFLC)
         DO 260 I = IPSTRT, IPEND
C
C      Calculate factor to reduce time step by
C
            CALL DTFACT (IDIM, JDIM, KDIM, I, Q, PFACTR)
C
            DO 250 K = 2, KDIM
               DO 240 J = 2, JDIM
                  RHO  = Q(J,K,I,1)
                  U    = Q(J,K,I,2)
                  V    = Q(J,K,I,3)
                  W    = Q(J,K,I,4)
                  P    = Q(J,K,I,5)
C
                  A    = SQRT (GAMMA*P/RHO)
C
                  RMU  = PROPS(J,K,I,1)
                  RMUT = PROPS(J,K,I,2)
C
C Calculate the average metric quantities at the cell center.
C
                  DXI = 0.5E0 * (S(J,K,I-1,1,1) + S(J,K,I,1,1))
                  DYI = 0.5E0 * (S(J,K,I-1,2,1) + S(J,K,I,2,1))
                  DZI = 0.5E0 * (S(J,K,I-1,3,1) + S(J,K,I,3,1))
                  DSI = 0.5E0 * (S(J,K,I-1,4,1) + S(J,K,I,4,1))
C
                  DXJ = 0.5E0 * (S(J-1,K,I,1,2) + S(J,K,I,1,2))
                  DYJ = 0.5E0 * (S(J-1,K,I,2,2) + S(J,K,I,2,2))
                  DZJ = 0.5E0 * (S(J-1,K,I,3,2) + S(J,K,I,3,2))
                  DSJ = 0.5E0 * (S(J-1,K,I,4,2) + S(J,K,I,4,2))
C
C Remove the three-dimensional influence in CFL if a 2D case
C
                  DXK = 0.5E0 * (S(J,K-1,I,1,3) + S(J,K,I,1,3)) * R3D
                  DYK = 0.5E0 * (S(J,K-1,I,2,3) + S(J,K,I,2,3)) * R3D
                  DZK = 0.5E0 * (S(J,K-1,I,3,3) + S(J,K,I,3,3)) * R3D
                  DSK = 0.5E0 * (S(J,K-1,I,4,3) + S(J,K,I,4,3)) * R3D
C
C Calculate local CFL
C
                  CFLLCL     = CFLSHK + PFACTR(J,K) * (DTCFLC - CFLSHK)
C
C Calculate the invscid and viscous eigenvalues in the three coordinates
C
                  RLAMII     = DSI * ( ABS(DXI*U + DYI*V + DZI*W) + A )
                  RLAMIJ     = DSJ * ( ABS(DXJ*U + DYJ*V + DZJ*W) + A )
                  RLAMIK     = DSK * ( ABS(DXK*U + DYK*V + DZK*W) + A )
C
                  RMUI       = 0.25E0 * (PROPS(J,K,I-1,1) + 2.E0*RMU  +
     1                                   PROPS(J,K,I+1,1))
                  RMUTI      = 0.25E0 * (PROPS(J,K,I-1,2) + 2.E0*RMUT +
     1                                   PROPS(J,K,I+1,2))
                  RLAMVI     = 4.E0 * VISI * DSI*DSI * GAMMA*FSMACH/RE*
     1                       (RMUI/PR + RMUTI/PRT) / (RHO * VOL(J,K,I))
C
                  RMUJ       = 0.25E0 * (PROPS(J-1,K,I,1) + 2.E0*RMU  +
     1                                   PROPS(J+1,K,I,1))
                  RMUTJ      = 0.25E0 * (PROPS(J-1,K,I,2) + 2.E0*RMUT +
     1                                   PROPS(J+1,K,I,2))
                  RLAMVJ     = 4.E0 * VISJ * DSJ*DSJ * GAMMA*FSMACH/RE*
     1                       (RMUJ/PR + RMUTJ/PRT) / (RHO * VOL(J,K,I))
C
                  RMUK       = 0.25E0 * (PROPS(J,K-1,I,1) + 2.E0*RMU  +
     1                                   PROPS(J,K+1,I,1))
                  RMUTK      = 0.25E0 * (PROPS(J,K-1,I,2) + 2.E0*RMUT +
     1                                   PROPS(J,K+1,I,2))
                  RLAMVK     = 4.E0 * VISK * DSK*DSK * GAMMA*FSMACH/RE*
     1                       (RMUK/PR + RMUTK/PRT) / (RHO * VOL(J,K,I))
C
C Calculate CFL as per Anderson, Thomas and van Leer for the inviscid
C portion (identical to Swanson et al) and include the viscous
C part due to Swanson et al.
C
                  DTJ(J,K,I) = CFLLCL * VOL(J,K,I) /
     1                         ( RLAMII + RLAMIJ + RLAMIK +
     2                           RLAMVI + RLAMVJ + RLAMVK )
 240           CONTINUE
 250        CONTINUE
 260     CONTINUE
C
C Calculate the minimum and maximum DT for constant CFL time-step.
C
         DO 290 I = IPSTRT, IPEND
            DO 280 K = 2, KDIM
               DO 270 J = 2, JDIM
                  IF (DTJ(J,K,I) .GT. DTMAX) THEN
                     DTMAX  = DTJ(J,K,I)
                     IBLKMX = IBLOCK
                     IDTMAX = I
                     JDTMAX = J
                     KDTMAX = K
                  ENDIF
                  IF (DTJ(J,K,I) .LT. DTMIN) THEN
                     DTMIN  = DTJ(J,K,I)
                     IBLKMN = IBLOCK
                     IDTMIN = I
                     JDTMIN = J
                     KDTMIN = K
                  ENDIF
  270          CONTINUE
  280       CONTINUE
  290    CONTINUE
C
      ENDIF
C
C 3. Scale time step by Jacobian (inverse of volume) DTJ = dt / vol
C
      DO 330 I = IPSTRT, IPEND
         DO 320 K = 2, KDIM
            DO 310 J = 2, JDIM
               DTJ(J,K,I) = DTJ(J,K,I) / VOL(J,K,I)
  310       CONTINUE
  320    CONTINUE
  330 CONTINUE
C
C Finished
      RETURN
      END
      SUBROUTINE FIXQ (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND, Q,
     1                 QMIN, NFIXQ, IERRCD)
C
C Routine to ensure positivity of the variables controlled by the QMIN array.
C If QMIN(L) >= 0, then perform the positivity correction for the L variable.
C
C Two types of positivty preservation are provided:
C     1. Set Q = QMIN
C     2. Set Q = average of neighboring points
C
C This routine is organized as follows
C     1. Check for positivity of density and pressure; return error code
C     2. Loop over all turbulence variables and enforce positivity
C        a. Calculate Q = QMIN positivity preservation
C        b. Calculate Q = average of neighboring points
C           i.  MARCHing routine (average only in the plane)
C           ii. Time dependent routine
C        c. Error - invalid option
C
C ITURB          : Turbulence model
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C Q              : Primitive variables at cell centers
C QMIN           : Control array for minimum value of Q
C NFIXQ          : Number of times reset Q
C IERRCD         : Error code
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION QMIN  (NQ)
C
      DIMENSION NFIXQ (NQ)
C
C 1.  Check for positivity of density and pressure; return error code
C
      DO I = IPSTRT, IPEND
         DO K = 2, KDIM
            DO J = 2, JDIM
               IF (Q(J,K,I,1) .LT. QMIN(1)) THEN
                  NFIXQ(1)   = NFIXQ(1) + 1
                  Q(J,K,I,1) = QMIN(1)
                  IERRCD     = IYES
               ENDIF
               IF (Q(J,K,I,5) .LT. QMIN(5)) THEN
                  NFIXQ(5)   = NFIXQ(5) + 1
                  Q(J,K,I,5) = QMIN(5)
                  IERRCD     = IYES
               ENDIF
            END DO
         END DO
      END DO
C
      IF (IERRCD .EQ. IYES) THEN
         RETURN
      END IF
C
C 2.  Loop over all turbulence variables and perform the positivity fix if
C     QMIN(L) >= 0
C
      DO 900 L = 6, NQ
         IF (QMIN(L) .GE. 0.E0) THEN
C
C 2-a. Set Q = QMIN
C
            IF (IFIXQ .EQ. IFIXMN) THEN
               DO 90 I = IPSTRT, IPEND
                  DO 80 K = 2, KDIM
                     DO 70 J = 2, JDIM
                        IF (Q(J,K,I,L) .LT. QMIN(L)) THEN
                           NFIXQ(L)   = NFIXQ(L) + 1
                           Q(J,K,I,L) = QMIN(L)
                        ENDIF
   70                CONTINUE
   80             CONTINUE
   90          CONTINUE
            ELSE IF (IFIXQ .EQ. IFIXAV) THEN
C
C 2-b. Set Q = average of neighboring points
C
C 2-b-i. MARCHing routine: average data only in the plane
C
               IF (ISOLVR .EQ. IMARCH) THEN
                  IF (THREED) THEN
                     DO 130 I = IPSTRT, IPEND
                        DO 120 K = 2, KDIM
CDIR$ IVDEP
                           DO 110 J = 2, JDIM
                              IF (Q(J,K,I,L) .LT. QMIN(L)) THEN
                                 NFIXQ(L)   = NFIXQ(L) + 1
                                 QNEW       =
     1                              ( MAX(QMIN(L), Q(J+1,K,I,L))
     2                               + MAX(QMIN(L), Q(J-1,K,I,L))
     3                               + MAX(QMIN(L), Q(J,K+1,I,L))
     4                               + MAX(QMIN(L), Q(J,K-1,I,L)) )/4.E0
                                 Q(J,K,I,L) = QNEW
                              ENDIF
  110                      CONTINUE
  120                   CONTINUE
  130                CONTINUE
                  ELSE
                     K = 2
                     DO 150 I = IPSTRT, IPEND
CDIR$ IVDEP
                        DO 140 J = 2, JDIM
                           IF (Q(J,K,I,L) .LT. QMIN(L)) THEN
                              NFIXQ(L)   = NFIXQ(L) + 1
                              QNEW = ( MAX(QMIN(L), Q(J+1,K,I,L))
     1                               + MAX(QMIN(L), Q(J-1,K,I,L)) )/2.E0
                              Q(J,K,I,L) = QNEW
                           ENDIF
  140                   CONTINUE
  150                CONTINUE
                  ENDIF
C
C 2-b-ii. Time dependent section - average all neighboring points
C
               ELSE
                  IF (THREED) THEN
                     DO 230 I = IPSTRT, IPEND
                        DO 220 K = 2, KDIM
CDIR$ IVDEP
                           DO 210 J = 2, JDIM
                              IF (Q(J,K,I,L) .LT. QMIN(L)) THEN
                                 NFIXQ(L)   = NFIXQ(L) + 1
                                 QNEW       =
     1                               ( MAX(QMIN(L), Q(J+1,K,I,L))
     2                               + MAX(QMIN(L), Q(J-1,K,I,L))
     3                               + MAX(QMIN(L), Q(J,K+1,I,L))
     4                               + MAX(QMIN(L), Q(J,K-1,I,L))
     5                               + MAX(QMIN(L), Q(J,K,I+1,L))
     6                               + MAX(QMIN(L), Q(J,K,I-1,L)) )/6.E0
                                 Q(J,K,I,L) = QNEW
                              ENDIF
  210                      CONTINUE
  220                   CONTINUE
  230                CONTINUE
                  ELSE
                     K = 2
                     DO 250 I = IPSTRT, IPEND
CDIR$ IVDEP
                        DO 240 J = 2, JDIM
                           IF (Q(J,K,I,L) .LT. QMIN(L)) THEN
                              NFIXQ(L)   = NFIXQ(L) + 1
                              QNEW = ( MAX(QMIN(L), Q(J+1,K,I,L))
     1                               + MAX(QMIN(L), Q(J-1,K,I,L))
     2                               + MAX(QMIN(L), Q(J,K,I+1,L))
     3                               + MAX(QMIN(L), Q(J,K,I-1,L)) )/4.E0
                              Q(J,K,I,L) = QNEW
                           ENDIF
  240                   CONTINUE
  250                CONTINUE
                  ENDIF
               ENDIF
            ELSE
C
C 2-c. Error - Invalid positivity type input
C
               WRITE (IOUT,1000) IFIXQ
               IERRCD = IYES
               RETURN
            ENDIF
C
C      Finished with this variable, do the next
C
         ENDIF
  900 CONTINUE
      RETURN
 1000 FORMAT (' ','FIXQ  : ERROR-> Invalid FIXQ option chosen ',I10,
     1       /' ','RUN ABORTING!')
      END
      SUBROUTINE FRCINT (ITURB, NBLKS, IDIM, JDIM, KDIM,
     1                   IOFF,  IOFFS, IOFFQ, IOFFP,
     2                   Q, PROPS, S, RC, NXBCS, NBCS, IBCDAT,
     3                   FORCE, CL, CD)
C
C Routine to loop over all blocks and all surfaces integrating the forces
C on the surface for the current grid level.
C If INVISCID case then integrate forces on TANGENCY boundaries.
C If VISCOUS  case then integrate forces on WALL or WALLFN boundaries.
C
C Programming note: The arrays (Q, PROPS, S, RC) are passed in as the
C                   complete array since the offset pointers are calculated
C                   from the very beginning of the array.
C
C This routine is organized as follows:
C     0. Initialize forces to zero
C     1. Calculate forces integrated over all blocks
C        For each block {
C           For each surface boundary condition {
C              Call routine to add incremental forces
C           }
C        }
C     2. Non-dimensionalize forces to force coefficients
C
C ITURB          : Turbulence model
C NBLKS          : Number of blocks
C IDIM,JDIM,KDIM : Dimensions of all blocks on finest level
C IOFF           : Offset pointer
C IOFFS          : Offset pointer for S     array
C IOFFQ          : Offset pointer for Q     array
C IOFFP          : Offset pointer for PROPS array
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C RC             : Position vector to cell center
C NXBCS          : Maximum number of bcs IBCDAT is dimensioned for
C NBCS           : Number of boundary conditions per block
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C FORCE          : Force coefficients (1 = x, 2 = y, 3 = z)
C CL,CD          : Lift, Drag coefficients
C
      include 'common.inc'
C
      DIMENSION IDIM  (NBLKS),
     1          JDIM  (NBLKS),
     2          KDIM  (NBLKS),
     3          IOFF  (NBLKS),
     4          IOFFS (NBLKS),
     5          IOFFQ (NBLKS),
     6          IOFFP (NBLKS)
C
      DIMENSION Q     (*),
     1          PROPS (*),
     2          S     (*),
     3          RC    (*)
C
      DIMENSION NBCS  (NBLKS),
     1          IBCDAT(10,NXBCS,NBLKS)
C
      DIMENSION FORCE (3)
C
      LOGICAL   VISCOS
C
C Set viscos to false if doing an inviscid case, else true
C
      IF (ITURB .EQ. ITNVSD) THEN
         VISCOS = .FALSE.
      ELSE
         VISCOS = .TRUE.
      ENDIF
C
C 0.  Initialize forces to zero
C
      FORCE(1) = 0.E0
      FORCE(2) = 0.E0
      FORCE(3) = 0.E0
C
C 1.  Calculate forces integrated over all blocks
C
      DO 190 IBLK = 1, NBLKS
         IQ    = IOFFQ(IBLK) * NQ    + 1
         IP    = IOFFP(IBLK) * NP    + 1
         IS    = IOFFS(IBLK) * 4 * 3 + 1
         IR    = IOFFS(IBLK) * 3     + 1
         DO 150 IBC = 1, NBCS(IBLK)
            IBCTYP   = IBCDAT(1,IBC,IBLK)
            IF ( (.NOT. VISCOS .AND. IBCTYP .EQ. ITAN)  .OR.
     1           (VISCOS .AND.
     2               (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN)) ) THEN
               CALL FRCEL (IDIM(IBLK), JDIM(IBLK), KDIM(IBLK),
     1                     Q(IQ), PROPS(IP), S(IS), RC(IR),
     2                     IBCDAT(1,IBC,IBLK), VISCOS, FORCE)
            ENDIF
  150    CONTINUE
  190 CONTINUE
C
C 2.  Non-dimensionalize forces to force coefficients
C     C_f = F / (1/2 rho_inf U_inf^2 Area_ref) where Area_ref is the
C                                              reference area of the body
C
      CONST    = 2.E0 / (FSMACH * FSMACH * AREARF)
      FORCE(1) = FORCE(1) * CONST
      FORCE(2) = FORCE(2) * CONST
      FORCE(3) = FORCE(3) * CONST
C
C     C_L and C_D: Defined relative to the freestream velocity direction
C
      PI     = ACOS(-1.E0)
      ALPHAR = ALPHA * PI / 180.E0
      IF (THREED) THEN
         CL  = FORCE(3) * COS(ALPHAR) - FORCE(1) * SIN(ALPHAR)
         CD  = FORCE(1) * COS(ALPHAR) + FORCE(3) * SIN(ALPHAR)
      ELSE
         CL  = FORCE(2) * COS(ALPHAR) - FORCE(1) * SIN(ALPHAR)
         CD  = FORCE(1) * COS(ALPHAR) + FORCE(2) * SIN(ALPHAR)
      ENDIF
C
C Finished calculating forces
      RETURN
      END
      SUBROUTINE FRCEL (IDIM, JDIM, KDIM, Q, PROPS, S, RC,
     1                  IBCDAT, VISCOS, FORCE)
C
C Routine to calculate the increment to the forces for the current surface
C element.
C
C This routine is organized as follows:
C     1. Setup memory for looping.
C     2.  Calculate Pressure force increments
C     3.  Calculate Viscous  force increments
C         i.  Wall contribution
C         ii. Wall function contribution
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C S              : Metrics
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C RC             : Cell center grid
C VISCOS         : Logical determining whether or not to include viscous forces
C FORCE          : Forces (1 = x, 2 = y, 3 = z)
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          RC    (JDIM+1,KDIM+1,IDIM+1,3)
C
      DIMENSION IBCDAT(10)
C
      DIMENSION FORCE (3)
C
      LOGICAL   VISCOS
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C Two-Thirds
C
      T23    = 2.E0 / 3.E0
C
C Set control for higher order evaluation of du/dn and dT/dn
C     IHIORD = 0 for first  order
C     IHIORD = 1 for second order
C
      IHIORD = 1
C
C 1.  Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C Store boundary condition data in mnemonic names
C
      IBCTYP   = IBCDAT(1)
      IDIR     = IBCDAT(2)
      INROUT   = IBCDAT(3)
      ISTRT(1) = IBCDAT(4)
      IEND (1) = IBCDAT(5)
      ISTRT(2) = IBCDAT(6)
      IEND (2) = IBCDAT(7)
      ISTRT(3) = IBCDAT(8)
      IEND (3) = IBCDAT(9)
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
      IF (INROUT .EQ. 1) THEN
         IBCPT  = 1
         IBCPT2 = 0
         IBCN   = 2
         IBCN2  = 3
         IBCM   = 1
         SGNM   = 1.E0
      ELSE
         IBCPT  = IJKDIM(IDIR) + 1
         IBCPT2 = IJKDIM(IDIR) + 2
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
         IBCM   = IJKDIM(IDIR)
         SGNM   = - 1.E0
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C 2.  Calculate Pressure force increments
C
      DO 220 I2 = ISTRT(IC2), IEND(IC2)
         DO 210 I3 = ISTRT(IC3), IEND(IC3)
C
            IBC  = IBCPT *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JBC  = IBCPT *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KBC  = IBCPT *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            IM   = IBCM  *IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
            JM   = IBCM  *IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
            KM   = IBCM  *IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
            PW   = Q(JBC,KBC,IBC,5)
C
C Calculate the pressure force
C Minus sign since pressure acts opposite direction of face normal
C
            FPRESS   = PW * S(JM,KM,IM,4,IDIR) * SGNM
            FORCE(1) = FORCE(1) - FPRESS * S(JM,KM,IM,1,IDIR)
            FORCE(2) = FORCE(2) - FPRESS * S(JM,KM,IM,2,IDIR)
            FORCE(3) = FORCE(3) - FPRESS * S(JM,KM,IM,3,IDIR)
  210    CONTINUE
  220 CONTINUE
C
C 3.    Calculate Viscous  force increments
C
      IF (VISCOS) THEN
C
C 3-i.  Wall contribution
C
         IF (IBCTYP .EQ. IWALL) THEN
            DO 320 I2 = ISTRT(IC2), IEND(IC2)
               DO 310 I3 = ISTRT(IC3), IEND(IC3)
C
                  IBC  = IBCPT *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JBC  = IBCPT *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KBC  = IBCPT *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IBC2 = IBCPT2*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JBC2 = IBCPT2*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KBC2 = IBCPT2*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IN   = IBCN  *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JN   = IBCN  *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KN   = IBCN  *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IN2  = IBCN2 *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JN2  = IBCN2 *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KN2  = IBCN2 *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IM   = IBCM  *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JM   = IBCM  *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KM   = IBCM  *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  RHOW = Q(JBC,KBC,IBC,1)
                  PW   = Q(JBC,KBC,IBC,5)
C
                  UN   = Q(JN ,KN ,IN ,2)
                  UN2  = Q(JN2,KN2,IN2,2)
                  VN   = Q(JN ,KN ,IN ,3)
                  VN2  = Q(JN2,KN2,IN2,3)
                  WN   = Q(JN ,KN ,IN ,4)
                  WN2  = Q(JN2,KN2,IN2,4)
C
C Viscosity (RMUW) at the wall
C
                  RMUW   = PROPS(JBC,KBC,IBC,1)
C
C Distances
C
                  DN     = SQRT (
     1                      (RC(JN ,KN ,IN ,1) - RC(JBC,KBC,IBC,1))**2
     2                    + (RC(JN ,KN ,IN ,2) - RC(JBC,KBC,IBC,2))**2
     3                    + (RC(JN ,KN ,IN ,3) - RC(JBC,KBC,IBC,3))**2 )
C
                  DN2    = SQRT (
     1                      (RC(JN2,KN2,IN2,1) - RC(JN ,KN ,IN ,1))**2
     2                    + (RC(JN2,KN2,IN2,2) - RC(JN ,KN ,IN ,2))**2
     3                    + (RC(JN2,KN2,IN2,3) - RC(JN ,KN ,IN ,3))**2 )
C
C Calculate first derivative terms using first or second order differencing
C
                  DUDN   = (1-IHIORD) * (UN / DN)
     1                     +  IHIORD  * (-DN*DN*UN2 + (DN+DN2)**2*UN)
     2                                  / (DN*DN2*(DN+DN2))
C
                  DVDN   = (1-IHIORD) * (VN / DN)
     1                     +  IHIORD  * (-DN*DN*VN2 + (DN+DN2)**2*VN)
     2                                  / (DN*DN2*(DN+DN2))
C
                  DWDN   = (1-IHIORD) * (WN / DN)
     1                     +  IHIORD  * (-DN*DN*WN2 + (DN+DN2)**2*WN)
     2                                  / (DN*DN2*(DN+DN2))
C
                  DUDX   = S(JM,KM,IM,1,IDIR) * DUDN * SGNM
                  DUDY   = S(JM,KM,IM,2,IDIR) * DUDN * SGNM
                  DUDZ   = S(JM,KM,IM,3,IDIR) * DUDN * SGNM
C
                  DVDX   = S(JM,KM,IM,1,IDIR) * DVDN * SGNM
                  DVDY   = S(JM,KM,IM,2,IDIR) * DVDN * SGNM
                  DVDZ   = S(JM,KM,IM,3,IDIR) * DVDN * SGNM
C
                  DWDX   = S(JM,KM,IM,1,IDIR) * DWDN * SGNM
                  DWDY   = S(JM,KM,IM,2,IDIR) * DWDN * SGNM
                  DWDZ   = S(JM,KM,IM,3,IDIR) * DWDN * SGNM
C
                  SXX    = T23 * ( 2.E0*DUDX - DVDY - DWDZ )
                  SYY    = T23 * ( 2.E0*DVDY - DUDX - DWDZ )
                  SZZ    = T23 * ( 2.E0*DWDZ - DUDX - DVDY )
                  SXY    = ( DUDY + DVDX )
                  SXZ    = ( DWDX + DUDZ )
                  SYZ    = ( DWDY + DVDZ )
C
                  VISC   = RMUW * FSMACH / RE
                  SIGXX  = VISC * SXX
                  SIGYY  = VISC * SYY
                  SIGZZ  = VISC * SZZ
                  SIGXY  = VISC * SXY
                  SIGXZ  = VISC * SXZ
                  SIGYZ  = VISC * SYZ
C
C Calculate the Shear force
C
                  CNST     = S(JM,KM,IM,4,IDIR) * SGNM
                  FORCE(1) = FORCE(1) + CNST*(SIGXX*S(JM,KM,IM,1,IDIR)
     1              +SIGXY*S(JM,KM,IM,2,IDIR)+SIGXZ*S(JM,KM,IM,3,IDIR))
                  FORCE(2) = FORCE(2) + CNST*(SIGXY*S(JM,KM,IM,1,IDIR)
     1              +SIGYY*S(JM,KM,IM,2,IDIR)+SIGYZ*S(JM,KM,IM,3,IDIR))
                  FORCE(3) = FORCE(3) + CNST*(SIGXZ*S(JM,KM,IM,1,IDIR)
     1              +SIGYZ*S(JM,KM,IM,2,IDIR)+SIGZZ*S(JM,KM,IM,3,IDIR))
  310          CONTINUE
  320       CONTINUE
C
C 3-ii. Wall function contribution
C
         ELSE IF (IBCTYP .EQ. IWALFN) THEN
            write (iout,'(a)')
     1            ' Wall functions not yet supported in force routine'
         ENDIF
      ENDIF
C
C Finished with force increment
      RETURN
      END
      SUBROUTINE GDXTND (IDIM, JDIM, KDIM, R)
C
C Routine to extend the grid by copying the information on I=1,IDIM
C J=1,JDIM and K=1,KDIM grid faces into additional storage.
C
C IDIM,JDIM,KDIM : Dimensions of current block
C R              : Position vector of grid vertices (x,y,z)
C
      include 'common.inc'
C
      DIMENSION R     (0:JDIM+1,0:KDIM+1,0:IDIM+1,3)
C
C 1. Extend K face
C
      DO 130 L = 1, 3
         DO 120 I = 1, IDIM
            DO 110 J = 1, JDIM
               R(J,0     ,I,L) = R(J,1   ,I,L)
               R(J,KDIM+1,I,L) = R(J,KDIM,I,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C 2. Extend J face
C
      DO 230 L = 1, 3
         DO 220 I = 1, IDIM
            DO 210 K = 0, KDIM+1
               R(0     ,K,I,L) = R(1   ,K,I,L)
               R(JDIM+1,K,I,L) = R(JDIM,K,I,L)
  210       CONTINUE
  220    CONTINUE
  230 CONTINUE
C
C 3. Extend I face
C
      DO 330 L = 1, 3
         DO 320 K = 0, KDIM+1
            DO 310 J = 0, JDIM+1
               R(J,K,0     ,L) = R(J,K,1   ,L)
               R(J,K,IDIM+1,L) = R(J,K,IDIM,L)
  310       CONTINUE
  320    CONTINUE
  330 CONTINUE
C
C Finished extending grid.
      RETURN
      END
      SUBROUTINE GRDCUT (IDIM1, JDIM1, KDIM1, R1,
     1                   IDIM2, JDIM2, KDIM2, R2, ICUTS)
C
C Routine to do cut boundary condition on grid points R.
C Grid points stored in R1 are updated from grid points in R2.
C
C IDIM1,JDIM1,KDIM1 : Dimensions of current block 1
C R1                : Position vector of grid vertices (x,y,z) for block 1
C IDIM2,JDIM2,KDIM2 : Dimensions of current block 2
C R2                : Position vector of grid vertices (x,y,z) for block 2
C ICUTS             : Data controlling transfer from block 2 to block 1
C
      include 'common.inc'
      DIMENSION R1   (0:JDIM1+1,0:KDIM1+1,0:IDIM1+1,3),
     1          R2   (0:JDIM2+1,0:KDIM2+1,0:IDIM2+1,3)
      DIMENSION ICUTS(21)
C
      DIMENSION IJKDM1(3), IJKDM2(3)
      DIMENSION ISTR1(3),  IEND1(3),
     1          ISTR2(3),  IEND2(3),
     2          ISGN1(3),  ISGN2(3),
     3          IORD(3),   LEN(3)
C
C     Store IDIM, JDIM, KDIM in IJKDIM for looping
C
      IJKDM1(1) = IDIM1
      IJKDM1(2) = JDIM1
      IJKDM1(3) = KDIM1
      IJKDM2(1) = IDIM2
      IJKDM2(2) = JDIM2
      IJKDM2(3) = KDIM2
C
C     Store boundary condition data in mnemonic names
C
      IDIR1    = ICUTS( 2)
      INOUT1   = ICUTS( 3)
      ISTR1(1) = ICUTS( 4)
      IEND1(1) = ICUTS( 5)
      ISTR1(2) = ICUTS( 6)
      IEND1(2) = ICUTS( 7)
      ISTR1(3) = ICUTS( 8)
      IEND1(3) = ICUTS( 9)
C
      IBLK2    = ICUTS(10)
      IDIR2    = ICUTS(11)
      INOUT2   = ICUTS(12)
      ISTR2(1) = ICUTS(13)
      IEND2(1) = ICUTS(14)
      ISTR2(2) = ICUTS(15)
      IEND2(2) = ICUTS(16)
      ISTR2(3) = ICUTS(17)
      IEND2(3) = ICUTS(18)
C
      IORD(1)  = ICUTS(19)
      IORD(2)  = ICUTS(20)
      IORD(3)  = ICUTS(21)
C
C     Translate ICUTS data from cell-centered storage to grid point storage.
C     This requires decrementing the minimum ('starting') index. Do this only
C     for the indices that the cut loops over, not the idir direction.
C
      DO 10 L = 1, 3
C
         IF (L .NE. IDIR1) THEN
            IF (IEND1(L) .GE. ISTR1(L)) THEN
               ISTR1(L) = ISTR1(L) - 1
            ELSE
               IEND1(L) = IEND1(L) - 1
            ENDIF
         ENDIF
C
         IF (L .NE. IDIR2) THEN
            IF (IEND2(L) .GE. ISTR2(L)) THEN
               ISTR2(L) = ISTR2(L) - 1
            ELSE
               IEND2(L) = IEND2(L) - 1
            ENDIF
         ENDIF
   10 CONTINUE
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INOUT1 = 1) or the outer boundary (INOUT1 > 1)
C          IBCPT  = boundary grid point of block 1
C          INR    = corresponding point of block 2
C
      IF (INOUT1 .EQ. 1) THEN
         IBCPT  = 0
      ELSE
         IBCPT  = IJKDM1(IDIR1) + 1
      ENDIF
C
      IF (INOUT2 .EQ. 1) THEN
         INR    = 1
      ELSE
         INR    = IJKDM2(IDIR2)
      ENDIF
C
C     Find the length of the two outer loops and loop over these using
C     offsets and delta function to set the two cut data points to the
C     two interior data points of block 2.
C
      DO 100 L = 1, 3
C
         LEN(L) = ABS ( IEND1(L) - ISTR1(L) )
C
C     Increment/Decrement
C
         IF ( IEND1(L) .GT. ISTR1(L) ) THEN
            ISGN1(L) =   1
         ELSE
            ISGN1(L) = - 1
         ENDIF
C
C     Increment/Decrement
C
         IF ( IEND2(L) .GT. ISTR2(L) ) THEN
            ISGN2(L) =   1
         ELSE
            ISGN2(L) = - 1
         ENDIF
  100 CONTINUE
C
C     II1 first  boundary point of block 1
C     II2 second boundary point of block 1
C     IN1 first  interior point of block 2
C     IN2 second interior point of block 2
C
      IC1 = ICY (IDIR1, 1)
      IC2 = ICY (IDIR1, 2)
      IC3 = ICY (IDIR1, 3)
C
      JC1 = IORD (IC1)
      JC2 = IORD (IC2)
      JC3 = IORD (IC3)
C
      DO 800 I3 = 0, LEN(IC3)
         DO 700 I2 = 0, LEN(IC2)
            II = IBCPT                        * IKD (IC1, 1) +
     1           (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 1) +
     2           (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 1)
            JJ = IBCPT                        * IKD (IC1, 2) +
     1           (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 2) +
     2           (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 2)
            KK = IBCPT                        * IKD (IC1, 3) +
     1           (ISTR1(IC2) + ISGN1(IC2)*I2) * IKD (IC2, 3) +
     2           (ISTR1(IC3) + ISGN1(IC3)*I3) * IKD (IC3, 3)
C
            IN = INR                          * IKD (JC1, 1) +
     1           (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 1) +
     2           (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 1)
            JN = INR                          * IKD (JC1, 2) +
     1           (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 2) +
     2           (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 2)
            KN = INR                          * IKD (JC1, 3) +
     1           (ISTR2(JC2) + ISGN2(JC2)*I2) * IKD (JC2, 3) +
     2           (ISTR2(JC3) + ISGN2(JC3)*I3) * IKD (JC3, 3)
C
 1000 format (' ',7i5)
            R1(JJ,KK,II,1) = R2(JN,KN,IN,1)
            R1(JJ,KK,II,2) = R2(JN,KN,IN,2)
            R1(JJ,KK,II,3) = R2(JN,KN,IN,3)
 700     CONTINUE
 800  CONTINUE
C
C     Finished with Grid Cut to set image points for metric evaluation
      RETURN
      END
      SUBROUTINE GETTKE (ITURB, NPTS, Q, TKE)
C
C     Routine to calculate turbulent kinetic energy from Q
C
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate fluxes on.
C     Q              : Flow variables
C     TKE            : Turbulent kinetic energy
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          TKE   (NPTS)
C
C     Calculate the Turbulence Kinetic Energy (TKE)
C
C     b. Turbulence Kinetic Energy for Two Equation Turbulence models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 100 I = 1, NPTS
            TKE(I) = Q(I,6)
  100    CONTINUE
C
C     c. Turbulence Kinetic Energy for Reynolds Stress Turbulence model
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 110 I = 1, NPTS
C
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TKE(I) = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
  110    CONTINUE
C
C     a. Turbulence Kinetic Energy = 0 for Inviscid, Laminar and
C          Algebraic Turbulence models
C
      ELSE
         DO 120 I = 1, NPTS
            TKE(I) = 0.E0
  120    CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE IDENT (AI)
C
C     Routine to initialize the matrix AI to the identity
C     matrix of rank NRANK.
C
      include 'common.inc'
C
      DIMENSION AI    (NRANK,NRANK)
C
C     Set Identity Matrix up
C     first initialize the entire matrix to zero and then reset the
C     diagonals to one
C
      DO 120 L = 1, NRANK
         DO 110 M = 1, NRANK
            AI(L,M) = 0.E0
  110    CONTINUE
  120 CONTINUE
C
      DO 130 L = 1, NRANK
         AI(L,L) = 1.E0
  130 CONTINUE
      RETURN
      END
      SUBROUTINE INIT   (IDIM, JDIM, KDIM, Q, ITURB)
C
C Routine to initialize the flowfield to non-dimensionalized values.
C
C This routine is organized as follows:
C     1. Initialize all points to freestream values
C        a. Mean Flow
C        b. Turbulence Quantities
C           i.   k-epsilon
C           ii.  k-omega
C           iii. Reynolds stress
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at cell centers
C ITURB          : Turbulence model
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
C 1.   Initialize all points to freestream data
C 1-a. Mean Flow
C      Initialize gas variables
C
      GAMM1 = GAMMA - 1.E0
      GSQM1 = GAMMA * GAMMA - 1.E0
C
C Calculate freestream quantities based on the following
C storage and non-dimensionalization:
C      Q(1) = rho / rhoinf
C      Q(2) =   u / ainf
C      Q(3) =   v / ainf
C      Q(4) =   w / ainf
C      Q(5) =   p / pref
C where p = (gamm1 - 1) * (e - 0.5 * rho * q**2)
C       pref = rhoinf * ainf**2
C
      PI     = ACOS(-1.E0)
C
C If doing a two-dimensional case, then use the I-J plane
C
      IF ( THREED ) THEN
         UINF   = FSMACH * (COS(ALPHA*PI/180.E0))
         VINF   = 0.E0
         WINF   = FSMACH * (SIN(ALPHA*PI/180.E0))
      ELSE
         UINF   = FSMACH * (COS(ALPHA*PI/180.E0))
         VINF   = FSMACH * (SIN(ALPHA*PI/180.E0))
         WINF   = 0.E0
      ENDIF
      PREF   = 1.E0 / GAMMA
      EINF   = PREF / (GAMM1 * RHOINF) +
     1         0.5E0 * (UINF*UINF + VINF*VINF + WINF*WINF)
C
C Initialize the flow field
C
      DO 230 I = 0, IDIM+2
         DO 220 K = 0, KDIM+2
            DO 210 J = 0, JDIM+2
               Q(J,K,I,1)  = RHOINF
               Q(J,K,I,2)  = UINF
               Q(J,K,I,3)  = VINF
               Q(J,K,I,4)  = WINF
               Q(J,K,I,5)  = PREF
 210        CONTINUE
 220     CONTINUE
 230  CONTINUE
C
C 1-b-i.   Initialization for k-epsilon two equation model
C          Turbulence intensity = sqrt (k) / u_inf -> Charles Speziale
C
      IF (ITURB .EQ. ITKE) THEN
         EINF = EINF + TKEINF
         DO 413 I = 0, IDIM+2
            DO 412 K = 0, KDIM+2
               DO 411 J = 0, JDIM+2
                  Q(J,K,I,6) = TKEINF
                  Q(J,K,I,7) = EPSINF
  411          CONTINUE
  412       CONTINUE
  413    CONTINUE
C
C 1-b-ii.  Initialization for k-omega two equation model
C          Turbulence intensity = sqrt (k) / u_inf -> Charles Speziale
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         EINF = EINF + TKEINF
         DO 423 I = 0, IDIM+2
            DO 422 K = 0, KDIM+2
               DO 421 J = 0, JDIM+2
                  Q(J,K,I,6) = TKEINF
                  Q(J,K,I,7) = OMEINF
  421          CONTINUE
  422       CONTINUE
  423    CONTINUE
C
C 1-b-iii. Initialization for Reynolds Stress Turbulence model
C          Turbulence intensity = sqrt (k) / u_inf -> Charles Speziale
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         EINF = EINF + TKEINF
         DO 453 I = 0, IDIM+2
            DO 452 K = 0, KDIM+2
               DO 451 J = 0, JDIM+2
                  Q(J,K,I, 6) = TAUINF(1)
                  Q(J,K,I, 7) = TAUINF(2)
                  Q(J,K,I, 8) = TAUINF(3)
                  Q(J,K,I, 9) = TAUINF(4)
                  Q(J,K,I,10) = TAUINF(5)
                  Q(J,K,I,11) = TAUINF(6)
                  Q(J,K,I,12) = EPSINF
  451          CONTINUE
  452       CONTINUE
  453    CONTINUE
      ENDIF
C
C Finished with the flowfield initialization.
      RETURN
      END
      SUBROUTINE INITBC (IDIM, JDIM, KDIM, Q, QTEST, ITURB)
C
C Routine to initialize the boundary data to infinity to verify input bc data.
C
C This routine is organized as follows:
C     1. Initialize QTEST
C     2. Initialize boundary to QTEST to test bc's set
C        a. I faces
C        b. J faces
C        c. K faces - If three dimensional
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at cell centers
C QTEST          : Test array to initialize Q on boundaries
C ITURB          : Turbulence model
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QTEST (NQ)
C
C 1.   Initialize QTEST - density, pressure, turbulent quantities to infinity;
C                         velocities to zero
C
      DO 100 L = 1, NQ
         QTEST(L) = RMAX
  100 CONTINUE
C
      QTEST(2) = 0.E0
      QTEST(3) = 0.E0
      QTEST(4) = 0.E0
C
C 2.   Initialize boundary points to QTEST
C 2-a. I-faces
C
      DO 230 L = 1, NQ
         DO 220 K = 2, KDIM
            DO 210 J = 2, JDIM
               Q(J,K,     0,L) = QTEST(L)
               Q(J,K,     1,L) = QTEST(L)
               Q(J,K,IDIM+1,L) = QTEST(L)
               Q(J,K,IDIM+2,L) = QTEST(L)
  210       CONTINUE
  220    CONTINUE
  230 CONTINUE
C
C 2-b. J-faces
C
      DO 260 L = 1, NQ
         DO 250 K = 2, KDIM
            DO 240 I = 2, IDIM
               Q(     0,K,I,L) = QTEST(L)
               Q(     1,K,I,L) = QTEST(L)
               Q(JDIM+1,K,I,L) = QTEST(L)
               Q(JDIM+2,K,I,L) = QTEST(L)
  240       CONTINUE
  250    CONTINUE
  260 CONTINUE
C
C 2-c. K-faces - If Three Dimensional
C
      IF (THREED .OR. AXISYM) THEN
         DO 290 L = 1, NQ
            DO 280 I = 2, IDIM
               DO 270 J = 2, JDIM
                  Q(J,     0,I,L) = QTEST(L)
                  Q(J,     1,I,L) = QTEST(L)
                  Q(J,KDIM+1,I,L) = QTEST(L)
                  Q(J,KDIM+2,I,L) = QTEST(L)
  270          CONTINUE
  280       CONTINUE
  290    CONTINUE
      ENDIF
C
C Finished with the boundary data initialization.
      RETURN
      END
      SUBROUTINE INITPR (IDIM, JDIM, KDIM, PROPS, ITURB)
C
C Routine to initialize the Properties array for the flowfield to CMU
C
C IDIM,JDIM,KDIM : Dimensions of current block
C PROPS          : Properties at cell centers
C ITURB          : Turbulence model
C
      include 'common.inc'
C
      DIMENSION PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
      DO 130 I = 0, IDIM+2
         DO 120 K = 0, KDIM+2
            DO 110 J = 0, JDIM+2
               PROPS (J,K,I,ICMUST) = CMU
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C Finished initializing CMUSTR
      RETURN
      END
      SUBROUTINE INITQN (IDIM, JDIM, KDIM, Q, QN, QCP, TKE, IMODEL)
C
C Routine to initialize QN to Q.
C
C N.B. This routine stores the previous time level solutions as conserved
C      variables rather than primitive variables.
C
C This routine is organized as follows:
C     1. Copy Q to work array
C     2. Convert Q from primitive to conserved variables
C     3. Initialize QN to Q
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at iterative time level p
C QN             : Conserved variables at time levels n, n-1, etc.
C QCP            : Work array for conserved Q at level p
C TKE            : Work array for turbulent kinetic energy
C IMODEL         : Turbulence model
C
      include 'common.inc'
C
      INTEGER   IDIM, JDIM, KDIM
C
      DIMENSION Q   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN  (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ,NTMLVL)
C
      DIMENSION QCP (0:JDIM+2,0:KDIM+2,NQ),
     1          TKE (0:JDIM+2,0:KDIM+2)
C
      DIMENSION IMODEL(NMDL)
C
C Local variables
C
      INTEGER   I, J, K, L, NPTS
C
C     Turbulence model
C
      ITURB = IMODEL(1)
C
C     Loop over each cross section and convert Q to conserved then store in QN
C
      DO 900 I = 0, IDIM+2
C
C 1.  Copy Q to work array
C
         DO 130 L = 1, NQ
            DO 120 K = 0, KDIM+2
               DO 110 J = 0, JDIM+2
                  QCP(J,K,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
C
C 2.  Convert Q from primitive to conserved
C
         NPTS = (JDIM+3) * (KDIM+3)
         CALL CONP2C (ITURB, NPTS, QCP, TKE)
C
C 3.  Initialize QN to Q
C
         DO 340 ITIM = 1, NTMLVL
            DO 330 L = 1, NQ
               DO 320 K = 0, KDIM+2
                  DO 310 J = 0, JDIM+2
                     QN(J,K,I,L,ITIM) = QCP(J,K,L)
  310             CONTINUE
  320          CONTINUE
  330       CONTINUE
  340    CONTINUE
C
C     Next cross section
C
  900 CONTINUE
C
C     Finished initializing QN
      RETURN
      END
      SUBROUTINE INITTQ (IDIM, JDIM, KDIM, PROPS, NBCS, IBCDAT)
C
C Routine to initialize tau_wall and qdot_wall for wall functions.
C
C This routine is organized as follows:
C     1. Loop over all boundary conditions
C     2. If wall function BC then set tau_wall and qdot_wall
C
C IDIM,JDIM,KDIM : Dimensions of current block
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C NBCS           : Number of boundary conditions for current block
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C
      include 'common.inc'
C
      DIMENSION PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C Initial wall values
C
      TAUW = TKEINF * RHOINF * RE / (3.E0 * FSMACH)
      QW   = 0.E0
C
C Setup memory for looping.
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C 1. Loop over boundary conditions
C
      DO 900 IBC = 1, NBCS
C
C Store boundary condition data in mnemonic names
C
         IBCTYP   = IBCDAT(1,IBC)
C
C 2. Set initial values for wall function BCs
C
         IF (IBCTYP .EQ. IWALFN) THEN
            IDIR     = IBCDAT(2,IBC)
            INROUT   = IBCDAT(3,IBC)
            ISTRT(1) = IBCDAT(4,IBC)
            IEND (1) = IBCDAT(5,IBC)
            ISTRT(2) = IBCDAT(6,IBC)
            IEND (2) = IBCDAT(7,IBC)
            ISTRT(3) = IBCDAT(8,IBC)
            IEND (3) = IBCDAT(9,IBC)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
            DO 10 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
                  IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
               END IF
   10       CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C
            IF (INROUT .EQ. 1) THEN
               IBCPT2 = 0
            ELSE
               IBCPT2 = IJKDIM(IDIR) + 2
            ENDIF
C
            IC1 = ICY (IDIR, 1)
            IC2 = ICY (IDIR, 2)
            IC3 = ICY (IDIR, 3)
C
            DO 120 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
               DO 110 I2 = ISTRT(IC2), IEND(IC2)
C
                  IBC2 = IBCPT2*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JBC2 = IBCPT2*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KBC2 = IBCPT2*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
C Initialize tau_wall and qdot_wall
C
                  PROPS (JBC2,KBC2,IBC2,ITQTAU) = TAUW
                  PROPS (JBC2,KBC2,IBC2,ITQDOT) = QW
  110          CONTINUE
  120       CONTINUE
         ENDIF
  900 CONTINUE
C
C Finished initializing tau_wall and qdot_wall
      RETURN
      END
      SUBROUTINE L2MAX  (IBLK, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   RES, VOL, RESMAX, IRESMX)
C
C Routine to calculate the maximum residual (of mean equations).  Actually,
C calculate the square of the residual and take the square root before output.
C RES as passed in is the sum of the fluxes and source term.  Need to
C divide this by the volume for the residual output.
C
C IBLK           : Current block
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C RES            : Residual
C VOL            : Cell volume
C R2NORM         : L2 norm of the residual of each equation
C                  and of all the equations
C RESMAX         : Maximum residual
C IRESMX         : Location of maximum residual
C
      include 'common.inc'
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION IRESMX(0:3)
C
C 1.  Loop to find the maximum residual.
C     Do not initialize the maximum residual to 0.  This is done in the main
C     routine so that the maximum is over the entire flowfield (i.e.,
C     including all zones) or by lines for marching.
C
      DO 130 I = IPSTRT, IPEND
         DO 120 K = 2, KDIM
            DO 110 J = 2, JDIM
               R2  = ( RES(J,K,I,1) * RES(J,K,I,1)
     1               + RES(J,K,I,2) * RES(J,K,I,2)
     2               + RES(J,K,I,3) * RES(J,K,I,3)
     3               + RES(J,K,I,4) * RES(J,K,I,4)
     4               + RES(J,K,I,5) * RES(J,K,I,5) ) /
     5               ( VOL(J,K,I)   * VOL(J,K,I) )
               IF (R2 .GT. RESMAX) THEN
                  RESMAX    = R2
                  IRESMX(0) = IBLK
                  IRESMX(1) = I
                  IRESMX(2) = J
                  IRESMX(3) = K
               ENDIF
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C Finished with maximum residual on this block
      RETURN
      END
      SUBROUTINE L2NORM (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   RES, VOL, R2NORM)
C
C     Routine to calculate the various L2 Norms of the Residual.
C     RES as passed in is the sum of the fluxes and source term.  Need
C     to divide this by the volume for the L2NORM of residual output.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     RES            : Residual
C     VOL            : Cell volume
C     R2NORM         : L2 norm of the residual of each equation
C                      and of all the equations
C
      include 'common.inc'
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION R2NORM(NF+1)
C
C     Loop to form the L2 Norms
C     Do not initialize the norms to 0.  This is done in the main
C     routine so that the norms are over the entire flowfield (i.e.,
C     including all zones) or by lines for marching.
C
      DO 400 L = 1, NF
         DO 300 I = IPSTRT, IPEND
            DO 200 K = 2, KDIM
               DO 100 J = 2, JDIM
                  R2NORM(L) = R2NORM(L) + RES(J,K,I,L)*RES(J,K,I,L) /
     1                                     (VOL(J,K,I)*VOL(J,K,I))
  100          CONTINUE
  200       CONTINUE
  300    CONTINUE
  400 CONTINUE
C
C     Form the L2 Norm of the entire residual
C
      R2NORM(NF+1) = 0.E0
      DO 500 L = 1, NF
         R2NORM(NF+1) = R2NORM(NF+1) + R2NORM(L)
  500 CONTINUE
C
C     Finished with L2 Norm
      RETURN
      END
      SUBROUTINE METBC (IDIM, JDIM, KDIM, S, VOL, NBCS, IBCDAT)
C
C     Routine to do boundary conditions on the metric terms.  This
C     routine sets up metric terms outside of the domain that is
C     necessary for the inviscid terms so that the viscous terms
C     may more easily be evaluated.
C
C     Presently set up only for IWALL, WALFN, ITAN  and IFAR for THIN LAYER
C
      include 'common.inc'
C
      DIMENSION S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     1          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IJKDIM(3)
C
C     Store IDIM, JDIM, KDIM in IJKDIM for looping
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
      DO 900 IBC = 1, NBCS
C
C     Store boundary condition data in mnemonic names
C
         IBCTYP = IBCDAT(1,IBC)
         IDIR   = IBCDAT(2,IBC)
         INROUT = IBCDAT(3,IBC)
         ISTRT  = IBCDAT(4,IBC)
         IEND   = IBCDAT(5,IBC)
         JSTRT  = IBCDAT(6,IBC)
         JEND   = IBCDAT(7,IBC)
         KSTRT  = IBCDAT(8,IBC)
         KEND   = IBCDAT(9,IBC)
C
C   a. FAR, FIX, EXT, JET, PROFILE, SUBSONIC PROFILE BCs
C
         IF (IBCTYP .EQ. IFAR   .OR. IBCTYP .EQ. IEXT .OR.
     1       IBCTYP .EQ. IFIX   .OR. IBCTYP .EQ. IJET .OR.
     2       IBCTYP .EQ. IPROFL .OR. IBCTYP .EQ. IPROSB) THEN
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C          NMET  is the location of the metrics on the boundary
C          NINRM is the location of the metrics interior to the boundary
C          NVOL  is the location of the volume on the boundary
C          NINRV is the location of the volume interior to the boundary
C
            IF (INROUT .EQ. 1) THEN
               NMET   = 0
               NINRM  = 1
               NVOL   = 1
               NINRV  = 2
            ELSE
               NMET   = IJKDIM(IDIR) + 1
               NINRM  = IJKDIM(IDIR)
               NVOL   = IJKDIM(IDIR) + 1
               NINRV  = IJKDIM(IDIR)
            ENDIF
C
C     I direction
C
            IF (IDIR .EQ. 1) THEN
               DO 120 K = KSTRT, KEND
                  DO 110 J = JSTRT, JEND
                     VOL(J,K,NVOL) = VOL(J,K,NINRV)
  110             CONTINUE
  120          CONTINUE
C
C     J Direction
C
            ELSE IF (IDIR .EQ. 2) THEN
               DO 140 I = ISTRT, IEND
                  DO 130 K = KSTRT, KEND
                     VOL(NVOL,K,I) = VOL(NINRV,K,I)
  130             CONTINUE
  140          CONTINUE
C
C     K Direction
C
            ELSE IF (IDIR .EQ. 3) THEN
               DO 160 I = ISTRT, IEND
                  DO 150 J = JSTRT, JEND
                     VOL(J,NVOL,I) = VOL(J,NINRV,I)
  150             CONTINUE
  160          CONTINUE
            ENDIF
C
C   b. PERIODIC BCs and Periodic HOMOGENEOUS SHEAR BC
C
         ELSE IF (IBCTYP .EQ. IPERD .OR. IBCTYP .EQ. IHSHR) THEN
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C          NMET  is the location of the metrics on the boundary
C          NPRDM is the location of the periodic metrics
C          NVOL  is the location of the volume on the boundary
C          NPRDV is the location of the periodic volume
C     N.B. Metrics normal to the BC direction must be set using periodic
C          condition with ISTRT-1,JSTRT-1,KSTRT-1 to account for the
C          numbering on a cell.
C
            IF (INROUT .EQ. 1) THEN
               NMET   = 0
               NPRDM  = IJKDIM(IDIR)
               NVOL   = 1
               NPRDV  = IJKDIM(IDIR)
            ELSE
               NMET   = IJKDIM(IDIR) + 1
               NPRDM  = 1
               NVOL   = IJKDIM(IDIR) + 1
               NPRDV  = 2
            ENDIF
C
C     I direction
C
            IF (IDIR .EQ. 1) THEN
               DO 210 K = KSTRT, KEND
                  DO 205 J = JSTRT, JEND
                     VOL(J,K,NVOL)     = VOL(J,K,NPRDV)
C
                     S  (J,K,NMET,1,1) = S  (J,K,NPRDM,1,1)
                     S  (J,K,NMET,2,1) = S  (J,K,NPRDM,2,1)
                     S  (J,K,NMET,3,1) = S  (J,K,NPRDM,3,1)
                     S  (J,K,NMET,4,1) = S  (J,K,NPRDM,4,1)
  205             CONTINUE
  210          CONTINUE
C
               DO 220 K = KSTRT-1, KEND
                  DO 215 J = JSTRT-1, JEND
                     S  (J,K,NVOL,1,2) = S  (J,K,NPRDV,1,2)
                     S  (J,K,NVOL,2,2) = S  (J,K,NPRDV,2,2)
                     S  (J,K,NVOL,3,2) = S  (J,K,NPRDV,3,2)
                     S  (J,K,NVOL,4,2) = S  (J,K,NPRDV,4,2)
                     S  (J,K,NVOL,1,3) = S  (J,K,NPRDV,1,3)
                     S  (J,K,NVOL,2,3) = S  (J,K,NPRDV,2,3)
                     S  (J,K,NVOL,3,3) = S  (J,K,NPRDV,3,3)
                     S  (J,K,NVOL,4,3) = S  (J,K,NPRDV,4,3)
  215             CONTINUE
  220          CONTINUE
C
C     J Direction
C
            ELSE IF (IDIR .EQ. 2) THEN
               DO 230 I = ISTRT, IEND
                  DO 225 K = KSTRT, KEND
                     VOL(NVOL,K,I)     = VOL(NPRDV,K,I)
C
                     S  (NMET,K,I,1,2) = S  (NPRDM,K,I,1,2)
                     S  (NMET,K,I,2,2) = S  (NPRDM,K,I,2,2)
                     S  (NMET,K,I,3,2) = S  (NPRDM,K,I,3,2)
                     S  (NMET,K,I,4,2) = S  (NPRDM,K,I,4,2)
  225             CONTINUE
  230          CONTINUE
C
               DO 240 I = ISTRT-1, IEND
                  DO 235 K = KSTRT-1, KEND
                     S  (NVOL,K,I,1,1) = S  (NPRDV,K,I,1,1)
                     S  (NVOL,K,I,2,1) = S  (NPRDV,K,I,2,1)
                     S  (NVOL,K,I,3,1) = S  (NPRDV,K,I,3,1)
                     S  (NVOL,K,I,4,1) = S  (NPRDV,K,I,4,1)
                     S  (NVOL,K,I,1,3) = S  (NPRDV,K,I,1,3)
                     S  (NVOL,K,I,2,3) = S  (NPRDV,K,I,2,3)
                     S  (NVOL,K,I,3,3) = S  (NPRDV,K,I,3,3)
                     S  (NVOL,K,I,4,3) = S  (NPRDV,K,I,4,3)
  235             CONTINUE
  240          CONTINUE
C
C     K Direction
C
            ELSE IF (IDIR .EQ. 3) THEN
               DO 250 I = ISTRT, IEND
                  DO 245 J = JSTRT, JEND
                     VOL(J,NVOL,I)     = VOL(J,NPRDV,I)
C
                     S  (J,NMET,I,1,3) = S  (J,NPRDM,I,1,3)
                     S  (J,NMET,I,2,3) = S  (J,NPRDM,I,2,3)
                     S  (J,NMET,I,3,3) = S  (J,NPRDM,I,3,3)
                     S  (J,NMET,I,4,3) = S  (J,NPRDM,I,4,3)
  245             CONTINUE
  250          CONTINUE
C
               DO 260 I = ISTRT, IEND
                  DO 255 J = JSTRT, JEND
                     S  (J,NVOL,I,1,1) = S  (J,NPRDV,I,1,1)
                     S  (J,NVOL,I,2,1) = S  (J,NPRDV,I,2,1)
                     S  (J,NVOL,I,3,1) = S  (J,NPRDV,I,3,1)
                     S  (J,NVOL,I,4,1) = S  (J,NPRDV,I,4,1)
                     S  (J,NVOL,I,1,2) = S  (J,NPRDV,I,1,2)
                     S  (J,NVOL,I,2,2) = S  (J,NPRDV,I,2,2)
                     S  (J,NVOL,I,3,2) = S  (J,NPRDV,I,3,2)
                     S  (J,NVOL,I,4,2) = S  (J,NPRDV,I,4,2)
  255             CONTINUE
  260          CONTINUE
            ENDIF
         ENDIF
  900 CONTINUE
C
C     Finished with metric boundary condition routine
      RETURN
 1000 FORMAT (' ','*** WARNING ***',
     1       /' ','Unsupported boundary condition type in METBC ',I6,
     2       /' ','Substituting extrapolation of interior metrics and ',
     3            'volumes and continuing.')
      END
      SUBROUTINE METRIC (IBLOCK, ILVL, IDIM, JDIM, KDIM, R, S, VOL,
     1                   IERRCD)
C
C Routine to calculate metrics of the grid
C
C This routine is organized as follows:
C     1. Calculate and normalize I metrics
C     2. Calculate and normalize J metrics
C     3. Calculate and normalize K metrics
C     4. Calculate cell volumes
C     5. Check for zero or negative metrics
C     6. Check for zero or negative volumes
C
C IBLOCK         : Current block
C ILVL           : Current grid level
C IDIM,JDIM,KDIM : Dimensions of current block
C R              : Position vector for the grid
C S              : Metrics
C VOL            : Cell volume
C IERRCD         : Error code
C
      include 'common.inc'
C
      DIMENSION R     (0:JDIM+1,0:KDIM+1,0:IDIM+1,3),
     1          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     2          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
C 0.  Control printout based on grid level
C
      IF (ILVL .EQ. 1) THEN
         MAXPRT = 50
      ELSE
         MAXPRT =  0
      ENDIF
C
C 1.  Calculate xsi(x), xsi(y), xsi(z).
C     Calculate S(J,K,I,4,1) = |del(xsi)|.
C
      DO 200 J = 1, JDIM+1
         DO 180 K = 1, KDIM+1
            DO 160 I = 0, IDIM+1
               S(J,K,I,1,1) = 0.5E0 * ( (R(J,K,I,2)-R(J-1,K-1,I,2))*
     1                                  (R(J-1,K,I,3)-R(J,K-1,I,3)) -
     2                                  (R(J,K,I,3)-R(J-1,K-1,I,3))*
     3                                  (R(J-1,K,I,2)-R(J,K-1,I,2)) )
               S(J,K,I,2,1) = 0.5E0 * ( (R(J,K,I,3)-R(J-1,K-1,I,3))*
     1                                  (R(J-1,K,I,1)-R(J,K-1,I,1)) -
     2                                  (R(J,K,I,1)-R(J-1,K-1,I,1))*
     3                                  (R(J-1,K,I,3)-R(J,K-1,I,3)) )
               S(J,K,I,3,1) = 0.5E0 * ( (R(J,K,I,1)-R(J-1,K-1,I,1))*
     1                                  (R(J-1,K,I,2)-R(J,K-1,I,2)) -
     2                                  (R(J,K,I,2)-R(J-1,K-1,I,2))*
     3                                  (R(J-1,K,I,1)-R(J,K-1,I,1)) )
               S(J,K,I,4,1) = SQRT ( S(J,K,I,1,1)*S(J,K,I,1,1) +
     1                               S(J,K,I,2,1)*S(J,K,I,2,1) +
     2                               S(J,K,I,3,1)*S(J,K,I,3,1) )
 160        CONTINUE
 180     CONTINUE
 200  CONTINUE
C
C     Normalize and store S(J,K,I,1,1) = xsi(x) / |del(xsi)|.
C     Normalize and store S(J,K,I,2,1) = xsi(y) / |del(xsi)|.
C     Normalize and store S(J,K,I,3,1) = xsi(z) / |del(xsi)|.
C
      DO 230 J = 1, JDIM+1
         DO 220 K = 1, KDIM+1
            DO 210 I = 0, IDIM+1
               IF (S(J,K,I,4,1) .GT. 0.E0) THEN
                  S(J,K,I,1,1) = S(J,K,I,1,1) / S(J,K,I,4,1)
                  S(J,K,I,2,1) = S(J,K,I,2,1) / S(J,K,I,4,1)
                  S(J,K,I,3,1) = S(J,K,I,3,1) / S(J,K,I,4,1)
               ELSE
                  S(J,K,I,1,1) = SHATX
                  S(J,K,I,2,1) = SHATY
                  S(J,K,I,3,1) = SHATZ
               ENDIF
  210       CONTINUE
  220    CONTINUE
  230 CONTINUE
C
C 2.  Calculate eta(x), eta(y), eta(z).
C     Calculate S(J,K,I,4,2) = |del(eta)|.
C
      DO 400 I = 1, IDIM+1
         DO 380 K = 1, KDIM+1
            DO 360 J = 0, JDIM+1
               S(J,K,I,1,2) = 0.5E0 * ( (R(J,K,I,3)-R(J,K-1,I-1,3))*
     1                                  (R(J,K,I-1,2)-R(J,K-1,I,2)) -
     2                                  (R(J,K,I,2)-R(J,K-1,I-1,2))*
     3                                  (R(J,K,I-1,3)-R(J,K-1,I,3)) )
               S(J,K,I,2,2) = 0.5E0 * ( (R(J,K,I,1)-R(J,K-1,I-1,1))*
     1                                  (R(J,K,I-1,3)-R(J,K-1,I,3)) -
     2                                  (R(J,K,I,3)-R(J,K-1,I-1,3))*
     3                                  (R(J,K,I-1,1)-R(J,K-1,I,1)) )
               S(J,K,I,3,2) = 0.5E0 * ( (R(J,K,I,2)-R(J,K-1,I-1,2))*
     1                                  (R(J,K,I-1,1)-R(J,K-1,I,1)) -
     2                                  (R(J,K,I,1)-R(J,K-1,I-1,1))*
     3                                  (R(J,K,I-1,2)-R(J,K-1,I,2)) )
               S(J,K,I,4,2) = SQRT ( S(J,K,I,1,2)*S(J,K,I,1,2) +
     1                               S(J,K,I,2,2)*S(J,K,I,2,2) +
     2                               S(J,K,I,3,2)*S(J,K,I,3,2) )
 360        CONTINUE
 380     CONTINUE
 400  CONTINUE
C
C     Normalize and store S(J,K,I,1,2) = eta(x) / |del(eta)|.
C     Normalize and store S(J,K,I,2,2) = eta(y) / |del(eta)|.
C     Normalize and store S(J,K,I,3,2) = eta(z) / |del(eta)|.
C
      DO 430 I = 1, IDIM+1
         DO 420 K = 1, KDIM+1
            DO 410 J = 0, JDIM+1
               IF (S(J,K,I,4,2) .GT. 0.E0) THEN
                  S(J,K,I,1,2) = S(J,K,I,1,2) / S(J,K,I,4,2)
                  S(J,K,I,2,2) = S(J,K,I,2,2) / S(J,K,I,4,2)
                  S(J,K,I,3,2) = S(J,K,I,3,2) / S(J,K,I,4,2)
               ELSE
                  S(J,K,I,1,2) = SHATX
                  S(J,K,I,2,2) = SHATY
                  S(J,K,I,3,2) = SHATZ
               ENDIF
  410       CONTINUE
  420    CONTINUE
  430 CONTINUE
C
C 3.  Calculate zeta(x), zeta(y), zeta(z).
C     Calculate S(J,K,I,4,3) = |del(zeta)|.
C
      DO 600 I = 1, IDIM+1
         DO 580 J = 1, JDIM+1
            DO 560 K = 0, KDIM+1
               S(J,K,I,1,3) = 0.5E0 * ( (R(J,K,I,2)-R(J-1,K,I-1,2))*
     1                                  (R(J,K,I-1,3)-R(J-1,K,I,3)) -
     2                                  (R(J,K,I,3)-R(J-1,K,I-1,3))*
     3                                  (R(J,K,I-1,2)-R(J-1,K,I,2)) )
               S(J,K,I,2,3) = 0.5E0 * ( (R(J,K,I,3)-R(J-1,K,I-1,3))*
     1                                  (R(J,K,I-1,1)-R(J-1,K,I,1)) -
     2                                  (R(J,K,I,1)-R(J-1,K,I-1,1))*
     3                                  (R(J,K,I-1,3)-R(J-1,K,I,3)) )
               S(J,K,I,3,3) = 0.5E0 * ( (R(J,K,I,1)-R(J-1,K,I-1,1))*
     1                                  (R(J,K,I-1,2)-R(J-1,K,I,2)) -
     2                                  (R(J,K,I,2)-R(J-1,K,I-1,2))*
     3                                  (R(J,K,I-1,1)-R(J-1,K,I,1)) )
               S(J,K,I,4,3) = SQRT ( S(J,K,I,1,3)*S(J,K,I,1,3) +
     1                               S(J,K,I,2,3)*S(J,K,I,2,3) +
     2                               S(J,K,I,3,3)*S(J,K,I,3,3) )
 560        CONTINUE
 580     CONTINUE
 600  CONTINUE
C
C     Normalize and store S(J,K,I,1,3) = zeta(x) / |del(zeta)|.
C     Normalize and store S(J,K,I,2,3) = zeta(y) / |del(zeta)|.
C     Normalize and store S(J,K,I,3,3) = zeta(z) / |del(zeta)|.
C
      DO 630 I = 1, IDIM+1
         DO 620 J = 1, JDIM+1
            DO 610 K = 0, KDIM+1
               IF (S(J,K,I,4,3) .GT. 0.E0) THEN
                  S(J,K,I,1,3) = S(J,K,I,1,3) / S(J,K,I,4,3)
                  S(J,K,I,2,3) = S(J,K,I,2,3) / S(J,K,I,4,3)
                  S(J,K,I,3,3) = S(J,K,I,3,3) / S(J,K,I,4,3)
               ELSE
                  S(J,K,I,1,3) = SHATX
                  S(J,K,I,2,3) = SHATY
                  S(J,K,I,3,3) = SHATZ
               ENDIF
  610       CONTINUE
  620    CONTINUE
  630 CONTINUE
C
C 4.  Calculate the cell volume from eqn. 2c of AIAA J. Vol. 21
C     No. 6 pp. 917-918 by Kordulla and Vinokur
C
      DO 800 K = 1, KDIM+1
         DO 780 J = 1, JDIM+1
            DO 760 I = 1, IDIM+1
               DX = ( S(J,K,I-1,1,1)*S(J,K,I-1,4,1) +
     1                S(J-1,K,I,1,2)*S(J-1,K,I,4,2) +
     2                S(J,K-1,I,1,3)*S(J,K-1,I,4,3) ) *
     3              ( R(J,K,I,1) - R(J-1,K-1,I-1,1) )
               DY = ( S(J,K,I-1,2,1)*S(J,K,I-1,4,1) +
     1                S(J-1,K,I,2,2)*S(J-1,K,I,4,2) +
     2                S(J,K-1,I,2,3)*S(J,K-1,I,4,3) ) *
     3              ( R(J,K,I,2) - R(J-1,K-1,I-1,2) )
               DZ = ( S(J,K,I-1,3,1)*S(J,K,I-1,4,1) +
     1                S(J-1,K,I,3,2)*S(J-1,K,I,4,2) +
     2                S(J,K-1,I,3,3)*S(J,K-1,I,4,3) ) *
     3              ( R(J,K,I,3) - R(J-1,K-1,I-1,3) )
               VOL(J,K,I) = (DX + DY + DZ) / 3.E0
 760        CONTINUE
 780     CONTINUE
 800  CONTINUE
C
C 5.  Check for negative or zero areas
C
C I faces
C
      ISNEG  = 0
      DO 830 J = 2, JDIM
         DO 820 K = 2, KDIM
            DO 810 I = 0, IDIM+1
               IF (S(J,K,I,4,1) .LE. 0.E0) THEN
                  ISNEG = ISNEG + 1
                  IF (ISNEG .LE. MAXPRT) THEN
                     WRITE (IOUT,1100) 'I', S(J,K,I,4,1), IBLOCK, ILVL,
     1                                  I, J, K
                  ENDIF
               ENDIF
  810       CONTINUE
  820    CONTINUE
  830 CONTINUE
      IF (ISNEG .GT. 0) THEN
         WRITE (IOUT,1110) ISNEG, 'I', IBLOCK, ILVL
      ENDIF
C
C J faces
C
      ISNEG  = 0
      DO 860 I = 2, IDIM
         DO 850 K = 2, KDIM
            DO 840 J = 0, JDIM+1
               IF (S(J,K,I,4,2) .LE. 0.E0) THEN
                  ISNEG = ISNEG + 1
                  IF (ISNEG .LE. MAXPRT) THEN
                     WRITE (IOUT,1100) 'J', S(J,K,I,4,2), IBLOCK, ILVL,
     1                                  I, J, K
                  ENDIF
               ENDIF
  840       CONTINUE
  850    CONTINUE
  860 CONTINUE
      IF (ISNEG .GT. 0) THEN
         WRITE (IOUT,1110) ISNEG, 'J', IBLOCK, ILVL
      ENDIF
C
C K faces
C
      ISNEG  = 0
      DO 890 I = 2, IDIM
         DO 880 J = 2, JDIM
            DO 870 K = 0, KDIM+1
               IF (S(J,K,I,4,3) .LE. 0.E0) THEN
                  ISNEG = ISNEG + 1
                  IF (ISNEG .LE. MAXPRT) THEN
                     WRITE (IOUT,1100) 'K', S(J,K,I,4,3), IBLOCK, ILVL,
     1                                  I, J, K
                  ENDIF
               ENDIF
  870       CONTINUE
  880    CONTINUE
  890 CONTINUE
      IF (ISNEG .GT. 0) THEN
         WRITE (IOUT,1110) ISNEG, 'K', IBLOCK, ILVL
      ENDIF
C
C 6. Check for negative or zero volumes - left-handed coordinate
C    systems or collapsed cells
C
      IERROR = 0
      DO 930 I = 2, IDIM
         DO 920 K = 2, KDIM
            DO 910 J = 2, JDIM
               IF (VOL(J,K,I) .LE. 0.E0) THEN
                  IERROR = IERROR + 1
                  IF (IERROR .LE. MAXPRT) THEN
                     WRITE (IOUT,1010) IBLOCK, ILVL, I, J, K, VOL(J,K,I)
                  ENDIF
               ENDIF
  910       CONTINUE
  920    CONTINUE
  930 CONTINUE
      IF (IERROR .GT. 0) THEN
         WRITE (IOUT,1015) IERROR, IBLOCK, ILVL, IDIM, JDIM, KDIM
         IERRCD = IYES
      ENDIF
C
C Finished with the metric calculations.
      RETURN
C
 1010 FORMAT (' ','METRIC: ERROR-> Volume <= 0 at BLOCK,LEVEL,I,J,K = ',
     1            I3,I3,3I4,1PE10.3)
 1015 FORMAT (' ','METRIC: ERROR-> ',I9,' negative or zero volumes ',
     1            'in grid ',
     2       /' ',16X,' BLOCK: LEVEL: IDIM, JDIM, KDIM = ',
     3            I3,':',I2,':',3I5/)
 1100 FORMAT (' ','METRIC: ',A,' face non-positive ',1PE9.2,
     1            ' at BLOCK:LEVEL:I,J,K ',I3,':',I2,':',3I4)
 1110 FORMAT (' ','METRIC: ',I9,' non-positive ',A,' face areas ',
     1            'for BLOCK ',I3,' LEVEL ',I2/)
C
      END
      SUBROUTINE QNSHFT (IDIM, JDIM, KDIM, Q, QN, QCP, TKE, IMODEL)
C
C Routine to shift Q, QN to prepare for the next time step.
C
C N.B. This routine assumes that the previous time level solutions are
C      passed as conserved variables rather than primitive variables.
C
C This routine is organized as follows:
C     1. Shift QN (QN(NTIME) <- QN(NTIME-1), etc)
C     2. Copy Q to work array
C     3. Convert Q from primitive to conserved variables
C     4. Store Q in QN(1)
C     5. Store Q as Q^(m-1) in QN(NTIME+1) for 2nd order pseudo time
C        sub-iterations in tau-ts
C
C IDIM,JDIM,KDIM : Dimensions of current block
C Q              : Primitive variables at iterative time level p
C QN             : Conserved variables at time levels n, n-1, etc.
C QCP            : Work array for conserved Q at level p
C TKE            : Work array for turbulent kinetic energy
C IMODEL         : Turbulence model
C
      include 'common.inc'
C
      INTEGER   IDIM, JDIM, KDIM
C
      DIMENSION Q   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN  (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ,NTMLVL)
C
      DIMENSION QCP (0:JDIM+2,0:KDIM+2,NQ),
     1          TKE (0:JDIM+2,0:KDIM+2)
C
      DIMENSION IMODEL(NMDL)
C
C Local variables
C
      INTEGER   I, J, K, L, NPTS
C
C     Turbulence model
C
      ITURB = IMODEL(1)
C
C 1.  Shift QN (QN(NTIME) <- QN(NTIME-1), etc)
C
      DO 150 ITIM = NTIME, 2, -1
         DO 140 L = 1, NQ
            DO 130 I = 0, IDIM+2
               DO 120 K = 0, KDIM+2
                  DO 110 J = 0, JDIM+2
                     QN(J,K,I,L,ITIM) = QN(J,K,I,L,ITIM-1)
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
  140    CONTINUE
  150 CONTINUE
C
C     Loop over each cross section and convert Q to conserved then store in QN
C
      DO 900 I = 0, IDIM+2
C
C 2.  Copy Q to work array
C
         DO 230 L = 1, NQ
            DO 220 K = 0, KDIM+2
               DO 210 J = 0, JDIM+2
                  QCP(J,K,L) = Q(J,K,I,L)
  210          CONTINUE
  220       CONTINUE
  230    CONTINUE
C
C 3.  Convert Q from primitive to conserved
C
         NPTS = (JDIM+3) * (KDIM+3)
         CALL CONP2C (ITURB, NPTS, QCP, TKE)
C
C 4.  Store Q in QN(1)
C
         DO 430 L = 1, NQ
            DO 420 K = 0, KDIM+2
               DO 410 J = 0, JDIM+2
                  QN(J,K,I,L,1) = QCP(J,K,L)
  410          CONTINUE
  420       CONTINUE
  430    CONTINUE
C
C 5.  Store Q as Q^(m-1) in QN(NTIME+1) for 2nd order pseudo time
C     sub-iterations in tau-ts
C
         IF (ITMTYP .EQ. ITAUTS .AND. TDPHIP .NE. 0.E0) THEN
            IT = NTIME + 1
            DO 530 L = 1, NQ
               DO 520 K = 0, KDIM+2
                  DO 510 J = 0, JDIM+2
                     QN(J,K,I,L,IT) = QCP(J,K,L)
  510             CONTINUE
  520          CONTINUE
  530       CONTINUE
         ENDIF
C
C     Next cross section
C
  900 CONTINUE
C
C     Finished shifting Q, QN
      RETURN
      END
      SUBROUTINE UPDATE (IDIM, JDIM, KDIM, IPSTRT, IPEND, Q, RES, ITURB,
     1                   QC, TKE, QMIN, NFIXQ, NRELIZ, DELTAQ, IERRCD)
C
C Routine to update the Conserved Variables
C
C This routine is organized as follows:
C     1. Convert dQ_cell-average to dQ_cell-centered
C        Begin I loop {
C     2. Convert Q from primitive to conserved variables
C     3. Update conserved variables
C     4. Convert conserved variables back to primitive variables.
C        } End I loop
C     5. Check for positivity of variables
C     6. Enforce realizability of Reynolds stresses for Reynolds stress models
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C Q              : Primitive variables at cell centers
C RES            : Residual
C ITURB          : Turbulence model
C QC             : Work array to store variable on a plane
C TKE            : Work array to store turbulent kinetic energy on a plane
C QMIN           : Control array for minimum value of Q
C NFIXQ          : Number of times reset Q
C NRELIZ         : Number of times violate realizability
C DELTAQ         : Work area to calculate delta(Q)_cell-centered
C IERRCD         : Error code
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF)
C
      DIMENSION QC    (2:JDIM,2:KDIM,NQ),
     1          TKE   (2:JDIM,2:KDIM)
C
      DIMENSION QMIN  (NQ)
      DIMENSION NFIXQ (NQ),
     1          NRELIZ(NQ)
C
      DIMENSION DELTAQ(JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF)
C
C 1.  Convert dQ_cell-average to dQ_cell-centered
C
      CALL DQCC   (IDIM, JDIM, KDIM, IPSTRT, IPEND, RES, DELTAQ)
C
C     Begin I loop {
C
      DO 490 I = IPSTRT, IPEND
C
C 2.   Convert Q from primitive variables to conservative variables
C
         DO 230 L = 1, NQ
            DO 220 K = 2, KDIM
               DO 210 J = 2, JDIM
                  QC(J,K,L) = Q(J,K,I,L)
  210          CONTINUE
  220       CONTINUE
  230    CONTINUE
C
         NPTS = (JDIM - 1) * (KDIM - 1)
         CALL CONP2C (ITURB, NPTS, QC, TKE)
C
C 3.  Update Conservative Variables
C
         DO 330 L = 1, NF
            DO 320 K = 2, KDIM
               DO 310 J = 2, JDIM
                  QC(J,K,L) = QC(J,K,L) + RES(J,K,I,L)
  310          CONTINUE
  320       CONTINUE
  330    CONTINUE
C
C 4.   Return Q to primitive variables
C
         CALL CONC2P (ITURB, NPTS, QC, TKE)
C
         DO 430 L = 1, NQ
            DO 420 K = 2, KDIM
               DO 410 J = 2, JDIM
                  Q(J,K,I,L) = QC(J,K,L)
  410          CONTINUE
  420       CONTINUE
  430    CONTINUE
C
C     } End I loop
C
  490 CONTINUE
C
C 5. Check for positivity of flow variables
C
      IF (IFIXQ .NE. INO) THEN
         CALL FIXQ   (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND, Q,
     1                QMIN,  NFIXQ, IERRCD)
      ENDIF
C
C 6. Enforce realizability of Reynolds stresses for Reynolds stress models
C
      IF (ITURB .EQ. ITRS) THEN
         CALL REALIZ (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND, Q, NRELIZ)
      ENDIF
C
C     Finished with conservative variable update
      RETURN
      END
      SUBROUTINE YNORM  (NXLVLS, NXBLKS, NXBCS, NXPPTS, NXNODE,
     1                   IOFFS, IOFFP,
     2                   NLVLS,  NBLKS,  NBCS,  IBCDAT,
     3                   IDIM, JDIM, KDIM, R, PROPS, YNORML)
C
C Routine to calculate distance to wall from cell center in the flowfield.
C Initially calculate the distances as the square of the distance to avoid
C unnecessary sqrt calculations. When all of the distances are complete for
C a block/level, then convert from the distance squared to the distance
C (advice from Veer Vatsa).
C
C This routine is organized as follows:
C     1. Loop over all levels doing steps 2-4
C     2. Initialize all values of y_normal to infinity
C     3. For each grid point on a wall or wall function boundary
C        loop through all blocks and set y_normal to min(y_normal, dist)
C     4. Convert y_normal from distance squared to distance and
C        Interpolate y_normal calculated on grid points to cell centers
C     5. Modify y_normal at first 'cell center' for wall functions
C
C NXLVLS         :
C NXBLKS         :
C NXBCS          :
C NXPPTS         :
C NXNODE         :
C IOFFS          :
C IOFFP          :
C NLVLS          : Number of grid levels
C NBLKS          : Number of blocks
C NBCS           : Number of boundary conditions per current block
C IBCDAT         : Data controlling boundary conditions
C IDIM,JDIM,KDIM : Dimensions of each block
C R              : Grid
C PROPS(4)       : Normal distance to wall at cell centers
C YNORML         : Temporary storage for distance to wall at grid points
C
      include 'common.inc'
C
      DIMENSION IOFFS  (NXBLKS,NXLVLS),
     1          IOFFP  (NXBLKS,NXLVLS)
C
      DIMENSION IDIM   (NXBLKS,NXLVLS),
     1          JDIM   (NXBLKS,NXLVLS),
     2          KDIM   (NXBLKS,NXLVLS)
C
      DIMENSION IBCDAT (10,NXBCS,NXBLKS,NXLVLS),
     1          NBCS   (NXBLKS)
C
      DIMENSION PROPS (NXPPTS*NP),
     1          R     (NXNODE*3),
     2          YNORML(NXNODE)
C
C 1.  Loop over all grid levels calculating y_normal
C
      DO 900 ILVL = 1, NLVLS
C
C 2.  Initialize y_normal to infinity
C
         DO 200 IBLK = 1, NBLKS
            IY   = IOFFS(IBLK,ILVL)         + 1
            NPTS = (IDIM(IBLK,ILVL)+2) * (JDIM(IBLK,ILVL)+2) *
     1             (KDIM(IBLK,ILVL)+2)
            CALL YNINIT (NPTS, YNORML(IY))
  200    CONTINUE
C
C 3.  For each block, call routines to check each wall or wall function
C     grid point against all points of all blocks
C
         DO 300 IBLK = 1, NBLKS
            IRC  = IOFFS(IBLK,ILVL) * 3     + 1
            CALL YNWALL (NXPPTS, NXNODE, IOFFS(1,ILVL), IOFFP(1,ILVL),
     1                   NBLKS,  IDIM(1,ILVL),  JDIM(1,ILVL),
     2                   KDIM(1,ILVL),  R,  YNORML,
     3                   IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     4                   KDIM(IBLK,ILVL), R(IRC),
     5                   NBCS(IBLK), IBCDAT(1,1,IBLK,ILVL))
  300    CONTINUE
C
C 4.  Convert y_normal from distance squared to distance and
C     Interpolate grid point values to cell centers
C
         DO 400 IBLK = 1, NBLKS
            IY   = IOFFS(IBLK,ILVL)         + 1
            IP   = IOFFP(IBLK,ILVL) * NP    + 1
            NPTS = (IDIM(IBLK,ILVL)+2) * (JDIM(IBLK,ILVL)+2) *
     1             (KDIM(IBLK,ILVL)+2)
            CALL YNSQRT (NPTS, YNORML(IY))
            CALL YNCENT (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                   KDIM(IBLK,ILVL), YNORML(IY), PROPS(IP))
  400    CONTINUE
C
C 5.  Modify y_normal for first 'cell center' for wall functions
C
         IF ( IFWALF ) THEN
            DO 510 IBLK = 1, NBLKS
               IY   = IOFFS(IBLK,ILVL)         + 1
               IP   = IOFFP(IBLK,ILVL) * NP    + 1
               DO 500 IBC = 1, NBCS(IBLK)
                  IBCTYP = IBCDAT(1,IBC,IBLK,ILVL)
                  IF (IBCTYP .EQ. IWALFN) THEN
                     CALL YNWALF (IDIM(IBLK,ILVL), JDIM(IBLK,ILVL),
     1                            KDIM(IBLK,ILVL), PROPS(IP),
     2                            IBCDAT(1,IBC,IBLK,ILVL))
                  ENDIF
  500          CONTINUE
  510       CONTINUE
         ENDIF
C
C     Next grid level
C
  900 CONTINUE
C
C     Finished calculating y_normal
      RETURN
      END
      SUBROUTINE YNINIT (NPTS, YNORML)
C
C Routine to initialize y_normal to infinity
C
C NPTS      : Number of points to calculate distance on
C YNORML    : Normal distance to wall at grid points
C
      include 'common.inc'
C
      DIMENSION YNORML(NPTS)
C
C     Initialize YNORML to <infinity> in case there are no walls
C
      DO 100 I = 1, NPTS
         YNORML(I) = RMAX
  100 CONTINUE
C
C     Finished with initialization
      RETURN
      END
      SUBROUTINE YNWALL (NXPPTS, NXNODE,
     1                   IOFFS, IOFFP, NBLKS,
     2                   IDIM,  JDIM,  KDIM,  R,  YNORML,
     3                   IDIMC, JDIMC, KDIMC, RC, NBCS,  IBCDAT)
C
C This routine loops over all boundary conditions for a given block
C and calculates distances from wall or wall function points to all points
C in all blocks.
C
C This routine is organized as follows:
C     1. Loop over all boundary conditions doing steps 2-3 for WALL and WALFN
C     2. Loop over all grid points on the boundary doing step 3
C     3. Loop over ALL blocks (including current block) calculating
C        y_normal as min (y_normal, distance to wall point)
C
C NXPPTS            :
C NXNODE            :
C IOFFS             :
C IOFFP             :
C NBLKS             : Number of blocks
C IDIM,JDIM,KDIM    : Dimensions of each block
C R                 : Grid
C YNORML            : Temporary storage for distance to wall at grid points
C IDIMC,JDIMC,KDIMC :
C RC                :
C NBCS              : Number of boundary conditions in current block
C IBCDAT            : Data controlling boundary conditions
C
      include 'common.inc'
C
      DIMENSION IOFFS  (NBLKS),
     1          IOFFP  (NBLKS)
C
      DIMENSION IDIM   (NBLKS),
     1          JDIM   (NBLKS),
     2          KDIM   (NBLKS)
C
      DIMENSION IBCDAT (10,NBCS)
C
      DIMENSION R     (NXNODE*3),
     1          YNORML(NXNODE)
C
      DIMENSION RC    (0:JDIMC+1,0:KDIMC+1,0:IDIMC+1,3)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
      DIMENSION RWALL (3)
C
C     Store IDIMC, JDIMC, KDIMC in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIMC
      IJKDIM(2) = JDIMC
      IJKDIM(3) = KDIMC
C
C 1.  Loop over WALL boundary conditions
C
      DO 500 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IF (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN) THEN
            IDIR     = IBCDAT(2,IBC)
            INROUT   = IBCDAT(3,IBC)
            ISTRT(1) = IBCDAT(4,IBC)
            IEND (1) = IBCDAT(5,IBC)
            ISTRT(2) = IBCDAT(6,IBC)
            IEND (2) = IBCDAT(7,IBC)
            ISTRT(3) = IBCDAT(8,IBC)
            IEND (3) = IBCDAT(9,IBC)
C
C     Decrement beginning index to account for cell-center/grid point storage.
C     Modify begin, end indices to extend boundary condition to edge/corner
C
            DO 10 L = 1, 3
               IF (L .NE. IDIR) THEN
                  ISTRT(L) = ISTRT(L) - 1
                  IF (ISTRT(L) .EQ. 1        ) ISTRT(L) = 0
                  IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
               END IF
   10       CONTINUE
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C         IBCPT  is the grid boundary location
C
            IF (INROUT .EQ. 1) THEN
               IBCPT  = 1
            ELSE
               IBCPT  = IJKDIM(IDIR)
            ENDIF
C
            IC1 = ICY (IDIR, 1)
            IC2 = ICY (IDIR, 2)
            IC3 = ICY (IDIR, 3)
C
C 2.  Loop over all grid points on the current block boundary
C
            DO 220 I3 = ISTRT(IC3), IEND(IC3)
               DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
                  IBCW = IBCPT*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JBCW = IBCPT*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KBCW = IBCPT*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  RWALL(1) = RC(JBCW,KBCW,IBCW,1)
                  RWALL(2) = RC(JBCW,KBCW,IBCW,2)
                  RWALL(3) = RC(JBCW,KBCW,IBCW,3)
C
C 3.  Loop over all blocks calculating distance from EACH boundary point
C     to ALL grid points
C
                  DO 100 IBLK = 1, NBLKS
                     IR   = IOFFS(IBLK) * 3     + 1
                     IY   = IOFFS(IBLK)         + 1
                     NPTS = (IDIM(IBLK)+2) * (JDIM(IBLK)+2) *
     1                      (KDIM(IBLK)+2)
                     CALL YNDIST (NPTS, RWALL, R(IR), YNORML(IY))
  100             CONTINUE
  210          CONTINUE
  220       CONTINUE
         ENDIF
  500 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE YNDIST (NPTS, RWALL, R, YNORML)
C
C Routine to calculate distance SQUARED from grid points to wall using simple
C distance formula. Using the distance squared speeds up the code by removing
C unnecessary sqrt calls.
C
C NPTS      : Number of points to calculate distance on
C RWALL     : Position of wall point
C R         : Grid
C YNORML    : Normal distance to wall at grid points
C
      include 'common.inc'
C
      DIMENSION RWALL (3),
     1          R     (NPTS,3),
     2          YNORML(NPTS)
C
C 1.  Loop over all points calculating distance from grid point to wall point
C
      DO 100 I = 1, NPTS
         DX        = R(I,1) - RWALL(1)
         DY        = R(I,2) - RWALL(2)
         DZ        = R(I,3) - RWALL(3)
         YDIST     = (DX*DX + DY*DY + DZ*DZ)
         YNORML(I) = MIN (YNORML(I), YDIST)
  100 CONTINUE
C
C     Finished calculating YNORML
      RETURN
      END
      SUBROUTINE YNCENT (IDIM, JDIM, KDIM, YNORML, PROPS)
C
C Routine to interpolate y_normal from grid points to cell centers
C
C IDIM,JDIM,KDIM : Dimensions of current block
C YNORML         : Normal distance to wall at grid points
C PROPS(4)       : Normal distance to wall at cell centers
C
      include 'common.inc'
C
      DIMENSION YNORML(0:JDIM+1,0:KDIM+1,0:IDIM+1),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
C     Calculate cell centered normal distance as average of 8 nodes
C
      DO 130 I = 1, IDIM + 1
         DO 120 K = 1, KDIM + 1
            DO 110 J = 1, JDIM + 1
               PROPS(J,K,I,4) = 0.125E0 *
     1                     ( YNORML(J  ,K  ,I  ) + YNORML(J-1,K  ,I  )
     2                     + YNORML(J  ,K-1,I  ) + YNORML(J  ,K  ,I-1)
     3                     + YNORML(J-1,K-1,I  ) + YNORML(J-1,K  ,I-1)
     4                     + YNORML(J  ,K-1,I-1) + YNORML(J-1,K-1,I-1) )
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C     Finished interpolating to cell-centers
      RETURN
      END
      SUBROUTINE YNSQRT (NPTS, YNORML)
C
C Routine to convert y_normal from the distance squared to the distance
C
C NPTS           : Number of points
C YNORML         : Normal distance to wall at grid points
C
      DIMENSION YNORML(NPTS)
C
C     Convert y_normal from distance squared to distance
C
      DO 100 I = 1, NPTS
         YNORML(I) = SQRT (YNORML(I))
  100 CONTINUE
C
C     Finished converting y_normal from distance squared to distance
      RETURN
      END
      SUBROUTINE YNWALF (IDIM, JDIM, KDIM, PROPS, IBCDAT)
C
C Routine to modify y_normal at the first 'cell center' for wall functions
C
C IDIM,JDIM,KDIM : Dimensions of current block
C PROPS(4)       : Normal distance to wall at cell centers
C IBCDAT         : Data controlling boundary conditions
C
      include 'common.inc'
C
      DIMENSION PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     1          IBCDAT(10)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C     Store boundary condition data in mnemonic names
C
      IDIR      = IBCDAT(2)
      INROUT    = IBCDAT(3)
      ISTRT(1)  = IBCDAT(4)
      IEND (1)  = IBCDAT(5)
      ISTRT(2)  = IBCDAT(6)
      IEND (2)  = IBCDAT(7)
      ISTRT(3)  = IBCDAT(8)
      IEND (3)  = IBCDAT(9)
C
C     Decrement beginning index to account for cell-center/grid point storage.
C     Modify begin, end indices to extend boundary condition to edge/corner
C
      DO 10 L = 1, 3
         IF (L .NE. IDIR) THEN
            IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
            IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
         END IF
   10 CONTINUE
C
C     Set needed variables depending on whether the boundary is
C     the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C         IBCN   is the 1st point to the inside of the block from IBCPT
C         IBCN2  is the 2nd point to the inside of the block from IBCPT
C
      IF (INROUT .EQ. 1) THEN
         IBCN   = 2
         IBCN2  = 3
      ELSE
         IBCN   = IJKDIM(IDIR)
         IBCN2  = IJKDIM(IDIR) - 1
      ENDIF
C
      IC1 = ICY (IDIR, 1)
      IC2 = ICY (IDIR, 2)
      IC3 = ICY (IDIR, 3)
C
C     Loop over all grid points on the current block boundary
C
            DO 220 I3 = ISTRT(IC3), IEND(IC3)
               DO 210 I2 = ISTRT(IC2), IEND(IC2)
C
                  IN   = IBCN *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JN   = IBCN *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KN   = IBCN *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IN2  = IBCN2*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JN2  = IBCN2*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KN2  = IBCN2*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  YINTRF = 2.E0 * PROPS(JN,KN,IN,4)
                  DELTAY = PROPS(JN2,KN2,IN2,4) - YINTRF
                  PROPS(JN,KN,IN,4) = YINTRF - DELTAY
  210    CONTINUE
  220 CONTINUE
C
C     Finished modifying first 'cell-center' y_normal
      RETURN
      END
      SUBROUTINE YNABS  (NPTS, PROPS)
C
C Routine to set y_normal to abs(y_normal) to allow the modification of
C the transition location on restart.
C
C NPTS      : Number of points to calculate distance on
C YNORML    : Normal distance to wall at cell centers
C
      include 'common.inc'
C
      DIMENSION PROPS (NPTS,NP)
C
C     Set y_normal = abs(y_normal)
C
      DO 100 I = 1, NPTS
         PROPS(I,4) = ABS (PROPS(I,4))
  100 CONTINUE
C
C     Finished with setting y_normal = abs(y_normal)
      RETURN
      END
      SUBROUTINE YNTRAN (IDIM, JDIM, KDIM, PROPS, ITRSEG)
C
C Routine to set y_normal to - (y_normal) to specify the transition location.
C
C IDIM,JDIM,KDIM : Dimensions of blocks
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = Ynorm
C ITRSEG         : Data specifying transition location
C
C This routine is organized as follows:
C     1. Set up transition indices
C     2. Loop over transition segment and set y_normal = - (y_normal)
C
      include 'common.inc'
C
      DIMENSION PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
      DIMENSION ITRSEG(7)
C
C 1.  Set up transition indices
C
      ISTRT = ITRSEG(2)
      JSTRT = ITRSEG(3)
      KSTRT = ITRSEG(4)
      IEND  = ITRSEG(5)
      JEND  = ITRSEG(6)
      KEND  = ITRSEG(7)
C
C 2.  Loop over transition segment and set y_normal = - (y_normal)
C
      DO I = ISTRT, IEND
         DO K = KSTRT, KEND
            DO J = JSTRT, JEND
               PROPS(J,K,I,4) = - PROPS(J,K,I,4)
            END DO
         END DO
      END DO
C
C     Finished
      RETURN
      END
C
      SUBROUTINE DQDT   (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, QN, VOL, DTJ, RES, QCP, TKE, IMODEL)
C
C Routine to calculate the dQ/dt term to add to residual.
C     t-ts: Physical Time Subiteration (Rumsey et al. Computers&Fluids, 1996)
C           dQ/dt = [(1 + phi) Q^(n+1) - (1 + 2 phi) Q^(n) + phi Q^(n-1)] / dt
C
C     tau-ts: Pseudo Time Subiteration (Rumsey et al. Computers&Fluids, 1996)
C           dQ/dt = [(1 + phi) Q^(n+1) - (1 + 2 phi) Q^(n) + phi Q^(n-1)] / dt
C                 + [phi' (Q^(m) - Q^(m-1))] / dtau
C
C     TDTHET : Theta for Time Dependent calculation (physical time term)
C     TDPHI  : Phi   for Time Dependent calculation (physical time term)
C     TDPHIP : Phi'  for Time Dependent calculation (pseudo   time term)
C
C +-------+-----------------+-------------+-------------------+---------------+
C |Scheme | Order           | Theta  Phi  |  Phi' store dQ^(m)| TDPDTJ TDPDEL |
C +-------+-----------------+-------------+-------------------+---------------+
C |t-ts   | 1st             |   1     0   |   -         No    | 1+Phi     0   |
C |       | 2nd             |   1    1/2  |   -         No    | 1+Phi     0   |
C |tau-ts | 2nd, 1st pseudo |   1    1/2  |   0         No    | 1+Phi'  1+Phi |
C |       | 2nd, 2nd pseudo |   1    1/2  |  1/2       Yes    | 1+Phi'  1+Phi |
C +-------+-----------------+-------------+-------------------+---------------+
C
C N.B. This routine assumes that the previous time level solutions are
C      passed as conserved variables rather than primitive variables.
C
C This routine is organized as follows:
C     1. Copy Q to work array
C     2. Convert Q from primitive to conserved variables
C     3. Calculate dQ/dt and add to residual array
C     4. Q^(m) - Q^(m-1) term for tau-ts
C        a. Add Q^(m) - Q^(m-1) term for tau-ts with 2nd order psuedo
C           time stepping
C        b. Shift Q^(m) to Q^(m-1) for next subiteration
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning temporary space)
C Q              : Primitive variables at iterative time level p
C QN             : Conserved variables at time levels n, n-1, etc.
C VOL            : Cell volumes
C DTJ            : Time step divided by cell volume
C RES            : Residual
C QCP            : Work array for conserved Q at level p
C TKE            : Work array for turbulent kinetic energy
C IMODEL         : Turbulence model
C
      include 'common.inc'
C
      INTEGER   IDIM, JDIM, KDIM
C
      DIMENSION Q   (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN  (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ,NTMLVL),
     2          VOL (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     3          DTJ (JDIM,KDIM,IDIM),
     4          RES (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF)
C
      DIMENSION QCP (2:JDIM,2:KDIM,NQ),
     1          TKE (2:JDIM,2:KDIM)
C
      DIMENSION IMODEL(NMDL)
C
C Local variables
C
      INTEGER   I, J, K, L, NPTS
C
C     Turbulence model
C
      ITURB = IMODEL(1)
C
C     Constants for temporal accuracy
C     (see e.g. Pulliam AIAA 93-3360, Rai AIAA 95-0583,
C               Rumsey et al. Computers & Fluids 1996)
C          CONP constant for level p, CONN constant for time n,
C          CONNM1 constant for time n-1
C
      CONP   = 1.E0 + TDPHI
      CONN   = 1.E0 + 2.E0 * TDPHI
      CONNM1 = TDPHI
C
C      Loop over each cross section
C
      DO 900 I = IPSTRT, IPEND
C
C 1.   Copy Q to work array
C
         DO 130 L = 1, NQ
            DO 120 K = 2, KDIM
               DO 110 J = 2, JDIM
                  QCP(J,K,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
C
C 2.   Convert Q from primitive to conserved
C
         NPTS = (JDIM-1) * (KDIM-1)
         CALL CONP2C (ITURB, NPTS, QCP, TKE)
C
C 3.   Calculate dQ/dt
C
         DO 330 L = 1, NQ
            DO 320 K = 2, KDIM
               DO 310 J = 2, JDIM
                  DQDTP = ( CONP   * QCP(J,K,L) - CONN * QN(J,K,I,L,1)
     1                    + CONNM1 * QN(J,K,I,L,2) ) * VOL(J,K,I)/TIMEDT
                  RES(J,K,I,L) = RES(J,K,I,L) + DQDTP
  310          CONTINUE
  320       CONTINUE
  330    CONTINUE
C
C 4.   Q^(m) - Q^(m-1) term for tau-ts
C
         IF (ITMTYP .EQ. ITAUTS .AND. TDPHIP .NE. 0.E0) THEN
            IT = NTIME + 1
C
C 4-a. Add Q^(m) - Q^(m-1) term for tau-ts with 2nd order psuedo time stepping
C
            DO 430 L = 1, NQ
               DO 420 K = 2, KDIM
                  DO 410 J = 2, JDIM
                     DQMDT = TDPHIP * (QCP(J,K,L) - QN(J,K,I,L,IT))
     1                       / DTJ(J,K,I)
                     RES(J,K,I,L) = RES(J,K,I,L) + DQMDT
  410             CONTINUE
  420          CONTINUE
  430       CONTINUE
C
C 4-b. Shift Q^(m) to Q^(m-1) for next subiteration
C
            DO 460 L = 1, NQ
               DO 450 K = 2, KDIM
                  DO 440 J = 2, JDIM
                     QN(J,K,I,L,IT) = QCP(J,K,L)
  440             CONTINUE
  450          CONTINUE
  460       CONTINUE
         ENDIF
C
C      Next cross section
C
  900 CONTINUE
C
C      Finished calculating dQ/dt
      RETURN
      END
      SUBROUTINE FLUXI (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                  Q, PROPS, NPPTS, S, VOL,
     2                  RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                  IBCDAT, NBCS,
     4                  IORDER, LIMIT, RKAP, IFLUX, VISCOS, IMODEL)
C
C     Routine to calculate the contriubtion to the residual from the
C     i direction.  This routine is used for either the
C     time dependent calculation or the marching calculation.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                      (used in dimensioning temporary space used for
C                       calculating q(+,-) and f.
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     RES            : Residual
C     DQP,DQM        : Storage for delta q = q(i) - q(i-1)
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     TAU            : Storage for Reynolds stresses at interfaces
C     F,FM           : Fluxes at cell interfaces -
C                      if Flux Difference Splitting then F = Flux
C                      if Flux Vector Splitting then F = Fplus, FM = Fminus
C     STEMP          : Storage for metrics passed to flux evaluation routine.
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IORDER         : Order of MUSCL interpolation for I direction
C                      IORDER = 1 first order
C                             = 2 second order (or 'third' order)
C     LIMIT          : Limiter to use for MUSCL interpolation
C     RKAP           : Kappa to use in MUSCL interpolation
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     IMODEL         : Turbulence model
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          DQP   (MXSECT,NQ),
     2          DQM   (MXSECT,NQ),
     3          QP    (MXSECT,NQ),
     4          QM    (MXSECT,NQ),
     5          TAU   (MXSECT,6),
     6          F     (IPSTRT-1:IPEND,2:JDIM,NF),
     7          FM    (IPSTRT-1:IPEND,2:JDIM,NF),
     8          STEMP (IPSTRT-1:IPEND,2:JDIM,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IMODEL(NMDL)
C
      LOGICAL   VISCOS
C
      ITURB = IMODEL(1)
C
C     Loop over K calculating Q(+,-), F(Q(+,-)) and updating the Residual.
C
      DO 500 K = 2, KDIM
C
C     Inviscid Residuals
C
         CALL MUSCLI (IDIM, JDIM, KDIM, K, IPSTRT, IPEND,
     1                Q, DQP, DQM, QP, QM,
     2                IBCDAT, NBCS, IORDER, LIMIT, RKAP)
C
C     Calculate the fluxes from q(plus) and q(minus).  Pass only
C     the appropriate metrics from the current direction.
C
         DO 120 I = IPSTRT - 1, IPEND
            DO 110 J = 2, JDIM
               DO 100 L = 1, 3
                  STEMP(I,J,L) = S(J,K,I,L,1)
  100          CONTINUE
  110       CONTINUE
  120    CONTINUE
         NPTS = (IPEND - IPSTRT + 2) * (JDIM - 1)
C
C     Flux Difference Splitting
C
         IF (IFCHAR(IFLUX,1) .EQ. IFDS) THEN
C
C     Add the flux contributions to the residual.
C
            CALL FDS (IFLUX, ITURB, NPTS, QP, QM, STEMP, DQP, DQM, F)
C
            DO 180 L = 1, NF
               DO 160 I = IPSTRT, IPEND
                  DO 140 J = 2, JDIM
                     RES(J,K,I,L) = RES(J,K,I,L) +
     1                              ( F(I,J,L)   * S(J,K,I,4,1) -
     2                                F(I-1,J,L) * S(J,K,I-1,4,1) )
  140             CONTINUE
  160          CONTINUE
  180       CONTINUE
         ENDIF
C
C     Viscous Residuals
C
         IF ( VISCOS ) THEN
C
C     Calculate the derivatives and averages of stored variables at the
C     interfaces.
C     Temporary variables passed to the viscous flux evaluation routine:
C         QP    for Q      (variables at interface)
C         FM    for PROPSI (properties at interface)
C               NOTE: This works properly only as long as NP <= NQ
C         QM    for DQDX   (derivatives of Q in x direction at interface)
C         DQP   for DQDY   (derivatives of Q in y direction at interface)
C         DQM   for DQDZ   (derivatives of Q in z direction at interface)
C     Temporary variables used internally in DELQ:
C         F(2-NQ) for SI (STEMP is dimensioned incorrectly to be used for
C                     the averaged metrics in the J direction.  F is large
C                     enough to provide the necessary space.  Do not use
C                     F for anything else in this call).
C         F(1)    for VOLAUX
C
            CALL DELQI (IDIM, JDIM, KDIM, IPSTRT, IPEND, K,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  F(1,2,2), F(1,2,1), QP, FM, QM, DQP, DQM)
C
C     Viscous Terms
C
            CALL FVIS(IMODEL, NPTS, QP, FM, QM, DQP, DQM, STEMP, TAU, F)
C
C Wall Functions - if not integrating to the wall
C
            IF ( IFWALF ) THEN
C
C Loop over WALL FUNCTION boundary conditions for I faces - Calculate
C flux boundary conditions for Wall Functions
C
               DO 300 IBC = 1, NBCS
                  IBCTYP = IBCDAT(1,IBC)
                  IDIR   = IBCDAT(2,IBC)
                  ISTRT  = IBCDAT(4,IBC)
                  IEND   = IBCDAT(5,IBC)
                  IF (IBCTYP .EQ. IWALFN .AND. IDIR .EQ. 1) THEN
C
                     INROUT = IBCDAT(3,IBC)
                     JSTRT  = MAX (IBCDAT(6,IBC), 2)
                     JEND   = MIN (IBCDAT(7,IBC), JDIM)
C
                     IF (INROUT .EQ. 1) THEN
                        IN     = 2
                        IM     = 1
                        IW     = 1
                        IBC2   = 0
                        SGNM   = 1.E0
                     ELSE
                        IN     = IDIM
                        IM     = IDIM
                        IW     = IDIM
                        IBC2   = IDIM + 2
                        SGNM   = - 1.E0
                     ENDIF
C
C Modify viscous wall fluxes - set all viscous fluxes to zero then correct
C
                     DO 270 L = 1, NQ
                        DO 260 J = JSTRT, JEND
                           F(IW,J,L) = 0.E0
  260                   CONTINUE
  270                CONTINUE
C
                     DO 280 J = JSTRT, JEND
C
C Non-dimensionalize variables for flux terms, SGNM to account for inner
C or outer end of coordinate
C
                        TAUW   = PROPS(J,K,IBC2,ITQTAU)*SGNM*FSMACH/RE
                        QW     = PROPS(J,K,IBC2,ITQDOT)*SGNM*FSMACH/RE
C
C Tangency vector => aligned with parallel velocity at adjoining cell center
C Note: SGNM used in specification of unit vector parallel to wall in BCWALF
C       cancels and is removed here for computational efficiency.
C
                        UDOTN  = Q(J,K,IN,2) * S(J,K,IM,1,IDIR) +
     1                           Q(J,K,IN,3) * S(J,K,IM,2,IDIR) +
     2                           Q(J,K,IN,4) * S(J,K,IM,3,IDIR)
                        UPN    = Q(J,K,IN,2) - UDOTN * S(J,K,IM,1,IDIR)
                        VPN    = Q(J,K,IN,3) - UDOTN * S(J,K,IM,2,IDIR)
                        WPN    = Q(J,K,IN,4) - UDOTN * S(J,K,IM,3,IDIR)
                        UPARN  = SQRT( UPN*UPN + VPN*VPN + WPN*WPN )
                        UPARN  = MAX ( UPARN, RSMALL )
C
C Calculate the viscous wall flux terms
C
                        F(IW,J,2) = TAUW * UPN / UPARN
                        F(IW,J,3) = TAUW * VPN / UPARN
                        F(IW,J,4) = TAUW * WPN / UPARN
                        F(IW,J,5) = - QW
  280                CONTINUE
                  ENDIF
  300          CONTINUE
            ENDIF
C
C     Add fluxes to residual
C
            DO 380 L = 1, NF
               DO 360 I = IPSTRT, IPEND
                  DO 340 J = 2, JDIM
                     RES(J,K,I,L) = RES(J,K,I,L) -
     1                              ( F(I,J,L)   * S(J,K,I,4,1) -
     2                                F(I-1,J,L) * S(J,K,I-1,4,1) )
  340             CONTINUE
  360          CONTINUE
  380       CONTINUE
C
         ENDIF
  500 CONTINUE
C
C     Finished with i direction residual computation.
      RETURN
      END
      SUBROUTINE FLUXJ (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                  Q, PROPS, NPPTS, S, VOL,
     2                  RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                  IBCDAT, NBCS, IORDER, LIMIT, RKAP, IFLUX,
     4                  VISCOS, IMODEL)
C
C     Routine to calculate the contriubtion to the residual from the
C     j direction.  This routine is used for either the
C     time dependent calculation or the marching calculation.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                      (used in dimensioning temporary space used for
C                       calculating q(+,-) and f.
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     RES            : Residual
C     DQP,DQM        : Storage for delta q = q(j) - q(j-1)
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     TAU            : Storage of Reynolds stresses at interfaces
C     F,FM           : Fluxes at cell interfaces -
C                      if Flux Difference Splitting then F = Flux
C                      if Flux Vector Splitting then F = Fplus, FM = Fminus
C     STEMP          : Storage for metrics passed to flux evaluation routine.
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IORDER         : Order of MUSCL interpolation for J direction
C                      IORDER = 1 first order
C                             = 2 second order (or 'third' order)
C     LIMIT          : Limiter to use for MUSCL interpolation
C     RKAP           : Kappa to use in MUSCL interpolation
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     IMODEL         : Turbulence model
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          DQP   (MXSECT,NQ),
     2          DQM   (MXSECT,NQ),
     3          QP    (MXSECT,NQ),
     4          QM    (MXSECT,NQ),
     5          TAU   (MXSECT,6),
     6          F     (JDIM,2:KDIM,NF),
     7          FM    (JDIM,2:KDIM,NF),
     8          STEMP (JDIM,2:KDIM,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IMODEL(NMDL)
C
      LOGICAL   VISCOS
C
      ITURB = IMODEL(1)
C
C     Loop over I calculating Q(+,-), F(Q(+,-)) and updating the Residual.
C
      DO 500 I = IPSTRT, IPEND
C
C     Inviscid Residuals
C
         CALL MUSCLJ (IDIM, JDIM, KDIM, I,
     1                Q, DQP, DQM, QP, QM,
     2                IBCDAT, NBCS, IORDER, LIMIT, RKAP)
C
C     Calculate the fluxes from q(plus) and q(minus).  Pass only
C     the appropriate metrics from the current direction.
C
         DO 120 K = 2, KDIM
            DO 110 J = 1, JDIM
               DO 100 L = 1, 3
                  STEMP(J,K,L) = S(J,K,I,L,2)
  100          CONTINUE
  110       CONTINUE
  120    CONTINUE
         NPTS = JDIM * (KDIM - 1)
C
C     Flux Difference Splitting
C
         IF (IFCHAR(IFLUX,1) .EQ. IFDS) THEN
C
C     Add the flux contributions to the residual.
C
            CALL FDS (IFLUX, ITURB, NPTS, QP, QM, STEMP, DQP, DQM, F)
C
            DO 180 L = 1, NF
               DO 160 K = 2, KDIM
                  DO 140 J = 2, JDIM
                     RES(J,K,I,L) = RES(J,K,I,L) +
     1                              ( F(J,K,L)   * S(J,K,I,4,2) -
     2                                F(J-1,K,L) * S(J-1,K,I,4,2) )
  140             CONTINUE
  160          CONTINUE
  180       CONTINUE
         ENDIF
C
C     Viscous Residuals
C
         IF ( VISCOS ) THEN
C
C     Calculate the derivatives and averages of stored variables at the
C     interfaces.
C     Temporary variables passed to the viscous flux evaluation routine:
C         QP    for Q      (variables at interface)
C         FM    for PROPSI (properties at interface)
C               NOTE: This works properly only as long as NP <= NQ
C         QM    for DQDX   (derivatives of Q in x direction at interface)
C         DQP   for DQDY   (derivatives of Q in y direction at interface)
C         DQM   for DQDZ   (derivatives of Q in z direction at interface)
C     Temporary variables used internally in DELQ:
C         F(2-NQ) for SJ (STEMP is dimensioned incorrectly to be used for
C                     the averaged metrics in the J direction.  F is large
C                     enough to provide the necessary space.  Do not use
C                     F for anything else in this call).
C         F(1)    for VOLAUX
C
            CALL DELQJ (IDIM, JDIM, KDIM, I,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  F(1,2,2), F(1,2,1), QP, FM, QM, DQP, DQM)
C
C     Viscous Terms
C
            CALL FVIS(IMODEL, NPTS, QP, FM, QM, DQP, DQM, STEMP, TAU, F)
C
C Wall Functions - if not integrating to the wall
C
            IF ( IFWALF ) THEN
C
C Loop over WALL FUNCTION boundary conditions for J faces - Calculate
C flux boundary conditions for Wall Functions
C
               DO 300 IBC = 1, NBCS
                  IBCTYP = IBCDAT(1,IBC)
                  IDIR   = IBCDAT(2,IBC)
                  ISTRT  = IBCDAT(4,IBC)
                  IEND   = IBCDAT(5,IBC)
                  IF (IBCTYP .EQ. IWALFN .AND. IDIR .EQ. 2 .AND.
     1                     I .GE. ISTRT .AND.    I .LE. IEND) THEN
C
                     INROUT = IBCDAT(3,IBC)
                     KSTRT  = MAX (IBCDAT(8,IBC), 2)
                     KEND   = MIN (IBCDAT(9,IBC), KDIM)
C
                     IF (INROUT .EQ. 1) THEN
                        JN     = 2
                        JM     = 1
                        JW     = 1
                        JBC2   = 0
                        SGNM   = 1.E0
                     ELSE
                        JN     = JDIM
                        JM     = JDIM
                        JW     = JDIM
                        JBC2   = JDIM + 2
                        SGNM   = - 1.E0
                     ENDIF
C
C Modify viscous wall fluxes - set all viscous fluxes to zero then correct
C
                     DO 270 L = 1, NQ
                        DO 260 K = KSTRT, KEND
                           F(JW,K,L) = 0.E0
  260                   CONTINUE
  270                CONTINUE
C
                     DO 280 K = KSTRT, KEND
C
C Non-dimensionalize variables for flux terms, SGNM to account for inner
C or outer end of coordinate
C
                        TAUW   = PROPS(JBC2,K,I,ITQTAU)*SGNM*FSMACH/RE
                        QW     = PROPS(JBC2,K,I,ITQDOT)*SGNM*FSMACH/RE
C
C Tangency vector => aligned with parallel velocity at adjoining cell center
C Note: SGNM used in specification of unit vector parallel to wall in BCWALF
C       cancels and is removed here for computational efficiency.
C
                        UDOTN  = Q(JN,K,I,2) * S(JM,K,I,1,IDIR) +
     1                           Q(JN,K,I,3) * S(JM,K,I,2,IDIR) +
     2                           Q(JN,K,I,4) * S(JM,K,I,3,IDIR)
                        UPN    = Q(JN,K,I,2) - UDOTN * S(JM,K,I,1,IDIR)
                        VPN    = Q(JN,K,I,3) - UDOTN * S(JM,K,I,2,IDIR)
                        WPN    = Q(JN,K,I,4) - UDOTN * S(JM,K,I,3,IDIR)
                        UPARN  = SQRT( UPN*UPN + VPN*VPN + WPN*WPN )
                        UPARN  = MAX ( UPARN, RSMALL )
C
C Calculate the viscous wall flux terms
C
                        F(JW,K,2) = TAUW * UPN / UPARN
                        F(JW,K,3) = TAUW * VPN / UPARN
                        F(JW,K,4) = TAUW * WPN / UPARN
                        F(JW,K,5) = - QW
  280                CONTINUE
                  ENDIF
  300          CONTINUE
            ENDIF
C
C     Add fluxes to residual
C
            DO 380 L = 1, NF
               DO 360 K = 2, KDIM
                  DO 340 J = 2, JDIM
                     RES(J,K,I,L) = RES(J,K,I,L) -
     1                              ( F(J,K,L)   * S(J,K,I,4,2) -
     2                                F(J-1,K,L) * S(J-1,K,I,4,2) )
  340             CONTINUE
  360          CONTINUE
  380       CONTINUE
C
         ENDIF
C
  500 CONTINUE
C
C     Finished with j direction residual computation.
      RETURN
      END
      SUBROUTINE FLUXK (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                  Q, PROPS, NPPTS, S, VOL,
     2                  RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                  IBCDAT, NBCS,
     4                  IORDER, LIMIT, RKAP, IFLUX, VISCOS, IMODEL)
C
C     Routine to calculate the contriubtion to the residual from the
C     k direction.  This routine is used for either the
C     time dependent calculation or the marching calculation.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                      (used in dimensioning temporary space used for
C                       calculating q(+,-) and f.
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     RES            : Residual
C     DQP,DQM        : Storage for delta q = q(k) - q(k-1)
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     TAU            : Storage for Reynolds stresses at interfaces
C     F,FM           : Fluxes at cell interfaces -
C                      if Flux Difference Splitting then F = Flux
C                      if Flux Vector Splitting then F = Fplus, FM = Fminus
C     STEMP          : Storage for metrics passed to flux evaluation routine.
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IORDER         : Order of MUSCL interpolation for K direction
C                      IORDER = 1 first order
C                             = 2 second order (or 'third' order)
C     LIMIT          : Limiter to use for MUSCL interpolation
C     RKAP           : Kappa to use in MUSCL interpolation
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     IMODEL         : Turbulence model array
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          DQP   (MXSECT,NQ),
     2          DQM   (MXSECT,NQ),
     3          QP    (MXSECT,NQ),
     4          QM    (MXSECT,NQ),
     5          TAU   (MXSECT,6),
     6          F     (KDIM,2:JDIM,NF),
     7          FM    (KDIM,2:JDIM,NF),
     8          STEMP (KDIM,2:JDIM,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IMODEL(NMDL)
C
      LOGICAL   VISCOS
C
      ITURB = IMODEL(1)
C
C     Loop over I calculating Q(+,-), F(Q(+,-)) and updating the Residual.
C
      DO 500 I = IPSTRT, IPEND
C
C     Inviscid Residuals
C
         CALL MUSCLK (IDIM, JDIM, KDIM, I,
     1                Q, DQP, DQM, QP, QM,
     2                IBCDAT, NBCS, IORDER, LIMIT, RKAP)
C
C     Calculate the fluxes from q(plus) and q(minus).  Pass only
C     the appropriate metrics from the current direction.
C
         DO 120 J = 2, JDIM
            DO 110 K = 1, KDIM
               DO 100 L = 1, 3
                  STEMP(K,J,L) = S(J,K,I,L,3)
  100          CONTINUE
  110       CONTINUE
  120    CONTINUE
         NPTS = KDIM * (JDIM - 1)
C
C     Flux Difference Splitting
C
         IF (IFCHAR(IFLUX,1) .EQ. IFDS) THEN
C
C     Add the flux contributions to the residual.
C
            CALL FDS (IFLUX, ITURB, NPTS, QP, QM, STEMP, DQP, DQM, F)
C
            DO 180 L = 1, NF
               DO 160 J = 2, JDIM
                  DO 140 K = 2, KDIM
                     RES(J,K,I,L) = RES(J,K,I,L) +
     1                              ( F(K,J,L)   * S(J,K,I,4,3) -
     2                                F(K-1,J,L) * S(J,K-1,I,4,3) )
  140             CONTINUE
  160          CONTINUE
  180       CONTINUE
         ENDIF
C
C     Viscous Residuals
C
         IF ( VISCOS ) THEN
C
C     Calculate the derivatives and averages of stored variables at the
C     interfaces.
C     Temporary variables passed to the viscous flux evaluation routine:
C         QP    for Q      (variables at interface)
C         FM    for PROPSI (properties at interface)
C               NOTE: This works properly only as long as NP <= NQ
C         QM    for DQDX   (derivatives of Q in x direction at interface)
C         DQP   for DQDY   (derivatives of Q in y direction at interface)
C         DQM   for DQDZ   (derivatives of Q in z direction at interface)
C     Temporary variables used internally in DELQ:
C         F(2-NQ) for SK (STEMP is dimensioned incorrectly to be used for
C                     the averaged metrics in the J direction.  F is large
C                     enough to provide the necessary space.  Do not use
C                     F for anything else in this call).
C         F(1)    for VOLAUX
C
            CALL DELQK (IDIM, JDIM, KDIM, I,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  F(1,2,2), F(1,2,1), QP, FM, QM, DQP, DQM)
C
C     Viscous Terms
C
            CALL FVIS(IMODEL, NPTS, QP, FM, QM, DQP, DQM, STEMP, TAU, F)
C
C Wall Functions - if not integrating to the wall
C
            IF ( IFWALF ) THEN
C
C Loop over WALL FUNCTION boundary conditions for K faces - Calculate
C flux boundary conditions for Wall Functions
C
               DO 300 IBC = 1, NBCS
                  IBCTYP = IBCDAT(1,IBC)
                  IDIR   = IBCDAT(2,IBC)
                  ISTRT  = IBCDAT(4,IBC)
                  IEND   = IBCDAT(5,IBC)
                  IF (IBCTYP .EQ. IWALFN .AND. IDIR .EQ. 3 .AND.
     1                     I .GE. ISTRT .AND.    I .LE. IEND) THEN
C
                     INROUT = IBCDAT(3,IBC)
                     JSTRT  = MAX (IBCDAT(6,IBC), 2)
                     JEND   = MIN (IBCDAT(7,IBC), JDIM)
C
                     IF (INROUT .EQ. 1) THEN
                        KN     = 2
                        KM     = 1
                        KW     = 1
                        KBC2   = 0
                        SGNM   = 1.E0
                     ELSE
                        KN     = KDIM
                        KM     = KDIM
                        KW     = KDIM
                        KBC2   = KDIM + 2
                        SGNM   = - 1.E0
                     ENDIF
C
C Modify viscous wall fluxes - set all viscous fluxes to zero then correct
C
                     DO 270 L = 1, NQ
                        DO 260 J = JSTRT, JEND
                           F(KW,J,L) = 0.E0
  260                   CONTINUE
  270                CONTINUE
C
                     DO 280 J = JSTRT, JEND
C
C Non-dimensionalize variables for flux terms, SGNM to account for inner
C or outer end of coordinate
C
                        TAUW   = PROPS(J,KBC2,I,ITQTAU)*SGNM*FSMACH/RE
                        QW     = PROPS(J,KBC2,I,ITQDOT)*SGNM*FSMACH/RE
C
C Tangency vector => aligned with parallel velocity at adjoining cell center
C Note: SGNM used in specification of unit vector parallel to wall in BCWALF
C       cancels and is removed here for computational efficiency.
C
                        UDOTN  = Q(J,KN,I,2) * S(J,KM,I,1,IDIR) +
     1                           Q(J,KN,I,3) * S(J,KM,I,2,IDIR) +
     2                           Q(J,KN,I,4) * S(J,KM,I,3,IDIR)
                        UPN    = Q(J,KN,I,2) - UDOTN * S(J,KM,I,1,IDIR)
                        VPN    = Q(J,KN,I,3) - UDOTN * S(J,KM,I,2,IDIR)
                        WPN    = Q(J,KN,I,4) - UDOTN * S(J,KM,I,3,IDIR)
                        UPARN  = SQRT( UPN*UPN + VPN*VPN + WPN*WPN )
                        UPARN  = MAX ( UPARN, RSMALL )
C
C Calculate the viscous wall flux terms
C
                        F(KW,J,2) = TAUW * UPN / UPARN
                        F(KW,J,3) = TAUW * VPN / UPARN
                        F(KW,J,4) = TAUW * WPN / UPARN
                        F(KW,J,5) = - QW
  280                CONTINUE
                  ENDIF
  300          CONTINUE
            ENDIF
C
C     Add fluxes to residual
C
            DO 380 L = 1, NF
               DO 360 J = 2, JDIM
                  DO 340 K = 2, KDIM
                     RES(J,K,I,L) = RES(J,K,I,L) -
     1                              ( F(K,J,L)   * S(J,K,I,4,3) -
     2                                F(K-1,J,L) * S(J,K-1,I,4,3) )
  340             CONTINUE
  360          CONTINUE
  380       CONTINUE
C
         ENDIF
C
  500 CONTINUE
C
C     Finished with k direction residual computation.
      RETURN
      END
      SUBROUTINE FLUXKA (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS,
     4                   IORDER, LIMIT, RKAP, IFLUX, VISCOS, IMODEL)
C
C Routine to calculate the axisymmetric flux contriubtion to the residual
C from the k direction.  This routine is used for either the time dependent
C calculation or the marching calculation.
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning temporary space used for
C                   calculating q(+,-) and f.
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RES            : Residual
C DQP,DQM        : Storage for delta q = q(k) - q(k-1)
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C TAU            : Storage for Reynolds stresses at interfaces
C F,FM           : Fluxes at cell interfaces -
C                  if Flux Difference Splitting then F = Flux
C                  if Flux Vector Splitting then F = Fplus, FM = Fminus
C STEMP          : Storage for metrics passed to flux evaluation routine.
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C IORDER         : Order of MUSCL interpolation for K direction
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C IFLUX          : Flux evaluation scheme
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C IMODEL         : Turbulence model array
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          DQP   (MXSECT,NQ),
     2          DQM   (MXSECT,NQ),
     3          QP    (KDIM,2:JDIM,NQ),
     4          QM    (MXSECT,NQ),
     5          TAU   (MXSECT,6),
     6          F     (KDIM,2:JDIM,NF),
     7          FM    (KDIM,2:JDIM,NF),
     8          STEMP (KDIM,2:JDIM,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IMODEL(NMDL)
C
      LOGICAL   VISCOS
C
      ITURB = IMODEL(1)
C
C     Loop over I calculating axisymmetric fluxes and updating the residual.
C
      DO 500 I = IPSTRT, IPEND
C
C 1.  Inviscid fluxes: Pressure only on the v- and w-momentum equations
C
         DO 110 J = 2, JDIM
            P            = Q(J,2,I,5)
C
            F(1,J,3)     = P * S(J,1,I,2,3)
            F(2,J,3)     = P * S(J,2,I,2,3)
            RES(J,2,I,3) = RES(J,2,I,3) +
     1                     ( F(2,J,3) * S(J,2,I,4,3) -
     2                       F(1,J,3) * S(J,1,I,4,3) )
C
            F(1,J,4)     = P * S(J,1,I,3,3)
            F(2,J,4)     = P * S(J,2,I,3,3)
            RES(J,2,I,4) = RES(J,2,I,4) +
     1                     ( F(2,J,4) * S(J,2,I,4,3) -
     2                       F(1,J,4) * S(J,1,I,4,3) )
  110    CONTINUE
C
C 2.  Viscous Residuals
C
         IF ( VISCOS ) THEN
C
C     Calculate the derivatives and averages of stored variables at the
C     interfaces.
C     Temporary variables passed to the viscous flux evaluation routine:
C         QP    for Q      (variables at interface)
C         FM    for PROPSI (properties at interface)
C               NOTE: This works properly only as long as NP <= NQ
C         QM    for DQDX   (derivatives of Q in x direction at interface)
C         DQP   for DQDY   (derivatives of Q in y direction at interface)
C         DQM   for DQDZ   (derivatives of Q in z direction at interface)
C     Temporary variables used internally in DELQ:
C         F(2-NQ) for SK (STEMP is dimensioned incorrectly to be used for
C                     the averaged metrics in the J direction.  F is large
C                     enough to provide the necessary space.  Do not use
C                     F for anything else in this call).
C         F(1)    for VOLAUX
C
            CALL DELQK (IDIM, JDIM, KDIM, I,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  F(1,2,2), F(1,2,1), QP, FM, QM, DQP, DQM)
C
C     Metrics from the current direction.
C
            DO 320 K = 1, KDIM
               DO 310 J = 2, JDIM
                  STEMP(K,J,1) = S(J,K,I,1,3)
                  STEMP(K,J,2) = S(J,K,I,2,3)
                  STEMP(K,J,3) = S(J,K,I,3,3)
  310          CONTINUE
  320       CONTINUE
            NPTS = KDIM * (JDIM - 1)
C
C     Viscous Terms
C
            CALL FVIS(IMODEL, NPTS, QP, FM, QM, DQP, DQM, STEMP, TAU, F)
C
C     Add fluxes to residual
C
            DO 380 L = 1, NF
               DO 360 K = 2, KDIM
                  DO 340 J = 2, JDIM
                     RES(J,K,I,L) = RES(J,K,I,L) -
     1                              ( F(K,J,L)   * S(J,K,I,4,3) -
     2                                F(K-1,J,L) * S(J,K-1,I,4,3) )
  340             CONTINUE
  360          CONTINUE
  380       CONTINUE
C
         ENDIF
C
  500 CONTINUE
C
C     Finished with k direction axisymmetric residual computation.
      RETURN
      END
      SUBROUTINE FLUXM (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                  Q, PROPS, NPPTS, S, VOL, RES,
     2                  DQP, DQM, QP, QM, FP, FM, STEMP,
     3                  IBCDAT, NBCS,
     4                  IORDER, LIMIT, VGNRN, SIGMA, IMODEL)
C
C     Routine to calculate the contribution to the residual from the
C     i direction for marching.  Uses fully upwind either first or
C     second order accurate in i.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                      (used in dimensioning temporary space used for
C                       calculating q(+,-) and f.
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     RES            : Residual
C     DQP,DQM        : Used as temporary storage for FLUX presently
C     QP,QM          : Q at a cell interface for MUSCL scheme
C                      QP = Q(i+1/2), QM = Q(i-1/2)
C     FP,FM          : Fluxes at cell interfaces
C                      FP = F(i+1/2), FM = F(i-1/2)
C     STEMP          : Storage for metrics passed to flux evaluation routine.
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IORDER         : Order of MUSCL interpolation for I direction
C                      IORDER = 1 first order
C                             = 2 second order (or 'third' order)
C     LIMIT          : Limiter to use for MUSCL interpolation
C                      If LIMIT > 0 then do catastrophic limiting in the
C                      I direction for marching
C     VGNRN          : Logical for Vigneron approach in marching flux
C                      evaluation
C     SIGMA          : Safety factor for Vigneron technique when marching
C     IMODEL         : Turbulence model array
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          DQP   (2:JDIM,2:KDIM,NQ),
     2          DQM   (2:JDIM,2:KDIM,NQ),
     3          QP    (2:JDIM,2:KDIM,NQ),
     4          QM    (2:JDIM,2:KDIM,NQ),
     5          FP    (2:JDIM,2:KDIM,NF),
     6          FM    (2:JDIM,2:KDIM,NF),
     7          STEMP (2:JDIM,2:KDIM,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IMODEL(NMDL)
C
      LOGICAL   VGNRN
C
      ITURB = IMODEL(1)
C
C     ICAT counts the number of times that the catastrophic limiter is on
C
      ICAT = 0
C
C     Calculate everything at the cross section I = IPSTRT = IPEND
C
      IF (IPSTRT .NE. IPEND) THEN
         WRITE (IOUT,1000) IPSTRT, IPEND
         STOP
      ENDIF
C
      I = IPSTRT
C
C     Inviscid Residuals
C
      IF (IORDER .EQ. 1) THEN
         DO 60 L = 1, NQ
            DO 50 K = 2, KDIM
               DO 40 J = 2, JDIM
                  QP(J,K,L) = Q(J,K,I,L)
                  QM(J,K,L) = Q(J,K,I-1,L)
   40          CONTINUE
   50       CONTINUE
   60    CONTINUE
      ELSE
         DO 90 L = 1, NQ
            DO 80 K = 2, KDIM
               DO 70 J = 2, JDIM
                  QP(J,K,L) = 1.5E0*Q(J,K,I,L)   - 0.5E0*Q(J,K,I-1,L)
                  QM(J,K,L) = 1.5E0*Q(J,K,I-1,L) - 0.5E0*Q(J,K,I-2,L)
   70          CONTINUE
   80       CONTINUE
   90    CONTINUE
C
C     Catastrophic limiting for higher order - check density and pressure
C
         IF ( LIMIT .GT. 0 ) THEN
            EPS  = 0.E0
            ICAT = 0
            DO 95 K = 2, KDIM
               DO 94 J = 2, JDIM
                  IF (QP(J,K,1) .LE. EPS .OR. QP(J,K,5) .LE. EPS) THEN
                     ICAT = ICAT + 1
                     DO 91 L = 1, NQ
                        QP(J,K,L) = Q(J,K,I,L)
   91                CONTINUE
                  ENDIF
                  IF (QM(J,K,1) .LE. EPS .OR. QM(J,K,5) .LE. EPS) THEN
                     ICAT = ICAT + 1
                     DO 92 L = 1, NQ
                        QM(J,K,L) = Q(J,K,I-1,L)
   92                CONTINUE
                  ENDIF
   94          CONTINUE
   95       CONTINUE
            IF (ICAT .GT. 0) THEN
               WRITE (IOUT,1200) ICAT
            ENDIF
         ENDIF
      ENDIF
C
C     Calculate the fluxes F(i+1/2) from q(plus). Pass only
C     the appropriate metrics from the current direction.
C
      DO 103 L = 1, 3
         DO 102 K = 2, KDIM
            DO 101 J = 2, JDIM
               STEMP(J,K,L) = S(J,K,I,L,1)
  101       CONTINUE
  102    CONTINUE
  103 CONTINUE
C
C     Call Flux evaluation routine.  For temporary storage use:
C        DQP => TKE
C        DQM => H
C
      NPTS = (JDIM - 1) * (KDIM - 1)
      CALL FLUX (ITURB, NPTS, QP, STEMP, DQP, DQM, FP)
C
C     Calculate the fluxes F(i-1/2) from q(minus). Pass only
C     the appropriate metrics from the current direction.
C
      DO 113 L = 1, 3
         DO 112 K = 2, KDIM
            DO 111 J = 2, JDIM
               STEMP(J,K,L) = S(J,K,I-1,L,1)
  111       CONTINUE
  112    CONTINUE
  113 CONTINUE
C
C     Call Flux evaluation routine.  For temporary storage use:
C        DQP => TKE
C        DQM => H
C
      NPTS = (JDIM - 1) * (KDIM - 1)
      CALL FLUX (ITURB, NPTS, QM, STEMP, DQP, DQM, FM)
C
C     Add the flux contributions to the residual.
C
      DO 180 L = 1, NF
         DO 160 K = 2, KDIM
            DO 140 J = 2, JDIM
               RES(J,K,I,L) = RES(J,K,I,L) +
     1                        ( FP(J,K,L) * S(J,K,I,4,1) -
     2                          FM(J,K,L) * S(J,K,I-1,4,1) )
  140       CONTINUE
  160    CONTINUE
  180 CONTINUE
C
C     Source term for the Vigneron technique
C
      IF (VGNRN) THEN
         DO 290 K = 2, KDIM
            DO 280 J = 2, JDIM
               UBAR  = 0.5E0*(S(J,K,I,1,1)+S(J,K,I-1,1,1))*Q(J,K,I,2)
     1               + 0.5E0*(S(J,K,I,2,1)+S(J,K,I-1,2,1))*Q(J,K,I,3)
     2               + 0.5E0*(S(J,K,I,3,1)+S(J,K,I-1,3,1))*Q(J,K,I,4)
               AMSQ  = UBAR*UBAR / (GAMMA * Q(J,K,I,5) / Q(J,K,I,1))
               OMEGA = MIN(1.E0, SIGMA*GAMMA*AMSQ/(1.E0+GAMM1*AMSQ) )
C
               PPI   = QP(J,K,5)
               PMI   = QM(J,K,5)
               PPJ   = 0.5E0*(Q(J,K,I,5) + Q(J+1,K,I,5))
               PMJ   = 0.5E0*(Q(J,K,I,5) + Q(J-1,K,I,5))
               PPK   = 0.5E0*(Q(J,K,I,5) + Q(J,K+1,I,5))
               PMK   = 0.5E0*(Q(J,K,I,5) + Q(J,K-1,I,5))
C
               UPI   = S(J,K,I,1,1)   * QP(J,K,2) +
     1                 S(J,K,I,2,1)   * QP(J,K,3) +
     2                 S(J,K,I,3,1)   * QP(J,K,4)
               UMI   = S(J,K,I-1,1,1) * QM(J,K,2) +
     1                 S(J,K,I-1,2,1) * QM(J,K,3) +
     2                 S(J,K,I-1,3,1) * QM(J,K,4)
C
               RES(J,K,I,2) = RES(J,K,I,2) + (OMEGA - 1.E0) *
     1                        ( PPI*S(J,K,I,1,1)*S(J,K,I,4,1)
     2                        - PMI*S(J,K,I-1,1,1)*S(J,K,I-1,4,1)
     3                        + PPJ*S(J,K,I,1,2)*S(J,K,I,4,2)
     4                        - PMJ*S(J-1,K,I,1,2)*S(J-1,K,I,4,2)
     5                        + PPK*S(J,K,I,1,3)*S(J,K,I,4,3)
     6                        - PMK*S(J,K-1,I,1,3)*S(J,K-1,I,4,3) )
C              RES(J,K,I,3) = RES(J,K,I,3) + (OMEGA - 1.E0) *
C    1                        ( PPI*S(J,K,I,2,1)*S(J,K,I,4,1)
C    2                        - PMI*S(J,K,I-1,2,1)*S(J,K,I-1,4,1)
C    3                        + PPJ*S(J,K,I,2,2)*S(J,K,I,4,2)
C    4                        - PMJ*S(J-1,K,I,2,2)*S(J-1,K,I,4,2)
C    5                        + PPK*S(J,K,I,2,3)*S(J,K,I,4,3)
C    6                        - PMK*S(J,K-1,I,2,3)*S(J,K-1,I,4,3) )
C              RES(J,K,I,4) = RES(J,K,I,4) + (OMEGA - 1.E0) *
C    1                        ( PPI*S(J,K,I,3,1)*S(J,K,I,4,1)
C    2                        - PMI*S(J,K,I-1,3,1)*S(J,K,I-1,4,1)
C    3                        + PPJ*S(J,K,I,3,2)*S(J,K,I,4,2)
C    4                        - PMJ*S(J-1,K,I,3,2)*S(J-1,K,I,4,2)
C    5                        + PPK*S(J,K,I,3,3)*S(J,K,I,4,3)
C    6                        - PMK*S(J,K-1,I,3,3)*S(J,K-1,I,4,3) )
  280       CONTINUE
  290    CONTINUE
      ENDIF
C
C     Finished with i direction residual computation for marching.
      RETURN
C
 1000 FORMAT (' ','Routine FLUXM - invalid IPSTRT not equal IPEND ',2I6,
     1       /' ','RUN STOPPING')
 1200 FORMAT (' ',' Catastrophic limiting for I direction ',I8,' times')
C
      END
      SUBROUTINE PRPRTY (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, S, VOL, IBCDAT, NBCS, IMODEL, IFDELQ,
     2                   T, QC, PROPSC, VOLC, DQDX, DQDY, DQDZ, WORKX)
C
C Routine to calculate the PROPERTIES of the flowfield.
C This routine is used for either the time dependent calculation
C or the marching calculation.
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 1)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM+1)
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning temporary space used for
C                   calculating q(+,-) and f.
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C S              : Metrics
C VOL            : Cell volumes
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C IMODEL         : Turbulence model array
C IFDELQ         : Array to control calculation of delq
C T              : Temporary storage for the Temperature
C QC,PROPSC,VOLC : Q, PROPS and VOL in one-dimensional array
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C WORKX          : Work array
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION T     (0:JDIM+2,0:KDIM+2),
     1          QC    (1:JDIM+1,1:KDIM+1,NQ),
     2          PROPSC(1:JDIM+1,1:KDIM+1,NP),
     3          VOLC  (1:JDIM+1,1:KDIM+1),
     4          DQDX  (1:JDIM+1,1:KDIM+1,NQ),
     5          DQDY  (1:JDIM+1,1:KDIM+1,NQ),
     6          DQDZ  (1:JDIM+1,1:KDIM+1,NQ)
C
      DIMENSION WORKX (MXSECT,NW)
      DIMENSION IBCDAT(10,NBCS)
      DIMENSION IMODEL(NMDL)
      IERROR=0
      ITURB = IMODEL(1)
      ISGS  = IMODEL(6)
C
C     Loop over I
C
      DO 300 I = IPSTRT, IPEND
C
C     Calculating the molecular viscosity
C
         DO 220 K = 0, KDIM + 2
            DO 210 J = 0, JDIM + 2
               T(J,K) = GAMMA * Q(J,K,I,5) / Q(J,K,I,1)
  210       CONTINUE
  220    CONTINUE
C
C     Calculate the molecular viscosity and store it into the PROPS array
C
         NPTS = (JDIM + 3) * (KDIM + 3)
         CALL VSCSTY (NPTS, T, PROPS(0,0,I,1))
  300 CONTINUE
C
C     Calculate the values of Y+
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW .OR.
     1    ITURB .EQ. ITRS .OR. ITURB .EQ. ITLES) THEN
         CALL YPLUSS (IDIM, JDIM, KDIM, IPSTRT, IPEND, ITURB,
     1                Q, PROPS, S, VOL, IBCDAT, NBCS)
      ENDIF
C
C     Calculate the Turbulent Eddy Viscosity
C
C     Loop over I
C
      DO 600 I = IPSTRT, IPEND
C
C     Baldwin-Lomax Turbulence Model
C     Update turbulent eddy viscosity with algebraic model if algebraic model
C     is specified or if NITALG < ITER such that the algebraic model is used
C     in the initial transient to provide a better convergence for the
C     higher order models.
C
C     Only call Baldwin-Lomax for 2 < i < idim-1
C     PROPS(2) is RMUT
C     Temporary storage: Use WORKX(1)     for VORT
C                            WORKX(2-5)   for TVIS
C                            WORKX(6-9)   for DIST
C                            WORKX(10)    for RHO
C                            WORKX(11)    for VORTJ
C                            WORKX(12)    for RMUTJ
C                            WORKX(13)    for Y
C                            WORKX(14)    for FUN
C
         IF (MUTALG .OR. ITURB .EQ. ITBLMX) THEN
            IF (I .GE. 2 .AND. I .LE. IDIM) THEN
               MAXDIM = MAX (JDIM, KDIM)
               CALL TURB (IDIM, JDIM, KDIM, MAXDIM, I, ITURB,
     1                    Q, PROPS(0,0,0,2), S, VOL, IBCDAT, NBCS,
     2                    WORKX(1, 1), WORKX(1, 2), WORKX(1, 6),
     3                    WORKX(1,10), WORKX(1,11), WORKX(1,12),
     4                    WORKX(1,13), WORKX(1,14))
            ENDIF
C
C     k-epsilon, Reynolds stress turbulence model
C     Temporary storage: Use WORKX(1)  for TKE
C                            WORKX(2)  for FDAMP
C
         ELSE IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITRS) THEN
C
            DO 330 L = 1, NQ
               DO 320 K = 1, KDIM+1
                  DO 310 J = 1, JDIM+1
                     QC(J,K,L) = Q(J,K,I,L)
  310             CONTINUE
  320          CONTINUE
  330       CONTINUE
C
            DO 360 L = 1, NP
               DO 350 K = 1, KDIM+1
                  DO 340 J = 1, JDIM+1
                     PROPSC(J,K,L) = PROPS(J,K,I,L)
  340             CONTINUE
  350          CONTINUE
  360       CONTINUE
C
            NPTS  = (JDIM + 1) * (KDIM + 1)
            CALL GETTKE (ITURB,  NPTS, QC, WORKX(1,1))
            CALL RMUTKE (IMODEL, NPTS, QC, PROPSC,WORKX(1,1),WORKX(1,2))
C
            DO 380 K = 1, KDIM + 1
               DO 370 J = 1, JDIM + 1
                  PROPS(J,K,I,2) = PROPSC(J,K,2)
  370          CONTINUE
  380       CONTINUE
C
C     k-omega turbulence model
C     PROPS(1) is RMU and PROPS(2) is RMUT
C
         ELSE IF (ITURB .EQ. ITKW) THEN
            CALL RMUTKW (IDIM, JDIM, KDIM, I, Q, PROPS(0,0,0,2))
C
C     Large-Eddy Simulation
C     Temporary storage: WORKX    for FDAMP
C
         ELSE IF (ITURB .EQ. ITLES) THEN
C
            DO 470 K = 1, KDIM+1
               DO 465 J = 1, JDIM+1
                  VOLC(J,K) = VOL(J,K,I)
  465          CONTINUE
  470       CONTINUE
C
            NPTS  = (JDIM + 1) * (KDIM + 1)
C
C     Temporary variables used internally in DELQC:
C         WORKX(1-2) for QJ
C         WORKX(3-4) for QK
C         WORKX(5-6) for QPI
C         WORKX(7-8) for QMI
C     QJ is dimensioned one larger than normal routines therefore assign it
C     2 planes of WORKX. Similarly for QK. QPI and QMI require only on plane
C     as they are dimensioned normally - but they are allocated one additional
C     plane as a precaution.
C
C     Calculate derivatives at interior cells and boundaries.
C
            NBOUND = 1
            CALL DELQC (IDIM, JDIM, KDIM, I, IFDELQ, NBOUND,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  WORKX(1,1), WORKX(1,3), WORKX(1,5), WORKX(1,7),
     3                  QC, PROPSC, DQDX, DQDY, DQDZ)
C
C     Calculate Structure function for SF model
C     Use WORKX(1) to store SF
C
            IF (ISGS .EQ. ISGSFM) THEN
               CALL GETSF2 (IMODEL, IDIM, JDIM, KDIM, I, Q, PROPS, S,
     1                      VOL, IBCDAT, NBCS, WORKX(1,1), IERROR)
            ENDIF
C
C     Calculate SGS coefficient
C
            CALL RMUSGS (IMODEL, NPTS, QC, PROPSC, VOLC, DQDX, DQDY,
     1                   DQDZ, WORKX(1,1), WORKX(1,2), IERROR)
            IF (IERROR .NE. INO) THEN
               STOP
            ENDIF
C
            DO 490 K = 1, KDIM + 1
               DO 480 J = 1, JDIM + 1
                  PROPS(J,K,I,2) = PROPSC(J,K,2)
  480          CONTINUE
  490       CONTINUE
C
C     No turbulence - set RMUT to zero
C
         ELSE
            DO 520 K = 0, KDIM + 2
               DO 510 J = 0, JDIM + 2
                  PROPS(J,K,I,2) = 0.E0
  510          CONTINUE
  520       CONTINUE
         ENDIF
C
  600 CONTINUE
C
C     Finished with the PROPERTIES
      RETURN
      END
      SUBROUTINE RESID (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                  Q, QN, NQNPTS, PROPS, NPPTS, S, VOL, RC,DTJ,RES,
     2                  FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,WORKX,
     3                  IBCDAT, NBCS, IORDER, LIMIT, RKAP, IFLUX,VISCOS,
     4                  IMODEL, INITRS, IFDELQ, MRCHNG,
     5                  VGNRN, SIGMA, NPRLIM, NPRNEG, IFL2DQ, R2DQDT)
C
C Routine to calculate the residual throughout the flowfield for either
C the time dependent calculation or the marching calculation.
C The input logical INITRS determines whether to initialize the residual
C to zero or to not initialize the residual. INITRS = false is used when
C the residual is initialized in the multigrid cycle to the coarse grid
C forcing function.
C
C Time dependent calculation: IPSTRT = 2, IPEND = IDIM
C Marching calculation      : IPSTRT = IPEND = I plane presently at
C
C This routine is organized as follows:
C     1. If INITRS then zero residuals
C     2. If iterative time dependent then add dQ/dt term
C     3. Residual in I direction - Add dF/dx term
C     4. Residual in J direction - Add dG/dy term
C     5. If 3D or axisymmetric then residual in K direction - add dH/dz term
C     6. Calculate Source Terms
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning temporary space used for
C                   calculating q(+,-) and f.
C Q              : Primitive variables at cell centers
C QN             : Conserved variables at time levels n, n-1, etc.
C NQNPTS         : Number of QN points. This allows avoiding storing QN when
C                  running time accurate.
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RC             : Position vector at cell centers
C DTJ            : Time step divided by cell volume
C RES            : Residual
C FHAT           : Storage for fluxes for 4th order
C DQP,DQM        : Storage for delta q = q(i) - q(i-1)
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C TAU            : Storage for Reynolds stresses to improve modularity
C F,FM           : Fluxes at cell interfaces -
C                  if Flux Difference Splitting then F = Flux
C                  if Flux Vector Splitting then F = Fplus, FM = Fminus
C STEMP          : Temporary storage for metrics
C WORKX          : Work array for cross-section (used for damping, etc.)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C IORDER         : Order of MUSCL interpolation for current direction
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C IFLUX          : Flux evaluation scheme
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C IMODEL         : Turbulence modeling scheme array
C INITRS         : Logical controlling initializing RES to zero for MG
C IFDELQ         : Array controlling calculation of delq
C MRCHNG         : Logical for Marching
C VGNRN          : Logical for Vigneron approach in marching flux evaluation
C SIGMA          : Safety factor for Vigneron technique when marching
C NPRLIM         : Number of times reset production
C NPRNEG         : Number of times invoke positivity preservation for production
C IFL2DQ         : Logical to calculate L2 norm of dQ/dt term for unsteady
C R2DQDT         : L2 norm of dQ/dt term for unsteady
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN    (NQNPTS,NQ,NTMLVL),
     2          PROPS (NPPTS,NP),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     5          RC    (JDIM+1,KDIM+1,IDIM+1,3),
     6          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          FHAT  (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     2          DQP   (MXSECT,NQ),
     3          DQM   (MXSECT,NQ),
     4          QP    (MXSECT,NQ),
     5          QM    (MXSECT,NQ),
     6          TAU   (MXSECT,6),
     7          F     (MXSECT,NF),
     8          FM    (MXSECT,NF),
     9          STEMP (MXSECT,3),
     A          WORKX (MXSECT,NW)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IORDER(3), LIMIT(3), RKAP(3)
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
      DIMENSION R2DQDT(NF+1)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
      LOGICAL   VISCOS(3), INITRS, MRCHNG, VGNRN, IFL2DQ
C
      ITURB = IMODEL(1)
C
C 1.  If INITRS then zero residuals
C
      IF (INITRS) THEN
         DO 140 L = 1, NF
            DO 130 I = IPSTRT - 1, IPEND + 1
               DO 120 K = 1, KDIM + 1
                  DO 110 J = 1, JDIM + 1
                     RES(J,K,I,L) = 0.E0
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
  140    CONTINUE
      ENDIF
C
C 2.  If iterative time dependent then add dQ/dt term and
C     calculate L2 Norm of dQ/dt residual
C
      IF (ITIMED .EQ. IUNSTD) THEN
         CALL DQDT   (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                Q, QN, VOL, DTJ, RES, QP, QM, IMODEL)
         IF (IFL2DQ) THEN
            CALL L2NORM (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   RES, VOL, R2DQDT)
         ENDIF
      ENDIF
C
C 3.  Residual in I direction - Add dF/dx term
C         FLUXM if marching calculation
C         FLUXI if time-dependent calculation
C
      IF ( MRCHNG ) THEN
         CALL FLUXM (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1               Q, PROPS, NPPTS, S, VOL,
     2               RES, DQP, DQM, QP, QM, F, FM, STEMP,
     3               IBCDAT, NBCS, IORDER(1), LIMIT(1),
     4               VGNRN, SIGMA, IMODEL)
      ELSE
         IF (FOURTH) THEN
            CALL FLUXI4 (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS, IORDER(1), LIMIT(1), RKAP(1),
     4                   IFLUX, VISCOS(1), IMODEL)
         ELSE
            CALL FLUXI  (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS, IORDER(1), LIMIT(1), RKAP(1),
     4                   IFLUX, VISCOS(1), IMODEL)
         ENDIF
      ENDIF
C
C 4.  Residual in J direction - Add dG/dy term
C
      IF (FOURTH) THEN
         CALL FLUXJ4 (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                Q, PROPS, NPPTS, S, VOL,
     2                RES, FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                IBCDAT, NBCS, IORDER(2), LIMIT(2), RKAP(2),
     4                IFLUX, VISCOS(2), IMODEL)
      ELSE
         CALL FLUXJ  (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                Q, PROPS, NPPTS, S, VOL,
     2                RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                IBCDAT, NBCS, IORDER(2), LIMIT(2), RKAP(2),
     4                IFLUX, VISCOS(2), IMODEL)
      ENDIF
C
C 5.  If 3D or axisymmetric then Residual in K direction - add dH/dz term
C
      IF ( THREED ) THEN
         IF (FOURTH) THEN
            CALL FLUXK4 (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS, IORDER(3), LIMIT(3), RKAP(3),
     4                   IFLUX, VISCOS(3), IMODEL)
         ELSE
            CALL FLUXK  (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                   IBCDAT, NBCS, IORDER(3), LIMIT(3), RKAP(3),
     4                   IFLUX, VISCOS(3), IMODEL)
         ENDIF
      ELSE IF ( AXISYM ) THEN
         CALL FLUXKA (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                Q, PROPS, NPPTS, S, VOL,
     2                RES, DQP, DQM, QP, QM, TAU, F, FM, STEMP,
     3                IBCDAT, NBCS, IORDER(3), LIMIT(3), RKAP(3),
     4                IFLUX, VISCOS(3), IMODEL)
      ENDIF
C
C 6.  Calculate Source Terms
C     Temporary variables passed to the source term evaluation routine:
C         QP     for QC (variables in one-dimensional array)
C         FM(2-) for PROPSC (properties in one-dimensional array - this is
C                            passed in using FM.  Must always be sure that
C                            NP+1 <= NF or else will need to fix this)
C         STEMP        for SN   (Wall normals - needed in Reynolds stress model)
C         QM           for DQDX (derivatives of Q wrt x at cell centers)
C         DQP          for DQDY (derivatives of Q wrt y at cell centers)
C         DQM          for DQDZ (derivatives of Q wrt z at cell centers)
C         FM(1)        for DEL2K (Laplacian of turbulent kinetic energy)
C         WORKX(1)     for TKE
C         WORKX(2)     for ETILDE
C         WORKX(3)     for XSIW
C         WORKX(4-5)   for FDAMP
C         WORKX(6)     for EPSC
C         WORKX(7)     for PDIL
C         WORKX( 8-13) for SIJ
C         WORKX(14-19) for WIJ
C
      IF ( ISRCE ) THEN
         IF (ITURB.EQ.ITKE .OR. ITURB.EQ.ITKW .OR. ITURB.EQ.ITRS) THEN
            IF (NF .LT. (NP + 1)) THEN
               WRITE (IOUT,1000) NP+1, NF
               STOP
            ENDIF
C
            CALL SRCRES (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, NPPTS, S, VOL, RC, RES,
     2                   QP, FM(1,2), STEMP, QM, DQP, DQM, FM(1,1),
     3                   WORKX(1,1), WORKX(1,2), WORKX(1,3),WORKX(1,4),
     4                   WORKX(1,6), WORKX(1,7), WORKX(1,8),WORKX(1,14),
     5                   TAU, F, IBCDAT, NBCS, IFLUX, IMODEL, IFDELQ,
     6                   NPRLIM, NPRNEG)
         ENDIF
      ENDIF
C
C Wall Functions: reset residuals to zero on the turbulence quantities that
C are set from the wall functions (epsilon is set from wall functions, all
C other turbulence quantities, tau_ij or k, are calculated at cell center).
C The assumption in the wall functions is that we replace the calculated
C value of the turbulence quantities with an 'exact' value.  This
C then implies that the residual at these points is zero.  Necessary as
C the implicit time integration couples the mean and turbulent variables.
C
      IF ( IFWALF ) THEN
C
C Set up equation indices to reset residual to zero
C
         IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
            LSTRT = 6
            LEND  = IEPSLN
         ELSE IF (ITURB .EQ. ITRS) THEN
            LSTRT = IEPSLN
            LEND  = IEPSLN
         ELSE
            LSTRT = 1
            LEND  = 0
         ENDIF
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
         IJKDIM(1) = IDIM
         IJKDIM(2) = JDIM
         IJKDIM(3) = KDIM
C
C Loop over all boundary conditions
C
         DO 490 IBC = 1, NBCS
            IBCTYP = IBCDAT(1,IBC)
            IF (IBCTYP .EQ. IWALFN) THEN
               IDIR      = IBCDAT(2,IBC)
               INROUT    = IBCDAT(3,IBC)
               ISTRT(1)  = MAX (IBCDAT(4,IBC), IPSTRT)
               IEND (1)  = MIN (IBCDAT(5,IBC), IPEND)
               ISTRT(2)  = IBCDAT(6,IBC)
               IEND (2)  = IBCDAT(7,IBC)
               ISTRT(3)  = IBCDAT(8,IBC)
               IEND (3)  = IBCDAT(9,IBC)
               IF (INROUT .EQ. 1) THEN
                  IBCN = 2
               ELSE
                  IBCN = IJKDIM(IDIR)
               ENDIF
C
               IC1 = ICY (IDIR, 1)
               IC2 = ICY (IDIR, 2)
               IC3 = ICY (IDIR, 3)
C
               DO 430 L = LSTRT, LEND
                  DO 420 I3 = ISTRT(IC3), IEND(IC3)
CDIR$ IVDEP
                     DO 410 I2 = ISTRT(IC2), IEND(IC2)
C
                        IN = IBCN*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                        JN = IBCN*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                        KN = IBCN*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                        RES(JN,KN,IN,L) = 0.E0
C
  410                CONTINUE
  420             CONTINUE
  430          CONTINUE
            ENDIF
  490    CONTINUE
      END IF
C
C     Finished with residual computation.
      RETURN
 1000 FORMAT (' ','***** FATAL ERROR - STOP in routine RESID ',
     1       /' ','Temporary storage required to evaluate source terms',
     2       /' ','is insufficient.  Contact ISAAC developer to fix.',
     3       /' ','NP+1 = ', I5, ' NF = ', I5)
      END
      SUBROUTINE SRCRES (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   Q, PROPS, NPPTS, S, VOL, RC, RES,
     2                   QC, PROPSC, SN, DQDX, DQDY, DQDZ, DEL2K,
     3                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                   TAU, SRC, IBCDAT, NBCS,
     5                   IFLUX, IMODEL, IFDELQ, NPRLIM, NPRNEG)
C
C     Routine to calculate the contriubtion to the residual from the
C     source terms.  This routine is used for either the
C     time dependent calculation or the marching calculation.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     RC             : Position vector at cell centers
C     RES            : Residual
C     QC             : Storage for Q in one-dimensional array
C     PROPSC         : Storage for PROPS array in one-dimensional array
C     SN             : Storage for wall normals in one-dimensional array
C     DQDX,DQDY,DQDZ : Storage for derivatives of Q at cell centers
C     DEL2K          : Laplacian of turbulent kinetic energy
C     TKE            :
C     ETILDE         :
C     XSIW           :
C     FDAMP          :
C     EPSC           :
C     PDIL           :
C     SIJ            :
C     WIJ            :
C     TAU            : Storage for Reynolds stress terms
C     SRC            : Source terms for cell (J,K)
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IFLUX          : Flux evaluation scheme
C     IMODEL         : Turbulence model array
C     IFDELQ         : Array controlling calculation of delq
C     NPRLIM         : Number of times reset production
C NPRNEG         : Number of times invoke positivity preservation for production
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          RC    (JDIM+1,KDIM+1,IDIM+1,3)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF),
     1          QC    (2:JDIM,2:KDIM,NQ),
     2          PROPSC(2:JDIM,2:KDIM,NP),
     3          SN    (2:JDIM,2:KDIM,3),
     4          DQDX  (2:JDIM,2:KDIM,NQ),
     5          DQDY  (2:JDIM,2:KDIM,NQ),
     6          DQDZ  (2:JDIM,2:KDIM,NQ),
     7          DEL2K (2:JDIM,2:KDIM),
     8          TKE   (2:JDIM,2:KDIM),
     9          ETILDE(2:JDIM,2:KDIM),
     A          XSIW  (2:JDIM,2:KDIM),
     B          FDAMP (2:JDIM,2:KDIM,2),
     C          EPSC  (2:JDIM,2:KDIM),
     D          PDIL  (2:JDIM,2:KDIM),
     E          SIJ   (2:JDIM,2:KDIM,6),
     F          WIJ   (2:JDIM,2:KDIM,6),
     G          TAU   (2:JDIM,2:KDIM,6),
     H          SRC   (2:JDIM,2:KDIM,NF)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
C     Local variable:
C
      LOGICAL   ISAVPR
C
      ITURB  = IMODEL( 1)
      IFDL2K = IMODEL( 5)
      IASM   = IMODEL(10)
C
C     Set up control to store CMUSTAR back into global array if
C     Algebraic Reynolds stress model
C
C-    Current EASM model for GS does not include variable C_mu for diffusion
C-    IF (IASM .EQ. IASMGS) THEN
C-       ISAVPR = .TRUE.
C-    ELSE
         ISAVPR = .FALSE.
C-    ENDIF
C
C     Number of points in a cross-section to calculate source terms at
C
      NPTS   = (JDIM - 1) * (KDIM - 1)
C
C     Loop over I calculating the source terms
C
      DO 300 I = IPSTRT, IPEND
C
         CALL SOURCE (IDIM, JDIM, KDIM, I, NPRLIM, NPRNEG,
     1                Q, PROPS, NPPTS, S, VOL, RC,
     2                QC, PROPSC, SN, DQDX, DQDY, DQDZ, DEL2K,
     3                TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                TAU, SRC, IBCDAT, NBCS,
     5                IFLUX, IMODEL, IFDELQ, ISAVPR)
C
C     Add the source term to the residual - include volume
C
         DO 250 L = 1, NF
            DO 240 K = 2, KDIM
               DO 230 J = 2, JDIM
                  RES(J,K,I,L) = RES(J,K,I,L) - SRC(J,K,L)*VOL(J,K,I)
  230          CONTINUE
  240       CONTINUE
  250    CONTINUE
  300 CONTINUE
C
C     Finished adding source terms to residual
      RETURN
      END
      SUBROUTINE SOURCE (IDIM, JDIM, KDIM, I, NPRLIM, NPRNEG,
     1                   Q, PROPS, NPPTS, S, VOL, RC,
     2                   QC, PROPSC, SN, DQDX, DQDY, DQDZ, DEL2K,
     3                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                   TAU, SRC, IBCDAT, NBCS,
     5                   IFLUX, IMODEL, IFDELQ, ISAVPR)
C
C Routine to calculate the contriubtion the source terms.  This routine is
C used for either the time dependent calculation or the marching calculation.
C This routine is used for explicit and implicit source term treatment.
C
C This routine is organized as follows:
C      1. Calculate the Laplacian of the turbulent kinetic energy
C      2. Calculate derivatives of Q at cell centers
C      3. Calculate turbulent kinetic energy in 1D array
C      4. Calculate the Reynold's stresses at the cell centers.
C      5. Store CMU* from the local array back into the global storage
C      6. Calculate S_ij, W_ij
C      7. Call routines to calculate turbulence model source terms
C         a. K-epsilon
C         b. K-omega
C         c. Reynolds stress
C
C IDIM,JDIM,KDIM : Dimensions of current block
C I              : I Plane (cell center) to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RC             : Position vector at cell centers
C RES            : Residual
C QC             : Storage for Q in one-dimensional array
C PROPSC         : Storage for PROPS array in one-dimensional array
C SN             : Storage for wall normals in one-dimensional array
C DQDX,DQDY,DQDZ : Storage for derivatives of Q at cell centers
C DEL2K          : Laplacian of turbulent kinetic energy
C TKE            :
C ETILDE         :
C XSIW           :
C FDAMP          :
C EPSC           :
C PDIL           :
C SIJ            :
C WIJ            :
C TAU            : Storage for Reynolds stress terms
C SRC            : Source terms for cell (J,K)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C IFLUX          : Flux evaluation scheme
C IMODEL         : Turbulence model array
C IFDELQ         : Array controlling calculation of delq
C ISAVPR         : Logical controlling storage of CMUSTAR from local
C                  array where it is calculated in TAUIJ back into
C                  global array.  This is done only when called from RESID.
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          RC    (JDIM+1,KDIM+1,IDIM+1,3)
C
      DIMENSION QC    (2:JDIM,2:KDIM,NQ),
     1          PROPSC(2:JDIM,2:KDIM,NP),
     2          SN    (2:JDIM,2:KDIM,3),
     3          DQDX  (2:JDIM,2:KDIM,NQ),
     4          DQDY  (2:JDIM,2:KDIM,NQ),
     5          DQDZ  (2:JDIM,2:KDIM,NQ),
     6          DEL2K (2:JDIM,2:KDIM),
     7          TKE   (2:JDIM,2:KDIM),
     8          ETILDE(2:JDIM,2:KDIM),
     9          XSIW  (2:JDIM,2:KDIM),
     A          FDAMP (2:JDIM,2:KDIM,2),
     B          EPSC  (2:JDIM,2:KDIM),
     C          PDIL  (2:JDIM,2:KDIM),
     D          SIJ   (2:JDIM,2:KDIM,6),
     E          WIJ   (2:JDIM,2:KDIM,6),
     F          TAU   (2:JDIM,2:KDIM,6),
     G          SRC   (2:JDIM,2:KDIM,NF)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
      LOGICAL   ISAVPR
C
      ITURB  = IMODEL( 1)
      IFDL2K = IMODEL( 5)
      IASM   = IMODEL(10)
      IEPSC  = IMODEL(11)
      IPDIL  = IMODEL(12)
      ISRCW  = IMODEL(13)
C
C     Number of points in a cross-section to calculate source terms at
C
      NPTS   = (JDIM - 1) * (KDIM - 1)
C
C 1.  Calculate the Laplacian of the turbulent kinetic energy
C     Temporary variables used internally in DEL2KC:
C         TAU(1-3) for QJ
C         SRC(1-3) for QK
C         TAU(5->) for QPI
C         SRC(4-6) for QMI
C     QJ is dimensioned as JDIM,2:KDIM therefore need more room for it
C     than 1 plane of TAU. Similarly for QK.  QPI and QMI require only
C     one plane as they are dimensioned 2:JDIM,2:KDIM.
C     Use SRC for some of the temporary space to fix a memory allocation
C     problem.  Use DQDX,DQDY,DQDZ as temporary space here as it isn't
C     calculated until after this call.
C
      IF (IFDL2K .EQ. 1) THEN
         CALL DEL2KC (IDIM, JDIM, KDIM, I, ITURB,
     1                Q, S, VOL, IBCDAT, NBCS,
     2                TAU(2,2,1), SRC(2,2,1), TAU(2,2,5), SRC(2,2,4),
     3                DQDX, DQDY, DQDZ, DEL2K)
      ENDIF
C
C 2.  Calculate derivatives of Q at cell centers.
C     Temporary variables used internally in DELQC:
C         TAU(1-3) for QJ
C         SRC(1-3) for QK
C         TAU(5->) for QPI
C         SRC(4-6) for QMI
C     QJ is dimensioned as JDIM,2:KDIM therefore need more room for it
C     than 1 plane of TAU. Similarly for QK.  QPI and QMI require only
C     one plane as they are dimensioned 2:JDIM,2:KDIM.
C     Use SRC for some of the temporary space to fix a memory allocation
C     problem.
C
C     Calculate derivatives at interior cell centers only.
C
      NBOUND = 0
      CALL DELQC (IDIM, JDIM, KDIM, I, IFDELQ, NBOUND,
     1            Q, PROPS, S, VOL, IBCDAT, NBCS,
     2            TAU(2,2,1), SRC(2,2,1), TAU(2,2,5), SRC(2,2,4),
     3            QC, PROPSC, DQDX, DQDY, DQDZ)
C
C 3.  Calculate turbulent kinetic energy in 1D array
C
      CALL GETTKE (ITURB, NPTS, QC, TKE)
C
C 4.  Calculate the Reynold's stresses at the cell centers.
C                                      ~
C     The array TAU contains {- rho (u" u")}.
C                                     i  j
C     For laminar flow:            TAU_ij => zero.
C         algebraic models:        TAU_ij => modeled with Boussinesq approx.
C         two-equation models:     TAU_ij => modeled with Boussinesq approx.
C         Reynold's stress models: TAU_ij => computed from PDE.
C     Pass in RMUT and DUDX,DUDY,DUDZ for Boussinesq approximation.
C     Pass in QC for Q data at same location as DQDX,... derivative data.
C     The Reynold's stresses are stored as:
C         TAU(1) = TAUXX, TAU(2) = TAUYY, TAU(3) = TAUZZ,
C         TAU(4) = TAUXY, TAU(5) = TAUXZ, TAU(6) = TAUYZ
C
      CALL TAUIJ (IMODEL, NPTS, QC, PROPSC, DQDX, DQDY, DQDZ, TAU)
C
C 5.  Store the value of CMU* from the local array back into the global
C     array if using Algebraic Reynolds stress model and ISAVPR is true
C
      IF (IASM .EQ. IASMGS  .AND.  ISAVPR) THEN
         CALL SAVEPR (IDIM, JDIM, KDIM, I, PROPSC, PROPS)
      ENDIF
C
C 6.  Calculate S_ij, W_ij
C
      CALL GETSW  (NPTS, QC, DQDX, DQDY, DQDZ, SIJ, WIJ)
C
C 7.  Turbulence model source terms
C
C 7-a. k-epsilon turbulence model
C
      IF (ITURB .EQ. ITKE) THEN
         CALL SRCKE  (IMODEL, NPTS, QC, PROPSC, DQDX, DQDY, DQDZ, TAU,
     1                DEL2K, TKE, ETILDE, XSIW, FDAMP,
     2                EPSC, PDIL, SIJ, WIJ, SRC, NPRLIM, NPRNEG)
C
C 7-b. k-omega turbulence model
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         CALL SRCKW  (NPTS, QC, PROPSC, DQDX, DQDY, DQDZ, TAU, SRC,
     1                NPRLIM, NPRNEG)
C
C 7-c. Reynolds Stress turbulence model
C      SRCRS  calculates the source terms
C      SRCRSW calculates additional wall normal dependent source terms
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         CALL SRCRS  (IMODEL, NPTS, QC, PROPSC, DQDX, DQDY, DQDZ,
     1                TAU, DEL2K, TKE, ETILDE, XSIW, FDAMP,
     2                EPSC, PDIL, SIJ, WIJ, SRC, NPRLIM, NPRNEG)
C
C     Calculate wall normal dependent source terms for models that include them
C     Temporary storage: TAU    for SRCW
C                        ETILDE for YNI
C                        XSIW   for YNITOT
C
         IF (ISRCW .EQ. IYES) THEN
            CALL SRCRSW (IMODEL, QC, PROPSC, SN, DQDX, DQDY, DQDZ,
     1                   TKE, EPSC, SRC, TAU,
     2                   IDIM, JDIM, KDIM, I, NBCS, IBCDAT,
     3                   S, RC, ETILDE, XSIW)
         ENDIF
      ENDIF
C
C     Finished with the source terms at I
      RETURN
      END
      SUBROUTINE SAVEPR (IDIM, JDIM, KDIM, I, PROPSC, PROPS)
C
C Routine to store CMUSTAR calculated in TAUIJ from local array in TAUIJ
C back into global array for the rest of the program.
C
C IDIM,JDIM,KDIM : Dimensions of block
C I              : Current I = const. plane
C PROPSC         : Local array for Properties (stored on an I = const. plane)
C PROPS          : Global array for Properties
C
      include 'common.inc'
C
      DIMENSION PROPSC(2:JDIM,2:KDIM,NP),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP)
C
C Copy data from temporary storage into permanent PROPS array
C
      DO 120 K = 2, KDIM
         DO 110 J = 2, JDIM
            PROPS(J,K,I,ICMUST) = PROPSC(J,K,ICMUST)
  110    CONTINUE
  120 CONTINUE
C
C Do boundary conditions so that Cmu* is consistently defined on boundaries.
C
      DO 210 K = 2, KDIM
         PROPS(1     ,K,I,ICMUST) = PROPS(2   ,K,I,ICMUST)
         PROPS(JDIM+1,K,I,ICMUST) = PROPS(JDIM,K,I,ICMUST)
  210 CONTINUE
C
      DO 310 J = 1, JDIM+1
         PROPS(J,1     ,I,ICMUST) = PROPS(J,2   ,I,ICMUST)
         PROPS(J,KDIM+1,I,ICMUST) = PROPS(J,KDIM,I,ICMUST)
  310 CONTINUE
C
C If I = 2   , then do I = 1      boundary
C If I = IDIM, then do I = IDIM+1 boundary
C
      IF (I .EQ. 2) THEN
         DO 420 K = 1, KDIM+1
            DO 410 J = 1, JDIM+1
               PROPS(J,K,1     ,ICMUST) = PROPS(J,K,2   ,ICMUST)
  410       CONTINUE
  420    CONTINUE
C
      ELSE IF (I .EQ. IDIM) THEN
         DO 440 K = 1, KDIM+1
            DO 430 J = 1, JDIM+1
               PROPS(J,K,IDIM+1,ICMUST) = PROPS(J,K,IDIM,ICMUST)
  430       CONTINUE
  440    CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE VSCSTY (NPTS, T, RMU)
C
C     Routine to calculate the molecular viscosity.
C
C     NPTS           : Number of points at which to calculate the molecular
C                      viscosity
C     T              : Temperature (T/Tinf)
C     RMU            : Molecular Viscosity
C
      include 'common.inc'
C
      DIMENSION T     (NPTS),
     1          RMU   (NPTS)
C
C     Sutherland's Law
C
C     Constants for Sutherland's Law
C     Sref = 198.6 degrees Rankine.  If using SI units, correct to Kelvins.
C
      SREF  = 198.6E0
      IF ( SIUNIT ) SREF = SREF / 1.8E0
      STINF = SREF / TINF
      SNUM  = 1.E0 + STINF
C
C     Calculate molecular viscosity
C
      DO 100 I = 1, NPTS
         RMU(I) = T(I) * SQRT( T(I) ) * SNUM / ( T(I) + STINF )
  100 CONTINUE
C
C     Finished calculating molecular viscosity
      RETURN
      END
      SUBROUTINE YPLUSS (IDIM, JDIM, KDIM, IPSTRT, IPEND, ITURB,
     1                   Q, PROPS, S, VOL, IBCDAT, NBCS)
C
C Routine to calculate Y+ in the flowfield.
C This routine is used for either the time dependent calculation
C or the marching calculation.
C
C This routine is organized as follows:
C     1. Initialize Y+ = infinity
C     2. Loop over all boundary conditions - for wall/wall functions do
C        a. Calculate Y+ = min (Y+, Y+ calculated from current wall)
C
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT,IPEND   : I plane to begin,end calculations at
C ITURB          : Turbulence model
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C                  PROPS(4) = YNORML
C S              : Metrics
C VOL            : Cell volumes
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local storage used to calculate indices
C
      DIMENSION IJKDIM(3),
     1          ISTRT (3),
     2          IEND  (3)
C
C Store IDIM, JDIM, KDIM in IJKDIM for boundary condition locations
C
      IJKDIM(1) = IDIM
      IJKDIM(2) = JDIM
      IJKDIM(3) = KDIM
C
C 1. Initialize Y+ to <infinity> in case there are no walls
C
      DO 130 I = IPSTRT, IPEND
         DO 120 K = 1, KDIM + 1
            DO 110 J = 1, JDIM + 1
               PROPS(J,K,I,3) = RMAX
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C 2. Loop over WALL boundary conditions
C    Calculate Y+ = MIN (y+, Y+) to allow for multiple walls in
C    the same coordinate direction.
C
      DO 500 LBC = 1, NBCS
         IBCTYP = IBCDAT(1,LBC)
         IF (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN) THEN
            IDIR      = IBCDAT(2,LBC)
            INROUT    = IBCDAT(3,LBC)
            ISTRT(1)  = MAX (IBCDAT(4,LBC), IPSTRT)
            IEND (1)  = MIN (IBCDAT(5,LBC), IPEND)
            ISTRT(2)  = IBCDAT(6,LBC)
            IEND (2)  = IBCDAT(7,LBC)
            ISTRT(3)  = IBCDAT(8,LBC)
            IEND (3)  = IBCDAT(9,LBC)
C
C Modify beginning, ending indices to extend boundary condition to edge/corner
C
            DO 210 L = 1, 3
               IF (L .NE. IDIR) THEN
                  IF (ISTRT(L) .EQ. 2        ) ISTRT(L) = 1
                  IF (IEND (L) .EQ. IJKDIM(L)) IEND (L) = IJKDIM(L) + 1
               END IF
  210       CONTINUE
C
C Set needed variables depending on whether the boundary is
C the inner boundary (INROUT = 1) or the outer boundary (INROUT > 1)
C      IBCPT  is the boundary condition location
C      IBCPT2 is the boundary condition location outside the block from IBCPT
C      IBCN   is the point to the inside of the block from IBCPT
C      IBCM   is the location of the metrics
C
            IF (INROUT .EQ. 1) THEN
               IBCPT  = 1
               IBCPT2 = 0
               IBCN   = 2
               IBCM   = 1
            ELSE
               IBCPT  = IJKDIM(IDIR) + 1
               IBCPT2 = IJKDIM(IDIR) + 2
               IBCN   = IJKDIM(IDIR)
               IBCM   = IJKDIM(IDIR)
            ENDIF
C
            IC1 = ICY (IDIR, 1)
            IC2 = ICY (IDIR, 2)
            IC3 = ICY (IDIR, 3)
C
            DO 320 I3 = ISTRT(IC3), IEND(IC3)
               DO 310 I2 = ISTRT(IC2), IEND(IC2)
C
                  IBC  = IBCPT *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JBC  = IBCPT *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KBC  = IBCPT *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IBC2 = IBCPT2*IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JBC2 = IBCPT2*IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KBC2 = IBCPT2*IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IN   = IBCN  *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JN   = IBCN  *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KN   = IBCN  *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  IM   = IBCM  *IKD(IC1,1)+I2*IKD(IC2,1)+I3*IKD(IC3,1)
                  JM   = IBCM  *IKD(IC1,2)+I2*IKD(IC2,2)+I3*IKD(IC3,2)
                  KM   = IBCM  *IKD(IC1,3)+I2*IKD(IC2,3)+I3*IKD(IC3,3)
C
                  RHOW   = Q    (JBC,KBC,IBC,1)
                  RMUW   = PROPS(JBC,KBC,IBC,1)
                  YNORMW = ABS (PROPS(JBC,KBC,IBC,4))
C
                  YNORMN = ABS (PROPS(JN ,KN ,IN ,4))
C
C Calculate wall shear or use value from wall functions
C
                  IF ( IFWALF ) THEN
                     TAUW   = ABS (PROPS(JBC2,KBC2,IBC2,ITQTAU))
                  ELSE
C
C Calculate the wall value of du/dn
C
                     UBARN = S(JM,KM,IM,1,IDIR) * Q(JN,KN,IN,2)
     1                     + S(JM,KM,IM,2,IDIR) * Q(JN,KN,IN,3)
     2                     + S(JM,KM,IM,3,IDIR) * Q(JN,KN,IN,4)
                     VELN = SQRT (
     1                     (Q(JN,KN,IN,2)-UBARN*S(JM,KM,IM,1,IDIR))**2
     2                   + (Q(JN,KN,IN,3)-UBARN*S(JM,KM,IM,2,IDIR))**2
     3                   + (Q(JN,KN,IN,4)-UBARN*S(JM,KM,IM,3,IDIR))**2 )
C
C Calculate first derivative term as du/dn = delta(u_parallel) / delta(normal)
C
                     DVELDN = VELN / (ABS (YNORMN - YNORMW) + RSMALL)
C
C TAUW = mu * du/dy |(wall)
C
                     TAUW   = RMUW * DVELDN
                  ENDIF
C
C CTAUW = constants for non-dimensionalization * ustar
C         ustar = sqrt (Tau_wall / rho_wall)
C
                  CTAUW  = SQRT ( RE / FSMACH * TAUW / RHOW )
C
C Loop normal to the wall setting Y+
C
CDIR$ IVDEP
                  DO 300 I1 = 1, IJKDIM(IDIR) + 1
C
                     II = I1*IKD(IC1,1) + I2*IKD(IC2,1) + I3*IKD(IC3,1)
                     JJ = I1*IKD(IC1,2) + I2*IKD(IC2,2) + I3*IKD(IC3,2)
                     KK = I1*IKD(IC1,3) + I2*IKD(IC2,3) + I3*IKD(IC3,3)
C
C Yplus = y ustar / nu
C
                     RHO               = Q    (JJ,KK,II,1)
                     RMU               = PROPS(JJ,KK,II,1)
                     YNORML            = ABS (PROPS(JJ,KK,II,4))
                     YPL               = CTAUW * YNORML * RHO / RMU
                     PROPS(JJ,KK,II,3) = MIN (YPL, PROPS(JJ,KK,II,3))
  300             CONTINUE
  310          CONTINUE
  320       CONTINUE
C
         ENDIF
C
C Next boundary condition
C
  500 CONTINUE
C
C Finished calculating Y+
      RETURN
      END
C
      SUBROUTINE DELQC (IDIM, JDIM, KDIM, I, IFDELQ, NBOUND,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  QJ, QK, QPI, QMI,
     3                  QC, PROPSC, DQDX, DQDY, DQDZ)
C
C     Routine to calculate the derivatives of the primitive variables
C     at the cell centers.  It also stores Q, RMU, RMUT in a one-dimensional
C     array stored the same way as the derivative data.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Current I Plane
C     IFDELQ         : Array to control calculation of delq
C     NBOUND         : Number of boundaries to include in derivative calculation
C                      = 0 : Calculate only at interior cell centers
C                      = 1 : Calculate at interior cell centers and on boundary
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     QJ,QK,QPI,QMI  : Temporary storage of Q velocities on the J,K,I+,I- faces
C     QC             : Q in one-dimensional array at cell centers
C     PROPSC         : Properties in one-dimensional array
C     DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C
      include 'common.inc'
C
      DIMENSION IFDELQ(NQ)
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION QJ    (1-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND),
     1          QK    (2-NBOUND:JDIM+NBOUND,1-NBOUND:KDIM+NBOUND),
     2          QPI   (2-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND),
     3          QMI   (2-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND)
C
      DIMENSION QC    (2-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND,NQ),
     1          PROPSC(2-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND,NP),
     2          DQDX  (2-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND,NQ),
     3          DQDY  (2-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND,NQ),
     4          DQDZ  (2-NBOUND:JDIM+NBOUND,2-NBOUND:KDIM+NBOUND,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Loop over all of the variables and calculate derivatives at cell centers
C
      DO 600 L = 1, NQ
C
C     Only calculate required derivatives
C
         IF (IFDELQ(L) .EQ. 1) THEN
C
C     Calculate Q at cell interfaces as averages of cell centers in J
C
            DO 220 K = 2-NBOUND, KDIM+NBOUND
               DO 210 J = 1-NBOUND, JDIM+NBOUND
                  QJ(J,K) = 0.5E0 * ( Q(J,K,I,L) + Q(J+1,K,I,L) )
  210          CONTINUE
  220       CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
            DO 250 IBC = 1, NBCS
               IBCTYP = IBCDAT(1,IBC)
               IDIR   = IBCDAT(2,IBC)
               IF ( (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN)
     1              .AND. IDIR .EQ. 2) THEN
                  INROUT = IBCDAT(3,IBC)
                  ISTRT  = IBCDAT(4,IBC)
                  IEND   = IBCDAT(5,IBC)
                  KSTRT  = IBCDAT(8,IBC)
                  KEND   = IBCDAT(9,IBC)
                  IF (INROUT .EQ. 1) THEN
                     JNTR  = 1
                     JNTR2 = 2
                     JBCPT = 1
                  ELSE
                     JNTR  = JDIM
                     JNTR2 = JDIM - 1
                     JBCPT = JDIM + 1
                  ENDIF
                  IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                     DO 230 K = KSTRT, KEND
                        QJ(JNTR,K) = Q(JBCPT,K,I,L)
  230                CONTINUE
                  ENDIF
               ENDIF
  250       CONTINUE
C
C     If using the MARCHing algorithm, set the QPI and QMI
C     values to be Q(i) to remove the spatial variation of Q
C     which will not be correct as the downstream values are not updated
C
            IF (ISOLVR .EQ. IMARCH) THEN
               DO 310 K = 2-NBOUND, KDIM+NBOUND
                  DO 305 J = 2-NBOUND, JDIM+NBOUND
                     QPI(J,K) = Q(J,K,I,L)
                     QMI(J,K) = Q(J,K,I,L)
  305             CONTINUE
  310          CONTINUE
C
C     Calculate QPI & QMI at cell interfaces as averages of cell centers in I
C
            ELSE
               DO 320 K = 2-NBOUND, KDIM+NBOUND
                  DO 315 J = 2-NBOUND, JDIM+NBOUND
                     QPI(J,K) = 0.5E0 * ( Q(J,K,I,L) + Q(J,K,I+1,L) )
                     QMI(J,K) = 0.5E0 * ( Q(J,K,I,L) + Q(J,K,I-1,L) )
  315             CONTINUE
  320          CONTINUE
            ENDIF
C
C     Loop over boundary conditions and fix the wall data -
C     Only if I = 2 or I = IDIM
C
            DO 350 IBC = 1, NBCS
               IBCTYP = IBCDAT(1,IBC)
               IDIR   = IBCDAT(2,IBC)
               IF ( (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN)
     1              .AND. IDIR .EQ. 1) THEN
                  INROUT = IBCDAT(3,IBC)
                  JSTRT  = IBCDAT(6,IBC)
                  JEND   = IBCDAT(7,IBC)
                  KSTRT  = IBCDAT(8,IBC)
                  KEND   = IBCDAT(9,IBC)
                  IF (INROUT .EQ. 1 .AND. I .EQ. 2) THEN
                     IBCPT = 1
                     DO 335 K = KSTRT, KEND
                        DO 330 J = JSTRT, JEND
                           QMI(J,K) = Q(J,K,IBCPT,L)
  330                   CONTINUE
  335                CONTINUE
                  ELSE IF (INROUT .NE. 1 .AND. I .EQ. IDIM) THEN
                     IBCPT = IDIM + 1
                     DO 345 K = KSTRT, KEND
                        DO 340 J = JSTRT, JEND
                           QPI(J,K) = Q(J,K,IBCPT,L)
  340                   CONTINUE
  345                CONTINUE
                  ENDIF
               ENDIF
  350       CONTINUE
C
C     Loop over J and K forming the derivatives at the cell centers
C     Calculate first derivative terms using Divergence Theorem
C     Use symmetric differencing of the cross-derivative terms
C     from Chakravarthy et al AIAA 85-0165.
C
            DO 420 K = 2-NBOUND, KDIM+NBOUND
               DO 410 J = 2-NBOUND, JDIM+NBOUND
C
                  DQDX(J,K,L) =
     1                   ( QPI(J,K)  * S(J,K,I  ,1,1) * S(J,K,I  ,4,1)
     2                   - QMI(J,K)  * S(J,K,I-1,1,1) * S(J,K,I-1,4,1)
     3                   + QJ(J,K)   * S(J  ,K,I,1,2) * S(J  ,K,I,4,2)
     4                   - QJ(J-1,K) * S(J-1,K,I,1,2) * S(J-1,K,I,4,2) )
                  DQDY(J,K,L) =
     1                   ( QPI(J,K)  * S(J,K,I  ,2,1) * S(J,K,I  ,4,1)
     2                   - QMI(J,K)  * S(J,K,I-1,2,1) * S(J,K,I-1,4,1)
     3                   + QJ(J,K)   * S(J  ,K,I,2,2) * S(J  ,K,I,4,2)
     4                   - QJ(J-1,K) * S(J-1,K,I,2,2) * S(J-1,K,I,4,2) )
                  DQDZ(J,K,L) = 0.E0
  410          CONTINUE
  420       CONTINUE
C
C     If three-dimensional calculation, then calculate QK at cell
C     interfaces as averages of cell centers in K
C
            IF (THREED .OR. AXISYM) THEN
               DO 520 J = 2-NBOUND, JDIM+NBOUND
                  DO 510 K = 1-NBOUND, KDIM+NBOUND
                     QK(J,K) = 0.5E0 * ( Q(J,K,I,L) + Q(J,K+1,I,L) )
  510             CONTINUE
  520          CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
               DO 550 IBC = 1, NBCS
                  IBCTYP = IBCDAT(1,IBC)
                  IDIR   = IBCDAT(2,IBC)
                  IF ((IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN)
     1                 .AND. IDIR .EQ. 3) THEN
                     INROUT = IBCDAT(3,IBC)
                     ISTRT  = IBCDAT(4,IBC)
                     IEND   = IBCDAT(5,IBC)
                     JSTRT  = IBCDAT(6,IBC)
                     JEND   = IBCDAT(7,IBC)
                     IF (INROUT .EQ. 1) THEN
                        KNTR  = 1
                        KNTR2 = 2
                        KBCPT = 1
                     ELSE
                        KNTR  = KDIM
                        KNTR2 = KDIM - 1
                        KBCPT = KDIM + 1
                     ENDIF
                     IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                        DO 530 J = JSTRT, JEND
                           QK(J,KNTR) = Q(J,KBCPT,I,L)
  530                   CONTINUE
                     ENDIF
                  ENDIF
  550          CONTINUE
C
C     Add K contribution to derivative calculation
C
               DO 570 K = 2-NBOUND, KDIM+NBOUND
                  DO 560 J = 2-NBOUND, JDIM+NBOUND
C
C     Metrics and volume
C
                     DQDX(J,K,L) = DQDX(J,K,L) +
     1                   ( QK(J,K)   * S(J,K  ,I,1,3) * S(J,K  ,I,4,3)
     2                   - QK(J,K-1) * S(J,K-1,I,1,3) * S(J,K-1,I,4,3) )
                     DQDY(J,K,L) = DQDY(J,K,L) +
     1                   ( QK(J,K)   * S(J,K  ,I,2,3) * S(J,K  ,I,4,3)
     2                   - QK(J,K-1) * S(J,K-1,I,2,3) * S(J,K-1,I,4,3) )
                     DQDZ(J,K,L) =
     1                   ( QPI(J,K)  * S(J,K,I  ,3,1) * S(J,K,I  ,4,1)
     2                   - QMI(J,K)  * S(J,K,I-1,3,1) * S(J,K,I-1,4,1)
     3                   + QJ(J,K)   * S(J  ,K,I,3,2) * S(J  ,K,I,4,2)
     4                   - QJ(J-1,K) * S(J-1,K,I,3,2) * S(J-1,K,I,4,2)
     5                   + QK(J,K)   * S(J,K  ,I,3,3) * S(J,K  ,I,4,3)
     6                   - QK(J,K-1) * S(J,K-1,I,3,3) * S(J,K-1,I,4,3) )
  560             CONTINUE
  570          CONTINUE
            ENDIF
C
C     Divide by volume
C
            DO 590 K = 2-NBOUND, KDIM+NBOUND
               DO 580 J = 2-NBOUND, JDIM+NBOUND
                  VOLI        = 1.E0 / (VOL(J,K,I) + RSMASQ)
                  DQDX(J,K,L) = DQDX(J,K,L) * VOLI
                  DQDY(J,K,L) = DQDY(J,K,L) * VOLI
                  DQDZ(J,K,L) = DQDZ(J,K,L) * VOLI
  580          CONTINUE
  590       CONTINUE
C
         ENDIF
  600 CONTINUE
C
C     Put Q into a one-dimensional array
C
      DO 730 L = 1, NQ
         DO 720 K = 2-NBOUND, KDIM+NBOUND
            DO 710 J = 2-NBOUND, JDIM+NBOUND
               QC(J,K,L) = Q(J,K,I,L)
  710       CONTINUE
  720    CONTINUE
  730 CONTINUE
C
C     Put PROPS into a one-dimensional array
C
      DO 830 L = 1, NP
         DO 820 K = 2-NBOUND, KDIM+NBOUND
            DO 810 J = 2-NBOUND, JDIM+NBOUND
               PROPSC(J,K,L) = PROPS(J,K,I,L)
  810       CONTINUE
  820    CONTINUE
  830 CONTINUE
C
C     Finished with derivatives
      RETURN
      END
      SUBROUTINE DEL2KC (IDIM, JDIM, KDIM, I, ITURB,
     1                   Q, S, VOL, IBCDAT, NBCS,
     2                   TKEJ, TKEK, TKEPI, TKEMI,
     3                   DKDX, DKDY, DKDZ,  DEL2K)
C
C Routine to calculate the second derivative of k term required in several
C turbulence models.  This routine approximates the term as:
C          2 {|del[sqrt(k)]|}^2
C
C IDIM,JDIM,KDIM : Dimensions of current block
C I              : Current I Plane
C ITURB          : Turbulence model
C Q              : Primitive variables at cell centers
C S              : Metrics
C VOL            : Cell volumes
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C TKEJ,TKEK,
C TKEPI,TKEMI    : Temporary storage of K on the J,K,I+,I- faces
C DEL2K          : Approximation to Laplacian of K
C
C This routine is arranged as:
C   1. Evaluate k at faces of computational cell as averages of cell centers
C      a. Two-equation
C      b. Reynolds stress
C   2. Correct k at faces for walls
C   3. Correct streamwise faces for marching scheme
C   4. Evaluate first derivative using Gauss' divergence theorem
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     2          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION TKEJ  (JDIM,2:KDIM),
     1          TKEK  (2:JDIM,KDIM),
     2          TKEPI (2:JDIM,2:KDIM),
     3          TKEMI (2:JDIM,2:KDIM)
C
      DIMENSION DKDX  (2:JDIM,2:KDIM),
     1          DKDY  (2:JDIM,2:KDIM),
     2          DKDZ  (2:JDIM,2:KDIM)
C
      DIMENSION DEL2K (2:JDIM,2:KDIM)
C
      DIMENSION IBCDAT(10,NBCS)
C
C 1. Calculate square root of K at cell interfaces as averages of cell centers
C
C 1-a. Two-Equation model
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
C
C Calculate I interfaces
C
         DO 110 K = 2, KDIM
            DO 105 J = 2, JDIM
               TKEPI(J,K) = SQRT (0.5E0*(Q(J,K,I,6) + Q(J,K,I+1,6)))
               TKEMI(J,K) = SQRT (0.5E0*(Q(J,K,I,6) + Q(J,K,I-1,6)))
  105       CONTINUE
  110    CONTINUE
C
C Calculate J interfaces
C
         DO 120 K = 2, KDIM
            DO 115 J = 1, JDIM
               TKEJ(J,K) = SQRT (0.5E0*(Q(J,K,I,6) + Q(J+1,K,I,6)))
  115       CONTINUE
  120    CONTINUE
C
C Calculate K interfaces
C
         IF (THREED .OR. AXISYM) THEN
            DO 130 J = 2, JDIM
               DO 125 K = 1, KDIM
                  TKEK(J,K) = SQRT (0.5E0*(Q(J,K,I,6) + Q(J,K+1,I,6)))
  125          CONTINUE
  130       CONTINUE
         ENDIF
C
C 1-b. Reynolds Stress model (K = (T_xx + T_yy + T_zz) / 2)
C
      ELSE IF (ITURB .EQ. ITRS) THEN
C
C Calculate I interfaces
C
         DO 160 K = 2, KDIM
            DO 155 J = 2, JDIM
               TKEPI(J,K) = SQRT (0.25E0 *
     1                ( Q(J,K,I  ,6) + Q(J,K,I  ,7) + Q(J,K,I  ,8)
     2                + Q(J,K,I+1,6) + Q(J,K,I+1,7) + Q(J,K,I+1,8) ) )
               TKEMI(J,K) = SQRT (0.25E0 *
     1                ( Q(J,K,I  ,6) + Q(J,K,I  ,7) + Q(J,K,I  ,8)
     2                + Q(J,K,I-1,6) + Q(J,K,I-1,7) + Q(J,K,I-1,8) ) )
  155       CONTINUE
  160    CONTINUE
C
C Calculate J interfaces
C
         DO 170 K = 2, KDIM
            DO 165 J = 1, JDIM
               TKEJ(J,K) = SQRT (
     1               0.25E0*( Q(J  ,K,I,6)+Q(J  ,K,I,7)+Q(J  ,K,I,8)
     2                      + Q(J+1,K,I,6)+Q(J+1,K,I,7)+Q(J+1,K,I,8) ) )
  165       CONTINUE
  170    CONTINUE
C
C Calculate K interfaces
C
         IF (THREED .OR. AXISYM) THEN
            DO 180 J = 2, JDIM
               DO 175 K = 1, KDIM
                  TKEK(J,K) = SQRT (
     1               0.25E0*( Q(J,K  ,I,6)+Q(J,K  ,I,7)+Q(J,K  ,I,8)
     2                      + Q(J,K+1,I,6)+Q(J,K+1,I,7)+Q(J,K+1,I,8) ) )
  175          CONTINUE
  180       CONTINUE
         ENDIF
C
C Error - Invalid Turbulence model
C
      ELSE
         WRITE (IOUT,1000) ITURB
         STOP
      ENDIF
C
C 2. Loop over boundary conditions and fix the wall data
C
      DO 250 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IF (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN) THEN
            IDIR   = IBCDAT(2,IBC)
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
C
C I direction
C
            IF (IDIR .EQ. 1) THEN
               IF (I .EQ. 2 .AND. INROUT .EQ. 1) THEN
                  DO 210 K = KSTRT, KEND
                     DO 205 J = JSTRT, JEND
                        TKEMI(J,K) = 0.E0
  205                CONTINUE
  210             CONTINUE
               ELSE IF (I .EQ. IDIM .AND. INROUT .NE. 1) THEN
                  DO 220 K = KSTRT, KEND
                     DO 215 J = JSTRT, JEND
                        TKEPI(J,K) = 0.E0
  215                CONTINUE
  220             CONTINUE
               ENDIF
C
C J direction
C
            ELSE IF (IDIR .EQ. 2) THEN
               IF (INROUT .EQ. 1) THEN
                  JNTR  = 1
                  JBCPT = 1
               ELSE
                  JNTR  = JDIM
                  JBCPT = JDIM + 1
               ENDIF
               IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                  DO 230 K = KSTRT, KEND
                     TKEJ(JNTR,K) = 0.E0
  230             CONTINUE
               ENDIF
C
C K direction
C
            ELSE IF (IDIR .EQ. 3) THEN
               IF (INROUT .EQ. 1) THEN
                  KNTR  = 1
                  KBCPT = 1
               ELSE
                  KNTR  = KDIM
                  KBCPT = KDIM + 1
               ENDIF
               IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                  DO 240 J = JSTRT, JEND
                     TKEK(J,KNTR) = 0.E0
  240             CONTINUE
               ENDIF
            ENDIF
         ENDIF
  250 CONTINUE
C
C 3. If using the MARCHing algorithm, set the TKEPI and TKEMI equal
C    to remove the spatial variation of K which will not be correct as
C    the downstream values are not updated
C
      IF (ISOLVR .EQ. IMARCH) THEN
         DO 310 K = 2, KDIM
            DO 305 J = 2, JDIM
               TKEPI(J,K) = TKEMI(J,K)
  305       CONTINUE
  310    CONTINUE
      ENDIF
C
C 4. Loop over J and K forming the derivatives at the cell centers
C    Calculate first derivative terms using Divergence Theorem
C    Use symmetric differencing of the cross-derivative terms
C    from Chakravarthy et al AIAA 85-0165.
C
      DO 420 K = 2, KDIM
         DO 410 J = 2, JDIM
C
            DKDX(J,K) =( TKEPI(J,K)  * S(J,K,I  ,1,1) * S(J,K,I  ,4,1)
     1                 - TKEMI(J,K)  * S(J,K,I-1,1,1) * S(J,K,I-1,4,1)
     2                 + TKEJ(J,K)   * S(J  ,K,I,1,2) * S(J  ,K,I,4,2)
     3                 - TKEJ(J-1,K) * S(J-1,K,I,1,2) * S(J-1,K,I,4,2) )
            DKDY(J,K) =( TKEPI(J,K)  * S(J,K,I  ,2,1) * S(J,K,I  ,4,1)
     1                 - TKEMI(J,K)  * S(J,K,I-1,2,1) * S(J,K,I-1,4,1)
     2                 + TKEJ(J,K)   * S(J  ,K,I,2,2) * S(J  ,K,I,4,2)
     3                 - TKEJ(J-1,K) * S(J-1,K,I,2,2) * S(J-1,K,I,4,2) )
            DKDZ(J,K) = 0.E0
  410    CONTINUE
  420 CONTINUE
C
C     Three-Dimensional Section
C
      IF (THREED .OR. AXISYM) THEN
         DO 440 K = 2, KDIM
            DO 430 J = 2, JDIM
               DKDX(J,K) = DKDX(J,K) +
     1                 ( TKEK(J,K)   * S(J,K  ,I,1,3) * S(J,K  ,I,4,3)
     2                 - TKEK(J,K-1) * S(J,K-1,I,1,3) * S(J,K-1,I,4,3) )
               DKDY(J,K) = DKDY(J,K) +
     1                 ( TKEK(J,K)   * S(J,K  ,I,2,3) * S(J,K  ,I,4,3)
     2                 - TKEK(J,K-1) * S(J,K-1,I,2,3) * S(J,K-1,I,4,3) )
               DKDZ(J,K) =
     1                 ( TKEPI(J,K)  * S(J,K,I  ,3,1) * S(J,K,I  ,4,1)
     2                 - TKEMI(J,K)  * S(J,K,I-1,3,1) * S(J,K,I-1,4,1)
     3                 + TKEJ(J,K)   * S(J  ,K,I,3,2) * S(J  ,K,I,4,2)
     4                 - TKEJ(J-1,K) * S(J-1,K,I,3,2) * S(J-1,K,I,4,2)
     5                 + TKEK(J,K)   * S(J,K  ,I,3,3) * S(J,K  ,I,4,3)
     6                 - TKEK(J,K-1) * S(J,K-1,I,3,3) * S(J,K-1,I,4,3) )
  430       CONTINUE
  440    CONTINUE
      ENDIF
C
C     Divide by volume and form 2*|del[sqrt(k)]|^2
C     Magnitude of del w is sqrt of sum of squares.
C
      DO 460 K = 2, KDIM
         DO 450 J = 2, JDIM
            VOLI  = 1.E0 / VOL(J,K,I)
            DRKDX = DKDX(J,K) * VOLI
            DRKDY = DKDY(J,K) * VOLI
            DRKDZ = DKDZ(J,K) * VOLI
            DEL2K(J,K) = 2.E0 * (DRKDX*DRKDX + DRKDY*DRKDY +
     1                           DRKDZ*DRKDZ)
  450    CONTINUE
  460 CONTINUE
C
C     Finished with K derivative
      RETURN
 1000 FORMAT (' ','Invalid turbulence model ',I3,' specified in DEL2KC',
     1       /' ','Run Aborting.')
      END
      SUBROUTINE DELQI (IDIM, JDIM, KDIM, IPSTRT, IPEND, K,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  STEMP, VOLAUX, QI, PROPSI,
     3                  DQDX, DQDY, DQDZ)
C
C     Routine to calculate derivatives of the primitive variables at
C     cell interfaces and to calculate interface averages for the
C     I direction.
C     Thin Layer:         Calculate DQDX,DQDY,DQDZ as metric times DQDXSI
C     Full Navier-Stokes: Use divergence theorem to calculate derivatives
C
C     This routine is not presently suited for the multiblock
C     approach.  It is close to being ready but is not.  The problem
C     lies that the metrics for one cell into the adjacent block
C     are needed to be completely general.  These are currently not available.
C     The routine metbc needs to be completed.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     IPSTRT,IPEND   : I plane to start, I plane to end on
C     K              : Current K Plane
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = RMU
C                      PROPS(2) = RMUT
C                      PROPS(3) = Y+
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     STEMP          : Temporary storage for metrics
C     QI             : Primitive variables at cell interfaces
C     PROPSI         : Properties at cell interfaces
C     DQDX,DQDY...   : Derivatives of primitive variables at interfaces.
C                      This routine calculates either thin-layer or full NS
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION STEMP (IPSTRT-1:IPEND+1,JDIM,3),
     1          VOLAUX(IPSTRT-1:IPEND,2:JDIM)
C
      DIMENSION QI    (IPSTRT-1:IPEND,2:JDIM,NQ),
     1          PROPSI(IPSTRT-1:IPEND,2:JDIM,NP)
C
      DIMENSION DQDX  (IPSTRT-1:IPEND,2:JDIM,NQ),
     1          DQDY  (IPSTRT-1:IPEND,2:JDIM,NQ),
     2          DQDZ  (IPSTRT-1:IPEND,2:JDIM,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Loop over J forming derivative terms along the I direction
C     on the I = IPSTRT-1, IPEND faces.
C     The storage of SJ reduces the overhead of recalculating the average
C     metric terms required for the derivative calculation.
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
      DO 120 J = 2, JDIM
         DO 110 I = IPSTRT-1, IPEND
            VOLAUX(I,J) = 2.0E0 / ( VOL(J,K,I) + VOL(J,K,I+1) )
  110    CONTINUE
  120 CONTINUE
C
C     For WALL FUNCTIONS ONLY: Modify the auxilliary cell volume at the
C     wall function cell interface to reflect the wall function grid.
C
      IF ( IFWALF ) THEN
C
C     Loop over boundary conditions and fix the wall function volume
C
         DO 125 IBC = 1, NBCS
            IBCTYP = IBCDAT(1,IBC)
            IDIR   = IBCDAT(2,IBC)
            IF (IBCTYP .EQ. IWALFN .AND. IDIR .EQ. 1) THEN
               INROUT = IBCDAT(3,IBC)
               JSTRT  = IBCDAT(6,IBC)
               JEND   = IBCDAT(7,IBC)
               KSTRT  = IBCDAT(8,IBC)
               KEND   = IBCDAT(9,IBC)
               IF (INROUT .EQ. 1) THEN
                  IINT   = 2
                  IBCN2  = 3
               ELSE
                  IINT   = IDIM - 1
                  IBCN2  = IDIM - 2
               ENDIF
               IF (IINT .GE. IPSTRT-1 .AND. IINT .LE. IPEND .AND.
     1                K .GE. KSTRT    .AND.    K .LE. KEND) THEN
                  DO 122 J = JSTRT, JEND
                     VOLAUX(IINT,J) = 1.0E0 / VOL(J,K,IBCN2)
  122             CONTINUE
               ENDIF
            ENDIF
  125    CONTINUE
C
      ENDIF
C
C     Thin Layer Derivatives
C
      IF ( THNLYR ) THEN
         DO 150 L = 1, NQ
            DO 140 J = 2, JDIM
               DO 130 I = IPSTRT-1, IPEND
                  DXSI        = (Q(J,K,I+1,L) - Q(J,K,I,L))
     1                          * VOLAUX(I,J) * S(J,K,I,4,1)
                  DQDX(I,J,L) = S(J,K,I,1,1) * DXSI
                  DQDY(I,J,L) = S(J,K,I,2,1) * DXSI
                  DQDZ(I,J,L) = S(J,K,I,3,1) * DXSI
  130          CONTINUE
  140       CONTINUE
  150    CONTINUE
      ELSE
C
C     Full Navier-Stokes terms
C     Calculate first derivative terms using Divergence Theorem
C     Use symmetric differencing of the cross-derivative terms
C     from Chakravarthy et al AIAA 85-0165.
C
C     Average metrics in I direction
C
         DO 220 J = 2, JDIM
            DO 210 I = IPSTRT-1, IPEND+1
               STEMP(I,J,1) = 0.5E0 * ( S(J,K,I-1,1,1)*S(J,K,I-1,4,1)
     1                                + S(J,K,I,1,1)*S(J,K,I,4,1) )
               STEMP(I,J,2) = 0.5E0 * ( S(J,K,I-1,2,1)*S(J,K,I-1,4,1)
     1                                + S(J,K,I,2,1)*S(J,K,I,4,1) )
               STEMP(I,J,3) = 0.5E0 * ( S(J,K,I-1,3,1)*S(J,K,I-1,4,1)
     1                                + S(J,K,I,3,1)*S(J,K,I,4,1) )
  210       CONTINUE
  220    CONTINUE
C
C     Calculate first derivative terms using Divergence Theorem
C
         DO 250 L = 1, NQ
            DO 240 J = 2, JDIM
               DO 230 I = IPSTRT-1, IPEND
                  DQDX(I,J,L) = VOLAUX(I,J)*(Q(J,K,I+1,L)*STEMP(I+1,J,1)
     1                                      -Q(J,K,I,L)*STEMP(I,J,1) )
                  DQDY(I,J,L) = VOLAUX(I,J)*(Q(J,K,I+1,L)*STEMP(I+1,J,2)
     1                                      -Q(J,K,I,L)*STEMP(I,J,2) )
                  DQDZ(I,J,L) = VOLAUX(I,J)*(Q(J,K,I+1,L)*STEMP(I+1,J,3)
     1                                      -Q(J,K,I,L)*STEMP(I,J,3) )
  230          CONTINUE
  240       CONTINUE
  250    CONTINUE
C
C     Average metric terms in J direction
C
         DO 320 J = 1, JDIM
            DO 310 I = IPSTRT-1, IPEND
               STEMP(I,J,1) = 0.5E0 * ( S(J,K,I,1,2)*S(J,K,I,4,2)
     1                                + S(J,K,I+1,1,2)*S(J,K,I+1,4,2) )
               STEMP(I,J,2) = 0.5E0 * ( S(J,K,I,2,2)*S(J,K,I,4,2)
     1                                + S(J,K,I+1,2,2)*S(J,K,I+1,4,2) )
               STEMP(I,J,3) = 0.5E0 * ( S(J,K,I,3,2)*S(J,K,I,4,2)
     1                                + S(J,K,I+1,3,2)*S(J,K,I+1,4,2) )
  310       CONTINUE
  320    CONTINUE
C
C     Add the derivative data from the J direction
C
         DO 350 L = 1, NQ
            DO 340 J = 2, JDIM
               DO 330 I = IPSTRT-1, IPEND
                  QPJ = 0.25E0 * ( Q(J,K,I,L) + Q(J+1,K,I+1,L)
     1                           + Q(J+1,K,I,L) + Q(J,K,I+1,L) )
                  QMJ = 0.25E0 * ( Q(J,K,I,L) + Q(J-1,K,I+1,L)
     1                           + Q(J-1,K,I,L) + Q(J,K,I+1,L) )
C
                  DQDX(I,J,L) = DQDX(I,J,L)
     1                        + VOLAUX(I,J) * ( QPJ*STEMP(I,J,1)
     2                                        - QMJ*STEMP(I,J-1,1) )
                  DQDY(I,J,L) = DQDY(I,J,L)
     1                        + VOLAUX(I,J) * ( QPJ*STEMP(I,J,2)
     2                                        - QMJ*STEMP(I,J-1,2) )
                  DQDZ(I,J,L) = DQDZ(I,J,L)
     1                        + VOLAUX(I,J) * ( QPJ*STEMP(I,J,3)
     2                                        - QMJ*STEMP(I,J-1,3) )
  330          CONTINUE
  340       CONTINUE
  350    CONTINUE
C
C     Add the contribution from the K+ term
C
C     Average metric terms in K+ direction
C
         IF (THREED .OR. AXISYM) THEN
            DO 420 J = 2, JDIM
               DO 410 I = IPSTRT-1, IPEND
                  STEMP(I,J,1) = 0.5E0*( S(J,K,I,1,3)*S(J,K,I,4,3)
     1                                 + S(J,K,I+1,1,3)*S(J,K,I+1,4,3) )
                  STEMP(I,J,2) = 0.5E0*( S(J,K,I,2,3)*S(J,K,I,4,3)
     1                                 + S(J,K,I+1,2,3)*S(J,K,I+1,4,3) )
                  STEMP(I,J,3) = 0.5E0*( S(J,K,I,3,3)*S(J,K,I,4,3)
     1                                 + S(J,K,I+1,3,3)*S(J,K,I+1,4,3) )
  410          CONTINUE
  420       CONTINUE
C
C     Add the derivative data from the K+ term
C
            DO 450 L = 1, NQ
               DO 440 J = 2, JDIM
                  DO 430 I = IPSTRT-1, IPEND
                     QPK = 0.25E0 * ( Q(J,K,I,L) + Q(J,K+1,I+1,L)
     1                              + Q(J,K+1,I,L) + Q(J,K,I+1,L) )
C
                     DQDX(I,J,L) = DQDX(I,J,L)
     1                           + VOLAUX(I,J) * ( QPK*STEMP(I,J,1) )
                     DQDY(I,J,L) = DQDY(I,J,L)
     1                           + VOLAUX(I,J) * ( QPK*STEMP(I,J,2) )
                     DQDZ(I,J,L) = DQDZ(I,J,L)
     1                           + VOLAUX(I,J) * ( QPK*STEMP(I,J,3) )
  430             CONTINUE
  440          CONTINUE
  450       CONTINUE
C
C     Add the contribution from the K- term
C
C     Average metric terms in K- direction
C
            DO 520 J = 2, JDIM
               DO 510 I = IPSTRT-1, IPEND
                  STEMP(I,J,1) = 0.5E0 * ( S(J,K-1,I,1,3)*S(J,K-1,I,4,3)
     1                             + S(J,K-1,I+1,1,3)*S(J,K-1,I+1,4,3) )
                  STEMP(I,J,2) = 0.5E0 * ( S(J,K-1,I,2,3)*S(J,K-1,I,4,3)
     1                             + S(J,K-1,I+1,2,3)*S(J,K-1,I+1,4,3) )
                  STEMP(I,J,3) = 0.5E0 * ( S(J,K-1,I,3,3)*S(J,K-1,I,4,3)
     1                             + S(J,K-1,I+1,3,3)*S(J,K-1,I+1,4,3) )
  510          CONTINUE
  520       CONTINUE
C
C     Add the derivative data from the K- term
C
            DO 550 L = 1, NQ
               DO 540 J = 2, JDIM
                  DO 530 I = IPSTRT-1, IPEND
                     QMK = 0.25E0 * ( Q(J,K,I,L) + Q(J,K-1,I+1,L)
     1                              + Q(J,K,I+1,L) + Q(J,K-1,I,L) )
C
                     DQDX(I,J,L) = DQDX(I,J,L)
     1                           - VOLAUX(I,J) * ( QMK*STEMP(I,J,1) )
                     DQDY(I,J,L) = DQDY(I,J,L)
     1                           - VOLAUX(I,J) * ( QMK*STEMP(I,J,2) )
                     DQDZ(I,J,L) = DQDZ(I,J,L)
     1                           - VOLAUX(I,J) * ( QMK*STEMP(I,J,3) )
  530             CONTINUE
  540          CONTINUE
  550       CONTINUE
         ENDIF
      ENDIF
C
C     Calculate Q at cell interfaces as averages of cell centers
C
      DO 630 L = 1, NQ
         DO 620 J = 2, JDIM
            DO 610 I = IPSTRT-1, IPEND
               QI(I,J,L) = 0.5E0 * ( Q(J,K,I,L)  + Q(J,K,I+1,L) )
  610       CONTINUE
  620    CONTINUE
  630 CONTINUE
C
C     Calculate PROPSI at cell interfaces as averages of cell centers
C
      DO 660 L = 1, NP
         DO 650 J = 2, JDIM
            DO 640 I = IPSTRT-1, IPEND
               PROPSI(I,J,L)  = 0.5E0*(PROPS(J,K,I,L)+PROPS(J,K,I+1,L))
  640       CONTINUE
  650    CONTINUE
  660 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 750 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IDIR   = IBCDAT(2,IBC)
         IF ( (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN)
     1        .AND. IDIR .EQ. 1) THEN
            INROUT = IBCDAT(3,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
            IF (INROUT .EQ. 1) THEN
               IBCPT = 1
               INTR  = 1
            ELSE
               IBCPT = IDIM + 1
               INTR  = IDIM
            ENDIF
            IF (IBCPT .GE. IPSTRT-1 .AND. IBCPT .LE. IPEND .AND.
     1              K .GE. KSTRT    .AND.     K .LE. KEND) THEN
               DO 720 L = 1, NQ
                  DO 710 J = JSTRT, JEND
                     QI(INTR,J,L) = Q(J,K,IBCPT,L)
  710             CONTINUE
  720          CONTINUE
C
C     Also do properties
C
               DO 740 L = 1, NP
                  DO 730 J = JSTRT, JEND
                     PROPSI(INTR,J,L) = PROPS(J,K,IBCPT,L)
  730             CONTINUE
  740          CONTINUE
            ENDIF
         ENDIF
  750 CONTINUE
C
C     Finished calculating derivatives in the I direction
      RETURN
      END
      SUBROUTINE DELQJ (IDIM, JDIM, KDIM, I,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  STEMP, VOLAUX, QI, PROPSI,
     3                  DQDX, DQDY, DQDZ)
C
C     Routine to calculate derivatives of the primitive variables at
C     cell interfaces and to calculate interface averages for the
C     J direction.
C     Thin Layer:         Calculate DQDX,DQDY,DQDZ as metric times DQDETA
C     Full Navier-Stokes: Use divergence theorem to calculate derivatives
C
C     This routine is not presently suited for the multiblock
C     approach.  It is close to being ready but is not.  The problem
C     lies that the metrics for one cell into the adjacent block
C     are needed to be completely general.  These are currently not available.
C     The routine metbc needs to be completed.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Current I Plane
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = RMU
C                      PROPS(2) = RMUT
C                      PROPS(3) = Y+
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     STEMP          : Temporary storage for metrics
C     QI             : Primitive variables at cell interfaces
C     PROPSI         : Properties at cell interfaces
C     DQDX,DQDY...   : Derivatives of primitive variables at interfaces.
C                      This routine calculates either thin-layer or full NS
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION STEMP (JDIM+1,KDIM,3),
     1          VOLAUX(JDIM,2:KDIM)
C
      DIMENSION QI    (JDIM,2:KDIM,NQ),
     1          PROPSI(JDIM,2:KDIM,NP)
C
      DIMENSION DQDX  (JDIM,2:KDIM,NQ),
     1          DQDY  (JDIM,2:KDIM,NQ),
     2          DQDZ  (JDIM,2:KDIM,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Loop over K forming derivative terms along the J direction
C     on the J = 1, JDIM faces.
C     The storage of SJ reduces the overhead of recalculating the average
C     metric terms required for the derivative calculation.
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
      DO 120 K = 2, KDIM
         DO 110 J = 1, JDIM
            VOLAUX(J,K) = 2.0E0 / ( VOL(J,K,I) + VOL(J+1,K,I) )
  110    CONTINUE
  120 CONTINUE
C
C     For WALL FUNCTIONS ONLY: Modify the auxilliary cell volume at the
C     wall function cell interface to reflect the wall function grid.
C
      IF ( IFWALF ) THEN
C
C     Loop over boundary conditions and fix the wall function volume
C
         DO 125 IBC = 1, NBCS
            IBCTYP = IBCDAT(1,IBC)
            IDIR   = IBCDAT(2,IBC)
            IF (IBCTYP .EQ. IWALFN .AND. IDIR .EQ. 2) THEN
               INROUT = IBCDAT(3,IBC)
               ISTRT  = IBCDAT(4,IBC)
               IEND   = IBCDAT(5,IBC)
               KSTRT  = IBCDAT(8,IBC)
               KEND   = IBCDAT(9,IBC)
               IF (INROUT .EQ. 1) THEN
                  JINT   = 2
                  JBCN2  = 3
               ELSE
                  JINT   = JDIM - 1
                  JBCN2  = JDIM - 2
               ENDIF
               IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                  DO 122 K = KSTRT, KEND
                     VOLAUX(JINT,K) = 1.0E0 / VOL(JBCN2,K,I)
  122             CONTINUE
               ENDIF
            ENDIF
  125    CONTINUE
C
      ENDIF
C
C     End of corrections for wall functions
C
C     Thin Layer Derivatives
C
      IF ( THNLYR ) THEN
         DO 150 L = 1, NQ
            DO 140 K = 2, KDIM
               DO 130 J = 1, JDIM
                  DETA        = (Q(J+1,K,I,L) - Q(J,K,I,L))
     1                          * VOLAUX(J,K) * S(J,K,I,4,2)
                  DQDX(J,K,L) = S(J,K,I,1,2) * DETA
                  DQDY(J,K,L) = S(J,K,I,2,2) * DETA
                  DQDZ(J,K,L) = S(J,K,I,3,2) * DETA
  130          CONTINUE
  140       CONTINUE
  150    CONTINUE
      ELSE
C
C     Full Navier-Stokes terms
C     Calculate first derivative terms using Divergence Theorem
C     Use symmetric differencing of the cross-derivative terms
C     from Chakravarthy et al AIAA 85-0165.
C
C     Average metrics in J direction
C
         DO 220 K = 2, KDIM
            DO 210 J = 1, JDIM+1
               STEMP(J,K,1) = 0.5E0 * ( S(J-1,K,I,1,2)*S(J-1,K,I,4,2)
     1                                + S(J,K,I,1,2)*S(J,K,I,4,2) )
               STEMP(J,K,2) = 0.5E0 * ( S(J-1,K,I,2,2)*S(J-1,K,I,4,2)
     1                                + S(J,K,I,2,2)*S(J,K,I,4,2) )
               STEMP(J,K,3) = 0.5E0 * ( S(J-1,K,I,3,2)*S(J-1,K,I,4,2)
     1                                + S(J,K,I,3,2)*S(J,K,I,4,2) )
  210       CONTINUE
  220    CONTINUE
C
C     Calculate first derivative terms using Divergence Theorem
C
         DO 250 L = 1, NQ
            DO 240 K = 2, KDIM
               DO 230 J = 1, JDIM
                  DQDX(J,K,L) = VOLAUX(J,K)*(Q(J+1,K,I,L)*STEMP(J+1,K,1)
     1                                      -Q(J,K,I,L)*STEMP(J,K,1) )
                  DQDY(J,K,L) = VOLAUX(J,K)*(Q(J+1,K,I,L)*STEMP(J+1,K,2)
     1                                      -Q(J,K,I,L)*STEMP(J,K,2) )
                  DQDZ(J,K,L) = VOLAUX(J,K)*(Q(J+1,K,I,L)*STEMP(J+1,K,3)
     1                                      -Q(J,K,I,L)*STEMP(J,K,3) )
  230          CONTINUE
  240       CONTINUE
  250    CONTINUE
C
C     Average metric terms in K direction
C
         IF (THREED .OR. AXISYM) THEN
            DO 320 K = 1, KDIM
               DO 310 J = 1, JDIM
                  STEMP(J,K,1) = 0.5E0*( S(J,K,I,1,3)*S(J,K,I,4,3)
     1                                 + S(J+1,K,I,1,3)*S(J+1,K,I,4,3) )
                  STEMP(J,K,2) = 0.5E0*( S(J,K,I,2,3)*S(J,K,I,4,3)
     1                                 + S(J+1,K,I,2,3)*S(J+1,K,I,4,3) )
                  STEMP(J,K,3) = 0.5E0*( S(J,K,I,3,3)*S(J,K,I,4,3)
     1                                 + S(J+1,K,I,3,3)*S(J+1,K,I,4,3) )
  310          CONTINUE
  320       CONTINUE
C
C     Add the derivative data from the K direction
C
            DO 350 L = 1, NQ
               DO 340 K = 2, KDIM
                  DO 330 J = 1, JDIM
                     QPK = 0.25E0 * ( Q(J,K,I,L) + Q(J+1,K+1,I,L)
     1                              + Q(J+1,K,I,L) + Q(J,K+1,I,L) )
                     QMK = 0.25E0 * ( Q(J,K,I,L) + Q(J+1,K-1,I,L)
     1                              + Q(J+1,K,I,L) + Q(J,K-1,I,L) )
C
                     DQDX(J,K,L) = DQDX(J,K,L)
     1                           + VOLAUX(J,K) * ( QPK*STEMP(J,K,1)
     2                                           - QMK*STEMP(J,K-1,1) )
                     DQDY(J,K,L) = DQDY(J,K,L)
     1                           + VOLAUX(J,K) * ( QPK*STEMP(J,K,2)
     2                                           - QMK*STEMP(J,K-1,2) )
                     DQDZ(J,K,L) = DQDZ(J,K,L)
     1                           + VOLAUX(J,K) * ( QPK*STEMP(J,K,3)
     2                                           - QMK*STEMP(J,K-1,3) )
  330             CONTINUE
  340          CONTINUE
  350       CONTINUE
         ENDIF
C
C     Add the contribution from the I+ term
C
C     Average metric terms in I+ direction
C
         DO 420 K = 2, KDIM
            DO 410 J = 1, JDIM
               STEMP(J,K,1) = 0.5E0 * ( S(J,K,I,1,1)*S(J,K,I,4,1)
     1                                + S(J+1,K,I,1,1)*S(J+1,K,I,4,1) )
               STEMP(J,K,2) = 0.5E0 * ( S(J,K,I,2,1)*S(J,K,I,4,1)
     1                                + S(J+1,K,I,2,1)*S(J+1,K,I,4,1) )
               STEMP(J,K,3) = 0.5E0 * ( S(J,K,I,3,1)*S(J,K,I,4,1)
     1                                + S(J+1,K,I,3,1)*S(J+1,K,I,4,1) )
  410       CONTINUE
  420    CONTINUE
C
C     Add the derivative data from the I+ term
C
         DO 450 L = 1, NQ
            DO 440 K = 2, KDIM
               DO 430 J = 1, JDIM
                  QPI = 0.25E0 * ( Q(J,K,I,L) + Q(J+1,K,I+1,L)
     1                           + Q(J+1,K,I,L) + Q(J,K,I+1,L) )
C
                  DQDX(J,K,L) = DQDX(J,K,L)
     1                        + VOLAUX(J,K) * ( QPI*STEMP(J,K,1) )
                  DQDY(J,K,L) = DQDY(J,K,L)
     1                        + VOLAUX(J,K) * ( QPI*STEMP(J,K,2) )
                  DQDZ(J,K,L) = DQDZ(J,K,L)
     1                        + VOLAUX(J,K) * ( QPI*STEMP(J,K,3) )
  430          CONTINUE
  440       CONTINUE
  450    CONTINUE
C
C     Add the contribution from the I- term
C
C     Average metric terms in I- direction
C
         DO 520 K = 2, KDIM
            DO 510 J = 1, JDIM
               STEMP(J,K,1) = 0.5E0 * ( S(J,K,I-1,1,1)*S(J,K,I-1,4,1)
     1                          + S(J+1,K,I-1,1,1)*S(J+1,K,I-1,4,1) )
               STEMP(J,K,2) = 0.5E0 * ( S(J,K,I-1,2,1)*S(J,K,I-1,4,1)
     1                          + S(J+1,K,I-1,2,1)*S(J+1,K,I-1,4,1) )
               STEMP(J,K,3) = 0.5E0 * ( S(J,K,I-1,3,1)*S(J,K,I-1,4,1)
     1                          + S(J+1,K,I-1,3,1)*S(J+1,K,I-1,4,1) )
  510       CONTINUE
  520    CONTINUE
C
C     Add the derivative data from the I- term
C
         DO 550 L = 1, NQ
            DO 540 K = 2, KDIM
               DO 530 J = 1, JDIM
                  QMI = 0.25E0 * ( Q(J,K,I,L) + Q(J+1,K,I-1,L)
     1                           + Q(J+1,K,I,L) + Q(J,K,I-1,L) )
C
                  DQDX(J,K,L) = DQDX(J,K,L)
     1                        - VOLAUX(J,K) * ( QMI*STEMP(J,K,1) )
                  DQDY(J,K,L) = DQDY(J,K,L)
     1                        - VOLAUX(J,K) * ( QMI*STEMP(J,K,2) )
                  DQDZ(J,K,L) = DQDZ(J,K,L)
     1                        - VOLAUX(J,K) * ( QMI*STEMP(J,K,3) )
  530          CONTINUE
  540       CONTINUE
  550    CONTINUE
      ENDIF
C
C     Calculate Q at cell interfaces as averages of cell centers
C
      DO 630 L = 1, NQ
         DO 620 K = 2, KDIM
            DO 610 J = 1, JDIM
               QI(J,K,L) = 0.5E0 * ( Q(J,K,I,L)  + Q(J+1,K,I,L) )
  610       CONTINUE
  620    CONTINUE
  630 CONTINUE
C
C     Calculate PROPSI at cell interfaces as averages of cell centers
C
      DO 660 L = 1, NP
         DO 650 K = 2, KDIM
            DO 640 J = 1, JDIM
               PROPSI(J,K,L)  = 0.5E0*(PROPS(J,K,I,L)+PROPS(J+1,K,I,L))
  640       CONTINUE
  650    CONTINUE
  660 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 750 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IDIR   = IBCDAT(2,IBC)
         IF ( (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN)
     1        .AND. IDIR .EQ. 2) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
            IF (INROUT .EQ. 1) THEN
               JBCPT = 1
               JNTR  = 1
            ELSE
               JBCPT = JDIM + 1
               JNTR  = JDIM
            ENDIF
            IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
               DO 720 L = 1, NQ
                  DO 710 K = KSTRT, KEND
                     QI(JNTR,K,L) = Q(JBCPT,K,I,L)
  710             CONTINUE
  720          CONTINUE
C
C     Also do properties
C
               DO 740 L = 1, NP
                  DO 730 K = KSTRT, KEND
                     PROPSI(JNTR,K,L) = PROPS(JBCPT,K,I,L)
  730             CONTINUE
  740          CONTINUE
            ENDIF
         ENDIF
  750 CONTINUE
C
C     Finished calculating derivatives in the J direction
      RETURN
      END
      SUBROUTINE DELQK (IDIM, JDIM, KDIM, I,
     1                  Q, PROPS, S, VOL, IBCDAT, NBCS,
     2                  STEMP, VOLAUX, QI, PROPSI,
     3                  DQDX, DQDY, DQDZ)
C
C     Routine to calculate derivatives of the primitive variables at
C     cell interfaces and to calculate interface averages of primitive
C     variables in the K direction.
C     Thin Layer:         Calculate DQDX,DQDY,DQDZ as metric times DQDZETA
C     Full Navier-Stokes: Use divergence theorem to calculate derivatives
C
C     This routine is not presently suited for the multiblock
C     approach.  It is close to being ready but is not.  The problem
C     lies that the metrics for one cell into the adjacent block
C     are needed to be completely general.  These are currently not available.
C     The routine metbc needs to be completed.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Current I Plane
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = RMU
C                      PROPS(2) = RMUT
C                      PROPS(3) = Y+
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     STEMP          : Temporary storage for metrics
C     QI             : Primitive variables at cell interfaces
C     PROPSI         : Properties at cell interfaces
C     DQDX,DQDY...   : Derivatives of primitive variables at interfaces.
C                      This routine calculates either thin-layer or full NS
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION STEMP (KDIM+1,JDIM,3),
     1          VOLAUX(KDIM,2:JDIM)
C
      DIMENSION QI    (KDIM,2:JDIM,NQ),
     1          PROPSI(KDIM,2:JDIM,NP)
C
      DIMENSION DQDX  (KDIM,2:JDIM,NQ),
     1          DQDY  (KDIM,2:JDIM,NQ),
     2          DQDZ  (KDIM,2:JDIM,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Loop over J forming derivative terms along the K direction
C     on the K = 1, KDIM faces.
C     The storage of SK reduces the overhead of recalculating the average
C     metric terms required for the derivative calculation.
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
      DO 120 J = 2, JDIM
         DO 110 K = 1, KDIM
            VOLAUX(K,J) = 2.0E0 / ( VOL(J,K,I) + VOL(J,K+1,I) )
  110    CONTINUE
  120 CONTINUE
C
C     For WALL FUNCTIONS ONLY: Modify the auxilliary cell volume at the
C     wall function cell interface to reflect the wall function grid.
C
      IF ( IFWALF ) THEN
C
C     Loop over boundary conditions and fix the wall function volume
C
         DO 125 IBC = 1, NBCS
            IBCTYP = IBCDAT(1,IBC)
            IDIR   = IBCDAT(2,IBC)
            IF (IBCTYP .EQ. IWALFN .AND. IDIR .EQ. 3) THEN
               INROUT = IBCDAT(3,IBC)
               ISTRT  = IBCDAT(4,IBC)
               IEND   = IBCDAT(5,IBC)
               JSTRT  = IBCDAT(6,IBC)
               JEND   = IBCDAT(7,IBC)
               IF (INROUT .EQ. 1) THEN
                  KINT   = 2
                  KBCN2  = 3
               ELSE
                  KINT   = KDIM - 1
                  KBCN2  = KDIM - 2
               ENDIF
               IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                  DO 122 J = JSTRT, JEND
                     VOLAUX(KINT,J) = 1.0E0 / VOL(J,KBCN2,I)
  122             CONTINUE
               ENDIF
            ENDIF
  125    CONTINUE
C
      ENDIF
C
C     Thin Layer Derivatives
C
      IF ( THNLYR ) THEN
         DO 150 L = 1, NQ
            DO 140 J = 2, JDIM
               DO 130 K = 1, KDIM
                  DZETA       = (Q(J,K+1,I,L) - Q(J,K,I,L))
     1                          * VOLAUX(K,J) * S(J,K,I,4,3)
                  DQDX(K,J,L) = S(J,K,I,1,3) * DZETA
                  DQDY(K,J,L) = S(J,K,I,2,3) * DZETA
                  DQDZ(K,J,L) = S(J,K,I,3,3) * DZETA
  130          CONTINUE
  140       CONTINUE
  150    CONTINUE
      ELSE
C
C     Full Navier-Stokes terms
C     Calculate first derivative terms using Divergence Theorem
C     Use symmetric differencing of the cross-derivative terms
C     from Chakravarthy et al AIAA 85-0165.
C
C     Average metrics in K direction
C
         DO 220 J = 2, JDIM
            DO 210 K = 1, KDIM+1
               STEMP(K,J,1) = 0.5E0 * ( S(J,K-1,I,1,3)*S(J,K-1,I,4,3)
     1                                + S(J,K,I,1,3)*S(J,K,I,4,3) )
               STEMP(K,J,2) = 0.5E0 * ( S(J,K-1,I,2,3)*S(J,K-1,I,4,3)
     1                                + S(J,K,I,2,3)*S(J,K,I,4,3) )
               STEMP(K,J,3) = 0.5E0 * ( S(J,K-1,I,3,3)*S(J,K-1,I,4,3)
     1                                + S(J,K,I,3,3)*S(J,K,I,4,3) )
  210       CONTINUE
  220    CONTINUE
C
C     Calculate first derivative terms using Divergence Theorem
C
         DO 250 L = 1, NQ
            DO 240 J = 2, JDIM
               DO 230 K = 1, KDIM
                  DQDX(K,J,L) = VOLAUX(K,J)*(Q(J,K+1,I,L)*STEMP(K+1,J,1)
     1                                      -Q(J,K,I,L)*STEMP(K,J,1) )
                  DQDY(K,J,L) = VOLAUX(K,J)*(Q(J,K+1,I,L)*STEMP(K+1,J,2)
     1                                      -Q(J,K,I,L)*STEMP(K,J,2) )
                  DQDZ(K,J,L) = VOLAUX(K,J)*(Q(J,K+1,I,L)*STEMP(K+1,J,3)
     1                                      -Q(J,K,I,L)*STEMP(K,J,3) )
  230          CONTINUE
  240       CONTINUE
  250    CONTINUE
C
C     Average metric terms in J direction
C
         DO 320 J = 1, JDIM
            DO 310 K = 1, KDIM
               STEMP(K,J,1) = 0.5E0 * ( S(J,K,I,1,2)*S(J,K,I,4,2)
     1                                + S(J,K+1,I,1,2)*S(J,K+1,I,4,2) )
               STEMP(K,J,2) = 0.5E0 * ( S(J,K,I,2,2)*S(J,K,I,4,2)
     1                                + S(J,K+1,I,2,2)*S(J,K+1,I,4,2) )
               STEMP(K,J,3) = 0.5E0 * ( S(J,K,I,3,2)*S(J,K,I,4,2)
     1                                + S(J,K+1,I,3,2)*S(J,K+1,I,4,2) )
  310       CONTINUE
  320    CONTINUE
C
C     Add the derivative data from the J direction
C
         DO 350 L = 1, NQ
            DO 340 J = 2, JDIM
               DO 330 K = 1, KDIM
                  QPJ = 0.25E0 * ( Q(J,K,I,L) + Q(J+1,K+1,I,L)
     1                           + Q(J+1,K,I,L) + Q(J,K+1,I,L) )
                  QMJ = 0.25E0 * ( Q(J,K,I,L) + Q(J-1,K+1,I,L)
     1                           + Q(J-1,K,I,L) + Q(J,K+1,I,L) )
C
                  DQDX(K,J,L) = DQDX(K,J,L)
     1                        + VOLAUX(K,J) * ( QPJ*STEMP(K,J,1)
     2                                        - QMJ*STEMP(K,J-1,1) )
                  DQDY(K,J,L) = DQDY(K,J,L)
     1                        + VOLAUX(K,J) * ( QPJ*STEMP(K,J,2)
     2                                        - QMJ*STEMP(K,J-1,2) )
                  DQDZ(K,J,L) = DQDZ(K,J,L)
     1                        + VOLAUX(K,J) * ( QPJ*STEMP(K,J,3)
     2                                        - QMJ*STEMP(K,J-1,3) )
  330          CONTINUE
  340       CONTINUE
  350    CONTINUE
C
C     Add the contribution from the I+ term
C
C     Average metric terms in I+ direction
C
         DO 420 J = 2, JDIM
            DO 410 K = 1, KDIM
               STEMP(K,J,1) = 0.5E0 * ( S(J,K,I,1,1)*S(J,K,I,4,1)
     1                                + S(J,K+1,I,1,1)*S(J,K+1,I,4,1) )
               STEMP(K,J,2) = 0.5E0 * ( S(J,K,I,2,1)*S(J,K,I,4,1)
     1                                + S(J,K+1,I,2,1)*S(J,K+1,I,4,1) )
               STEMP(K,J,3) = 0.5E0 * ( S(J,K,I,3,1)*S(J,K,I,4,1)
     1                                + S(J,K+1,I,3,1)*S(J,K+1,I,4,1) )
  410       CONTINUE
  420    CONTINUE
C
C     Add the derivative data from the I+ term
C
         DO 450 L = 1, NQ
            DO 440 J = 2, JDIM
               DO 430 K = 1, KDIM
                  QPI = 0.25E0 * ( Q(J,K,I,L) + Q(J,K+1,I+1,L)
     1                           + Q(J,K+1,I,L) + Q(J,K,I+1,L) )
C
                  DQDX(K,J,L) = DQDX(K,J,L)
     1                        + VOLAUX(K,J) * ( QPI*STEMP(K,J,1) )
                  DQDY(K,J,L) = DQDY(K,J,L)
     1                        + VOLAUX(K,J) * ( QPI*STEMP(K,J,2) )
                  DQDZ(K,J,L) = DQDZ(K,J,L)
     1                        + VOLAUX(K,J) * ( QPI*STEMP(K,J,3) )
  430          CONTINUE
  440       CONTINUE
  450    CONTINUE
C
C     Add the contribution from the I- term
C
C     Average metric terms in I- direction
C
         DO 520 J = 2, JDIM
            DO 510 K = 1, KDIM
               STEMP(K,J,1) = 0.5E0*( S(J,K,I-1,1,1)*S(J,K,I-1,4,1)
     1                              + S(J,K+1,I-1,1,1)*S(J,K+1,I-1,4,1))
               STEMP(K,J,2) = 0.5E0*( S(J,K,I-1,2,1)*S(J,K,I-1,4,1)
     1                              + S(J,K+1,I-1,2,1)*S(J,K+1,I-1,4,1))
               STEMP(K,J,3) = 0.5E0*( S(J,K,I-1,3,1)*S(J,K,I-1,4,1)
     1                              + S(J,K+1,I-1,3,1)*S(J,K+1,I-1,4,1))
  510       CONTINUE
  520    CONTINUE
C
C     Add the derivative data from the I- term
C
         DO 550 L = 1, NQ
            DO 540 J = 2, JDIM
               DO 530 K = 1, KDIM
                  QMI = 0.25E0 * ( Q(J,K,I,L) + Q(J,K+1,I-1,L)
     1                           + Q(J,K+1,I,L) + Q(J,K,I-1,L) )
C
                  DQDX(K,J,L) = DQDX(K,J,L)
     1                        - VOLAUX(K,J) * ( QMI*STEMP(K,J,1) )
                  DQDY(K,J,L) = DQDY(K,J,L)
     1                        - VOLAUX(K,J) * ( QMI*STEMP(K,J,2) )
                  DQDZ(K,J,L) = DQDZ(K,J,L)
     1                        - VOLAUX(K,J) * ( QMI*STEMP(K,J,3) )
  530          CONTINUE
  540       CONTINUE
  550    CONTINUE
      ENDIF
C
C     Calculate Q at cell interfaces as averages of cell centers
C
      DO 630 L = 1, NQ
         DO 620 J = 2, JDIM
            DO 610 K = 1, KDIM
               QI(K,J,L) = 0.5E0 * ( Q(J,K,I,L)  + Q(J,K+1,I,L) )
  610       CONTINUE
  620    CONTINUE
  630 CONTINUE
C
C     Calculate PROPSI at cell interfaces as averages of cell centers
C
      DO 660 L = 1, NP
         DO 650 J = 2, JDIM
            DO 640 K = 1, KDIM
               PROPSI(K,J,L) = 0.5E0*(PROPS(J,K,I,L)+PROPS(J,K+1,I,L))
  640       CONTINUE
  650    CONTINUE
  660 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 750 IBC = 1, NBCS
         IBCTYP = IBCDAT(1,IBC)
         IDIR   = IBCDAT(2,IBC)
         IF ( (IBCTYP .EQ. IWALL .OR. IBCTYP .EQ. IWALFN)
     1        .AND. IDIR .EQ. 3) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            IF (INROUT .EQ. 1) THEN
               KBCPT = 1
               KNTR  = 1
            ELSE
               KBCPT = KDIM + 1
               KNTR  = KDIM
            ENDIF
            IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
               DO 720 L = 1, NQ
                  DO 710 J = JSTRT, JEND
                     QI(KNTR,J,L) = Q(J,KBCPT,I,L)
  710             CONTINUE
  720          CONTINUE
C
C     Also do properties
C
               DO 740 L = 1, NP
                  DO 730 J = JSTRT, JEND
                     PROPSI(KNTR,J,L) = PROPS(J,KBCPT,I,L)
  730             CONTINUE
  740          CONTINUE
            ENDIF
         ENDIF
  750 CONTINUE
C
C     Finished calculating derivatives for K interfaces
      RETURN
      END
      SUBROUTINE FVIS (IMODEL, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ,
     1                 S, TAU, F)
C
C     Routine to calculate the Navier-Stokes viscous fluxes.  This routine
C     is for laminar flow or mean equations in Favre averaged form coupled
C     with a turbulence model.  Currently, algebraic, two-equation and
C     Reynold's stress models are supported by this routine.
C
C     The flow variables, properties and derivatives of the flow
C     variables are provided to this routine from which it calculates
C     the viscous fluxes.
C
C     This routine is organized as follows:
C          1. Calculate the Reynolds Stresses at the Interfaces
C             (this uses a model or the actual Reynolds stresses)
C          2. Calculate the Viscous Fluxes for the Mean Equations
C          3. Calculate Additional Viscous Fluxes
C             a. Laminar, algebraic model => No additional fluxes
C             b. Two-Equation model       => Fluxes for K and T2 equations
C             c. Reynolds Stress model    => Fluxes for Tau_ij and T2 eqns,
C                                            Molecular and Turbulent diffusion
C
C     IMODEL         : Turbulence model array
C     NPTS           : Number of interfaces to calculate viscous fluxes
C     QI             : Primitive variables at interfaces
C     PROPSI         : Properties at the interfaces
C                      PROPSI(1) = RMU
C                      PROPSI(2) = RMUT
C                      PROPSI(3) = Y+
C     DQDX           : X-Derivative of primitive variables at the interface
C     DQDY           : Y-Derivative of primitive variables at the interface
C     DQDZ           : Z-Derivative of primitive variables at the interface
C     S              : Metrics
C     TAU            : Reynold's stresses
C     F              : Viscous fluxes at cell interfaces
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION QI    (NPTS,NQ),
     1          PROPSI(NPTS,NP),
     2          DQDX  (NPTS,NQ),
     3          DQDY  (NPTS,NQ),
     4          DQDZ  (NPTS,NQ),
     5          S     (NPTS,3),
     6          TAU   (NPTS,6),
     7          F     (NPTS,NF)
C
C     Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
      ITURB = IMODEL(1)
C
C     1. Calculate the Reynold's Stresses at the Interfaces.
C                                      ~
C     The array TAU contains {- rho (u" u")}.
C                                     i  j
C     For laminar flow:            TAU_ij => zero.
C         algebraic models:        TAU_ij => modeled with Boussinesq approx.
C         two-equation models:     TAU_ij => modeled with Boussinesq approx.
C         Reynold's stress models: TAU_ij => computed from PDE.
C     Pass in PROPS and DUDX,DUDY,DUDZ for Boussinesq approximation.
C     Pass in QI for average interface data.  Pass in derivative data DQDX,...
C     The Reynold's stresses are stored as:
C         TAU(1) = TAUXX, TAU(2) = TAUYY, TAU(3) = TAUZZ,
C         TAU(4) = TAUXY, TAU(5) = TAUXZ, TAU(6) = TAUYZ
C
      CALL TAUIJ (IMODEL, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ, TAU)
C
C     2. Calculate the Viscous Fluxes for the Mean Flow Equations
C
      DO 100 I = 1, NPTS
C
         RHO   = QI(I,1)
         U     = QI(I,2)
         V     = QI(I,3)
         W     = QI(I,4)
         P     = QI(I,5)
C
         T     = GAMMA * P / RHO
C
         RMU   = PROPSI(I,1)
         RMUT  = PROPSI(I,2)
C
C     Calculate Strain Rates and Shear Stress Terms
C     Use molecular viscosity (RMU) averaged from cell centers to
C     get the viscosity at the cell interface.
C     T23 is two-thirds.
C
         SXX   = T23 * ( 2.E0*DQDX(I,2) - DQDY(I,3) - DQDZ(I,4) )
         SYY   = T23 * ( 2.E0*DQDY(I,3) - DQDX(I,2) - DQDZ(I,4) )
         SZZ   = T23 * ( 2.E0*DQDZ(I,4) - DQDX(I,2) - DQDY(I,3) )
         SXY   = ( DQDY(I,2) + DQDX(I,3) )
         SXZ   = ( DQDX(I,4) + DQDZ(I,2) )
         SYZ   = ( DQDY(I,4) + DQDZ(I,3) )
C
         VISC  = RMU * FSMACH / RE
         SIGXX = VISC * SXX + TAU(I,1)
         SIGYY = VISC * SYY + TAU(I,2)
         SIGZZ = VISC * SZZ + TAU(I,3)
         SIGXY = VISC * SXY + TAU(I,4)
         SIGXZ = VISC * SXZ + TAU(I,5)
         SIGYZ = VISC * SYZ + TAU(I,6)
C
C     Calculate Heat Flux Terms.
C     Turbulent heat flux uses the gradient transport assumption here.
C     DTDx_i can be calculated from derivatives of primitive variables as
C          DTDx_i = T [DPDx_i / P - DrhoDx_i / rho]
C
         DTDX  = T * (DQDX(I,5) / P - DQDX(I,1) / RHO)
         DTDY  = T * (DQDY(I,5) / P - DQDY(I,1) / RHO)
         DTDZ  = T * (DQDZ(I,5) / P - DQDZ(I,1) / RHO)
C
         CNDCT =   (RMU/PR + RMUT/PRT) * FSMACH / (RE * GAMM1)
         QDOTX = - CNDCT * DTDX
         QDOTY = - CNDCT * DTDY
         QDOTZ = - CNDCT * DTDZ
C
C--->    CSTAR = SIGRHO * RMUT / (RHO * RHO) * FSMACH / RE
C turn this term off as it is inconsistent to have it here and not in the
C tke or tau_ij equations.  this causes problems for the code - so zero it out.
         CSTAR = 0.e0
C
C     Calculate F(viscous)
C
         F(I,1)  = 0.E0
         F(I,2)  = S(I,1) * SIGXX + S(I,2) * SIGXY + S(I,3) * SIGXZ
         F(I,3)  = S(I,1) * SIGXY + S(I,2) * SIGYY + S(I,3) * SIGYZ
         F(I,4)  = S(I,1) * SIGXZ + S(I,2) * SIGYZ + S(I,3) * SIGZZ
         F(I,5)  = S(I,1) * ( U*SIGXX + V*SIGXY + W*SIGXZ - QDOTX
     1              +CSTAR*(SXX*DQDX(I,1)+SXY*DQDY(I,1)+SXZ*DQDZ(I,1)) )
     2           + S(I,2) * ( U*SIGXY + V*SIGYY + W*SIGYZ - QDOTY
     3              +CSTAR*(SXY*DQDX(I,1)+SYY*DQDY(I,1)+SYZ*DQDZ(I,1)) )
     4           + S(I,3) * ( U*SIGXZ + V*SIGYZ + W*SIGZZ - QDOTZ
     5              +CSTAR*(SXZ*DQDX(I,1)+SYZ*DQDY(I,1)+SZZ*DQDZ(I,1)) )
  100 CONTINUE
C
C     3. Calculate Additional Viscous Fluxes
C
C     3-b. Calculate the viscous fluxes for two-equation turbulence models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 200 I = 1, NPTS
C
            RHO   = QI(I,1)
            P     = QI(I,5)
C
            T     = GAMMA * P / RHO
C
            RMU   = PROPSI(I,1)
            RMUT  = PROPSI(I,2)
C
C     DTDx_i can be calculated from derivatives of primitive variables as
C          DTDx_i = T [DPDx_i / P - DrhoDx_i / rho]
C
            DTDX  = T * (DQDX(I,5) / P - DQDX(I,1) / RHO)
            DTDY  = T * (DQDY(I,5) / P - DQDY(I,1) / RHO)
            DTDZ  = T * (DQDZ(I,5) / P - DQDZ(I,1) / RHO)
C
C     Calculate Pressure Diffusion Correlation terms
C
            VISCPD = RMUT * P / RHO * FSMACH / RE
C           VISCPD = (RMU + RMUT) * P / RHO * FSMACH / RE
            PDIFX  = VISCPD * (CPDFRO*DQDX(I,1)/RHO + CPDFT*DTDX/T)
            PDIFY  = VISCPD * (CPDFRO*DQDY(I,1)/RHO + CPDFT*DTDY/T)
            PDIFZ  = VISCPD * (CPDFRO*DQDZ(I,1)/RHO + CPDFT*DTDZ/T)
C
C     Coefficients for DKDX and DT2DX diffusion terms
C
            VISCK  = (RMU + SIGK  * RMUT) * FSMACH / RE
            VISCT2 = (RMU + SIGT2 * RMUT) * FSMACH / RE
            F(I,5) = F(I,5) + S(I,1) * ( VISCK*DQDX(I,6) )
     1                      + S(I,2) * ( VISCK*DQDY(I,6) )
     2                      + S(I,3) * ( VISCK*DQDZ(I,6) )
            F(I,6) = S(I,1) * ( VISCK*DQDX(I,6) + PDIFX )
     1             + S(I,2) * ( VISCK*DQDY(I,6) + PDIFY )
     2             + S(I,3) * ( VISCK*DQDZ(I,6) + PDIFZ )
            F(I,7) = S(I,1) * ( VISCT2*DQDX(I,7) )
     1             + S(I,2) * ( VISCT2*DQDY(I,7) )
     2             + S(I,3) * ( VISCT2*DQDZ(I,7) )
  200    CONTINUE
C
C     3-c. Calculate viscous fluxes for Reynolds stress models
C          i.   Zero out the fluxes F(6-12)
C          ii.  Call routines to calculate
C               1. Molecular diffusion
C               2. Diffusion model for Epsilon_ij_wall from So et al. 1995
C               3. Turbulent diffusion (triple correlation)
C          iii. Calculate additional fluxes including the contraction (trace)
C               of the molecular and turbulent diffusions for Reynolds
C               stresses in the energy equation
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         IPSMDL = IMODEL(6)
         IEPSIJ = IMODEL(7)
         IDMMDL = IMODEL(8)
         IDTMDL = IMODEL(9)
C
C     3-c.i   Zero fluxes F(6-12)
C
         DO 300 I = 1, NPTS
            F(I, 6) = 0.E0
            F(I, 7) = 0.E0
            F(I, 8) = 0.E0
            F(I, 9) = 0.E0
            F(I,10) = 0.E0
            F(I,11) = 0.E0
            F(I,12) = 0.E0
  300    CONTINUE
C
C     3-c.ii.1  Add contribution due to Molecular diffusion model
C
         CALL RSMDIF (IDMMDL, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ, S,
     1                TAU, F)
C
C     3-c.ii.2  Add contribution for Epsilon_ij_wall for So et al. 1995 model
C
         IF (IEPSIJ .EQ. IESO95) THEN
            CALL RSDFEW (IEPSIJ, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ, S,
     1                   TAU, F)
         ENDIF
C
C     3-c.ii.3  Add contribution due to Turbulent diffusion model
C
         CALL RSTDIF (IDTMDL, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ, S,
     1                TAU, F)
C
C     3-c.iii Add additional fluxes include contraction of diffusion
C             fluxes to Energy equation
C
         DO 350 I = 1, NPTS
            RHO    = QI(I,1)
            P      = QI(I,5)
C
            T      = GAMMA * P / RHO
C
            TKE    = 0.5E0 * (QI(I,6) + QI(I,7) + QI(I,8))
            EPSLN  = QI(I,12)
C
            RMU    = PROPSI(I,1)
            RMUT   = PROPSI(I,2)
C
C     DTDx_i can be calculated from derivatives of primitive variables as
C          DTDx_i = T [DPDx_i / P - DrhoDx_i / rho]
C
            DTDX  = T * (DQDX(I,5) / P - DQDX(I,1) / RHO)
            DTDY  = T * (DQDY(I,5) / P - DQDY(I,1) / RHO)
            DTDZ  = T * (DQDZ(I,5) / P - DQDZ(I,1) / RHO)
C
C     Calculate Pressure Diffusion Correlation terms
C
            VISCPD = RMUT * P / RHO * FSMACH / RE
C           VISCPD = (RMU + RMUT) * P / RHO * FSMACH / RE
            PDIFX  = VISCPD * (CPDFRO*DQDX(I,1)/RHO + CPDFT*DTDX/T)
            PDIFY  = VISCPD * (CPDFRO*DQDY(I,1)/RHO + CPDFT*DTDY/T)
            PDIFZ  = VISCPD * (CPDFRO*DQDZ(I,1)/RHO + CPDFT*DTDZ/T)
C
C     Coefficients for diffusion terms in epsilon equation
C
            VISCT2 = RMU * FSMACH / RE
            CRKE   = CEPSLN * RHO * TKE / EPSLN
C
C     Calculate F(viscous)
C
           TRACE   = 0.5E0 * (F(I, 6) + F(I, 7) + F(I, 8))
           F(I, 5) = F(I, 5) + TRACE
           F(I, 6) = F(I, 6) + S(I,1)*PDIFX+S(I,2)*PDIFY+S(I,3)*PDIFZ
           F(I, 7) = F(I, 7) + S(I,1)*PDIFX+S(I,2)*PDIFY+S(I,3)*PDIFZ
           F(I, 8) = F(I, 8) + S(I,1)*PDIFX+S(I,2)*PDIFY+S(I,3)*PDIFZ
           F(I, 9) = F(I, 9) + S(I,1)*PDIFX+S(I,2)*PDIFY+S(I,3)*PDIFZ
           F(I,10) = F(I,10) + S(I,1)*PDIFX+S(I,2)*PDIFY+S(I,3)*PDIFZ
           F(I,11) = F(I,11) + S(I,1)*PDIFX+S(I,2)*PDIFY+S(I,3)*PDIFZ
           F(I,12) = F(I,12)
     1             + S(I,1)*( VISCT2*DQDX(I,12)+
     2                        CRKE  *(QI(I, 6)*DQDX(I,12)+
     3                                QI(I, 9)*DQDY(I,12)+
     4                                QI(I,10)*DQDZ(I,12)) )
     5             + S(I,2)*( VISCT2*DQDY(I,12)+
     6                        CRKE  *(QI(I, 9)*DQDX(I,12)+
     7                                QI(I, 7)*DQDY(I,12)+
     8                                QI(I,11)*DQDZ(I,12)) )
     9             + S(I,3)*( VISCT2*DQDZ(I,12)+
     A                        CRKE  *(QI(I,10)*DQDX(I,12)+
     B                                QI(I,11)*DQDY(I,12)+
     C                                QI(I, 8)*DQDZ(I,12)) )
  350    CONTINUE
      ENDIF
C
C     Finished with Viscous Terms
      RETURN
      END
      SUBROUTINE TAUIJ (IMODEL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU)
C
C     Routine to calculate the Reynold's stress terms.
C                       ~
C     TAU   = {- rho (u"  u" )} => be careful of the density term.
C        ij            i   j
C     For laminar flow:            TAU_ij => zero.
C         algebraic models:        TAU_ij => modeled with Boussinesq approx.
C         two-equation models:     TAU_ij => modeled with Boussinesq approx.
C         Reynold's stress models: TAU_ij => computed from PDE.
C     Pass in PROPS and DQDX,DQDY,DQDZ for Boussinesq approximation.
C     Pass in Q for primtive variable data at the same location as
C     DQDX and PROPS.
C         DQDn(2) = DuDn; DQDn(3) = DvDn; DQDn(4) = DwDn, where n = (X,Y,Z).
C     The Reynold's stresses are stored as:
C         TAU(1) = TAUXX, TAU(2) = TAUYY, TAU(3) = TAUZZ,
C         TAU(4) = TAUXY, TAU(5) = TAUXZ, TAU(6) = TAUYZ
C
C     This routine is structured as follows:
C          1. Laminar Flow          => Tau_ij = 0
C          2. Algebraic Model       => Boussinesq assumption
C          3. Two-Equation Model
C             a. Boussinesq assumption
C             b. Algebraic Stress model
C          4. Reynolds Stress Model => Solved directly
C          5. Large-Eddy Simulation => Boussinesq assumption
C
C     IMODEL         : Turbulence model array
C     NPTS           : Number of points
C     Q              : Primitive variables
C     PROPS          : Properties at same location as Q and DQ
C                      PROPS(1) = RMU
C                      PROPS(2) = RMUT
C                      PROPS(3) = Y+
C     DQDX           : X-Derivative of primitive variables
C     DQDY           : Y-Derivative of primitive variables
C     DQDZ           : Z-Derivative of primitive variables
C     TAU            : Reynold's stresses
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q    (NPTS,NQ),
     1          PROPS(NPTS,NP),
     2          DQDX (NPTS,NQ),
     3          DQDY (NPTS,NQ),
     4          DQDZ (NPTS,NQ),
     5          TAU  (NPTS,6)
C
C     One-Third
C     Two-Thirds
C
      T13 = 1.E0 / 3.E0
      T23 = 2.E0 / 3.E0
C
      ITURB = IMODEL( 1)
      IASM  = IMODEL(10)
C
C     Loop over the points calculating Reynold's stresses
C
C     1. Laminar Flow.
C        TAU = 0.
C
      IF (ITURB .EQ. ITLMNR) THEN
         DO 100 I = 1, NPTS
            TAU(I,1) = 0.E0
            TAU(I,2) = 0.E0
            TAU(I,3) = 0.E0
            TAU(I,4) = 0.E0
            TAU(I,5) = 0.E0
            TAU(I,6) = 0.E0
  100    CONTINUE
C
C     2. Algebraic Turbulence Model.
C        Boussinesq assumption (no rho*k term).
C
      ELSE IF (ITURB .EQ. ITBLMX) THEN
         DO 200 I = 1, NPTS
C
            RMUT     = PROPS(I,2)
C
            SXX      = T23 * ( 2.E0*DQDX(I,2) - DQDY(I,3) - DQDZ(I,4) )
            SYY      = T23 * ( 2.E0*DQDY(I,3) - DQDX(I,2) - DQDZ(I,4) )
            SZZ      = T23 * ( 2.E0*DQDZ(I,4) - DQDX(I,2) - DQDY(I,3) )
            SXY      = ( DQDY(I,2) + DQDX(I,3) )
            SXZ      = ( DQDX(I,4) + DQDZ(I,2) )
            SYZ      = ( DQDY(I,4) + DQDZ(I,3) )
C
            VISC     = RMUT * FSMACH / RE
            TAU(I,1) = VISC * SXX
            TAU(I,2) = VISC * SYY
            TAU(I,3) = VISC * SZZ
            TAU(I,4) = VISC * SXY
            TAU(I,5) = VISC * SXZ
            TAU(I,6) = VISC * SYZ
  200    CONTINUE
C
C     3. Two-Equation Turbulence Model.
C
C     3-a. Boussinesq assumption.
C     3-b. Gatski's algebraic Reynolds stress model
C
      ELSE IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 300 I = 1, NPTS
C
            RHOK     = Q(I,1) * Q(I,6)
            RMUT     = PROPS(I,2)
C
            SXX      = T23 * ( 2.E0*DQDX(I,2) - DQDY(I,3) - DQDZ(I,4) )
            SYY      = T23 * ( 2.E0*DQDY(I,3) - DQDX(I,2) - DQDZ(I,4) )
            SZZ      = T23 * ( 2.E0*DQDZ(I,4) - DQDX(I,2) - DQDY(I,3) )
            SXY      = ( DQDY(I,2) + DQDX(I,3) )
            SXZ      = ( DQDX(I,4) + DQDZ(I,2) )
            SYZ      = ( DQDY(I,4) + DQDZ(I,3) )
C
            VISC     = RMUT * FSMACH / RE
            TAU(I,1) = VISC * SXX - T23 * RHOK
            TAU(I,2) = VISC * SYY - T23 * RHOK
            TAU(I,3) = VISC * SZZ - T23 * RHOK
            TAU(I,4) = VISC * SXY
            TAU(I,5) = VISC * SXZ
            TAU(I,6) = VISC * SYZ
  300    CONTINUE
C
         IF (IASM .EQ. IASMGS) THEN
            DO 320 LOOP = 1, 1
               DO 310 I = 1, NPTS
C
                  RHO      = Q(I,1)
                  TKE      = Q(I,6)
                  RHOK     = RHO * TKE
C
C     Constants from pressure-strain model
C---- Begin SSG constants -------------------------------------------------
                  CC1      = 6.80E0
                  CC2      = 0.36E0
                  CC3      = 1.25E0
                  CC4      = 0.40E0
                  CC5      = 1.88E0
C---- End SSG constants ---------------------------------------------------
C
                  IF (ITURB .EQ. ITKW) THEN
                     TIMSCL   = 1.E0 / (BSTRKW * Q(I,7) + RSMALL)
                  ELSE
                     TIMSCL   = TKE  / (Q(I,7) + RSMALL)
                  ENDIF
C
                  GSMALL   = 1.E0 / (.5E0*CC1 + CC5 - 1.E0)
C
                  RALF1    = 0.50E0 * (4.E0/3.E0-CC2) * GSMALL
                  RALF2    = 0.25E0 * (2.E0 - CC3)**2 * GSMALL * GSMALL
                  RALF3    = 0.25E0 * (2.E0 - CC4)**2 * GSMALL * GSMALL
                  RALF4    = 0.50E0 * (2.E0 - CC4)    * GSMALL
                  RALF5    =          (2.E0 - CC3)    * GSMALL
C
C     S_ij
C           - note: sxx,etc. terms appearing elsewhere in this routine are
C                  NOT S_ij but a leftover from the original viscos routines
C
                  SXX      = DQDX(I,2)
                  SYY      = DQDY(I,3)
                  SZZ      = DQDZ(I,4)
                  SXY      = 0.5E0 * (DQDY(I,2) + DQDX(I,3))
                  SXZ      = 0.5E0 * (DQDZ(I,2) + DQDX(I,4))
                  SYZ      = 0.5E0 * (DQDZ(I,3) + DQDY(I,4))
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
                  SKK      = (SXX + SYY + SZZ) / 3.E0
C
C     S_kl * S_lk / 3
C
                  SKLSLK   = ( SXX*SXX + SYY*SYY + SZZ*SZZ
     1                 + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ) )/3.E0
C
C     W_ij : for a non-rotating frame
C
                  WYX      = 0.5E0 * (DQDX(I,3) - DQDY(I,2))
                  WZX      = 0.5E0 * (DQDX(I,4) - DQDZ(I,2))
                  WZY      = 0.5E0 * (DQDY(I,4) - DQDZ(I,3))
                  WXY      = 0.5E0 * (DQDY(I,2) - DQDX(I,3))
                  WXZ      = 0.5E0 * (DQDZ(I,2) - DQDX(I,4))
                  WYZ      = 0.5E0 * (DQDZ(I,3) - DQDY(I,4))
C
                  ETASQ    = RALF2 * TIMSCL * TIMSCL *
     1                           ( SXX*SXX + SYY*SYY + SZZ*SZZ
     2                     + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ) )
                  ZETSQ    = RALF3 * TIMSCL * TIMSCL *
     1                       2.E0*(WXY*WXY + WXZ*WXZ + WYZ*WYZ)
C
                  ETA6     = ETASQ * ETASQ * ETASQ
                  ZET6     = ZETSQ * ZETSQ * ZETSQ
C
                  CMUS     = RALF1 * ( 3.E0 * (1.E0 + ETASQ)
     1                               + 0.2E0 * (ETA6 + ZET6) ) /
     2                  ( 3.E0 + ETASQ + 6.E0*ETASQ*ZETSQ + 6.E0*ZETSQ
     3                  + ETA6 + ZET6 )
                  CMUSS    = RALF1 * ( 3.E0 * (1.E0 + ETASQ) ) /
     1                  ( 3.E0 + ETASQ + 6.E0*ETASQ*ZETSQ + 6.E0*ZETSQ
     2                  + ETA6 + ZET6 )
C
                  RMUTS    = RHO * CMUS  * TKE * TIMSCL
                  RMUTSS   = RHO * CMUSS * TKE * TIMSCL
C
C Store C_mu^* (CMUS) to pass into calculation of Mu_T
C
                  PROPS(I,ICMUST) = CMUS
C
                  TAU(I,1) = - T23 * RHOK + 2.E0 * RMUTS * (SXX-SKK)
     1                       + 2.E0 * RMUTSS * TIMSCL *
     2                   ( RALF4*2.E0*(        SXY*WYX+SXZ*WZX)
     3                   - RALF5*     (SXX*SXX+SXY*SXY+SXZ*SXZ-SKLSLK) )
                  TAU(I,2) = - T23 * RHOK + 2.E0 * RMUTS * (SYY-SKK)
     1                       + 2.E0 * RMUTSS * TIMSCL *
     2                   ( RALF4*2.E0*(SXY*WXY        +SYZ*WZY)
     3                   - RALF5*     (SXY*SXY+SYY*SYY+SYZ*SYZ-SKLSLK) )
                  TAU(I,3) = - T23 * RHOK + 2.E0 * RMUTS * (SZZ-SKK)
     1                       + 2.E0 * RMUTSS * TIMSCL *
     2                   ( RALF4*2.E0*(SXZ*WXZ+SYZ*WYZ        )
     3                   - RALF5*     (SXZ*SXZ+SYZ*SYZ+SZZ*SZZ-SKLSLK) )
                  TAU(I,4) =                2.E0 * RMUTS * (SXY)
     1                       + 2.E0 * RMUTSS * TIMSCL *
     2                   ( RALF4*     (SXX*WXY          +SXZ*WZY
     3                                          +SYY*WYX+SYZ*WZX)
     4                   - RALF5*     (SXX*SXY+SXY*SYY+SXZ*SYZ) )
                  TAU(I,5) =                2.E0 * RMUTS * (SXZ)
     1                       + 2.E0 * RMUTSS * TIMSCL *
     2                   ( RALF4*     (SXX*WXZ+SXY*WYZ
     3                                        +SYZ*WYX+SZZ*WZX)
     4                   - RALF5*     (SXX*SXZ+SXY*SYZ+SXZ*SZZ) )
                  TAU(I,6) =                2.E0 * RMUTS * (SYZ)
     1                       + 2.E0 * RMUTSS * TIMSCL *
     2                   ( RALF4*     (SXY*WXZ+SYY*WYZ
     3                                +SXZ*WXY        +SZZ*WZY)
     4                   - RALF5*     (SXY*SXZ+SYY*SYZ+SYZ*SZZ) )
C
C     Enforce positivity of normal stresses
C     N.B. TAU = - rho tau_ij
C
                  TAU(I,1) = MIN (TAU(I,1), 0.E0)
                  TAU(I,2) = MIN (TAU(I,2), 0.E0)
                  TAU(I,3) = MIN (TAU(I,3), 0.E0)
  310          CONTINUE
  320       CONTINUE
         ENDIF
C
C     4. Reynold's Stress Model.
C        Solved directly.
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 500 I = 1, NPTS
C
            RHO      = Q(I,1)
C
            TAU(I,1) = - RHO * Q(I, 6)
            TAU(I,2) = - RHO * Q(I, 7)
            TAU(I,3) = - RHO * Q(I, 8)
            TAU(I,4) = - RHO * Q(I, 9)
            TAU(I,5) = - RHO * Q(I,10)
            TAU(I,6) = - RHO * Q(I,11)
  500    CONTINUE
C
C     5. Large-Eddy Simulation
C        Boussinesq assumption (no rho*k term).
C
      ELSE IF (ITURB .EQ. ITLES) THEN
         DO 600 I = 1, NPTS
C
            RMUT     = PROPS(I,2)
C
            SXX      = T23 * ( 2.E0*DQDX(I,2) - DQDY(I,3) - DQDZ(I,4) )
            SYY      = T23 * ( 2.E0*DQDY(I,3) - DQDX(I,2) - DQDZ(I,4) )
            SZZ      = T23 * ( 2.E0*DQDZ(I,4) - DQDX(I,2) - DQDY(I,3) )
            SXY      = ( DQDY(I,2) + DQDX(I,3) )
            SXZ      = ( DQDX(I,4) + DQDZ(I,2) )
            SYZ      = ( DQDY(I,4) + DQDZ(I,3) )
C
            VISC     = RMUT * FSMACH / RE
            TAU(I,1) = VISC * SXX
            TAU(I,2) = VISC * SYY
            TAU(I,3) = VISC * SZZ
            TAU(I,4) = VISC * SXY
            TAU(I,5) = VISC * SXZ
            TAU(I,6) = VISC * SYZ
  600    CONTINUE
      ELSE
         WRITE (IOUT,1000) ITURB
         STOP
      ENDIF
C
C     Finished with Reynold's stresses
      RETURN
 1000 FORMAT (' ','Invalid turbulence model specified in TAUIJ => ',I5,
     1       /' ','Run Aborting.')
      END
      SUBROUTINE NEWTPN (NORDR, P, ROOT)
C
C     Routine to perform a Newton iteration to solve for the root of
C     a polynomial of degree N.
C
C     NORDR : Degree (order) of polynomial to solve (>= 1).
C             This is set < 0 if iterations do not converge.
C     P     : Coefficients of polynomial to solve
C             F(x) = P(0) + P(1)*x + P(2)*x^2 + P(3)*X^3 + ...
C     ROOT  : The solution for the polynomial
C             ROOT = guess of root on input
C             ROOT = calculated root upon return
C
      include 'common.inc'
C
      DIMENSION P     (0:NORDR)
C
C     Check to verify that NORDR > 0
C
      IF (NORDR .LE. 0) THEN
         WRITE (IOUT,1000) NORDR
         STOP
      ENDIF
C
C     Set maximum number of iterations and tolerance for convergence
C
      MAXIT = 50
C-->  TOLER = 1.0E-8
      TOLER = 1.0E-6
C
C     Perform MAXIT iterations of Newton iteration to calculate root
C
      DO 900 ITER = 1, MAXIT
         F  = 0.E0
         FP = 0.E0
         DO 100 I = NORDR, 1, -1
            F  = (F + P(I)) * ROOT
            FP = FLOAT(I) * P(I) + FP * ROOT
  100    CONTINUE
         F = F + P(0)
C
C     Update the root guess, prevent divide by zero
C
         IF (FP .EQ. 0.E0) THEN
            DROOT = - 0.1E0 * F
         ELSE
            DROOT = - F / FP
         ENDIF
         ROOT  = ROOT + DROOT
C
C        write (*,'(a,i5,4e15.7)') ' iter,f,fp,dr,root ',
C    1                               iter,f,fp,droot,root
C
C     Check for convergence of ROOT.
C
C-->     IF (ABS(DROOT) .LE. TOLER) GO TO 990
         IF (ABS(DROOT/ROOT) .LE. TOLER) GO TO 990
  900 CONTINUE
C
C     Newton iteration did not converge.  Set NORDR negative and return.
C
      NORDR = -1
  990 RETURN
 1000 FORMAT (' ','RUN ABORTING=> Invalid polynomial in NEWTPN ',I5)
      END
C
      SUBROUTINE RK (IBLK, IDIM, JDIM, KDIM, MXSECT,
     1               NSTAGE, ISTAGE, RKALPH,
     2               Q, QN, NQNPTS, PROPS, NPPTS, S, VOL, RC, DTJ, RES,
     3               FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP, WORKX,
     4               IBCDAT, NBCS, IORDER, LIMIT, RKAP, IFLUX, VISCOS,
     5               IMODEL, IFDELQ, W,
     6               QMIN, NFIXQ, NRELIZ, NPRLIM, NPRNEG, IERRCD)
C
C Routine for a single stage of multistage Runge-Kutta time integration
C
C IBLK           : Current block
C IDIM,JDIM,KDIM : Dimensions of current block
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning of temporary space used
C                   for calculating q(+,-) and f.
C NSTAGE         : Number of stages of multistage scheme
C ISTAGE         : Current stage of multistage scheme
C RKALPH         : Coefficient for current stage
C Q              : Primitive variables at cell centers
C QN             : Conserved variables at time levels n, n-1, etc.
C NQNPTS         : Number of QN points. This allows avoiding storing QN when
C                  running time accurate.
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RC             : Position vector at cell centers
C DTJ            : Time step divided by cell volume
C RES            : Residual
C FHAT           : Storage for fluxes for 4th order
C DQP,DQM        : Storage for delta q = q(i) - q(i-1)
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C TAU            : Storage for Reynolds stresses
C F,FM           : Fluxes at cell interfaces -
C                  if Flux Difference Splitting then F = Flux
C                  if Flux Vector Splitting then F = Fplus, FM = Fminus
C STEMP          : Storage for metrics passed to flux evaluation routine.
C WORKX          : Work array for cross-section (used for damping, etc.)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C IORDER         : Order of MUSCL interpolation
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C IFLUX          : Flux evaluation scheme
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C IMODEL         : Turbulence modeling scheme array
C IFDELQ         : Array controlling calculation of delq
C W              : Temporary storage for Q in the Runge-Kutta scheme
C QMIN           : Control array for minimum value of Q
C NFIXQ          : Number of times reset Q
C NRELIZ         : Number of times violate realizability
C NPRLIM         : Number of times reset production
C NPRNEG         : Number of times invoke positivity preservation for production
C IERRCD         : Error code
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN    (NQNPTS,NQ,NTMLVL),
     2          PROPS (NPPTS,NP),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     5          RC    (JDIM+1,KDIM+1,IDIM+1,3),
     6          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          FHAT  (JDIM+1,KDIM+1,IDIM+1,NF),
     2          DQP   (MXSECT,NQ),
     3          DQM   (MXSECT,NQ),
     4          QP    (MXSECT,NQ),
     5          QM    (MXSECT,NQ),
     6          TAU   (MXSECT,6),
     7          F     (MXSECT,NF),
     8          FM    (MXSECT,NF),
     9          STEMP (MXSECT,3),
     A          WORKX (MXSECT,NW)
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
      DIMENSION W     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IORDER(3), RKAP(3), LIMIT(3)
C
      LOGICAL   VISCOS(3)
C
      DIMENSION QMIN  (NQ)
      DIMENSION NFIXQ (NQ),
     1          NRELIZ(NQ)
C
      ITURB  = IMODEL(1)
C
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C
      IPSTRT = 2
      IPEND  = IDIM
C
C     For first stage, Set W = Q(t=n)
C
      IF (ISTAGE .EQ. 1) THEN
         DO 140 L = 1, NQ
            DO 130 I = 0, IDIM + 2
               DO 120 K = 0, KDIM + 2
                  DO 110 J = 0, JDIM + 2
                     W(J,K,I,L) = Q(J,K,I,L)
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
  140    CONTINUE
      ENDIF
C
C     Perform one stage of Runge-Kutta integration
C
C     Set Q = Q(t=n)
C
      DO 540 L = 1, NQ
         DO 530 I = 2, IDIM
            DO 520 K = 2, KDIM
               DO 510 J = 2, JDIM
                  Q(J,K,I,L)   = W(J,K,I,L)
  510          CONTINUE
  520       CONTINUE
  530    CONTINUE
  540 CONTINUE
C
C     Multiply residual by Runge-Kutta coefficient and DTJ to get Delta(Q)
C
      DO 640 L = 1, NF
         DO 630 I = 2, IDIM
            DO 620 K = 2, KDIM
               DO 610 J = 2, JDIM
                  RES(J,K,I,L) = - RKALPH * DTJ(J,K,I) * RES(J,K,I,L)
  610          CONTINUE
  620       CONTINUE
  630    CONTINUE
  640 CONTINUE
C
C     Update Conserved Variables
C
      CALL UPDATE (IDIM, JDIM, KDIM, IPSTRT, IPEND, Q, RES, ITURB,
     1             QP, QM, QMIN, NFIXQ, NRELIZ, FHAT, IERRCD)
C
C     Finished with one stage of Runge-Kutta time step
      RETURN
      END
C
      SUBROUTINE LGSFBJ (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                   RES, A, B, C, RTEMP)
C
C     Routine to do the J implicit forward/backward sweep of LU
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : The current plane
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(J-1) + B*DQ(J) + C*DQ(J+1) = RTEMP
C                      Implicit in the J direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.  The
C                      vectorization direction is K.  This is
C                      stored in the first index for a unit stride
C                      in the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C
      include 'common.inc'
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF)
C
C     Storage for the implicit system to invert
C     Store the system only in the internal portion of
C     the field and use explicit boundary conditions
C     of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:KDIM,2:JDIM,NRANK,NRANK),
     1          B     (2:KDIM,2:JDIM,NRANK,NRANK),
     2          C     (2:KDIM,2:JDIM,NRANK,NRANK),
     3          RTEMP (2:KDIM,2:JDIM,NF)
C
C     Store Residual array for inversion
C
      DO 490 L = 1, NF
         DO 480 K = 2, KDIM
            DO 470 J = 2, JDIM
               RTEMP(K,J,L) = RES(J,K,I,L)
  470       CONTINUE
  480    CONTINUE
  490 CONTINUE
C
C     Forward/Backward sweeps of the LU decomposition
C
      NPTS = JDIM - 1
      NSIM = KDIM - 1
      CALL VFBTR (NPTS, NSIM, NRANK, A, B, C, RTEMP)
C
C     Update the residual array
C
      DO 880 L = 1, NF
         DO 870 K = 2, KDIM
            DO 860 J = 2, JDIM
               RES(J,K,I,L) = RTEMP(K,J,L)
  860       CONTINUE
  870    CONTINUE
  880 CONTINUE
C
C     Finished with the J implicit forward/backward sweep of LU
      RETURN
      END
      SUBROUTINE LGSFBK (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                   RES, A, B, C, RTEMP)
C
C     Routine to do the K implicit forward/backward sweep of LU
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : The current plane
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(K-1) + B*DQ(K) + C*DQ(K+1) = RTEMP
C                      Implicit in the I direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.  The
C                      vectorization direction is J.  This is
C                      stored in the first index for a unit stride
C                      in the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C
      include 'common.inc'
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF)
C
C     Storage for the implicit system to invert
C     Store the system only in the internal portion of
C     the field and use explicit boundary conditions
C     of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:JDIM,2:KDIM,NRANK,NRANK),
     1          B     (2:JDIM,2:KDIM,NRANK,NRANK),
     2          C     (2:JDIM,2:KDIM,NRANK,NRANK),
     3          RTEMP (2:JDIM,2:KDIM,NF)
C
C     Store Residual array for inversion
C
      DO 490 L = 1, NF
         DO 480 K = 2, KDIM
            DO 470 J = 2, JDIM
               RTEMP(J,K,L) = RES(J,K,I,L)
  470       CONTINUE
  480    CONTINUE
  490 CONTINUE
C
C     Forward/Backward sweeps of the LU decomposition to invert
C
      NPTS = KDIM - 1
      NSIM = JDIM - 1
      CALL VFBTR (NPTS, NSIM, NRANK, A, B, C, RTEMP)
C
C     Update the residual array
C
      DO 880 L = 1, NF
         DO 870 K = 2, KDIM
            DO 860 J = 2, JDIM
               RES(J,K,I,L) = RTEMP(J,K,L)
  860       CONTINUE
  870    CONTINUE
  880 CONTINUE
C
C     Finished with the K implicit forward/backward sweep of the LU
      RETURN
      END
      SUBROUTINE LGSLUJ (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, QP, QM,
     2                   STEMP, IBCDAT, NBCS, ICUTS, NCUTS,
     3                   IFLUX, VISCOS, ITURB,
     4                   A, B, C, RM, APT, AMT, ART, AI, WORK)
C
C     Routine to form the LU decomposition of the J implicit sweep of
C     Line Gauss Seidel with Approximate Factorisation in
C     the I = constant plane.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : The current plane
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     STEMP          : Storage for metrics passed to Jacobian routine
C                      including the area term
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     ICUTS          : Data controlling zone communication
C     NCUTS          : Number of cuts for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence model
C     A,B,C          : LU decomposition of the tridiagonal systems to invert
C                      A*DQ(J-1) + B*DQ(J) + C*DQ(J+1) = RTEMP
C                      Implicit in the J direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.  The
C                      vectorization direction is K.  This is
C                      stored in the first index for a unit stride
C                      in the inversion.
C     RM             : The I direction contribution to the implicit scheme
C     APT,AMT,ART    : Storage on a plane (JxK) to calculate the
C                      Jacobians
C     AI             : Identity Matrix
C     WORK           : Temporary array of size NPTS*4 for Jacobian calculation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION QP    (JDIM,2:KDIM,NQ),
     1          QM    (JDIM,2:KDIM,NQ),
     2          STEMP (JDIM,2:KDIM,4),
     3          WORK  (JDIM,2:KDIM,4)
C
C     Storage for the implicit system to invert
C     Store the system only in the internal portion of
C     the field and use explicit boundary conditions
C     of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:KDIM,2:JDIM,NRANK,NRANK),
     1          B     (2:KDIM,2:JDIM,NRANK,NRANK),
     2          C     (2:KDIM,2:JDIM,NRANK,NRANK)
C
      DIMENSION RM    (2:JDIM,2:KDIM,NRANK,NRANK)
C
C     Storage for the Jacobians used to calculate A,B and C
C
      DIMENSION APT   (JDIM,2:KDIM,NRANK,NRANK),
     1          AMT   (JDIM,2:KDIM,NRANK,NRANK),
     2          ART   (JDIM,2:KDIM,NRANK,NRANK)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS),
     1          ICUTS (21,NCUTS)
C
      LOGICAL   VISCOS
C
C     Calculate QP,QM using first order
C
      DO 130 L = 1, NQ
         DO 120 K = 2, KDIM
            DO 110 J = 1, JDIM
               QP(J,K,L) = Q(J+1,K,I,L)
               QM(J,K,L) = Q(J,K,I,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C     Store the metrics for the Jacobian calculation
C     including the area term
C
      DO 190 L = 1, 4
         DO 180 K = 2, KDIM
            DO 170 J = 1, JDIM
               STEMP(J,K,L) = S(J,K,I,L,2)
  170       CONTINUE
  180    CONTINUE
  190 CONTINUE
C
C     Calculate Jacobians and set up matrices to invert
C
      NPTS = JDIM * (KDIM - 1)
C
C     Roe's scheme
C          APT = dF/dQ(QP)
C          AMT = dF/dQ(QM)
C          ART = T |Lambda| T(-1)
C
      IF (IFLUX .EQ. IFROE) THEN
         CALL DFROE (ITURB, NPTS, QP, QM, STEMP, APT, AMT, ART, WORK)
C
         DO 214 L = 1, NRANK
            DO 213 M = 1, NRANK
               DO 212 K = 2, KDIM
                  DO 211 J = 2, JDIM
                     A(K,J,L,M) = -0.5E0*(AMT(J-1,K,L,M)+ART(J-1,K,L,M))
                     B(K,J,L,M) =  RM(J,K,L,M)
     1                            +0.5E0*( AMT(J,K,L,M)-APT(J-1,K,L,M)
     2                                   + ART(J,K,L,M)+ART(J-1,K,L,M) )
                     C(K,J,L,M) =  0.5E0*(APT(J,K,L,M)-ART(J,K,L,M))
  211             CONTINUE
  212          CONTINUE
  213       CONTINUE
  214    CONTINUE
C
      ELSE
         write (iout,'(a)') ' *** Invalid Flux Function ***'
         stop
      ENDIF
C
C     Implicit Viscous Terms
C          AP = DF(j+1/2)/DQ(j+1)
C          AM = DF(j+1/2)/DQ(j)
C          PROPS(1) is RMU and PROPS(2) is RMUT
C          Use QM as temporary space to store U,V,W,RMUJ,RMUTJ
C          Use QP as temporary space to store T - being
C          careful as T is dimensioned as JDIM+1, therefore
C          store T in QP(1) and leave QP(2) unused in this call.
C
      IF ( VISCOS ) THEN
         CALL DFVISJ (IDIM, JDIM, KDIM, I, ITURB,
     1                Q, PROPS(1,1), PROPS(1,2), S, VOL, IBCDAT, NBCS,
     2                QP(1,2,1), QM(1,2,1), QM(1,2,2), QM(1,2,3),
     3                QM(1,2,4), QM(1,2,5), APT, AMT)
C
         DO 324 L = 1, NRANK
            DO 323 M = 1, NRANK
               DO 322 K = 2, KDIM
                  DO 321 J = 2, JDIM
                     A(K,J,L,M) = A(K,J,L,M)
     1                    + AMT(J-1,K,L,M)
                     B(K,J,L,M) = B(K,J,L,M)
     1                    + ( APT(J,K,L,M)-AMT(J-1,K,L,M) )
                     C(K,J,L,M) = C(K,J,L,M)
     1                    - APT(J,K,L,M)
  321             CONTINUE
  322          CONTINUE
  323       CONTINUE
  324    CONTINUE
      ENDIF
C
C     Form the LU decomposition of the block tridiagonal system:
C     A*DQ(J-1) + B*DQ(J) + C*DQ(J+1)
C
      NPTS = JDIM - 1
      NSIM = KDIM - 1
      CALL VLUTR (NPTS, NSIM, NRANK, A, B, C)
C
C     Finished forming the LU decomposition of the J implicit sweep of
C     Line Gauss Seidel with AF in the plane.
      RETURN
      END
      SUBROUTINE LGSLUK (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, QP, QM,
     2                   STEMP, IBCDAT, NBCS, ICUTS, NCUTS,
     3                   IFLUX, VISCOS, ITURB,
     4                   A, B, C, RM, APT, AMT, ART, AI, WORK)
C
C     Routine to form the LU decomposition of the K implicit sweep of
C     Line Gauss Seidel with Approximate Factorisation in
C     the I = constant plane.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : The current plane
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     STEMP          : Storage for metrics passed to Jacobian routine
C                      including the area term
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     ICUTS          : Data controlling zone communication
C     NCUTS          : Number of cuts for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence model
C     A,B,C          : LU decomposition of the tridiagonal systems to invert
C                      A*DQ(K-1) + B*DQ(K) + C*DQ(K+1) = RTEMP
C                      Implicit in the K direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.  The
C                      vectorization direction is J.  This is
C                      stored in the first index for a unit stride
C                      in the inversion.
C     RM             : The I direction contribution to the implicit scheme
C     APT,AMT,ART    : Storage on a plane (KxJ) to calculate the
C                      Jacobians
C     AI             : Identity Matrix
C     WORK           : Temporary array of size NPTS*4 for Jacobian calculation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION QP    (KDIM,2:JDIM,NQ),
     1          QM    (KDIM,2:JDIM,NQ),
     2          STEMP (KDIM,2:JDIM,4),
     3          WORK  (KDIM,2:JDIM,4)
C
C     Storage for the implicit system to invert
C     Store the system only in the internal portion of
C     the field and use explicit boundary conditions
C     of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:JDIM,2:KDIM,NRANK,NRANK),
     1          B     (2:JDIM,2:KDIM,NRANK,NRANK),
     2          C     (2:JDIM,2:KDIM,NRANK,NRANK)
C
      DIMENSION RM    (2:JDIM,2:KDIM,NRANK,NRANK)
C
C     Storage for the Jacobians used to calculate A,B and C
C
      DIMENSION APT   (KDIM,2:JDIM,NRANK,NRANK),
     1          AMT   (KDIM,2:JDIM,NRANK,NRANK),
     2          ART   (KDIM,2:JDIM,NRANK,NRANK)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS),
     1          ICUTS (21,NCUTS)
C
      LOGICAL   VISCOS
C
C     Calculate QP,QM using first order
C
      DO 130 L = 1, NQ
         DO 120 J = 2, JDIM
            DO 110 K = 1, KDIM
               QP(K,J,L) = Q(J,K+1,I,L)
               QM(K,J,L) = Q(J,K,I,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C     Store the metrics for the Jacobian calculation
C     including the area term
C
      DO 190 L = 1, 4
         DO 180 J = 2, JDIM
            DO 170 K = 1, KDIM
               STEMP(K,J,L) = S(J,K,I,L,3)
  170       CONTINUE
  180    CONTINUE
  190 CONTINUE
C
C     Calculate Jacobians and set up matrices to invert
C
      NPTS = KDIM * (JDIM - 1)
C
C     Roe's scheme
C          APT = dF/dQ(QP)
C          AMT = dF/dQ(QM)
C          ART = T |Lambda| T(-1)
C
      IF (IFLUX .EQ. IFROE) THEN
         CALL DFROE (ITURB, NPTS, QP, QM, STEMP, APT, AMT, ART, WORK)
C
         DO 214 L = 1, NRANK
            DO 213 M = 1, NRANK
               DO 212 K = 2, KDIM
                  DO 211 J = 2, JDIM
                     A(J,K,L,M) = -0.5E0*(AMT(K-1,J,L,M)+ART(K-1,J,L,M))
                     B(J,K,L,M) =  RM(J,K,L,M)
     1                            +0.5E0*( AMT(K,J,L,M)-APT(K-1,J,L,M)
     2                                   + ART(K,J,L,M)+ART(K-1,J,L,M) )
                     C(J,K,L,M) =  0.5E0*(APT(K,J,L,M)-ART(K,J,L,M))
  211             CONTINUE
  212          CONTINUE
  213       CONTINUE
  214    CONTINUE
C
      ELSE
         write (iout,'(a)') ' *** Invalid Flux Function ***'
         stop
      ENDIF
C
C     Implicit Viscous Terms
C          AP = DF(k+1/2)/DQ(k+1)
C          AM = DF(k+1/2)/DQ(k)
C          PROPS(1) is RMU and PROPS(2) is RMUT
C          Use QM as temporary space to store U,V,W,RMUK,RMUTK
C          Use QP as temporary space to store T - being
C          careful as T is dimensioned as KDIM+1, therefore
C          store T in QP(1) and leave QP(2) unused in this call.
C
      IF ( VISCOS ) THEN
         CALL DFVISK (IDIM, JDIM, KDIM, I, ITURB,
     1                Q, PROPS(1,1), PROPS(1,2), S, VOL, IBCDAT, NBCS,
     2                QP(1,2,1), QM(1,2,1), QM(1,2,2), QM(1,2,3),
     3                QM(1,2,4), QM(1,2,5), APT, AMT)
C
         DO 324 L = 1, NRANK
            DO 323 M = 1, NRANK
               DO 322 K = 2, KDIM
                  DO 321 J = 2, JDIM
                     A(J,K,L,M) = A(J,K,L,M)
     1                    + AMT(K-1,J,L,M)
                     B(J,K,L,M) = B(J,K,L,M)
     1                    + ( APT(K,J,L,M)-AMT(K-1,J,L,M) )
                     C(J,K,L,M) = C(J,K,L,M)
     1                    - APT(K,J,L,M)
  321             CONTINUE
  322          CONTINUE
  323       CONTINUE
  324    CONTINUE
      ENDIF
C
C     Form the LU decomposition of the block tridiagonal system:
C     A*DQ(K-1) + B*DQ(K) + C*DQ(K+1)
C
      NPTS = KDIM - 1
      NSIM = JDIM - 1
      CALL VLUTR (NPTS, NSIM, NRANK, A, B, C)
C
C     Finished forming the LU decomposition of the K implicit sweep of
C     Line Gauss Seidel with AF in the plane.
      RETURN
      END
      SUBROUTINE LGSRES (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                   RES, RM)
C
C     Routine to multiply RM by RES as the step between the two
C     Approximate Factorisation sweeps of implicit Line Gauss Seidel
C     in the I = constant plane.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : The current plane
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     RM             : The I direction contribution to the implicit scheme
C
      include 'common.inc'
C
      DIMENSION RES   (JDIM+1,KDIM+1,IPSTRT-1:IPEND+1,NF)
C
C     Storage for the I direction contribution to the implicit scheme
C
      DIMENSION RM    (2:JDIM,2:KDIM,NRANK,NRANK)
C
C     Multiply RM by RES
C
C     Rank = 5
C
      IF (NRANK .EQ. 5) THEN
         DO 120 K = 2, KDIM
            DO 110 J = 2, JDIM
               R1 = RES(J,K,I,1)
               R2 = RES(J,K,I,2)
               R3 = RES(J,K,I,3)
               R4 = RES(J,K,I,4)
               R5 = RES(J,K,I,5)
               RES(J,K,I,1) = RM(J,K,1,1)*R1 + RM(J,K,1,2)*R2
     1                      + RM(J,K,1,3)*R3 + RM(J,K,1,4)*R4
     2                      + RM(J,K,1,5)*R5
               RES(J,K,I,2) = RM(J,K,2,1)*R1 + RM(J,K,2,2)*R2
     1                      + RM(J,K,2,3)*R3 + RM(J,K,2,4)*R4
     2                      + RM(J,K,2,5)*R5
               RES(J,K,I,3) = RM(J,K,3,1)*R1 + RM(J,K,3,2)*R2
     1                      + RM(J,K,3,3)*R3 + RM(J,K,3,4)*R4
     2                      + RM(J,K,3,5)*R5
               RES(J,K,I,4) = RM(J,K,4,1)*R1 + RM(J,K,4,2)*R2
     1                      + RM(J,K,4,3)*R3 + RM(J,K,4,4)*R4
     2                      + RM(J,K,4,5)*R5
               RES(J,K,I,5) = RM(J,K,5,1)*R1 + RM(J,K,5,2)*R2
     1                      + RM(J,K,5,3)*R3 + RM(J,K,5,4)*R4
     2                      + RM(J,K,5,5)*R5
  110       CONTINUE
  120    CONTINUE
C
C     Rank = 7
C
      ELSE IF (NRANK .EQ. 7) THEN
         DO 220 K = 2, KDIM
            DO 210 J = 2, JDIM
               R1 = RES(J,K,I,1)
               R2 = RES(J,K,I,2)
               R3 = RES(J,K,I,3)
               R4 = RES(J,K,I,4)
               R5 = RES(J,K,I,5)
               R6 = RES(J,K,I,6)
               R7 = RES(J,K,I,7)
               RES(J,K,I,1) = RM(J,K,1,1)*R1 + RM(J,K,1,2)*R2
     1                      + RM(J,K,1,3)*R3 + RM(J,K,1,4)*R4
     2                      + RM(J,K,1,5)*R5 + RM(J,K,1,6)*R6
     3                      + RM(J,K,1,7)*R7
               RES(J,K,I,2) = RM(J,K,2,1)*R1 + RM(J,K,2,2)*R2
     1                      + RM(J,K,2,3)*R3 + RM(J,K,2,4)*R4
     2                      + RM(J,K,2,5)*R5 + RM(J,K,2,5)*R5
     3                      + RM(J,K,2,7)*R7
               RES(J,K,I,3) = RM(J,K,3,1)*R1 + RM(J,K,3,2)*R2
     1                      + RM(J,K,3,3)*R3 + RM(J,K,3,4)*R4
     2                      + RM(J,K,3,5)*R5 + RM(J,K,3,5)*R5
     3                      + RM(J,K,3,7)*R7
               RES(J,K,I,4) = RM(J,K,4,1)*R1 + RM(J,K,4,2)*R2
     1                      + RM(J,K,4,3)*R3 + RM(J,K,4,4)*R4
     2                      + RM(J,K,4,5)*R5 + RM(J,K,4,5)*R5
     3                      + RM(J,K,4,7)*R7
               RES(J,K,I,5) = RM(J,K,5,1)*R1 + RM(J,K,5,2)*R2
     1                      + RM(J,K,5,3)*R3 + RM(J,K,5,4)*R4
     2                      + RM(J,K,5,5)*R5 + RM(J,K,5,5)*R5
     3                      + RM(J,K,5,7)*R7
               RES(J,K,I,6) = RM(J,K,6,1)*R1 + RM(J,K,6,2)*R2
     1                      + RM(J,K,6,3)*R3 + RM(J,K,6,4)*R4
     2                      + RM(J,K,6,5)*R5 + RM(J,K,6,5)*R5
     3                      + RM(J,K,6,7)*R7
               RES(J,K,I,7) = RM(J,K,7,1)*R1 + RM(J,K,7,2)*R2
     1                      + RM(J,K,7,3)*R3 + RM(J,K,7,4)*R4
     2                      + RM(J,K,7,5)*R5 + RM(J,K,7,5)*R5
     3                      + RM(J,K,7,7)*R7
  210       CONTINUE
  220    CONTINUE
C
C     Error
C
      ELSE
         WRITE (IOUT,1000) NRANK
         STOP
      ENDIF
C
C     Finished with the multiplication of RM and RES.
      RETURN
 1000 FORMAT (' ','LGSRES : ERROR-> Unsupported matrix size for ',
     1            'matrix-vector multiply.'
     2       /' ','                 Contact programmer.')
      END
      SUBROUTINE MARCH (IDIM, JDIM, KDIM, MXSECT, MXABC,
     1                  Q, QN, NQNPTS, PROPS, NPPTS, S, VOL,RC,DTJ,RES,
     2                  FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,WORKX,
     3                  IBCDAT, NBCS, NXPROF, NPROFL, IOFQBC, QBC,
     4                  ICUTS, NCUTS, R2NORM, ITRSMX, RESMAX, IRESMX,
     5                  IORDER, LIMIT, RKAP,IFLUX,VISCOS,IMODEL,IFDELQ,
     6                  ABC, RM, RTEMP, AT, AI,
     7                  IMSTRT, IMEND, NITS, NITFO, NITALG, ITUPJ,
     8                  TOLER, VGNRN, SIGMA, ITER,
     9                  QMIN, NFIXQ, NRELIZ, NPRLIM, NPRNEG,
     A                  IFL2DQ, R2DQDT, CL, RCNTR, IERRCD)
C
C     Routine to do Marching.
C     Presently, this routine will march only for one block.
C
C IDIM,JDIM,KDIM : Dimensions of current block
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning of temporary space used
C                   for calculating q(+,-) and f.
C MXABC          : Amount of memory to use to store the tridiagonal
C                  systems to invert.  Must be at least
C                  max (IDIM*JDIM, JDIM*KDIM) * number of planes to
C                  vectorize inversion on
C Q              : Primitive variables at cell centers
C QN             : Conserved variables at time levels n, n-1, etc.
C NQNPTS         : Number of QN points. This allows avoiding storing QN
C                  when running time accurate.
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RC             : Position vector at cell centers
C DTJ            : Time step divided by cell volume
C RES            : Residual
C FHAT           : Storage for fluxes for 4th order
C DQP,DQM        : Storage for delta q = q(i) - q(i-1)
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C TAU            : Storage for Reynolds stresses
C F,FM           : Fluxes at cell interfaces -
C                  if Flux Difference Splitting then F = Flux
C                  if Flux Vector Splitting then F = Fplus, FM = Fminus
C STEMP          : Storage for metrics passed to flux evaluation routine.
C WORKX          : Work array for cross-section (used for damping, etc.)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C NXPROF         : Maximum number of profile boundary condition segments
C NPROFL         : Number of profile boundary condition segments
C IOFQBC         : Offsets for QBC array
C QBC            : Q array for PROFILE bc
C ICUTS          : Data controlling zone communication
C NCUTS          : Number of cuts for current block
C R2NORM         : Array of residuals for each equation and
C                  L2 norm of all equations
C ITRSMX         : Number of iterations to output maximum residual
C RESMAX         : Maximum residual
C IRESMX         : Location of maximum residual
C IORDER         : Order of MUSCL interpolation
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C IFLUX          : Flux evaluation scheme
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C IMODEL         : Turbulence model scheme array
C IFDELQ         : Array controlling calculation of delq
C ABC            : Storage for the tridiagonal system to invert.
C                  This is permanent storage as it stores the LU
C                  decomposition of the two approximate factorization
C                  sweeps which are reused for every NITUPJ iterations.
C RM             : The I direction contribution to the implicit scheme
C RTEMP          : Storage for the residual to be put in the proper
C                  form to use with the inversion routine
C AT             : Storage for the Jacobian calculations
C AI             : Identity Matrix
C IMSTRT         : I plane to begin marching at
C IMEND          : I plane to end marching
C NITS           : Number of iterations to perform on each plane
C NITFO          : Number of iterations to perform first order accurate
C NITALG         : Number of iterations to update turbulent eddy viscosity
C                  with algebraic model while doing higher order turb
C                  model for the initial iterations.
C ITUPJ          : Number of iterations to update the LU decomposition
C                  of the implicit terms
C TOLER          : Specified tolerance to converge the solution on a
C                  plane - RES/RES(iter=1) <= TOLER
C VGNRN          : Logical for Vigneron approximation (TRUE) or not (FALSE)
C SIGMA          : Safety factor for the Vigneron term in the pressure
C ITER           : The iteration counter used back in the main routine
C                  to write out the restart file.
C QMIN           : Control array for minimum value of Q
C NFIXQ          : Number of times reset Q
C NRELIZ         : Number of times violate realizability
C NPRLIM         : Number of times reset production
C NPRNEG         : Number of times invoke positivity preservation for production
C IFL2DQ         : Logical to calculate L2 norm of dQ/dt term for unsteady
C R2DQDT         : L2 norm of dQ/dt term for unsteady
C CL             : Lift coefficient. Used for 2D farfield vortex bc.
C RCNTR          : Center of airfoil. Used as location of point vortex.
C                  Also used as airfoil location at which to calculate moments.
C IERRCD         : Error code
C
      include 'common.inc'
      include 'histry.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN    (NQNPTS,NQ,NTMLVL),
     2          PROPS (NPPTS,NP),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     5          RC    (JDIM+1,KDIM+1,IDIM+1,3),
     6          DTJ   (JDIM,KDIM,IDIM)
C
C     Dimension RES with I = 3 to correspond to the dimensioning
C     as IPSTRT-1:IPEND+1 in routines below this where IPSTRT = IPEND.
C
      DIMENSION RES   (JDIM+1,KDIM+1,3,NF),
     1          FHAT  (JDIM+1,KDIM+1,3,NF),
     2          DQP   (MXSECT,NQ),
     3          DQM   (MXSECT,NQ),
     4          QP    (MXSECT,NQ),
     5          QM    (MXSECT,NQ),
     6          TAU   (MXSECT,6),
     7          F     (MXSECT,NF),
     8          FM    (MXSECT,NF),
     9          STEMP (MXSECT,4),
     A          WORKX (MXSECT,NW)
C
      DIMENSION ABC   (MXABC*NRANK*NRANK,3,2),
     1          RTEMP (MXABC*NF),
     2          RM    (MXABC*NRANK*NRANK),
     3          AT    (MXSECT*NRANK*NRANK,3)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS),
     1          ICUTS (21,NCUTS)
C
      DIMENSION IOFQBC(NXPROF)
      DIMENSION QBC   (*)
C
      DIMENSION IORDER(3), RKAP(3), LIMIT(3)
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
      LOGICAL   VISCOS(3), INITRS, MRCHNG, VGNRN, NCSTOP, NCCHCK, IFL2DQ
C
      DIMENSION R2NORM(NF+1),
     1          R2DQDT(NF+1)
C
      DIMENSION IRESMX(0:3)
C
      DIMENSION QMIN  (NQ)
      DIMENSION NFIXQ (NQ),
     1          NRELIZ(NQ)
C
      DIMENSION RCNTR (3)
C
C     Set to march and initialize residual to zero
C
      MRCHNG = .TRUE.
      INITRS = .TRUE.
C
      ITURB  = IMODEL(1)
C
C     Test to asure that sufficient room exists to store the entire
C     LU in the plane to reuse.
C
      ISIZE = JDIM * KDIM
      IF (ISIZE .GT. MXABC) THEN
         WRITE (IOUT,1900) ISIZE
         STOP
      ENDIF
 1900 FORMAT (' ','MARCH : ERROR-> Insufficient room in ABC array to'
     1       /' ','        allow for storage of the LU decomposition in'
     2       /' ','        the marching algorithm.'
     3       /' ','        Increase MXABC in MAIN to at least ',I20)
C
C     Save the values of RKAP and LIMIT for the I direction to restore after
C     finished with marching to allow contnuation with global solution.
C     Set RKAP and LIMIT for the I direction to be fully upwind unlimited
C     for marching.
C
      RKAPS    = RKAP(1)
      LIMITS   = LIMIT(1)
      RKAP(1)  = - 1.E0
      LIMIT(1) =   0
C
C     Set variable to abort marching when a plane does not converge.
C
      NCSTOP = .TRUE.
C
C     Make sure that are marching on the available planes (2 to IDIM)
C
      IMSTRT = MAX ( IMSTRT, 2 )
      IMEND  = MIN ( IMEND,  IDIM )
C
C     March plane to plane doing NITS iterations per plane.
C
      DO 900 I = IMSTRT, IMEND
         IPSTRT = I
         IPEND  = I
C
C     Initialize the cross section to the solution from the previous
C     cross section UNLESS are doing a restart.
C     Then call boundary conditions. Use QP as work array
C
         IF (ITTOT .LE. 0) THEN
            WRITE (IOUT,1020) I
 1020 FORMAT (//' ','Initializing cross section I = ',I5)
C
            DO 130 L = 1, NQ
               DO 120 K = 1, KDIM
                  DO 110 J = 1, JDIM
                     Q(J,K,I,L) = Q(J,K,I-1,L)
  110             CONTINUE
  120          CONTINUE
  130       CONTINUE
C
            CALL BC (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1               Q, PROPS, NPPTS, S, VOL, RC, NBCS, IBCDAT,
     2               NXPROF, NPROFL, IOFQBC, QBC,
     3               VISCOS, IMODEL, QP, MXSECT, CL, RCNTR)
         ENDIF
C
C     End of initialization section
C
         WRITE (IOUT,1000) I
 1000 FORMAT (/' ','Iteration History for Cross Section I = ',I5/)
C
C     Loop for NITS iterations on the current plane
C
         NCCHCK = .FALSE.
         DO 800 ITER = 1, NITS
C
C     Check for presence of STOP file; if it exists, write restart and quit
C
            OPEN (ISTOPFL,FILE='STOP',STATUS='OLD',ERR=701)
            WRITE (IOUT,1490)
            GO TO 999
 1490 FORMAT (//' ','MARCH : STOP file encountered! Run stopping.'//)
C
C     STOP does not exist; continue run
C
  701       CONTINUE
C
C     Set up switch from first order scheme to higher order
C     This sets first order to be ONLY streamwise for now.
C
            IF (ITER .GT. NITFO) THEN
               IORDER(1) = 2
               IORDER(2) = 2
               IORDER(3) = 2
            ELSE
               IORDER(1) = 1
               IORDER(2) = 2
               IORDER(3) = 2
            ENDIF
C
C     Set up switch to use the algebraic turbulent eddy viscosity in
C     the initial phases of the iteration to improve convergence.
C
            IF (ITER .GT. NITALG) THEN
               MUTALG = .FALSE.
            ELSE
               MUTALG = .TRUE.
            ENDIF
C
C     Update time step.
C     Use DQP as temporary storage for PFACTR.
C
            IF ( MOD((ITER-1), ITUPDT) .EQ. 0) THEN
               IBLK  =  1
               DTMIN =  999.E0
               DTMAX = -999.E0
               CALL DELTAT (IBLK, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                      Q, PROPS, DTJ, VOL, S, DQP,
     2                      VISCOS, ITURB, ITER, CFLCUR,
     3                      DTMIN, IBLKMN, IDTMIN, JDTMIN, KDTMIN,
     4                      DTMAX, IBLKMX, IDTMAX, JDTMAX, KDTMAX)
C-need to output this only when running in CFL specified mode
               WRITE (IOUT,1450) CFLCUR,
     1                           DTMIN, IBLKMN, IDTMIN, JDTMIN, KDTMIN,
     2                           DTMAX, IBLKMX, IDTMAX, JDTMAX, KDTMAX
            ENDIF
 1450 FORMAT (' ','MARCH : CFL =',1PE10.3,'  DTMIN =',1PE10.3,
     1            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')',
     2       /' ',23X,'  DTMAX =',1PE10.3,
     3            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')')
C
C     Reset norms to zero
C
            DO 400 L = 1, NF + 1
               R2NORM(L) = 0.E0
 400        CONTINUE
C
            DO 410 L = 1, NQ
               NFIXQ (L) = 0
               NRELIZ(L) = 0
 410        CONTINUE
            NPRLIM = 0
            NPRNEG = 0
            RESMAX = 0.E0
C
C     Set up control parameter for Jacobian update.
C
            IF ( MOD((ITER-1), ITUPJ) .EQ. 0) THEN
               UPDATJ = .TRUE.
            ELSE
               UPDATJ = .FALSE.
            ENDIF
C
C     If running a viscous case, calculate the PROPS array
C     Use QP, QM, F and DQP as temporary storage.
C
            IF (ITURB .GE. ITLMNR) THEN
               CALL PRPRTY (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                      Q, PROPS, S, VOL,
     2                      IBCDAT, NBCS, IMODEL, IFDELQ,
     3                      STEMP, QP, F, FM, QM, DQP, DQM, WORKX)
            ENDIF
C
C     Call Residual routine for the current plane
C
            CALL RESID (IDIM, JDIM, KDIM, IPSTRT, IPEND, MXSECT,
     1                  Q, QN, NQNPTS, PROPS, NPPTS, S, VOL, RC,DTJ,RES,
     2                  FHAT, DQP, DQM, QP, QM, TAU, F, FM, STEMP,WORKX,
     3                  IBCDAT, NBCS, IORDER, LIMIT, RKAP, IFLUX,VISCOS,
     4                  IMODEL, INITRS, IFDELQ, MRCHNG, VGNRN, SIGMA,
     5                  NPRLIM, NPRNEG, IFL2DQ, R2DQDT)
C
C     Output if reset turbulence production
C
            IF (NPRNEG .GT. 0) THEN
               WRITE (IOUT,2400) NPRNEG
 2400 FORMAT (' ','MAIN  : from SRCRES: Turb. Prod reset posit',
     1            'ive   at ',I6,' locations')
            ENDIF
C
            IF (NPRLIM .GT. 0) THEN
               WRITE (IOUT,2401) PRDLIM, NPRLIM
 2401 FORMAT (' ','MAIN  : from SRCRES: Turb. Prod limited to ',1PE10.2,
     1            '*diss at ',I6,' locations')
            ENDIF
C
C     Calculate L2 Norm of residual on the current plane and add
C     it to the residual for the entire flowfield
C
            CALL L2NORM (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                   RES, VOL, R2NORM)
C
            DO 405 LL = 1, NF + 1
               R2NORM(LL) = SQRT ( R2NORM(LL) )
  405       CONTINUE
            IT   = ITER + ITTOT
C
C     Look at continuity equation for convergence
C
C--         R2(IT) = R2NORM(NF+1)
            R2(IT) = R2NORM(1)
C
C     Store the first residual for comparison of convergence; If the first
C     residual is zero, then store the second residual.
C
            IF (IT .EQ. 1) THEN
               R2ONE  = R2(IT)
               R2TEST = 1.E0
            ELSE IF (IT .EQ. 2) THEN
               IF (R2ONE .EQ. 0.E0) THEN
                  R2ONE  = R2(IT)
                  R2TEST = 1.E0
               ENDIF
            ELSE
               R2TEST = R2(IT) / R2ONE
            ENDIF
C
C     Calculate the maximum residual
C
            IF ( MOD( ITER, ITRSMX ) .EQ. 0) THEN
               CALL L2MAX  (IBLK, IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1                      RES, VOL, RESMAX, IRESMX)
               RESMAX = SQRT (RESMAX)
               WRITE (IOUT,2490) ITER, IT, RESMAX, (IRESMX(L),L=0,3)
            ENDIF
 2490 FORMAT (' ','Iter = ',2I6,' Max Res = ',1PE12.5,
     1            ' At BLOCK:I,J,K=(',I3,':',I4,',',I4,',',I4,')')
C
            WRITE (IOUT,2500) ITER, IT, (R2NORM(LL),LL=1,NF+1)
 2500 FORMAT (' ','ITER = ',2I8,' RES = ',13(1PE14.7,2X))
C
C     Set RES = - RES
C     RES is dimensioned as I = 3
C
            DO 413 L = 1, NF
               DO 412 K = 2, KDIM
                  DO 411 J = 2, JDIM
                     RES(J,K,1,L) = - RES(J,K,1,L)
                     RES(J,K,2,L) = - RES(J,K,2,L)
                     RES(J,K,3,L) = - RES(J,K,3,L)
  411             CONTINUE
  412          CONTINUE
  413       CONTINUE
C
C     Update the LU decomposition of the approximate factorization terms
C
 1010 FORMAT (' ','Jacobian LU Update')
            IF (UPDATJ) THEN
               WRITE (IOUT,1010)
C
C     Calculate the I direction contribution to the implicit scheme
C
               CALL MARRM (IDIM, JDIM, KDIM, I,
     1                     Q, PROPS, NPPTS, S, VOL, DTJ,
     2                     MXSECT, DQP, DQM, QP, QM, TAU, F, FM,
     3                     STEMP, WORKX, IBCDAT, NBCS, ICUTS, NCUTS,
     4                     IFLUX, VISCOS(1), IMODEL, IFDELQ,
     5                     RM, AT(1,1), AT(1,2), AT(1,3), AI)
C
C     Form LU decomposition for J implicit sweep
C     K is the vectorization direction.
C
               CALL LGSLUJ (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                      Q, PROPS, NPPTS, S, VOL, DTJ, QP, QM,
     2                      STEMP, IBCDAT, NBCS, ICUTS, NCUTS,
     3                      IFLUX, VISCOS(2), ITURB,
     4                      ABC(1,1,1), ABC(1,2,1), ABC(1,3,1), RM,
     5                      AT(1,1), AT(1,2), AT(1,3), AI, DQM)
C
C     Form LU decomposition for K implicit sweep
C     J is the vectorization direction.
C
               IF ( THREED ) THEN
                  CALL LGSLUK (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                         Q, PROPS, NPPTS, S, VOL, DTJ, QP, QM,
     2                         STEMP, IBCDAT, NBCS, ICUTS, NCUTS,
     3                         IFLUX, VISCOS(3), ITURB,
     4                         ABC(1,1,2), ABC(1,2,2), ABC(1,3,2), RM,
     5                         AT(1,1), AT(1,2), AT(1,3), AI, DQM)
               ENDIF
            ENDIF
C
C     Forward/Backward sweeps of LU decomposition
C
C     J implicit sweep
C     K is the vectorization direction.
C
            CALL LGSFBJ (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                   RES, ABC(1,1,1), ABC(1,2,1), ABC(1,3,1),
     2                   RTEMP)
C
C     K implicit sweep
C     J is the vectorization direction.
C
            IF ( THREED ) THEN
               CALL LGSRES (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                      RES, RM)
               CALL LGSFBK (IDIM, JDIM, KDIM, I, IPSTRT, IPEND,
     1                      RES, ABC(1,1,2), ABC(1,2,2), ABC(1,3,2),
     2                      RTEMP)
            ENDIF
C
C     Conservative Variable Update
C
            CALL UPDATE (IDIM, JDIM, KDIM, IPSTRT, IPEND, Q, RES, ITURB,
     1                   QP, QM, QMIN, NFIXQ, NRELIZ, FHAT, IERRCD)
CN.B. Q is it not NaN until after this call!
C     kk = 2
C     do jj = 1, jdim
C        write (iout,'(a,3i3,5e12.4)') 'i,q', i, jj, kk,
C    1         (q(jj,kk,i,ll),ll=1,5)
C     end do
C
C     Check error code and abort run
C
            IF (IERRCD .NE. INO) THEN
               GO TO 999
            ENDIF
C
C     Call Boundary Conditions
C     Use QP as work array
C
            CALL BC (IDIM, JDIM, KDIM, IPSTRT, IPEND,
     1               Q, PROPS, NPPTS, S, VOL, RC, NBCS, IBCDAT,
     2               NXPROF, NPROFL, IOFQBC, QBC,
     3               VISCOS, IMODEL, QP, MXSECT, CL, RCNTR)
C
C     Check for convergence of present cross section
C
            IF (R2TEST .LE. TOLER) GO TO 805
 800     CONTINUE
C
C     Set up check for non-convergence of cross section
C
          NCCHCK = .TRUE.
 805     CONTINUE
C
C     Write body data
C
         WRITE (IOUT,1100) I
 1100 FORMAT (///' ','  Solution completed at I = ',I5/)
C        DO 897 J = 1, JDIM
C           WRITE (IOUT,1105) J,(Q(J,2,I,L),L=1,NQ)
C1105 FORMAT (' ',I3,5X,6(E14.7,2X))
C897     CONTINUE
C
C     Stop the marching procedure if the present cross section did not converge
C     and the variable NCSTOP is true to enable this check
C
         IF ( NCCHCK ) THEN
            WRITE (IOUT,1200)
 1200 FORMAT (///' ','Marching did not converge on present plane',
     1          /' ','*** MARCHING ABORTED ***')
            IF ( NCSTOP ) GO TO 999
         ENDIF
C
C     Reset ITTOT to zero for the next cross section (this one is converged)
C
         ITTOT = 0
C
  900 CONTINUE
C
C     If all planes converged fine then will get here.  If this occurs,
C     set ITER to zero on return to the main routine so that the convergence
C     history is not saved for a restart of the current plane.
C
      ITER  = 0
C
C     Rewind the restart file that is written to avoid storing residual
C     history
C
      REWIND (IWRRST)
C
C     Jump here if plane doesn't converge and NCSTOP is set or error detected
C     Jump here if STOP file is detected
C
  999 CONTINUE
C
C     Restore RKAP and LIMIT for the I direction to continue global
C     solution.
C
      RKAP(1)  = RKAPS
      LIMIT(1) = LIMITS
C
C     Finished with Marching
      RETURN
      END
      SUBROUTINE MARRM (IDIM, JDIM, KDIM, I,
     1                  Q, PROPS, NPPTS, S, VOL, DTJ,
     2                  MXSECT, DQP, DQM, QP, QM, TAU, F, FM,
     3                  STEMP, WORKX, IBCDAT, NBCS, ICUTS, NCUTS,
     4                  IFLUX, VISCOS, IMODEL, IFDELQ,
     5                  RM, APT, AMT, ART, AI)
C
C     Routine to calculate the I direction contribution to the
C     implicit Line Gauss Seidel with Approximate Factorisation
C     in the I = constant plane for MARCHING.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : The current plane
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                      (used in dimensioning of temporary space used
C                       for calculating q(+,-) and f.
C     DQP,DQM        : Storage for delta q = q(j) - q(j-1)
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     TAU            : Storage for Reynolds stresses
C     F,FM           : Fluxes at cell interfaces - currently temp storage
C     STEMP          : Storage for metrics passed to Jacobian routine
C                      including the area term
C     WORKX          :
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     ICUTS          : Data controlling zone communication
C     NCUTS          : Number of cuts for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     IMODEL         : Turbulence model array
C     IFDELQ         : Array controlling calculation of delq
C     RM             : The I direction contribution to the implicit scheme
C     APT,AMT,ART    : Storage on a plane (JxK) to calculate the
C                      Jacobians
C     AI             : Identity Matrix
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION DQP   (MXSECT,NQ),
     1          DQM   (MXSECT,NQ),
     2          QP    (2:JDIM,2:KDIM,NQ),
     3          QM    (2:JDIM,2:KDIM,NQ),
     4          TAU   (2:JDIM,2:KDIM,6),
     5          F     (2:JDIM,2:KDIM,NQ),
     6          FM    (2:JDIM,2:KDIM,NQ),
     7          STEMP (2:JDIM,2:KDIM,4),
     8          WORKX (MXSECT,NW)
C
C     Storage for the I direction contribution to the implicit scheme
C
      DIMENSION RM    (2:JDIM,2:KDIM,NRANK,NRANK)
C
C     Storage for the Jacobians used to calculate A,B and C
C
      DIMENSION APT   (2:JDIM,2:KDIM,NRANK,NRANK),
     1          AMT   (2:JDIM,2:KDIM,NRANK,NRANK),
     2          ART   (2:JDIM,2:KDIM,NRANK,NRANK)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS),
     1          ICUTS (21,NCUTS)
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
      LOGICAL   VISCOS
C
      ITURB  = IMODEL(1)
C
C     Contribution to RM from I+1/2
C
C     Calculate QM using first order
C
      DO 113 L = 1, NQ
         DO 112 K = 2, KDIM
            DO 111 J = 2, JDIM
               QM(J,K,L) = Q(J,K,I,L)
  111       CONTINUE
  112    CONTINUE
  113 CONTINUE
C
C     Store the metrics for the Jacobian calculation
C     including the area term
C
      DO 163 L = 1, 4
         DO 162 K = 2, KDIM
            DO 161 J = 2, JDIM
               STEMP(J,K,L) = S(J,K,I,L,1)
  161       CONTINUE
  162    CONTINUE
  163 CONTINUE
C
C     Calculate Jacobians and add I+1/2 contribution to RM matrix
C
      NPTS = (JDIM - 1) * (KDIM - 1)
      CALL DFDQ (ITURB, NPTS, QM, STEMP, DQM(1,1), DQM(1,2), AMT)
C
      DO 214 L = 1, NRANK
         DO 213 M = 1, NRANK
            DO 212 K = 2, KDIM
               DO 211 J = 2, JDIM
                  RM(J,K,L,M) = AI(L,M) / DTJ(J,K,I) + AMT(J,K,L,M)
  211          CONTINUE
  212       CONTINUE
  213    CONTINUE
  214 CONTINUE
C
C     Source term contribution to RM matrix
C     Temporary variables passed to the source term evaluation routine:
C         QP     for QC (variables in one-dimensional array)
C         FM     for PROPSC (properties in one-dimensional array - this is
C                            passed in using FM.  Must always be sure that
C                            NP <= NQ or else will need to fix this)
C         QM     for DQDX (derivatives of Q in x direction at cell centers)
C         DQP    for DQDY (derivatives of Q in y direction at cell centers)
C         DQM    for DQDZ (derivatives of Q in z direction at cell centers)
C         STEMP  for DEL2K (Laplacian of turbulent kinetic energy)
C         WORKX(1)     for TKE
C         WORKX(2)     for ETILDE
C         WORKX(3)     for XSIW
C         WORKX(4-5)   for FDAMP
C         WORKX(6)     for EPSC
C         WORKX(7)     for PDIL
C         WORKX( 8-13) for SIJ
C         WORKX(14-19) for WIJ
C         F            for SRC
C
      IF (ISRCE) THEN
         IF ( ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW .OR.
     1        ITURB .EQ. ITRS ) THEN
            CALL DSRCDQ (IDIM, JDIM, KDIM, I, IMODEL,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   QP, FM, QM, DQP, DQM, STEMP,
     3                   WORKX(1,1), WORKX(1,2), WORKX(1,3),WORKX(1, 4),
     4                   WORKX(1,6), WORKX(1,7), WORKX(1,8),WORKX(1,14),
     5                   TAU, F, IBCDAT, NBCS, APT)
C
            DO 314 L = 1, NRANK
               DO 313 M = 1, NRANK
                  DO 312 K = 2, KDIM
                     DO 311 J = 2, JDIM
                        RM(J,K,L,M) = RM(J,K,L,M) - APT(J,K,L,M)
  311                CONTINUE
  312             CONTINUE
  313          CONTINUE
  314       CONTINUE
         ENDIF
      ENDIF
C
C     Finished with the RM calculation.
      RETURN
      END
      SUBROUTINE AF3F (IBLK, IDIM, JDIM, KDIM, MXSECT, MXABC,
     1                 Q, QN, NQNPTS, PROPS, NPPTS, S, VOL, RC, DTJ,
     2                 RES, FHAT, DQP, DQM, QP, QM,TAU,F,FM,STEMP,WORKX,
     3                 IBCDAT, NBCS,
     4                 IORDER, LIMIT, RKAP, IFLUX, VISCOS, DIAG,
     5                 IMODEL, IFDELQ, ABC, RTEMP, AT, AI,
     6                 QMIN, NFIXQ, NRELIZ, NPRLIM, NPRNEG, IERRCD)
C
C Routine to do spatially split Three Factor Approximate Factorisation
C using block inversions with implicit terms of the form
C     df/dq = T |Lambda| T(-1).
C For inviscid, laminar, algebraic turbulence model:
C     (I + DTJ A) (I + DTJ B) (I + DTJ C) = - DTJ RES
C for implicit source terms (including 2 eqn turbulence models)
C     (I + DTJ D) (I + DTJ A) (I + DTJ B) (I + DTJ C) = - DTJ RES
C where
C     A = dF/dQ, B = dG/dQ, C = dH/dQ and D = dS/dQ (S = source terms).
C IJKMAX is a parameter passed from the main storage holding the
C value of the maximum dimension anywhere in the grid which is
C used to set up the temporary storage.
C
C IBLK           : Current block
C IDIM,JDIM,KDIM : Dimensions of current block
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning of temporary space used
C                   for calculating q(+,-) and f.
C MXABC          : Amount of memory to use to store the tridiagonal
C                  systems to invert.  Must be at least
C                  max (IDIM*JDIM, JDIM*KDIM) * number of planes to
C                  vectorize inversion on
C Q              : Primitive variables at cell centers
C QN             : Conserved variables at time levels n, n-1, etc.
C NQNPTS         : Number of QN points. This allows avoiding storing QN when
C                  running time accurate.
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RC             : Position vector at cell centers
C DTJ            : Time step divided by cell volume
C RES            : Residual
C FHAT           : Storage for fluxes for 4th order
C DQP,DQM        : Storage for delta q = q(i) - q(i-1)
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C TAU            : Storage for Reynolds stresses
C F,FM           : Fluxes at cell interfaces -
C                  if Flux Difference Splitting then F = Flux
C                  if Flux Vector Splitting then F = Fplus, FM = Fminus
C STEMP          : Storage for metrics passed to flux evaluation routine.
C WORKX          : Work array for cross-section (used for damping, etc.)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C IORDER         : Order of MUSCL interpolation
C                  IORDER = 1 first order
C                         = 2 second order (or 'third' order)
C LIMIT          : Limiter to use for MUSCL interpolation
C RKAP           : Kappa to use in MUSCL interpolation
C IFLUX          : Flux evaluation scheme
C VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C DIAG           : Control for diagonalized scheme (TRUE) or block (FALSE)
C IMODEL         : Turbulence modeling scheme array
C IFDELQ         : Array controlling calculation of delq
C ABC            : Storage for the tridiagonal system to invert
C RTEMP          : Storage for the residual to be put in the proper
C                  form to use with the inversion routine
C AT             : Storage for the Jacobian calculations
C AI             : Identity Matrix
C QMIN           : Control array for minimum value of Q
C NFIXQ          : Number of times reset Q
C NRELIZ         : Number of times violate realizability
C NPRLIM         : Number of times reset production
C NPRNEG         : Number of times invoke positivity preservation for production
C IERRCD         : Error code
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          QN    (NQNPTS,NQ,NTMLVL),
     2          PROPS (NPPTS,NP),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     5          RC    (JDIM+1,KDIM+1,IDIM+1,3),
     6          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          FHAT  (JDIM+1,KDIM+1,IDIM+1,NF),
     2          DQP   (MXSECT,NQ),
     3          DQM   (MXSECT,NQ),
     4          QP    (MXSECT,NQ),
     5          QM    (MXSECT,NQ),
     6          TAU   (MXSECT,6),
     7          F     (MXSECT,NF),
     8          FM    (MXSECT,NF),
     9          STEMP (MXSECT,4),
     A          WORKX (MXSECT,NW)
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
      DIMENSION ABC   (MXABC*NRANK*NRANK,3),
     1          RTEMP (MXABC*NF),
     2          AT    (MXSECT*NRANK*NRANK,3)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION IORDER(3), RKAP(3), LIMIT(3)
C
      LOGICAL   VISCOS(3), DIAG(3)
C
      DIMENSION QMIN  (NQ)
      DIMENSION NFIXQ (NQ),
     1          NRELIZ(NQ)
C
      ITURB  = IMODEL(1)
C
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C
      IPSTRT = 2
      IPEND  = IDIM
C
C     Set RES = - RES / ( (1+phi')/(dtau*J) + (1+phi)/(dt*J) ) for inversions
C
      DO 140 L = 1, NF
         DO 130 I = 2, IDIM
            DO 120 K = 2, KDIM
               DO 110 J = 2, JDIM
                  DTTERM       = 1.0E0 /
     1                           ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                           + TDPDEL * VOL(J,K,I) / TIMEDT )
                  RES(J,K,I,L) = - DTTERM * RES(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
  140 CONTINUE
C
C     Perform the (I + DTJ D) inversion for the case with implicit source
C     terms -> IMPSRC not equal INO and 2 equation or higher turbulence model
C
      IF (IMPSRC .NE. INO) THEN
         IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW .OR.
     1       ITURB .EQ. ITRS) THEN
C
C     Calculate INPL to be the number of planes that will fit
C     in the memory allocated.  Actually vectorize over NPL
C     which takes into account if the last loop would be longer
C     then IDIM.  K is the primary vectorization direction and
C     I is the secondary vectorization direction.
C     Make sure that INPL is no larger than the maximum size of the grid.
C     Temporary storage: Use WORKX(1)    for TKE ,     WORKX(2)     for ETILDE,
C                            WORKX(3)    for XSIW,     WORKX(4-5)   for FDAMP,
C                            WORKX(6)    for EPSC,     WORKX(7)     for PDIL,
C                            WORKX(8-13) for SIJ ,     WORKX(14-19) for WIJ,
C                            F           for SRC
C
            INPL = MXABC / ( (KDIM-1) * (JDIM-1) )
            INPL = MIN (INPL, (IDIM-1))
            NPL  = INPL
            DO 190 I = 2, IDIM, INPL
               IF ( (I+INPL) .GT. IDIM ) NPL = IDIM - I + 1
               CALL PISRC (IDIM, JDIM, KDIM, NPL, I, IMODEL, IFDELQ,
     1                     Q, PROPS, NPPTS, S, VOL, RC, DTJ, RES,
     2                     MXSECT, DQP, DQM, QP, QM, TAU, FM, STEMP,
     3                     WORKX(1,1),WORKX(1,2),WORKX(1,3),WORKX(1,4),
     4                     WORKX(1,6),WORKX(1,7),WORKX(1,8),WORKX(1,14),
     5                     F, IBCDAT, NBCS, ABC(1,2), RTEMP, AI,AT(1,1))
  190       CONTINUE
         ENDIF
      ENDIF
C
C     I implicit sweep
C
C     I Diagonalized Inversion:
C     Use F(1-3), FM(1-3) for lhat, mhat.  Use F(5) for TKE.  FM(5) for VOLJ.
C     Use QM for PROPSJ.  AT(3) for EIGENP, DQP for EIGENM, DQM for EIGEN.
C
      IF ( DIAG(1) ) THEN
         DO 200 K = 2, KDIM
            CALL AF3DI  (IDIM, JDIM, KDIM, K,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES,
     2                   QP, QM, STEMP, FM(1,5), F(1,1), FM(1,1),F(1,5),
     3                   IBCDAT, NBCS, IFLUX, VISCOS(1), ITURB,
     4                   ABC(1,1), ABC(1,2), ABC(1,3), RTEMP,
     5                   AT(1,1), AT(1,2), AT(1,3), DQP, DQM)
  200    CONTINUE
C
C     I Block Inversion:
C     Calculate INPL to be the number of planes that will fit
C     in the memory allocated.  Actually vectorize over NPL
C     which takes into account if the last loop would be longer
C     then KDIM.  J is the primary vectorization direction and
C     K is the secondary vectorization direction.
C     Make sure that INPL is no larger than the maximum size of the grid.
C
      ELSE
         INPL = MXABC / ( (IDIM-1) * (JDIM-1) )
         INPL = MIN (INPL, (KDIM-1))
         NPL  = INPL
         DO 210 K = 2, KDIM, INPL
            IF ( (K+INPL) .GT. KDIM ) NPL = KDIM - K + 1
            CALL AF3SWI (IDIM, JDIM, KDIM, NPL, K,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES, QP, QM,
     2                   STEMP, IBCDAT, NBCS, IFLUX, VISCOS(1), ITURB,
     3                   ABC(1,1), ABC(1,2), ABC(1,3), RTEMP,
     4                   AT(1,1), AT(1,2), AT(1,3), AI, DQP)
  210    CONTINUE
      ENDIF
C
C     J implicit sweep
C
C     J Diagonal Inversion:
C     Use F(1-3), FM(1-3) for lhat, mhat.  Use F(5) for TKE.  FM(5) for VOLJ.
C     Use QM for PROPSJ.  AT(3) for EIGENP, DQP for EIGENM, DQM for EIGEN.
C
      IF ( DIAG(2) ) THEN
         DO 300 K = 2, KDIM
            CALL AF3DJ  (IDIM, JDIM, KDIM, K,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES,
     2                   QP, QM, STEMP, FM(1,5), F(1,1), FM(1,1),F(1,5),
     3                   IBCDAT, NBCS, IFLUX, VISCOS(2), ITURB,
     4                   ABC(1,1), ABC(1,2), ABC(1,3), RTEMP,
     5                   AT(1,1), AT(1,2), AT(1,3), DQP, DQM)
  300    CONTINUE
C
C     J Block Inversion:
C     Calculate INPL to be the number of planes that will fit
C     in the memory allocated.  Actually vectorize over NPL
C     which takes into account if the last loop would be longer
C     then IDIM.  K is the primary vectorization direction and
C     I is the secondary vectorization direction.
C     Make sure that INPL is no larger than the maximum size of the grid.
C
      ELSE
         INPL = MXABC / ( (KDIM-1) * (JDIM-1) )
         INPL = MIN (INPL, (IDIM-1))
         NPL  = INPL
         DO 310 I = 2, IDIM, INPL
            IF ( (I+INPL) .GT. IDIM ) NPL = IDIM - I + 1
            CALL AF3SWJ (IDIM, JDIM, KDIM, NPL, I,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES, QP, QM,
     2                   STEMP, IBCDAT, NBCS,
     3                   IFLUX, VISCOS(2), ITURB,
     4                   ABC(1,1), ABC(1,2), ABC(1,3), RTEMP,
     5                   AT(1,1), AT(1,2), AT(1,3), AI, DQP)
  310    CONTINUE
      ENDIF
C
C     K implicit sweep
C
      IF ( THREED ) THEN
C
C     K Diagonal Inversion:
C     Use F(1-3), FM(1-3) for lhat, mhat.  Use F(5) for TKE.  FM(5) for VOLJ.
C     Use QM for PROPSJ.  AT(3) for EIGENP, DQP for EIGENM, DQM for EIGEN.
C
         IF ( DIAG(3) ) THEN
            DO 400 I = 2, IDIM
               CALL AF3DK  (IDIM, JDIM, KDIM, I,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES,
     2                   QP, QM, STEMP, FM(1,5), F(1,1), FM(1,1),F(1,5),
     3                   IBCDAT, NBCS, IFLUX, VISCOS(3), ITURB,
     4                   ABC(1,1), ABC(1,2), ABC(1,3), RTEMP,
     5                   AT(1,1), AT(1,2), AT(1,3), DQP, DQM)
  400       CONTINUE
C
C     K Block Inversion:
C     Calculate INPL to be the number of planes that will fit
C     in the memory allocated.  Actually vectorize over NPL
C     which takes into account if the last loop would be longer
C     then IDIM.  J is the primary vectorization direction and
C     I is the secondary vectorization direction.
C     Make sure that INPL is no larger than the maximum size of the grid.
C
         ELSE
            INPL = MXABC / ( (JDIM-1) * (KDIM-1) )
            INPL = MIN (INPL, (IDIM-1))
            NPL  = INPL
            DO 410 I = 2, IDIM, INPL
               IF ( (I+INPL) .GT. IDIM ) NPL = IDIM - I + 1
               CALL AF3SWK (IDIM, JDIM, KDIM, NPL, I,
     1                      Q, PROPS, NPPTS, S, VOL, DTJ, RES, QP, QM,
     2                      STEMP, IBCDAT, NBCS, IFLUX, VISCOS(3),ITURB,
     3                      ABC(1,1), ABC(1,2), ABC(1,3), RTEMP,
     5                      AT(1,1), AT(1,2), AT(1,3), AI, DQP)
  410       CONTINUE
         ENDIF
      ENDIF
C
C     Conservative Variable Update
C
      CALL UPDATE (IDIM, JDIM, KDIM, IPSTRT, IPEND, Q, RES, ITURB,
     1             QP, QM, QMIN, NFIXQ, NRELIZ, FHAT, IERRCD)
C
C     Finished with 3 Factor AF
      RETURN
      END
      SUBROUTINE AF3SWI (IDIM, JDIM, KDIM, NPL, KSTART,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES, QP, QM,
     2                   STEMP, IBCDAT, NBCS, IFLUX, VISCOS, ITURB,
     3                   A, B, C, RTEMP, APT, AMT, ART, AI, WORK)
C
C     Routine to do the I implicit sweep of three factor
C     Approximate Factorisation
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     NPL            : Number of IxJ planes to invert simultaneously
C     KSTART         : K to begin the multiple plane work on
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     STEMP          : Storage for metrics passed to Jacobian routine
C                      including the area term
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence modeling scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(I-1) + B*DQ(I) + C*DQ(I+1) = RTEMP
C                      Implicit in the I direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.  The primary
C                      vectorization direction is J and the secondary
C                      (for multiple plane vectorization) is K.  These
C                      are stored in the first index for a unit stride
C                      in the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C     APT,AMT,ART    : Storage on a plane (IxJ) to calculate the
C                      Jacobians
C     AI             : Identity matrix
C     WORK           : Temporary array of size NPTS*4 for Jacobian calculation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          QP    (IDIM,2:JDIM,NQ),
     2          QM    (IDIM,2:JDIM,NQ),
     3          STEMP (IDIM,2:JDIM,4),
     4          WORK  (IDIM,2:JDIM,4)
C
C     Storage for the implicit system to invert
C     Store the system only in the internal portion of
C     the field and use explicit boundary conditions
C     of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:JDIM,NPL,2:IDIM,NRANK,NRANK),
     1          B     (2:JDIM,NPL,2:IDIM,NRANK,NRANK),
     2          C     (2:JDIM,NPL,2:IDIM,NRANK,NRANK),
     3          RTEMP (2:JDIM,NPL,2:IDIM,NF)
C
C     Storage for the Jacobians used to calculate A,B and C
C
      DIMENSION APT   (IDIM,2:JDIM,NRANK,NRANK),
     1          AMT   (IDIM,2:JDIM,NRANK,NRANK),
     2          ART   (IDIM,2:JDIM,NRANK,NRANK)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
      LOGICAL   VISCOS
C
C     Loop over NPL planes of IxJ, forming the tridiagonal system
C     on on IxJ plane at a time.  Invert the system after all NPL
C     planes have been created.  This reduces the amount of temporary
C     storage required to store QP,QM and the Jacobian matrices
C     but also allows the vectorization of the inversion over
C     NPL*(JDIM-1) as memory allows.
C
      DO 500 KPL = 1, NPL
         K = KSTART + KPL - 1
C
C     Calculate QP,QM using first order
C
         DO 130 L = 1, NQ
            DO 120 J = 2, JDIM
               DO 110 I = 1, IDIM
                  QP(I,J,L) = Q(J,K,I+1,L)
                  QM(I,J,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
C
C     Store the metrics for the Jacobian calculation
C     including the area term
C
         DO 190 L = 1, 4
            DO 180 J = 2, JDIM
               DO 170 I = 1, IDIM
                  STEMP(I,J,L) = S(J,K,I,L,1)
  170          CONTINUE
  180       CONTINUE
  190    CONTINUE
C
C     Calculate Jacobians and set up matrices to invert
C
         NPTS = IDIM * (JDIM - 1)
C
C     Roe's scheme
C          APT = dF/dQ(QP)
C          AMT = dF/dQ(QM)
C
         IF (IFLUX .EQ. IFROE) THEN
            CALL DFROE (ITURB, NPTS, QP, QM, STEMP, APT, AMT, ART, WORK)
C
            DO 214 L = 1, NRANK
               DO 213 M = 1, NRANK
                  DO 212 I = 2, IDIM
                     DO 211 J = 2, JDIM
                        DTTERM         = 0.5E0 /
     1                                 ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                                 + TDPDEL * VOL(J,K,I) / TIMEDT )
                        A(J,KPL,I,L,M) = - DTTERM *
     1                                   (AMT(I-1,J,L,M)+ART(I-1,J,L,M))
                        B(J,KPL,I,L,M) =   AI(L,M) + DTTERM *
     1                                   ( AMT(I,J,L,M)-APT(I-1,J,L,M)
     2                                   + ART(I,J,L,M)+ART(I-1,J,L,M) )
                        C(J,KPL,I,L,M) =   DTTERM *
     1                                   ( APT(I,J,L,M)-ART(I,J,L,M) )
  211                CONTINUE
  212             CONTINUE
  213          CONTINUE
  214       CONTINUE
C
         ELSE
            write (iout,'(a)') ' *** Invalid Flux Function ***'
            stop
         ENDIF
C
C     Implicit Viscous Terms
C          PROPS(2) is RMUT
C          AP = DF(i+1/2)/DQ(i+1)
C          AM = DF(i+1/2)/DQ(i)
C          PROPS(1) is RMU and PROPS(2) is RMUT
C          Use QM as temporary space to store U,V,W,RMUI,RMUTI
C          Use QP as temporary space to store T - being
C          careful as T is dimensioned as IDIM+1, therefore
C          store T in QP(1) and leave QP(2) unused in this call.
C
C        IF ( VISCOS ) THEN
C           CALL DFVTLI (IDIM, JDIM, KDIM, K, 2, IDIM,
C    1                   Q, PROPS(1,1), PROPS(1,2), S, VOL,
C    2                   IBCDAT, NBCS,
C    3                   QP(1,2,1), QM(1,2,1), QM(1,2,2), QM(1,2,3),
C    4                   QM(1,2,4), QM(1,2,5), APT, AMT)
C
C           DO 324 L = 1, NRANK
C              DO 323 M = 1, NRANK
C                 DO 322 I = 2, IDIM
C                    DO 321 J = 2, JDIM
C                       DTTERM       = 1.0E0 /
C    1                                 ( TDPDTJ / (TDTHET*DTJ(J,K,I))
C    2                                 + TDPDEL * VOL(J,K,I) / TIMEDT )
C                       A(J,KPL,I,L,M) = A(J,KPL,I,L,M)
C    1                    + DTTERM * AMT(I-1,J,L,M)
C                       B(J,KPL,I,L,M) = B(J,KPL,I,L,M)
C    1                    + DTTERM *
C    2                            ( APT(I,J,L,M)-AMT(I-1,J,L,M) )
C                       C(J,KPL,I,L,M) = C(J,KPL,I,L,M)
C    1                    - DTTERM * APT(I,J,L,M)
C 321                CONTINUE
C 322             CONTINUE
C 323          CONTINUE
C 324       CONTINUE
C        ENDIF
C
C     Store Residual array for inversion
C
         DO 490 L = 1, NF
            DO 480 I = 2, IDIM
               DO 470 J = 2, JDIM
                  RTEMP(J,KPL,I,L) = RES(J,K,I,L)
  470          CONTINUE
  480       CONTINUE
  490    CONTINUE
C
  500 CONTINUE
C
C     Invert the block tridiagonal system:
C     A*DQ(I-1) + B*DQ(I) + C*DQ(I+1) = RTEMP
C
      NPTS = IDIM - 1
      NSIM = NPL * (JDIM - 1)
      CALL VBTRI (NPTS, NSIM, NRANK, A, B, C, RTEMP)
C
C     Update the residual array
C
      DO 890 KPL = 1, NPL
         K = KSTART + KPL - 1
         DO 880 L = 1, NF
            DO 870 I = 2, IDIM
               DO 860 J = 2, JDIM
                  RES(J,K,I,L) = RTEMP(J,KPL,I,L)
  860          CONTINUE
  870       CONTINUE
  880    CONTINUE
  890 CONTINUE
C
C     Finished with the I implicit sweep of three factor AF
      RETURN
      END
      SUBROUTINE AF3SWJ (IDIM, JDIM, KDIM, NPL, ISTART,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES, QP, QM,
     2                   STEMP, IBCDAT, NBCS, IFLUX, VISCOS, ITURB,
     3                   A, B, C, RTEMP, APT, AMT, ART, AI, WORK)
C
C     Routine to do the J implicit sweep of three factor
C     Approximate Factorisation
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     NPL            : Number of JxK planes to invert simultaneously
C     ISTART         : I to begin the multiple plane work on
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     STEMP          : Storage for metrics passed to Jacobian routine
C                      including the area term
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence modeling scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(J-1) + B*DQ(J) + C*DQ(J+1) = RTEMP
C                      Implicit in the J direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.  The primary
C                      vectorization direction is I and the secondary
C                      (for multiple plane vectorization) is K.  These
C                      are stored in the first index for a unit stride
C                      in the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C     APT,AMT,ART    : Storage on a plane (IxJ) to calculate the
C                      Jacobians
C     AI             : Identity matrix
C     WORK           : Temporary array of size NPTS*4 for Jacobian calculation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          QP    (JDIM,2:KDIM,NQ),
     2          QM    (JDIM,2:KDIM,NQ),
     3          STEMP (JDIM,2:KDIM,4),
     4          WORK  (JDIM,2:KDIM,4)
C
C     Storage for the implicit system to invert
C     Store the system only in the internal portion of
C     the field and use explicit boundary conditions
C     of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:KDIM,NPL,2:JDIM,NRANK,NRANK),
     1          B     (2:KDIM,NPL,2:JDIM,NRANK,NRANK),
     2          C     (2:KDIM,NPL,2:JDIM,NRANK,NRANK),
     3          RTEMP (2:KDIM,NPL,2:JDIM,NF)
C
C     Storage for the Jacobians used to calculate A,B and C
C
      DIMENSION APT   (JDIM,2:KDIM,NRANK,NRANK),
     1          AMT   (JDIM,2:KDIM,NRANK,NRANK),
     2          ART   (JDIM,2:KDIM,NRANK,NRANK)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
      LOGICAL   VISCOS
C
C     Loop over NPL planes of JxK, forming the tridiagonal system
C     on on JxK plane at a time.  Invert the system after all NPL
C     planes have been created.  This reduces the amount of temporary
C     storage required to store QP,QM and the Jacobian matrices
C     but also allows the vectorization of the inversion over
C     NPL*(KDIM-1) as memory allows.
C
      DO 500 IPL = 1, NPL
         I = ISTART + IPL - 1
C
C     Calculate QP,QM using first order
C
         DO 130 L = 1, NQ
            DO 120 K = 2, KDIM
               DO 110 J = 1, JDIM
                  QP(J,K,L) = Q(J+1,K,I,L)
                  QM(J,K,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
C
C     Store the metrics for the Jacobian calculation
C     including the area term
C
         DO 190 L = 1, 4
            DO 180 K = 2, KDIM
               DO 170 J = 1, JDIM
                  STEMP(J,K,L) = S(J,K,I,L,2)
  170          CONTINUE
  180       CONTINUE
  190    CONTINUE
C
C     Calculate Jacobians and set up matrices to invert
C
         NPTS = JDIM * (KDIM - 1)
C
C     Roe's scheme
C          APT = dF/dQ(QP)
C          AMT = dF/dQ(QM)
C
         IF (IFLUX .EQ. IFROE) THEN
            CALL DFROE (ITURB, NPTS, QP, QM, STEMP, APT, AMT, ART, WORK)
C
            DO 214 L = 1, NRANK
               DO 213 M = 1, NRANK
                  DO 212 K = 2, KDIM
                     DO 211 J = 2, JDIM
                        DTTERM         = 0.5E0 /
     1                                 ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                                 + TDPDEL * VOL(J,K,I) / TIMEDT )
                        A(K,IPL,J,L,M) = - DTTERM *
     1                                   (AMT(J-1,K,L,M)+ART(J-1,K,L,M))
                        B(K,IPL,J,L,M) =   AI(L,M) + DTTERM *
     1                                   ( AMT(J,K,L,M)-APT(J-1,K,L,M)
     2                                   + ART(J,K,L,M)+ART(J-1,K,L,M) )
                        C(K,IPL,J,L,M) =   DTTERM *
     1                                   ( APT(J,K,L,M)-ART(J,K,L,M) )
  211                CONTINUE
  212             CONTINUE
  213          CONTINUE
  214       CONTINUE
C
         ELSE
            write (iout,'(a)') ' *** Invalid Flux Function ***'
            stop
         ENDIF
C
C     Implicit Viscous Terms
C
C          PROPS(2) is RMUT
C          AP = DF(j+1/2)/DQ(j+1)
C          AM = DF(j+1/2)/DQ(j)
C          PROPS(1) is RMU and PROPS(2) is RMUT
C          Use QM as temporary space to store U,V,W,RMUJ,RMUTJ
C          Use QP as temporary space to store T - being
C          careful as T is dimensioned as JDIM+1, therefore
C          store T in QP(1) and leave QP(2) unused in this call.
C
         IF ( VISCOS ) THEN
            CALL DFVISJ (IDIM, JDIM, KDIM, I, ITURB,
     1                   Q, PROPS(1,1), PROPS(1,2), S, VOL,
     2                   IBCDAT, NBCS,
     3                   QP(1,2,1), QM(1,2,1), QM(1,2,2), QM(1,2,3),
     4                   QM(1,2,4), QM(1,2,5), APT, AMT)
C
            DO 324 L = 1, NRANK
               DO 323 M = 1, NRANK
                  DO 322 K = 2, KDIM
                     DO 321 J = 2, JDIM
                        DTTERM         = 1.0E0 /
     1                                 ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                                 + TDPDEL * VOL(J,K,I) / TIMEDT )
                        A(K,IPL,J,L,M) = A(K,IPL,J,L,M)
     1                    + DTTERM * AMT(J-1,K,L,M)
                        B(K,IPL,J,L,M) = B(K,IPL,J,L,M)
     1                    + DTTERM * ( APT(J,K,L,M)-AMT(J-1,K,L,M) )
                        C(K,IPL,J,L,M) = C(K,IPL,J,L,M)
     1                    - DTTERM * APT(J,K,L,M)
  321                CONTINUE
  322             CONTINUE
  323          CONTINUE
  324       CONTINUE
         ENDIF
C
C     Store Residual array for inversion
C
         DO 490 L = 1, NF
            DO 480 K = 2, KDIM
               DO 470 J = 2, JDIM
                  RTEMP(K,IPL,J,L) = RES(J,K,I,L)
  470          CONTINUE
  480       CONTINUE
  490    CONTINUE
C
  500 CONTINUE
C
C     Invert the block tridiagonal system:
C     A*DQ(J-1) + B*DQ(J) + C*DQ(J+1) = RTEMP
C
      NPTS = JDIM - 1
      NSIM = NPL * (KDIM - 1)
      CALL VBTRI (NPTS, NSIM, NRANK, A, B, C, RTEMP)
C
C     Update the residual array
C
      DO 890 IPL = 1, NPL
         I = ISTART + IPL - 1
         DO 880 L = 1, NF
            DO 870 K = 2, KDIM
               DO 860 J = 2, JDIM
                  RES(J,K,I,L) = RTEMP(K,IPL,J,L)
  860          CONTINUE
  870       CONTINUE
  880    CONTINUE
  890 CONTINUE
C
C     Finished with the J implicit sweep of three factor AF
      RETURN
      END
      SUBROUTINE AF3SWK (IDIM, JDIM, KDIM, NPL, ISTART,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES, QP, QM,
     2                   STEMP, IBCDAT, NBCS, IFLUX, VISCOS, ITURB,
     3                   A, B, C, RTEMP, APT, AMT, ART, AI, WORK)
C
C     Routine to do the K implicit sweep of three factor
C     Approximate Factorisation
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     NPL            : Number of KxJ planes to invert simultaneously
C     ISTART         : I to begin the multiple plane work on
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     STEMP          : Storage for metrics passed to Jacobian routine
C                      including the area term
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence modeling scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(K-1) + B*DQ(K) + C*DQ(K+1) = RTEMP
C                      Implicit in the I direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.  The primary
C                      vectorization direction is J and the secondary
C                      (for multiple plane vectorization) is I.  These
C                      are stored in the first index for a unit stride
C                      in the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C     APT,AMT,ART    : Storage on a plane (KxJ) to calculate the
C                      Jacobians
C     AI             : Identity matrix
C     WORK           : Temporary array of size NPTS*4 for Jacobian calculation
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          QP    (KDIM,2:JDIM,NQ),
     2          QM    (KDIM,2:JDIM,NQ),
     3          STEMP (KDIM,2:JDIM,4),
     4          WORK  (KDIM,2:JDIM,4)
C
C     Storage for the implicit system to invert
C     Store the system only in the internal portion of
C     the field and use explicit boundary conditions
C     of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:JDIM,NPL,2:KDIM,NRANK,NRANK),
     1          B     (2:JDIM,NPL,2:KDIM,NRANK,NRANK),
     2          C     (2:JDIM,NPL,2:KDIM,NRANK,NRANK),
     3          RTEMP (2:JDIM,NPL,2:KDIM,NF)
C
C     Storage for the Jacobians used to calculate A,B and C
C
      DIMENSION APT   (KDIM,2:JDIM,NRANK,NRANK),
     1          AMT   (KDIM,2:JDIM,NRANK,NRANK),
     2          ART   (KDIM,2:JDIM,NRANK,NRANK)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
      LOGICAL   VISCOS
C
C     Loop over NPL planes of KxJ, forming the tridiagonal system
C     on on KxJ plane at a time.  Invert the system after all NPL
C     planes have been created.  This reduces the amount of temporary
C     storage required to store QP,QM and the Jacobian matrices
C     but also allows the vectorization of the inversion over
C     NPL*(JDIM-1) as memory allows.
C
      DO 500 IPL = 1, NPL
         I = ISTART + IPL - 1
C
C     Calculate QP,QM using first order
C
         DO 130 L = 1, NQ
            DO 120 J = 2, JDIM
               DO 110 K = 1, KDIM
                  QP(K,J,L) = Q(J,K+1,I,L)
                  QM(K,J,L) = Q(J,K,I,L)
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
C
C     Store the metrics for the Jacobian calculation
C     including the area term
C
         DO 190 L = 1, 4
            DO 180 J = 2, JDIM
               DO 170 K = 1, KDIM
                  STEMP(K,J,L) = S(J,K,I,L,3)
  170          CONTINUE
  180       CONTINUE
  190    CONTINUE
C
C     Calculate Jacobians and set up matrices to invert
C
         NPTS = KDIM * (JDIM - 1)
C
C     Roe's scheme
C          APT = dF/dQ(QP)
C          AMT = dF/dQ(QM)
C
         IF (IFLUX .EQ. IFROE) THEN
            CALL DFROE (ITURB, NPTS, QP, QM, STEMP, APT, AMT, ART, WORK)
C
            DO 214 L = 1, NRANK
               DO 213 M = 1, NRANK
                  DO 212 K = 2, KDIM
                     DO 211 J = 2, JDIM
                        DTTERM         = 0.5E0 /
     1                                 ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                                 + TDPDEL * VOL(J,K,I) / TIMEDT )
                        A(J,IPL,K,L,M) = - DTTERM *
     1                                   (AMT(K-1,J,L,M)+ART(K-1,J,L,M))
                        B(J,IPL,K,L,M) =   AI(L,M) + DTTERM *
     1                                   ( AMT(K,J,L,M)-APT(K-1,J,L,M)
     2                                   + ART(K,J,L,M)+ART(K-1,J,L,M) )
                        C(J,IPL,K,L,M) =   DTTERM *
     1                                   ( APT(K,J,L,M)-ART(K,J,L,M) )
  211                CONTINUE
  212             CONTINUE
  213          CONTINUE
  214       CONTINUE
C
         ELSE
            write (iout,'(a)') ' *** Invalid Flux Function ***'
            stop
         ENDIF
C
C     Implicit Viscous Terms
C
C          PROPS(2) is RMUT
C          AP = DF(i+1/2)/DQ(i+1)
C          AM = DF(i+1/2)/DQ(i)
C          PROPS(1) is RMU and PROPS(2) is RMUT
C          Use QM as temporary space to store U,V,W,RMUK,RMUTK
C          Use QP as temporary space to store T - being
C          careful as T is dimensioned as KDIM+1, therefore
C          store T in QP(1) and leave QP(2) unused in this call.
C
         IF ( VISCOS ) THEN
            CALL DFVISK (IDIM, JDIM, KDIM, I, ITURB,
     1                   Q, PROPS(1,1), PROPS(1,2), S, VOL,
     2                   IBCDAT, NBCS,
     3                   QP(1,2,1), QM(1,2,1), QM(1,2,2), QM(1,2,3),
     4                   QM(1,2,4), QM(1,2,5), APT, AMT)
C
            DO 324 L = 1, NRANK
               DO 323 M = 1, NRANK
                  DO 322 K = 2, KDIM
                     DO 321 J = 2, JDIM
                        DTTERM         = 1.0E0 /
     1                                 ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                                 + TDPDEL * VOL(J,K,I) / TIMEDT )
                        A(J,IPL,K,L,M) = A(J,IPL,K,L,M)
     1                    + DTTERM * AMT(K-1,J,L,M)
                        B(J,IPL,K,L,M) = B(J,IPL,K,L,M)
     1                    + DTTERM * ( APT(K,J,L,M)-AMT(K-1,J,L,M) )
                        C(J,IPL,K,L,M) = C(J,IPL,K,L,M)
     1                    - DTTERM * APT(K,J,L,M)
  321                CONTINUE
  322             CONTINUE
  323          CONTINUE
  324       CONTINUE
         ENDIF
C
C     Store Residual array for inversion
C
         DO 490 L = 1, NF
            DO 480 K = 2, KDIM
               DO 470 J = 2, JDIM
                  RTEMP(J,IPL,K,L) = RES(J,K,I,L)
  470          CONTINUE
  480       CONTINUE
  490    CONTINUE
C
  500 CONTINUE
C
C     Invert the block tridiagonal system:
C     A*DQ(K-1) + B*DQ(K) + C*DQ(K+1) = RTEMP
C
      NPTS = KDIM - 1
      NSIM = NPL * (JDIM - 1)
      CALL VBTRI (NPTS, NSIM, NRANK, A, B, C, RTEMP)
C
C     Update the residual array
C
      DO 890 IPL = 1, NPL
         I = ISTART + IPL - 1
         DO 880 L = 1, NF
            DO 870 K = 2, KDIM
               DO 860 J = 2, JDIM
                  RES(J,K,I,L) = RTEMP(J,IPL,K,L)
  860          CONTINUE
  870       CONTINUE
  880    CONTINUE
  890 CONTINUE
C
C     Finished with the K implicit sweep of three factor AF
      RETURN
      END
      SUBROUTINE PISRC (IDIM, JDIM, KDIM, NPL, ISTART, IMODEL, IFDELQ,
     1                  Q, PROPS, NPPTS, S, VOL, RC, DTJ, RES,
     2                  MXSECT, DQP, DQM, QP, QM, TAU, FM, STEMP,
     3                  TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                  SRC, IBCDAT, NBCS, B, RTEMP, AI, AT)
C
C Routine to perform the Point Implicit Source term treatment
C This routine is organized as follows:
C     1. Diagonal implicit source term treatment
C     2. Block    implicit source term treatment
C     3. Error
C
C IDIM,JDIM,KDIM : Dimensions of current block
C NPL            : Number of JxK planes to invert simultaneously
C ISTART         : I to begin the multiple plane work on
C IMODEL         : Turbulence model array
C IFDELQ         : Array controlling calculation of delq
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C RC             : Position vector at cell centers
C DTJ            : Time step divided by cell volume
C RES            : Residual - must be over the entire field for
C                  this time integration scheme
C MXSECT         : Maximum size of any (ixj, jxk or ixk)
C                  (used in dimensioning of temporary space used
C                   for calculating q(+,-) and f.
C DQP,DQM        : Storage for delta q = q(j) - q(j-1)
C QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C TAU            : Storage for Reynolds stresses
C FM             : Fluxes at cell interfaces - currently temp storage
C STEMP          : Temporary storage for metrics - currently temp stor.
C TKE            : Turbulent kinetic energy
C ETILDE         : Epsilon^tilde
C XSIW           :
C FDAMP          : Damping functions F1, F2
C EPSC           :
C PDIL           :
C SIJ            :
C WIJ            :
C SRC            : Source terms at cell (J,K)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C B              : Diagonal term = I + DTJ D (D = dS/dQ)
C AI             : Identity matrix
C AT             : Temporary storage of implicit source terms
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL),
     1          IFDELQ(NQ)
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          RC    (JDIM+1,KDIM+1,IDIM+1,3),
     5          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF)
C
      DIMENSION DQP   (MXSECT,NQ),
     1          DQM   (MXSECT,NQ),
     2          QP    (MXSECT,NQ),
     3          QM    (MXSECT,NQ),
     4          TAU   (MXSECT,6),
     5          FM    (MXSECT,NQ),
     6          STEMP (MXSECT,4),
     7          TKE   (MXSECT),
     8          ETILDE(MXSECT),
     9          XSIW  (MXSECT),
     A          FDAMP (MXSECT,2),
     B          EPSC  (MXSECT),
     C          PDIL  (MXSECT),
     D          SIJ   (MXSECT,6),
     E          WIJ   (MXSECT,6),
     F          SRC   (2:JDIM,2:KDIM,NF)
C
      DIMENSION B     (2:KDIM,NPL,2:JDIM,NRANK,NRANK),
     1          RTEMP (2:KDIM,NPL,2:JDIM,NF)
C
      DIMENSION AI    (NRANK,NRANK)
C
      DIMENSION AT    (2:JDIM,2:KDIM,NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
C Local variable:
C
      LOGICAL   ISAVPR
C
      ITURB  = IMODEL(1)
C
C Do not store CMUSTAR from local array back into global array when doing
C implicit source terms.  This has been done in RESID.
C
      ISAVPR = .FALSE.
C
C 1.  Diagonal implicit source term treatment
C
C     impsrc = 0
      IF (IMPSRC .EQ. ISDIAG) THEN
         NPRLIM = 0
         NPRNEG = 0
         DO 200 IPL = 1, NPL
            I = ISTART + IPL - 1
C
C     Temporary variables passed to the source term evaluation routine:
C         FM(2-) for PROPSC (properties in one-dimensional array - this is
C                            passed in using FM.  Must always be sure that
C                            NP+1 <= NQ or else will need to fix this)
C         STEMP      for SN   (Wall normals - needed in Reynolds stress model)
C         QM         for DQDX (derivatives of Q in x direction at cell centers)
C         DQP        for DQDY (derivatives of Q in y direction at cell centers)
C         DQM        for DQDZ (derivatives of Q in z direction at cell centers)
C         FM(1)      for DEL2K (Laplacian of turbulent kinetic energy)
C
            CALL SOURCE (IDIM, JDIM, KDIM, I, NPRLIM, NPRNEG,
     1                   Q, PROPS, NPPTS, S, VOL, RC,
     2                   QP, FM(1,2), STEMP, QM, DQP, DQM, FM(1,1),
     3                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                   TAU, SRC, IBCDAT, NBCS,
     5                   IFLUX, IMODEL, IFDELQ, ISAVPR)
C
C     Divide residual by 1 - delta(t)*min(source/(rho phi), 0) as the
C     diagonal inversion of the point implicit treatment (after work
C     of Huang and Spallart,Allmaras)
C
            LSTRT = 6
            DO 190 L = LSTRT, NQ
               DO 180 K = 2, KDIM
                  DO 170 J = 2, JDIM
                     DTTERM = 1.0E0 /
     1                        ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                        + TDPDEL * VOL(J,K,I) / TIMEDT )
                     PHI    = Q(J,K,I,L)
                     SGNPHI = SIGN (1.E0, PHI)
                     RHOPHI = Q(J,K,I,1) * PHI + SGNPHI * RSMALL
C--                  BDIAG  = MIN (SRC(J,K,L)*VOL(J,K,I)/RHOPHI, 0.E0)
                     BDIAG  = - ABS ( SRC(J,K,L)*VOL(J,K,I)/RHOPHI )
                     DENOM  = 1.E0 - DTTERM * BDIAG
                     RES(J,K,I,L) = RES(J,K,I,L) / DENOM
  170             CONTINUE
  180          CONTINUE
  190       CONTINUE
  200    CONTINUE
C
C 2.  Block implicit source terms
C     Loop over NPL planes of JxK
C
      ELSE IF (IMPSRC .EQ. ISBLOC) THEN
         DO 500 IPL = 1, NPL
            I = ISTART + IPL - 1
C
C     Temporary variables passed to the source term evaluation routine:
C         FM(2-) for PROPSC (properties in one-dimensional array - this is
C                            passed in using FM.  Must always be sure that
C                            NP+1 <= NQ or else will need to fix this)
C         STEMP      for SN   (Wall normals - needed in Reynolds stress model)
C         QM         for DQDX (derivatives of Q in x direction at cell centers)
C         DQP        for DQDY (derivatives of Q in y direction at cell centers)
C         DQM        for DQDZ (derivatives of Q in z direction at cell centers)
C         FM(1)      for DEL2K (Laplacian of turbulent kinetic energy)
C
            CALL SOURCE (IDIM, JDIM, KDIM, I, NPRLIM, NPRNEG,
     1                   Q, PROPS, NPPTS, S, VOL, RC,
     2                   QP, FM(1,2), STEMP, QM, DQP, DQM, FM(1,1),
     3                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                   TAU, SRC, IBCDAT, NBCS,
     5                   IFLUX, IMODEL, IFDELQ, ISAVPR)
C
C     Add the implicit source terms to the identity matrix
C     Temporary variables passed to the source term evaluation routine:
C         QP     for QC (variables in one-dimensional array)
C         FM(2-) for PROPSC (properties in one-dimensional array - this is
C                            passed in using FM.  Must always be sure that
C                            NP+1 <= NQ or else will need to fix this)
C         QM         for DQDX (derivatives of Q in x direction at cell centers)
C         DQP        for DQDY (derivatives of Q in y direction at cell centers)
C         DQM        for DQDZ (derivatives of Q in z direction at cell centers)
C         FM(1)      for DEL2K (Laplacian of turbulent kinetic energy)
C
            CALL DSRCDQ (IDIM, JDIM, KDIM, I, IMODEL,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   QP, FM(1,2), QM, DQP, DQM, FM(1,1),
     3                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                   TAU, SRC, IBCDAT, NBCS, AT)
C
            DO 340 L = 1, NRANK
               DO 330 M = 1, NRANK
                  DO 320 K = 2, KDIM
                     DO 310 J = 2, JDIM
                        DTTERM = 1.0E0 /
     1                           ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                           + TDPDEL * VOL(J,K,I) / TIMEDT )
                        B(K,IPL,J,L,M) = AI(L,M) - DTTERM * AT(J,K,L,M)
  310                CONTINUE
  320             CONTINUE
  330          CONTINUE
  340       CONTINUE
C
C     Store residual array for inversion
C
            DO 490 L = 1, NF
               DO 480 K = 2, KDIM
                  DO 470 J = 2, JDIM
                     RTEMP(K,IPL,J,L) = RES(J,K,I,L)
  470             CONTINUE
  480          CONTINUE
  490       CONTINUE
C
  500    CONTINUE
C
C     Finished forming B = I - DTJ D(S)
C
C     Invert the diagonal system:
C          B * DQ = RTEMP
C
         NPTS = JDIM - 1
         NSIM = NPL * (KDIM - 1)
         CALL VBDIA (NPTS, NSIM, NRANK, B, RTEMP)
C
C     Update the residual array
C
         DO 890 IPL = 1, NPL
            I = ISTART + IPL - 1
            DO 880 L = 1, NF
               DO 870 K = 2, KDIM
                  DO 860 J = 2, JDIM
                     RES(J,K,I,L) = RTEMP(K,IPL,J,L)
  860             CONTINUE
  870          CONTINUE
  880       CONTINUE
  890    CONTINUE
C
C 3.  Error
C
      ELSE
         WRITE (IOUT,1000) IMPSRC
         STOP
      ENDIF
C
C     Finished with the implicit source term inversion
      RETURN
 1000 FORMAT (' ','PISRC : ERROR-> Invalid implicit source terms ',
     1            'specified = ',I10,
     2       /' ', 8X,'RUN ABORTING!')
      END
      SUBROUTINE AF3DI  (IDIM, JDIM, KDIM, K,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES,
     2                   QI, PROPSI, STEMP, VOLI, EL, EM, TKE,
     3                   IBCDAT, NBCS, IFLUX, VISCOS, ITURB,
     4                   A, B, C, RT, RTEMP, RTEMP2,
     5                   EIGENP, EIGENM, EIGEN)
C
C     Routine to do the diagonalized I implicit sweep of three factor
C     Approximate Factorisation
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     K              : K plane to perform I implicit sweep on
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     QI             : Q at cell center for diagonalized scheme
C     PROPSI         : Properties at cell centers for eigenvalue routine
C     STEMP          : Storage for metrics passed to eigenvalue routine
C                      including the area term
C     VOLI           : Storage for volum,e passed to eigenvalue routine
C     EL, EM         : Unit tangency vectors
C     TKE            : Turbulent kinetic energy
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence modeling scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(I-1) + B*DQ(I) + C*DQ(I+1) = RTEMP
C                      Implicit in the I direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C     EIGENP,M       : Storage for eigenvalues(+,-)
C     EIGEN          : Storage for viscous eigenvalue
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          QI    (2:JDIM,1:IDIM+1,NQ),
     2          PROPSI(2:JDIM,1:IDIM+1,NP),
     3          STEMP (2:JDIM,1:IDIM+1,4),
     4          VOLI  (2:JDIM,1:IDIM+1),
     5          EL    (2:JDIM,1:IDIM+1,3),
     6          EM    (2:JDIM,1:IDIM+1,3),
     7          TKE   (2:JDIM,1:IDIM+1)
C
C     Storage for the implicit system to invert.
C     Store the system only in the internal portion of the field and use
C     explicit boundary conditions of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:JDIM,2:IDIM),
     1          B     (2:JDIM,2:IDIM),
     2          C     (2:JDIM,2:IDIM),
     3          RT    (2:JDIM,2:IDIM),
     4          RTEMP (2:JDIM,1:IDIM+1,NF),
     5          RTEMP2(2:JDIM,1:IDIM+1,NF)
C
C     Storage for the eigenvalues used to calculate A,B and C
C
      DIMENSION EIGENP(2:JDIM,1:IDIM+1,3),
     1          EIGENM(2:JDIM,1:IDIM+1,3),
     2          EIGEN (2:JDIM,1:IDIM+1,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      LOGICAL   VISCOS
C
C     Store Q in QI at cell centers
C
      DO 130 L = 1, NQ
         DO 120 I = 1, IDIM+1
            DO 110 J = 2, JDIM
               QI(J,I,L) = Q(J,K,I,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C     Calculate the metrics for the at the cell centers for the eigenvalues
C     When prevent division by zero, don't set S=<1,1,1> since TANVEC
C     calculates the tangency vectors by crossing S with <1,1,1>.
C
      DO 180 I = 1, IDIM+1
         DO 170 J = 2, JDIM
            SX           = 0.5E0*( S(J,K,I  ,1,1)*S(J,K,I  ,4,1)
     1                           + S(J,K,I-1,1,1)*S(J,K,I-1,4,1) )
            SY           = 0.5E0*( S(J,K,I  ,2,1)*S(J,K,I  ,4,1)
     1                           + S(J,K,I-1,2,1)*S(J,K,I-1,4,1) )
            SZ           = 0.5E0*( S(J,K,I  ,3,1)*S(J,K,I  ,4,1)
     1                           + S(J,K,I-1,3,1)*S(J,K,I-1,4,1) )
            STEMP(J,I,4) = SQRT (SX*SX + SY*SY + SZ*SZ)
            IF (STEMP(J,I,4) .GT. 0.E0) THEN
               STEMP(J,I,1) = SX / STEMP(J,I,4)
               STEMP(J,I,2) = SY / STEMP(J,I,4)
               STEMP(J,I,3) = SZ / STEMP(J,I,4)
            ELSE
               STEMP(J,I,1) =   SHATX
               STEMP(J,I,2) = - SHATY
               STEMP(J,I,3) =   SHATZ
            ENDIF
  170    CONTINUE
  180 CONTINUE
C
C     Calculate unit tangency vectors
C
      NPTS = (IDIM + 1) * (JDIM - 1)
      CALL TANVEC (NPTS, STEMP, EL, EM)
C
C     Calculate RTEMP = T[-1] * RES
C
      DO 230 L = 1, NF
         DO 220 I = 1, IDIM+1
            DO 210 J = 2, JDIM
               RTEMP2(J,I,L) = RES(J,K,I,L)
  210       CONTINUE
  220    CONTINUE
  230 CONTINUE
C
      CALL GETTKE (ITURB, NPTS, QI, TKE)
      CALL TINVR  (ITURB, NPTS, QI, STEMP, EL, EM, TKE, RTEMP2, RTEMP)
C
C     Calculate eigenvalues
C
      CALL EIGENI (ITURB, NPTS, QI, STEMP, EIGENP, EIGENM)
C
C     Viscous eigenvalues
C
      IF (VISCOS) THEN
         DO 320 L = 1, NP
            DO 310 I = 1, IDIM+1
               DO 300 J = 2, JDIM
                  PROPSI(J,I,L) = PROPS(J,K,I,L)
  300          CONTINUE
  310       CONTINUE
  320    CONTINUE
C
         DO 340 I = 1, IDIM+1
            DO 330 J = 2, JDIM
               VOLI(J,I) = VOL(J,K,I)
  330       CONTINUE
  340    CONTINUE
C
         CALL EIGENV (ITURB, NPTS, QI, PROPSI, STEMP, VOLI, EIGEN)
      ENDIF
C
C     Setup and invert each system
C
      DO 490 L = 1, NRANK
         IF (L .EQ. 4) THEN
            M = 2
         ELSE IF (L .EQ. 5) THEN
            M = 3
         ELSE
            M = 1
         ENDIF
C
C     Viscous eigenvalue
C
         IF (L .LE. 5) THEN
            MV = 1
         ELSE IF (L .EQ. NQ) THEN
            MV = 3
         ELSE
            MV = 2
         ENDIF
C
C     Fourth-order central scheme
C
         IF (FOURTH) THEN
            DO 410 I = 2, IDIM
               DO 400 J = 2, JDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (J,I) = - DTTERM*(EIGENP(J,I-1,M) + EIGENM(J,I-1,M))
                  B (J,I) =   1.0E0
                  C (J,I) =   DTTERM*(EIGENP(J,I+1,M) + EIGENM(J,I+1,M))
                  RT(J,I) =   RTEMP(J,I,L)
  400          CONTINUE
  410       CONTINUE
C
C     Second-order MUSCL scheme
C
         ELSE
            DO 430 I = 2, IDIM
               DO 420 J = 2, JDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (J,I) = - DTTERM * EIGENP(J,I-1,M)
                  B (J,I) =   1.0E0  + DTTERM *
     1                                 (EIGENP(J,I,M) - EIGENM(J,I,M))
                  C (J,I) =   DTTERM * EIGENM(J,I+1,M)
                  RT(J,I) =   RTEMP(J,I,L)
  420          CONTINUE
  430       CONTINUE
         ENDIF
C
C     Viscous contribution
C
         IF (VISCOS) THEN
            DO 450 I = 2, IDIM
               DO 440 J = 2, JDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (J,I) = A(J,I)-     DTTERM * EIGEN(J,I,MV)
                  B (J,I) = B(J,I)+2.E0*DTTERM * EIGEN(J,I,MV)
                  C (J,I) = C(J,I)-     DTTERM * EIGEN(J,I,MV)
  440          CONTINUE
  450       CONTINUE
         ENDIF
C
C     Invert the tridiagonal systems:
C     A*DQ(I-1) + B*DQ(I) + C*DQ(I+1) = RT
C
         NPTS = IDIM - 1
         NSIM = JDIM - 1
         CALL VSTRI (NPTS, NSIM, A, B, C, RT)
C
C     Store inversion back into RTEMP
C
         DO 470 I = 2, IDIM
            DO 460 J = 2, JDIM
               RTEMP(J,I,L) = RT(J,I)
  460       CONTINUE
  470    CONTINUE
C
C     Next equation
C
  490 CONTINUE
C
C     Calculate RTEMP = T * RTEMP
C
      NPTS = (IDIM + 1) * (JDIM - 1)
      CALL TR     (ITURB, NPTS, QI, STEMP, EL, EM, TKE, RTEMP, RTEMP2)
C
C     Update the residual array
C
      DO 830 L = 1, NF
         DO 820 I = 2, IDIM
            DO 810 J = 2, JDIM
               RES(J,K,I,L) = RTEMP2(J,I,L)
  810       CONTINUE
  820    CONTINUE
  830 CONTINUE
C
C     Reset the residual to zero for the case of a two-dimensional calculation
C     as roundoff error in the transform-solve-transform process can lead to
C     non-zero residual.
C          For Reynolds stress calculations reset W, Tau_xz, Tau_yz
C              inviscid, laminar, two-equation reset W
C
      IF (.NOT. THREED) THEN
         IF (ITURB .EQ. ITRS) THEN
            DO 920 I = 2, IDIM
               DO 910 J = 2, JDIM
                  RES(J,K,I, 4) = 0.E0
                  RES(J,K,I,10) = 0.E0
                  RES(J,K,I,11) = 0.E0
  910          CONTINUE
  920       CONTINUE
         ELSE
            DO 950 I = 2, IDIM
               DO 940 J = 2, JDIM
                  RES(J,K,I, 4) = 0.E0
  940          CONTINUE
  950       CONTINUE
         ENDIF
      ENDIF
C
C     Finished with the I implicit sweep of diagonalized three factor AF
      RETURN
      END
      SUBROUTINE AF3DJ  (IDIM, JDIM, KDIM, K,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES,
     2                   QI, PROPSJ, STEMP, VOLJ, EL, EM, TKE,
     3                   IBCDAT, NBCS, IFLUX, VISCOS, ITURB,
     4                   A, B, C, RT, RTEMP, RTEMP2,
     5                   EIGENP, EIGENM, EIGEN)
C
C     Routine to do the diagonalized J implicit sweep of three factor
C     Approximate Factorisation
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     K              : K plane to perform I implicit sweep on
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     QI             : Q at cell center for diagonalized scheme
C     PROPSJ         : Properties at cell centers for eigenvalue routine
C     STEMP          : Storage for metrics passed to eigenvalue routine
C                      including the area term
C     VOLJ           : Storage for volum,e passed to eigenvalue routine
C     EL, EM         : Unit tangency vectors
C     TKE            : Turbulent kinetic energy
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence modeling scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(I-1) + B*DQ(I) + C*DQ(I+1) = RTEMP
C                      Implicit in the I direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C     EIGENP,M       : Storage for eigenvalues(+,-)
C     EIGEN          : Storage for viscous eigenvalue
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          QI    (2:IDIM,1:JDIM+1,NQ),
     2          PROPSJ(2:IDIM,1:JDIM+1,NP),
     3          STEMP (2:IDIM,1:JDIM+1,4),
     4          VOLJ  (2:IDIM,1:JDIM+1),
     5          EL    (2:IDIM,1:JDIM+1,3),
     6          EM    (2:IDIM,1:JDIM+1,3),
     7          TKE   (2:IDIM,1:JDIM+1)
C
C     Storage for the implicit system to invert.
C     Store the system only in the internal portion of the field and use
C     explicit boundary conditions of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:IDIM,2:JDIM),
     1          B     (2:IDIM,2:JDIM),
     2          C     (2:IDIM,2:JDIM),
     3          RT    (2:IDIM,2:JDIM),
     4          RTEMP (2:IDIM,1:JDIM+1,NF),
     5          RTEMP2(2:IDIM,1:JDIM+1,NF)
C
C     Storage for the eigenvalues used to calculate A,B and C
C
      DIMENSION EIGENP(2:IDIM,1:JDIM+1,3),
     1          EIGENM(2:IDIM,1:JDIM+1,3),
     2          EIGEN (2:IDIM,1:JDIM+1,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      LOGICAL   VISCOS
C
C     Store Q in QI at cell centers
C
      DO 130 L = 1, NQ
         DO 120 J = 1, JDIM+1
            DO 110 I = 2, IDIM
               QI(I,J,L) = Q(J,K,I,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C     Calculate the metrics for the at the cell centers for the eigenvalues
C     When prevent division by zero, don't set S=<1,1,1> since TANVEC
C     calculates the tangency vectors by crossing S with <1,1,1>.
C
      DO 150 J = 1, JDIM+1
         DO 140 I = 2, IDIM
            SX           = 0.5E0*( S(J  ,K,I,1,2)*S(J  ,K,I,4,2)
     1                           + S(J-1,K,I,1,2)*S(J-1,K,I,4,2) )
            SY           = 0.5E0*( S(J  ,K,I,2,2)*S(J  ,K,I,4,2)
     1                           + S(J-1,K,I,2,2)*S(J-1,K,I,4,2) )
            SZ           = 0.5E0*( S(J  ,K,I,3,2)*S(J  ,K,I,4,2)
     1                           + S(J-1,K,I,3,2)*S(J-1,K,I,4,2) )
            STEMP(I,J,4) = SQRT (SX*SX + SY*SY + SZ*SZ)
            IF (STEMP(I,J,4) .GT. 0.E0) THEN
               STEMP(I,J,1) = SX / STEMP(I,J,4)
               STEMP(I,J,2) = SY / STEMP(I,J,4)
               STEMP(I,J,3) = SZ / STEMP(I,J,4)
            ELSE
               STEMP(I,J,1) =   SHATX
               STEMP(I,J,2) = - SHATY
               STEMP(I,J,3) =   SHATZ
            ENDIF
  140    CONTINUE
  150 CONTINUE
C
C     Calculate unit tangency vectors
C
      NPTS = (JDIM + 1) * (IDIM - 1)
      CALL TANVEC (NPTS, STEMP, EL, EM)
C
C     Calculate RTEMP = T[-1] * RES
C
      DO 230 L = 1, NF
         DO 220 J = 1, JDIM+1
            DO 210 I = 2, IDIM
               RTEMP2(I,J,L) = RES(J,K,I,L)
  210       CONTINUE
  220    CONTINUE
  230 CONTINUE
C
      CALL GETTKE (ITURB, NPTS, QI, TKE)
      CALL TINVR  (ITURB, NPTS, QI, STEMP, EL, EM, TKE, RTEMP2, RTEMP)
C
C     Calculate eigenvalues
C
      CALL EIGENI (ITURB, NPTS, QI, STEMP, EIGENP, EIGENM)
C
C     Viscous eigenvalues
C
      IF (VISCOS) THEN
         DO 320 L = 1, NP
            DO 310 J = 1, JDIM+1
               DO 300 I = 2, IDIM
                  PROPSJ(I,J,L) = PROPS(J,K,I,L)
  300          CONTINUE
  310       CONTINUE
  320    CONTINUE
C
         DO 340 J = 1, JDIM+1
            DO 330 I = 2, IDIM
               VOLJ(I,J) = VOL(J,K,I)
  330       CONTINUE
  340    CONTINUE
C
         CALL EIGENV (ITURB, NPTS, QI, PROPSJ, STEMP, VOLJ, EIGEN)
      ENDIF
C
C     Setup and invert each system
C
      DO 490 L = 1, NRANK
         IF (L .EQ. 4) THEN
            M = 2
         ELSE IF (L .EQ. 5) THEN
            M = 3
         ELSE
            M = 1
         ENDIF
C
C     Viscous eigenvalue
C
         IF (L .LE. 5) THEN
            MV = 1
         ELSE IF (L .EQ. NQ) THEN
            MV = 3
         ELSE
            MV = 2
         ENDIF
C
C     Fourth-order central scheme
C
         IF (FOURTH) THEN
            DO 410 J = 2, JDIM
               DO 400 I = 2, IDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (I,J) = - DTTERM*(EIGENP(I,J-1,M) + EIGENM(I,J-1,M))
                  B (I,J) =   1.0E0
                  C (I,J) =   DTTERM*(EIGENP(I,J+1,M) + EIGENM(I,J+1,M))
                  RT(I,J) =   RTEMP(I,J,L)
  400          CONTINUE
  410       CONTINUE
C
C     Second-order MUSCL scheme
C
         ELSE
            DO 430 J = 2, JDIM
               DO 420 I = 2, IDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (I,J) = - DTTERM * EIGENP(I,J-1,M)
                  B (I,J) =   1.0E0  + DTTERM *
     1                                 (EIGENP(I,J,M) - EIGENM(I,J,M))
                  C (I,J) =   DTTERM * EIGENM(I,J+1,M)
                  RT(I,J) =   RTEMP(I,J,L)
  420          CONTINUE
  430       CONTINUE
         ENDIF
C
C     Viscous contribution
C
         IF (VISCOS) THEN
            DO 450 J = 2, JDIM
               DO 440 I = 2, IDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (I,J) = A(I,J)-     DTTERM * EIGEN(I,J,MV)
                  B (I,J) = B(I,J)+2.E0*DTTERM * EIGEN(I,J,MV)
                  C (I,J) = C(I,J)-     DTTERM * EIGEN(I,J,MV)
  440          CONTINUE
  450       CONTINUE
         ENDIF
C
C     Invert the tridiagonal systems:
C     A*DQ(I-1) + B*DQ(I) + C*DQ(I+1) = RT
C
         NPTS = JDIM - 1
         NSIM = IDIM - 1
         CALL VSTRI (NPTS, NSIM, A, B, C, RT)
C
C     Store inversion back into RTEMP
C
         DO 470 J = 2, JDIM
            DO 460 I = 2, IDIM
               RTEMP(I,J,L) = RT(I,J)
  460       CONTINUE
  470    CONTINUE
C
C     Next equation
C
  490 CONTINUE
C
C     Calculate RTEMP = T * RTEMP
C
      NPTS = (JDIM + 1) * (IDIM - 1)
      CALL TR     (ITURB, NPTS, QI, STEMP, EL, EM, TKE, RTEMP, RTEMP2)
C
C     Update the residual array
C
      DO 830 L = 1, NF
         DO 820 J = 2, JDIM
            DO 810 I = 2, IDIM
               RES(J,K,I,L) = RTEMP2(I,J,L)
  810       CONTINUE
  820    CONTINUE
  830 CONTINUE
C
C     Reset the residual to zero for the case of a two-dimensional calculation
C     as roundoff error in the transform-solve-transform process can lead to
C     non-zero residual.
C          For Reynolds stress calculations reset W, Tau_xz, Tau_yz
C              inviscid, laminar, two-equation reset W
C
      IF (.NOT. THREED) THEN
         IF (ITURB .EQ. ITRS) THEN
            DO 920 I = 2, IDIM
               DO 910 J = 2, JDIM
                  RES(J,K,I, 4) = 0.E0
                  RES(J,K,I,10) = 0.E0
                  RES(J,K,I,11) = 0.E0
  910          CONTINUE
  920       CONTINUE
         ELSE
            DO 950 I = 2, IDIM
               DO 940 J = 2, JDIM
                  RES(J,K,I, 4) = 0.E0
  940          CONTINUE
  950       CONTINUE
         ENDIF
      ENDIF
C
C     Finished with the J implicit sweep of diagonalized three factor AF
      RETURN
      END
      SUBROUTINE AF3DK  (IDIM, JDIM, KDIM, I,
     1                   Q, PROPS, NPPTS, S, VOL, DTJ, RES,
     2                   QI, PROPSK, STEMP, VOLK, EL, EM, TKE,
     3                   IBCDAT, NBCS, IFLUX, VISCOS, ITURB,
     4                   A, B, C, RT, RTEMP, RTEMP2,
     5                   EIGENP, EIGENM, EIGEN)
C
C     Routine to do the diagonalized K implicit sweep of three factor
C     Approximate Factorisation
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     K              : K plane to perform I implicit sweep on
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C                      PROPS(1) = molecular viscosity
C                      PROPS(2) = turbulent eddy viscosity
C                      PROPS(3) = Y+
C     NPPTS          : Number of points at which PROPS are stored.  This allows
C                      the storage of PROPS for viscous flows and the avoidance
C                      of the additional storage for inviscid flows.
C     S              : Metrics
C     VOL            : Cell volumes
C     DTJ            : Time step divided by cell volume
C     RES            : Residual - must be over the entire field for
C                      this time integration scheme
C     QI             : Q at cell center for diagonalized scheme
C     PROPSK         : Properties at cell centers for eigenvalue routine
C     STEMP          : Storage for metrics passed to eigenvalue routine
C                      including the area term
C     VOLK           : Storage for volume passed to eigenvalue routine
C     EL, EM         : Unit tangency vectors
C     TKE            : Turbulent kinetic energy
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     IFLUX          : Flux evaluation scheme
C     VISCOS         : Logical for viscous (TRUE) or inviscid (FALSE) flow
C     ITURB          : Turbulence modeling scheme
C     A,B,C          : Tridiagonal systems to invert
C                      A*DQ(I-1) + B*DQ(I) + C*DQ(I+1) = RTEMP
C                      Implicit in the I direction.  Vectorization
C                      by inverting multiple systems at one time to
C                      avoid the recursion of the inversion.
C     RTEMP          : Storage for the residual array in the form
C                      appropriate for the inversion routine
C     EIGENP,M       : Storage for eigenvalues(+,-)
C     EIGEN          : Storage for viscous eigenvalue
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (0:JDIM+2,0:KDIM+2,0:IDIM+2,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1),
     4          DTJ   (JDIM,KDIM,IDIM)
C
      DIMENSION RES   (JDIM+1,KDIM+1,IDIM+1,NF),
     1          QI    (2:JDIM,1:KDIM+1,NQ),
     2          PROPSK(2:JDIM,1:KDIM+1,NP),
     3          STEMP (2:JDIM,1:KDIM+1,4),
     4          VOLK  (2:JDIM,1:KDIM+1),
     5          EL    (2:JDIM,1:KDIM+1,3),
     6          EM    (2:JDIM,1:KDIM+1,3),
     7          TKE   (2:JDIM,1:KDIM+1)
C
C     Storage for the implicit system to invert.
C     Store the system only in the internal portion of the field and use
C     explicit boundary conditions of the form Delta(Q) boundaries = 0.
C
      DIMENSION A     (2:JDIM,2:KDIM),
     1          B     (2:JDIM,2:KDIM),
     2          C     (2:JDIM,2:KDIM),
     3          RT    (2:JDIM,2:KDIM),
     4          RTEMP (2:JDIM,1:KDIM+1,NF),
     5          RTEMP2(2:JDIM,1:KDIM+1,NF)
C
C     Storage for the eigenvalues used to calculate A,B and C
C
      DIMENSION EIGENP(2:JDIM,1:KDIM+1,3),
     1          EIGENM(2:JDIM,1:KDIM+1,3),
     2          EIGEN (2:JDIM,1:KDIM+1,3)
C
      DIMENSION IBCDAT(10,NBCS)
C
      LOGICAL   VISCOS
C
C     Store Q in QI at cell centers
C
      DO 130 L = 1, NQ
         DO 120 K = 1, KDIM+1
            DO 110 J = 2, JDIM
               QI(J,K,L) = Q(J,K,I,L)
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C     Calculate the metrics for the at the cell centers for the eigenvalues
C     When prevent division by zero, don't set S=<1,1,1> since TANVEC
C     calculates the tangency vectors by crossing S with <1,1,1>.
C
      DO 150 K = 1, KDIM+1
         DO 140 J = 2, JDIM
            SX           = 0.5E0*( S(J,K  ,I,1,3)*S(J,K  ,I,4,3)
     1                           + S(J,K-1,I,1,3)*S(J,K-1,I,4,3) )
            SY           = 0.5E0*( S(J,K  ,I,2,3)*S(J,K  ,I,4,3)
     1                           + S(J,K-1,I,2,3)*S(J,K-1,I,4,3) )
            SZ           = 0.5E0*( S(J,K  ,I,3,3)*S(J,K  ,I,4,3)
     1                           + S(J,K-1,I,3,3)*S(J,K-1,I,4,3) )
            STEMP(J,K,4) = SQRT (SX*SX + SY*SY + SZ*SZ)
            IF (STEMP(J,K,4) .GT. 0.E0) THEN
               STEMP(J,K,1) = SX / STEMP(J,K,4)
               STEMP(J,K,2) = SY / STEMP(J,K,4)
               STEMP(J,K,3) = SZ / STEMP(J,K,4)
            ELSE
               STEMP(J,K,1) =   SHATX
               STEMP(J,K,2) = - SHATY
               STEMP(J,K,3) =   SHATZ
            ENDIF
  140    CONTINUE
  150 CONTINUE
C
C     Calculate unit tangency vectors
C
      NPTS = (KDIM + 1) * (JDIM - 1)
      CALL TANVEC (NPTS, STEMP, EL, EM)
C
C     Calculate RTEMP = T[-1] * RES
C
      DO 230 L = 1, NF
         DO 220 K = 1, KDIM+1
            DO 210 J = 2, JDIM
               RTEMP2(J,K,L) = RES(J,K,I,L)
  210       CONTINUE
  220    CONTINUE
  230 CONTINUE
C
      CALL GETTKE (ITURB, NPTS, QI, TKE)
      CALL TINVR  (ITURB, NPTS, QI, STEMP, EL, EM, TKE, RTEMP2, RTEMP)
C
C     Calculate eigenvalues
C
      CALL EIGENI (ITURB, NPTS, QI, STEMP, EIGENP, EIGENM)
C
C     Viscous eigenvalues
C
      IF (VISCOS) THEN
         DO 320 L = 1, NP
            DO 310 K = 1, KDIM+1
               DO 300 J = 2, JDIM
                  PROPSK(J,K,L) = PROPS(J,K,I,L)
  300          CONTINUE
  310       CONTINUE
  320    CONTINUE
C
         DO 340 K = 1, KDIM+1
            DO 330 J = 2, JDIM
               VOLK(J,K) = VOL(J,K,I)
  330       CONTINUE
  340    CONTINUE
C
         CALL EIGENV (ITURB, NPTS, QI, PROPSK, STEMP, VOLK, EIGEN)
      ENDIF
C
C     Setup and invert each system
C
      DO 490 L = 1, NRANK
         IF (L .EQ. 4) THEN
            M = 2
         ELSE IF (L .EQ. 5) THEN
            M = 3
         ELSE
            M = 1
         ENDIF
C
C     Viscous eigenvalue
C
         IF (L .LE. 5) THEN
            MV = 1
         ELSE IF (L .EQ. NQ) THEN
            MV = 3
         ELSE
            MV = 2
         ENDIF
C
C     Fourth-order central scheme
C
         IF (FOURTH) THEN
            DO 410 K = 2, KDIM
               DO 400 J = 2, JDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (J,K) = - DTTERM*(EIGENP(J,K-1,M) + EIGENM(J,K-1,M))
                  B (J,K) =   1.0E0
                  C (J,K) =   DTTERM*(EIGENP(J,K+1,M) + EIGENM(J,K+1,M))
                  RT(J,K) =   RTEMP(J,K,L)
  400          CONTINUE
  410       CONTINUE
C
C    Second-order MUSCL scheme
C
         ELSE
            DO 430 K = 2, KDIM
               DO 420 J = 2, JDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (J,K) = - DTTERM * EIGENP(J,K-1,M)
                  B (J,K) =   1.0E0  + DTTERM *
     1                                 (EIGENP(J,K,M) - EIGENM(J,K,M))
                  C (J,K) =   DTTERM * EIGENM(J,K+1,M)
                  RT(J,K) =   RTEMP(J,K,L)
  420          CONTINUE
  430       CONTINUE
         ENDIF
C
C     Viscous contribution
C
         IF (VISCOS) THEN
            DO 450 K = 2, KDIM
               DO 440 J = 2, JDIM
                  DTTERM  = 1.0E0 /
     1                      ( TDPDTJ / (TDTHET*DTJ(J,K,I))
     2                      + TDPDEL * VOL(J,K,I) / TIMEDT )
                  A (J,K) = A(J,K)-     DTTERM * EIGEN(J,K,MV)
                  B (J,K) = B(J,K)+2.E0*DTTERM * EIGEN(J,K,MV)
                  C (J,K) = C(J,K)-     DTTERM * EIGEN(J,K,MV)
  440          CONTINUE
  450       CONTINUE
         ENDIF
C
C     Invert the tridiagonal systems:
C     A*DQ(K-1) + B*DQ(K) + C*DQ(K+1) = RT
C
         NPTS = KDIM - 1
         NSIM = JDIM - 1
         CALL VSTRI (NPTS, NSIM, A, B, C, RT)
C
C     Store inversion back into RTEMP
C
         DO 470 K = 2, KDIM
            DO 460 J = 2, JDIM
               RTEMP(J,K,L) = RT(J,K)
  460       CONTINUE
  470    CONTINUE
C
C     Next equation
C
  490 CONTINUE
C
C     Calculate RTEMP = T * RTEMP
C
      NPTS = (KDIM + 1) * (JDIM - 1)
      CALL TR     (ITURB, NPTS, QI, STEMP, EL, EM, TKE, RTEMP, RTEMP2)
C
C     Update the residual array
C
      DO 830 L = 1, NF
         DO 820 K = 2, KDIM
            DO 810 J = 2, JDIM
               RES(J,K,I,L) = RTEMP2(J,K,L)
  810       CONTINUE
  820    CONTINUE
  830 CONTINUE
C
C     The reset of non-zero residuals caused by roundoff of transform-solve-
C     transform procedure for the two-dimensional cases is not needed here
C     as this routine is not called if doing a 2D case!
C
C     Finished with the K implicit sweep of diagonalized three factor AF
      RETURN
      END
      SUBROUTINE EIGENI (ITURB, NPTS, Q, S, EIGENP, EIGENM)
C
C     Routine to calculate the inviscid eigenvalues
C
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate on
C     Q              : Flow variables
C     S              : Metrics - including area term
C     EIGENP,EIGENM  : Eigenvalues (+,-)
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          S     (NPTS,4),
     2          EIGENP(NPTS,3),
     3          EIGENM(NPTS,3)
C
C     Calculate the Eigenvalues
C
      DO 100 I = 1, NPTS
         RHO   = Q(I,1)
         U     = Q(I,2)
         V     = Q(I,3)
         W     = Q(I,4)
         P     = Q(I,5)
C
         A     = SQRT ( GAMMA * P / RHO )
C
         AREA  = S(I,4)
C
         UBAR        = (S(I,1) * U + S(I,2) * V + S(I,3) * W) * AREA
         UBARPA      = (UBAR + A * AREA)
         UBARMA      = (UBAR - A * AREA)
C
         EIGENP(I,1) = 0.5E0 * (UBAR   + ABS(UBAR  ))
         EIGENP(I,2) = 0.5E0 * (UBARPA + ABS(UBARPA))
         EIGENP(I,3) = 0.5E0 * (UBARMA + ABS(UBARMA))
C
         EIGENM(I,1) = 0.5E0 * (UBAR   - ABS(UBAR  ))
         EIGENM(I,2) = 0.5E0 * (UBARPA - ABS(UBARPA))
         EIGENM(I,3) = 0.5E0 * (UBARMA - ABS(UBARMA))
C     write (iout,'(a,i4,6e15.7)') ' EIGENI: i ', i,
C    1                            (eigenp(i,ll),ll=1,3),
C    2                            (eigenm(i,lk),lk=1,3)
C
  100 CONTINUE
      RETURN
      END
      SUBROUTINE EIGENV (ITURB, NPTS, Q, PROPS, S, VOL, EIGEN)
C
C     Routine to calculate the viscous eigenvalues
C
C     VISCOS         : Viscous switch
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate on
C     Q              : Flow variables
C     PROPS          : Properties array
C     S              : Metrics - including area term
C     VOL            : Cell volume
C     EIGEN          : Maximum viscous eigenvalues
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP),
     2          S     (NPTS,4),
     3          VOL   (NPTS),
     4          EIGEN (NPTS,3)
C
C     Calculate the Mean Flow Eigenvalue
C
      DO 100 I = 1, NPTS
         RHO      = Q(I,1)
C
         RMU      = PROPS(I,1)
         RMUT     = PROPS(I,2)
C
         AREA     = S(I,4)
C
         EIGEN(I,1) = AREA * AREA / (RHO*VOL(I) + RSMASQ) * FSMACH/RE *
     1            MAX ( 4.E0/3.E0*(RMU+RMUT), GAMMA*(RMU/PR+RMUT/PRT) )
C     write (iout,'(a,i4,e15.7)') ' EIGENV: i ', i, eigen(i)
C
  100 CONTINUE
C
C     Calculate the Additional Eigenvalues
C     II-b. Two-Equation Models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 200 I = 1, NPTS
            RHO        = Q(I,1)
C
            RMU        = PROPS(I,1)
            RMUT       = PROPS(I,2)
C
            AREA       = S(I,4)
C
            EIGEN(I,2) = AREA * AREA / (RHO*VOL(I)+RSMASQ) * FSMACH/RE *
     1                   (RMU + SIGK  * RMUT)
            EIGEN(I,3) = AREA * AREA / (RHO*VOL(I)+RSMASQ) * FSMACH/RE *
     1                   (RMU + SIGT2 * RMUT)
C
  200    CONTINUE
C
C     II-c. Reynolds Stress Models
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         T23 = 2.E0 / 3.E0
         DO 210 I = 1, NPTS
            RHO        = Q(I, 1)
            TAUXX      = Q(I, 6)
            TAUYY      = Q(I, 7)
            TAUZZ      = Q(I, 8)
            EPSLN      = Q(I,12)
C
            TKE        = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU        = PROPS(I,1)
            RMUT       = PROPS(I,2)
C
            AREA       = S(I,4)
C
            TMP        = RHO * TKE / EPSLN *
     1             MAX( (S(I,1)*TAUXX+S(I,2)*TAUYY+S(I,3)*TAUZZ), 0.E0 )
            EIGEN(I,2) = AREA * AREA / (RHO*VOL(I)+RSMASQ) *
     1                   ( RMU*FSMACH/RE + CSUBS *TMP )
            EIGEN(I,3) = AREA * AREA / (RHO*VOL(I)+RSMASQ) *
     1                   ( RMU*FSMACH/RE + CEPSLN*TMP )
C
  210    CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE TINVR  (ITURB, NPTS, Q, S, EL, EM, TKE, R, TIR)
C
C     Routine to calculate T[-1] R.  This routine is done in two steps:
C          I.  Calculate T[-1] R for mean-flow equations
C          II. Calculate T[-1] R for additional equations
C              a. Inviscid, Laminar, Algebraic turb. => None
C              b. Two-Equation turb. model           => k, phi equations
C              c. Reynolds stress model              => tau_ij, epsilon
C
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate on
C     Q              : Flow variables
C     S              : Metrics - including area term
C     EL, EM         : Unit tangency vectors
C     TKE            : Tubulent kinetic energy
C     R              : Residual to be multiplied by T[-1]
C     TIR            : T[-1] R
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          S     (NPTS,4),
     2          EL    (NPTS,3),
     3          EM    (NPTS,3),
     4          TKE   (NPTS),
     5          R     (NPTS,NF),
     6          TIR   (NPTS,NF)
C
C     I. Calculate the T[-1] R for the mean-flow equations
C
      DO 100 I = 1, NPTS
         RHO   = Q(I,1)
         U     = Q(I,2)
         V     = Q(I,3)
         W     = Q(I,4)
         P     = Q(I,5)
C
         QSQ   = U*U + V*V + W*W
         ASQ   = GAMMA * P / RHO
         A     = SQRT ( ASQ )
C
         UBAR  = S (I,1) * U + S (I,2) * V + S (I,3) * W
         VBAR  = EL(I,1) * U + EL(I,2) * V + EL(I,3) * W
         WBAR  = EM(I,1) * U + EM(I,2) * V + EM(I,3) * W
C
         CAPG  = GAMM1 / ASQ
C
         TIR(I, 1) = (1.E0 - 0.5E0*CAPG*QSQ)*R(I,1)
     1             + CAPG * (U*R(I,2) + V*R(I,3) + W*R(I,4) - R(I,5))
         TIR(I, 2) = -VBAR*R(I,1) + EL(I,1)*R(I,2) + EL(I,2)*R(I,3)
     1                            + EL(I,3)*R(I,4)
         TIR(I, 3) = -WBAR*R(I,1) + EM(I,1)*R(I,2) + EM(I,2)*R(I,3)
     1                            + EM(I,3)*R(I,4)
         TIR(I, 4) = 0.5E0 * ( (0.5E0*CAPG*QSQ-UBAR/A)*R(I,1)
     1                       + (S(I,1)/A-CAPG*U)*R(I,2)
     2                       + (S(I,2)/A-CAPG*V)*R(I,3)
     3                       + (S(I,3)/A-CAPG*W)*R(I,4) + CAPG*R(I,5) )
         TIR(I, 5) = 0.5E0 * ( (0.5E0*CAPG*QSQ+UBAR/A)*R(I,1)
     1                       - (S(I,1)/A+CAPG*U)*R(I,2)
     2                       - (S(I,2)/A+CAPG*V)*R(I,3)
     3                       - (S(I,3)/A+CAPG*W)*R(I,4) + CAPG*R(I,5) )
  100 CONTINUE
C
C     II.   Additional equations for T[-1] R
C
C     II-b. Two-Equation model
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 210 I = 1, NPTS
            RHO   = Q(I, 1)
            P     = Q(I, 5)
            EPSLN = Q(I, 7)
C
            ASQ   = GAMMA * P / RHO
            A     = SQRT ( ASQ )
C
            CAPG  = GAMM1 / ASQ
C
            TIR(I, 1) =  TIR(I, 1) +         CAPG * R(I, 6)
            TIR(I, 4) =  TIR(I, 4) - 0.5E0 * CAPG * R(I, 6)
            TIR(I, 5) =  TIR(I, 5) - 0.5E0 * CAPG * R(I, 6)
            TIR(I, 6) = -TKE(I)*R(I, 1) + R(I, 6)
            TIR(I, 7) = -EPSLN *R(I, 1) + R(I, 7)
  210    CONTINUE
C
C     II-c. Reynolds Stress model
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 220 I = 1, NPTS
            RHO   = Q(I, 1)
            P     = Q(I, 5)
            TAUXX = Q(I, 6)
            TAUYY = Q(I, 7)
            TAUZZ = Q(I, 8)
            TAUXY = Q(I, 9)
            TAUXZ = Q(I,10)
            TAUYZ = Q(I,11)
            EPSLN = Q(I,12)
C
            ASQ   = GAMMA * P / RHO
            A     = SQRT ( ASQ )
C
            CAPG  = GAMM1 / ASQ
C
            TRACE     =  R(I,6) + R(I,7) + R(I,8)
            TIR(I, 1) =  TIR(I, 1) + 0.50E0 * CAPG * TRACE
            TIR(I, 4) =  TIR(I, 4) - 0.25E0 * CAPG * TRACE
            TIR(I, 5) =  TIR(I, 5) - 0.25E0 * CAPG * TRACE
            TIR(I, 6) = -TAUXX*R(I, 1) + R(I, 6)
            TIR(I, 7) = -TAUYY*R(I, 1) + R(I, 7)
            TIR(I, 8) = -TAUZZ*R(I, 1) + R(I, 8)
            TIR(I, 9) = -TAUXY*R(I, 1) + R(I, 9)
            TIR(I,10) = -TAUXZ*R(I, 1) + R(I,10)
            TIR(I,11) = -TAUYZ*R(I, 1) + R(I,11)
            TIR(I,12) = -EPSLN*R(I, 1) + R(I,12)
  220    CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE TR     (ITURB, NPTS, Q, S, EL, EM, TKE, R, TTR)
C
C     Routine to calculate T R.  This routine is done in two steps:
C          I.  Calculate T R for mean-flow equations
C          II. Calculate T R for additional equations
C              a. Inviscid, Laminar, Algebraic turb. => None
C              b. Two-Equation turb. model           => k, phi equations
C              c. Reynolds stress model              => tau_ij, epsilon
C
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate on
C     Q              : Flow variables
C     S              : Metrics - including area term
C     EL, EM         : Unit tangency vectors
C     TKE            : Tubulent kinetic energy
C     R              : Residual to be multiplied by T[-1]
C     TTR            : T R (T times R)
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          S     (NPTS,4),
     2          EL    (NPTS,3),
     3          EM    (NPTS,3),
     4          TKE   (NPTS),
     5          R     (NPTS,NF),
     6          TTR   (NPTS,NF)
C
C     I. Calculate the T R for the mean-flow equations
C
      DO 100 I = 1, NPTS
         RHO   = Q(I,1)
         U     = Q(I,2)
         V     = Q(I,3)
         W     = Q(I,4)
         P     = Q(I,5)
C
         H     = GAMMA * P / (RHO * GAMM1)
     1            + 0.5E0 * (U*U + V*V + W*W) + TKE(I)
C
         QSQ   = U*U + V*V + W*W
         ASQ   = GAMMA * P / RHO
         A     = SQRT ( ASQ )
C
         UBAR  = S (I,1) * U + S (I,2) * V + S (I,3) * W
         VBAR  = EL(I,1) * U + EL(I,2) * V + EL(I,3) * W
         WBAR  = EM(I,1) * U + EM(I,2) * V + EM(I,3) * W
C
         CAPG  = GAMM1 / ASQ
C
         TTR(I, 1) = R(I,1) + R(I,4) + R(I,5)
         TTR(I, 2) = U*R(I,1) + EL(I,1)*R(I,2) + EM(I,1)*R(I,3)
     1               + (U+S(I,1)*A)*R(I,4) + (U-S(I,1)*A)*R(I,5)
         TTR(I, 3) = V*R(I,1) + EL(I,2)*R(I,2) + EM(I,2)*R(I,3)
     1               + (V+S(I,2)*A)*R(I,4) + (V-S(I,2)*A)*R(I,5)
         TTR(I, 4) = W*R(I,1) + EL(I,3)*R(I,2) + EM(I,3)*R(I,3)
     1               + (W+S(I,3)*A)*R(I,4) + (W-S(I,3)*A)*R(I,5)
         TTR(I, 5) = (0.5E0*QSQ+TKE(I))*R(I,1)
     1               + VBAR*R(I,2) + WBAR*R(I,3)
     2               + (H+UBAR*A)*R(I,4) + (H-UBAR*A)*R(I,5)
  100 CONTINUE
C
C     II.   Additional equations for T R
C
C     II-b. Two-Equation model
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 210 I = 1, NPTS
            RHO   = Q(I, 1)
            P     = Q(I, 5)
            EPSLN = Q(I, 7)
C
            ASQ   = GAMMA * P / RHO
            A     = SQRT ( ASQ )
C
            CAPG  = GAMM1 / ASQ
C
            TTR(I, 5) = TTR(I, 5) + R(I, 6)
            TTR(I, 6) = TKE(I)*(R(I, 1) + R(I, 4) + R(I, 5)) + R(I, 6)
            TTR(I, 7) = EPSLN *(R(I, 1) + R(I, 4) + R(I, 5)) + R(I, 7)
  210    CONTINUE
C
C     II-c. Reynolds Stress model
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 220 I = 1, NPTS
            TAUXX = Q(I, 6)
            TAUYY = Q(I, 7)
            TAUZZ = Q(I, 8)
            TAUXY = Q(I, 9)
            TAUXZ = Q(I,10)
            TAUYZ = Q(I,11)
            EPSLN = Q(I,12)
C
            TERM      = R(I, 1) + R(I, 4) + R(I, 5)
            TRACE     = R(I, 6) + R(I, 7) + R(I, 8)
            TTR(I, 5) = TTR(I, 5) + 0.5E0 * TRACE
            TTR(I, 6) = TAUXX*TERM + R(I, 6)
            TTR(I, 7) = TAUYY*TERM + R(I, 7)
            TTR(I, 8) = TAUZZ*TERM + R(I, 8)
            TTR(I, 9) = TAUXY*TERM + R(I, 9)
            TTR(I,10) = TAUXZ*TERM + R(I,10)
            TTR(I,11) = TAUYZ*TERM + R(I,11)
            TTR(I,12) = EPSLN*TERM + R(I,12)
  220    CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE TANVEC (NPTS, S, EL, EM)
C
C     Routine to calculate the unit tangency vectors lhat (EL) and mhat (EM)
C     such that S dot EL = 0 and S dot EM = 0.
C     Formula adapted from Thomas based on vector identity that
C     A . B X C = - C . B X A so that lhat = nhat X (1, 1, 1)
C     and then mhat = nhat X lhat.
C     This method will fail if nhat = (1, 1, 1) and then a correction will
C     need to be applied.
C
C     NPTS           : Size of array to calculate on
C     S              : Metrics - including area term
C     EL             : Unit tangency vector
C     EM             : Unit tangency vector
C
      include 'common.inc'
C
      DIMENSION S     (NPTS,4),
     1          EL    (NPTS,3),
     2          EM    (NPTS,3)
C
C     Loop over all points and calculate tangency vectors
C
      DO 100 I = 1, NPTS
C
C     Calculate lhat = nhat X (1, 1, 1)
C
         ELX     = S(I,2) - S(I,3)
         ELY     = S(I,3) - S(I,1)
         ELZ     = S(I,1) - S(I,2)
         ELNORM  = SQRT (ELX*ELX + ELY*ELY + ELZ*ELZ)
C->      if (elnorm .le. 0.e0) write (iout,'(a,i5,3e15.7)')
C->  1       ' lhat zero in TANVEC i,lhat ', i, elx, ely, elz
         EL(I,1) = ELX / ELNORM
         EL(I,2) = ELY / ELNORM
         EL(I,3) = ELZ / ELNORM
C
C     Calculate mhat = nhat X lhat (already normalized)
C
         EM(I,1) =   S(I,2) * EL(I,3) - S(I,3) * EL(I,2)
         EM(I,2) = - S(I,1) * EL(I,3) + S(I,3) * EL(I,1)
         EM(I,3) =   S(I,1) * EL(I,2) - S(I,2) * EL(I,1)
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DFDQ (ITURB, NPTS, Q, S, TKE, H, A)
C
C     Routine to calculate Jacobians at the interface using Q
C     as DF/DQ for the mean equations and a either a two-equation
C     turbulence model of the k-psi form or a Reynolds stress closure.
C     DF/DQ formulas match those given by Pulliam and Steger in
C     AIAA 85-0360 in the Appendix for the special case of k = 0.
C
C     ITURB  : Turbulence model
C     NPTS   : Number of points at which to calculate DF/DQ
C     Q      : The primitive variables from which to calculate DF/DQ
C     S      : Metrics
C     TKE    : Turbulent kinetic energy
C     H      : Total enthalpy
C     A      : The Jacobian matrix DF/DQ
C
C     The two-equation and Reynolds stress models require the turbulent
C     kinetic energy in the mean flow equations.  Therefore, this routine
C     is organized into the following sections:
C
C          1. Calculate the Turbulent Kinetic Energy (TKE)
C             a. Inviscid, laminar, algebraic model => TKE = 0
C             b. Two-Equation model                 => TKE = Q(6)
C             c. Reynolds stress model              => TKE = (Q(7)+Q(8)+Q(9))/2
C          2. Calculate Total Enthalpy
C             a. Perfect Gas   => H = gamma P / (RHO(gamma-1)) + (q^2)/2 + TKE
C          3. Calculate Flux Jacobians for the Mean Flow Equations
C          4. Calculate Additional Flux Jacobians
C             a. Inviscid, laminar, algebraic model => No additional Jacobians
C             b. Two-Equation model                 => Jacobians for TKE, phi
C             c. Reynolds stress model              => Jacobians for Tau_ij,phi
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          S     (NPTS,4),
     2          TKE   (NPTS),
     3          H     (NPTS),
     4          A     (NPTS,NRANK,NRANK)
C
C     1. Calculate Turbulent Kinetic Energy (TKE)
C
C     1-b. Turbulent Kinetic Energy for Two-Equation models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 100 I = 1, NPTS
            TKE(I) = Q(I,6)
  100    CONTINUE
C
C     1-c. Turbulent Kinetic Energy for Reynolds Stress models
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 110 I = 1, NPTS
            TKE(I) = 0.5E0 * (Q(I,6) + Q(I,7) + Q(I,8))
  110    CONTINUE
C
C     1-a. Turbulent Kinetic Energy = 0 for inviscid, laminar, algebraic models
C
      ELSE
         DO 120 I = 1, NPTS
            TKE(I) = 0.E0
  120    CONTINUE
      ENDIF
C
C     2. Calculate Total Enthalpy
C
C     2-a. Perfect Gas
C
      DO 200 I = 1, NPTS
         RHO  = Q(I,1)
         U    = Q(I,2)
         V    = Q(I,3)
         W    = Q(I,4)
         P    = Q(I,5)
         H(I) = GAMMA * P / (RHO * GAMM1)
     1          + 0.5E0 * (U*U + V*V + W*W) + TKE(I)
  200 CONTINUE
C
C     3. Calculate DF/DQ at the cell interfaces for Mean Flow Equations
C
      DO 300 I = 1, NPTS
         RHO   = Q(I,1)
         U     = Q(I,2)
         V     = Q(I,3)
         W     = Q(I,4)
         P     = Q(I,5)
C
         UBAR  = S(I,1)*U + S(I,2)*V + S(I,3)*W
         PHISQ = 0.5E0 * GAMM1 * (U*U + V*V + W*W)
C
         A(I,1,1) =   0.0E0
         A(I,1,2) =   S(I,4) * S(I,1)
         A(I,1,3) =   S(I,4) * S(I,2)
         A(I,1,4) =   S(I,4) * S(I,3)
         A(I,1,5) =   0.0E0
C
         A(I,2,1) =   S(I,4)*( S(I,1)*PHISQ - U*UBAR )
         A(I,2,2) =   S(I,4)*( UBAR     - S(I,1)*(GAMMA-2.E0)*U )
         A(I,2,3) =   S(I,4)*( S(I,2)*U - S(I,1)*GAMM1*V )
         A(I,2,4) =   S(I,4)*( S(I,3)*U - S(I,1)*GAMM1*W )
         A(I,2,5) =   S(I,4)*S(I,1)*GAMM1
C
         A(I,3,1) =   S(I,4)*( S(I,2)*PHISQ - V*UBAR )
         A(I,3,2) =   S(I,4)*( S(I,1)*V - S(I,2)*GAMM1*U )
         A(I,3,3) =   S(I,4)*( UBAR     - S(I,2)*(GAMMA-2.E0)*V )
         A(I,3,4) =   S(I,4)*( S(I,3)*V - S(I,2)*GAMM1*W )
         A(I,3,5) =   S(I,4)*S(I,2)*GAMM1
C
         A(I,4,1) =   S(I,4)*( S(I,3)*PHISQ - W*UBAR )
         A(I,4,2) =   S(I,4)*( S(I,1)*W - S(I,3)*GAMM1*U )
         A(I,4,3) =   S(I,4)*( S(I,2)*W - S(I,3)*GAMM1*V )
         A(I,4,4) =   S(I,4)*( UBAR     - S(I,3)*(GAMMA-2.E0)*W )
         A(I,4,5) =   S(I,4)*S(I,3)*GAMM1
C
         A(I,5,1) =   S(I,4)*UBAR*( PHISQ - H(I) )
         A(I,5,2) =   S(I,4)*( S(I,1)*H(I) - GAMM1*UBAR*U )
         A(I,5,3) =   S(I,4)*( S(I,2)*H(I) - GAMM1*UBAR*V )
         A(I,5,4) =   S(I,4)*( S(I,3)*H(I) - GAMM1*UBAR*W )
         A(I,5,5) =   S(I,4)*GAMMA*UBAR
C
  300 CONTINUE
C
C     4. Additional Jacobians
C
C     4-b. Two-Equation Models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 410 I = 1, NPTS
            RHO      = Q(I,1)
            U        = Q(I,2)
            V        = Q(I,3)
            W        = Q(I,4)
            P        = Q(I,5)
            T2       = Q(I,7)
            UBAR     = S(I,1)*U + S(I,2)*V + S(I,3)*W
C
            A(I,1,6) =   0.0E0
            A(I,1,7) =   0.0E0
C
            A(I,2,6) = - S(I,4)*S(I,1)*GAMM1
            A(I,2,7) =   0.0E0
C
            A(I,3,6) = - S(I,4)*S(I,2)*GAMM1
            A(I,3,7) =   0.0E0
C
            A(I,4,6) = - S(I,4)*S(I,3)*GAMM1
            A(I,4,7) =   0.0E0
C
            A(I,5,6) = - S(I,4)*GAMM1*UBAR
            A(I,5,7) =   0.0E0
C
            A(I,6,1) = - S(I,4) * UBAR * TKE(I)
            A(I,6,2) =   S(I,4) * S(I,1) * TKE(I)
            A(I,6,3) =   S(I,4) * S(I,2) * TKE(I)
            A(I,6,4) =   S(I,4) * S(I,3) * TKE(I)
            A(I,6,5) =   0.0E0
            A(I,6,6) =   S(I,4) * UBAR
            A(I,6,7) =   0.0E0
C
            A(I,7,1) = - S(I,4) * UBAR * T2
            A(I,7,2) =   S(I,4) * S(I,1) * T2
            A(I,7,3) =   S(I,4) * S(I,2) * T2
            A(I,7,4) =   S(I,4) * S(I,3) * T2
            A(I,7,5) =   0.0E0
            A(I,7,6) =   0.0E0
            A(I,7,7) =   S(I,4) * UBAR
  410    CONTINUE
C
C     4-c. Additional Jacobians for Reynolds Stress models
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 420 I = 1, NPTS
C
            U          = Q(I,2)
            V          = Q(I,3)
            W          = Q(I,4)
            UBAR       = S(I,1)*U + S(I,2)*V + S(I,3)*W
C
            TAUXX      = Q(I, 6)
            TAUYY      = Q(I, 7)
            TAUZZ      = Q(I, 8)
            TAUXY      = Q(I, 9)
            TAUXZ      = Q(I,10)
            TAUYZ      = Q(I,11)
            T2         = Q(I,12)
C
            A(I, 1, 6) =   0.0E0
            A(I, 1, 7) =   0.0E0
            A(I, 1, 8) =   0.0E0
            A(I, 1, 9) =   0.0E0
            A(I, 1,10) =   0.0E0
            A(I, 1,11) =   0.0E0
            A(I, 1,12) =   0.0E0
C
            A(I, 2, 6) = - 0.5E0*S(I,4)*S(I,1)*GAMM1
            A(I, 2, 7) = - 0.5E0*S(I,4)*S(I,1)*GAMM1
            A(I, 2, 8) = - 0.5E0*S(I,4)*S(I,1)*GAMM1
            A(I, 2, 9) =   0.0E0
            A(I, 2,10) =   0.0E0
            A(I, 2,11) =   0.0E0
            A(I, 2,12) =   0.0E0
C
            A(I, 3, 6) = - 0.5E0*S(I,4)*S(I,2)*GAMM1
            A(I, 3, 7) = - 0.5E0*S(I,4)*S(I,2)*GAMM1
            A(I, 3, 8) = - 0.5E0*S(I,4)*S(I,2)*GAMM1
            A(I, 3, 9) =   0.0E0
            A(I, 3,10) =   0.0E0
            A(I, 3,11) =   0.0E0
            A(I, 3,12) =   0.0E0
C
            A(I, 4, 6) = - 0.5E0*S(I,4)*S(I,3)*GAMM1
            A(I, 4, 7) = - 0.5E0*S(I,4)*S(I,3)*GAMM1
            A(I, 4, 8) = - 0.5E0*S(I,4)*S(I,3)*GAMM1
            A(I, 4, 9) =   0.0E0
            A(I, 4,10) =   0.0E0
            A(I, 4,11) =   0.0E0
            A(I, 4,12) =   0.0E0
C
            A(I, 5, 6) = - 0.5E0*S(I,4)*UBAR*GAMM1
            A(I, 5, 7) = - 0.5E0*S(I,4)*UBAR*GAMM1
            A(I, 5, 8) = - 0.5E0*S(I,4)*UBAR*GAMM1
            A(I, 5, 9) =   0.0E0
            A(I, 5,10) =   0.0E0
            A(I, 5,11) =   0.0E0
            A(I, 5,12) =   0.0E0
C
            A(I, 6, 1) = - S(I,4)*UBAR*TAUXX
            A(I, 6, 2) =   S(I,4)*S(I,1)*TAUXX
            A(I, 6, 3) =   S(I,4)*S(I,2)*TAUXX
            A(I, 6, 4) =   S(I,4)*S(I,3)*TAUXX
            A(I, 6, 5) =   0.0E0
            A(I, 6, 6) =   S(I,4)*UBAR
            A(I, 6, 7) =   0.0E0
            A(I, 6, 8) =   0.0E0
            A(I, 6, 9) =   0.0E0
            A(I, 6,10) =   0.0E0
            A(I, 6,11) =   0.0E0
            A(I, 6,12) =   0.0E0
C
            A(I, 7, 1) = - S(I,4)*UBAR*TAUYY
            A(I, 7, 2) =   S(I,4)*S(I,1)*TAUYY
            A(I, 7, 3) =   S(I,4)*S(I,2)*TAUYY
            A(I, 7, 4) =   S(I,4)*S(I,3)*TAUYY
            A(I, 7, 5) =   0.0E0
            A(I, 7, 6) =   0.0E0
            A(I, 7, 7) =   S(I,4)*UBAR
            A(I, 7, 8) =   0.0E0
            A(I, 7, 9) =   0.0E0
            A(I, 7,10) =   0.0E0
            A(I, 7,11) =   0.0E0
            A(I, 7,12) =   0.0E0
C
            A(I, 8, 1) = - S(I,4)*UBAR*TAUZZ
            A(I, 8, 2) =   S(I,4)*S(I,1)*TAUZZ
            A(I, 8, 3) =   S(I,4)*S(I,2)*TAUZZ
            A(I, 8, 4) =   S(I,4)*S(I,3)*TAUZZ
            A(I, 8, 5) =   0.0E0
            A(I, 8, 6) =   0.0E0
            A(I, 8, 7) =   0.0E0
            A(I, 8, 8) =   S(I,4)*UBAR
            A(I, 8, 9) =   0.0E0
            A(I, 8,10) =   0.0E0
            A(I, 8,11) =   0.0E0
            A(I, 8,12) =   0.0E0
C
            A(I, 9, 1) = - S(I,4)*UBAR*TAUXY
            A(I, 9, 2) =   S(I,4)*S(I,1)*TAUXY
            A(I, 9, 3) =   S(I,4)*S(I,2)*TAUXY
            A(I, 9, 4) =   S(I,4)*S(I,3)*TAUXY
            A(I, 9, 5) =   0.0E0
            A(I, 9, 6) =   0.0E0
            A(I, 9, 7) =   0.0E0
            A(I, 9, 8) =   0.0E0
            A(I, 9, 9) =   S(I,4)*UBAR
            A(I, 9,10) =   0.0E0
            A(I, 9,11) =   0.0E0
            A(I, 9,12) =   0.0E0
C
            A(I,10, 1) = - S(I,4)*UBAR*TAUXZ
            A(I,10, 2) =   S(I,4)*S(I,1)*TAUXZ
            A(I,10, 3) =   S(I,4)*S(I,2)*TAUXZ
            A(I,10, 4) =   S(I,4)*S(I,3)*TAUXZ
            A(I,10, 5) =   0.0E0
            A(I,10, 6) =   0.0E0
            A(I,10, 7) =   0.0E0
            A(I,10, 8) =   0.0E0
            A(I,10, 9) =   0.0E0
            A(I,10,10) =   S(I,4)*UBAR
            A(I,10,11) =   0.0E0
            A(I,10,12) =   0.0E0
C
            A(I,11, 1) = - S(I,4)*UBAR*TAUYZ
            A(I,11, 2) =   S(I,4)*S(I,1)*TAUYZ
            A(I,11, 3) =   S(I,4)*S(I,2)*TAUYZ
            A(I,11, 4) =   S(I,4)*S(I,3)*TAUYZ
            A(I,11, 5) =   0.0E0
            A(I,11, 6) =   0.0E0
            A(I,11, 7) =   0.0E0
            A(I,11, 8) =   0.0E0
            A(I,11, 9) =   0.0E0
            A(I,11,10) =   0.0E0
            A(I,11,11) =   S(I,4)*UBAR
            A(I,11,12) =   0.0E0
C
            A(I,12, 1) = - S(I,4)*UBAR*T2
            A(I,12, 2) =   S(I,4)*S(I,1)*T2
            A(I,12, 3) =   S(I,4)*S(I,2)*T2
            A(I,12, 4) =   S(I,4)*S(I,3)*T2
            A(I,12, 5) =   0.0E0
            A(I,12, 6) =   0.0E0
            A(I,12, 7) =   0.0E0
            A(I,12, 8) =   0.0E0
            A(I,12, 9) =   0.0E0
            A(I,12,10) =   0.0E0
            A(I,12,11) =   0.0E0
            A(I,12,12) =   S(I,4)*UBAR
  420    CONTINUE
      ENDIF
C
C     Finished with DF/DQ calculation.
      RETURN
      END
      SUBROUTINE DFROE (ITURB, NPTS, QP, QM, S, AP, AM, AR, WORK)
C
C     Routine to calculate Jacobians by calling the
C     appropriate Roe's implicit routine.
C
C     ITURB          : Turbulence model
C     NPTS           : Size of array to calculate fluxes on.
C     QP,QM          : Q(+),Q(-) at a cell interface for MUSCL scheme
C     S              : Metrics
C     AP,AM          : The Jacobian matrices DF(Q+)/DQ and DF(Q-)/DQ
C     AR             : The Jacobian matrix T |Lambda| T(-1) using Roe's avg.
C     WORK           : Temporary storage for TKE,H in Jacobian routines
C
      include 'common.inc'
C
      DIMENSION QP    (NPTS,NQ),
     1          QM    (NPTS,NQ),
     2          S     (NPTS,4),
     3          AP    (NPTS,NRANK,NRANK),
     4          AM    (NPTS,NRANK,NRANK),
     5          AR    (NPTS,NRANK,NRANK),
     6          WORK  (NPTS,4)
C
C     Calculate dF/dQ(QP), dF/dQ(QM) and T |Lambda| T[-1]
C
      CALL DFDQ   (ITURB, NPTS, QP, S, WORK(1,1), WORK(1,2), AP)
      CALL DFDQ   (ITURB, NPTS, QM, S, WORK(1,1), WORK(1,2), AM)
      CALL TLTROE (ITURB, NPTS, QP, QM, S, WORK(1,1), WORK(1,2),
     1             WORK(1,3), WORK(1,4), AR)
C
C     Finished calculating Jacobians for Roe's scheme
      RETURN
      END
      SUBROUTINE DFVISJ (IDIM, JDIM, KDIM, I, ITURB,
     1                   Q, RMU, RMUT, S, VOL, IBCDAT, NBCS,
     2                   T, U, V, W, RMUJ, RMUTJ, AP, AM)
C
C     Routine to calculate the Jacobians of the viscous
C     terms for the J direction.  This routine calculates the terms
C     from the mean equations and adds the terms due to the
C     turbulence model.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Current I Plane
C     ITURB          : Turbulence model
C     Q              : Primitive variables at cell centers
C     RMU            : Molecular viscosity at cell centers
C     RMUT           : Turbulent eddy viscosity at cell centers
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     T              : Temporary storage of Temperature
C     U,V,W          : Temporary storage of U,V,W velocities
C     RMUJ           : Temporary storage of Viscosity at cell interfaces
C     RMUTJ          : Temporary storage of turbulent eddy viscosity
C                      at cell interfaces
C     AP,AM          : Implicit terms
C                      AP = dF(i+1/2)/dQ(i+1)
C                      AM = dF(i+1/2)/dQ(i)
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMU   (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     2          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION T     (JDIM+1,2:KDIM),
     1          RMUJ  (JDIM,2:KDIM),
     2          RMUTJ (JDIM,2:KDIM),
     3          U     (JDIM,2:KDIM),
     4          V     (JDIM,2:KDIM),
     5          W     (JDIM,2:KDIM)
C
      DIMENSION AP    (JDIM,2:KDIM,NRANK,NRANK),
     1          AM    (JDIM,2:KDIM,NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Zero the matrices
C
      DO 114 L = 1, NRANK
         DO 113 M = 1, NRANK
            DO 112 K = 2, KDIM
               DO 111 J = 1, JDIM
                  AP(J,K,L,M) = 0.E0
                  AM(J,K,L,M) = 0.E0
  111          CONTINUE
  112       CONTINUE
  113    CONTINUE
  114 CONTINUE
C
C     Calculate the thin-layer Navier-Stokes terms for the mean equations
C
      CALL DFVTLJ (IDIM, JDIM, KDIM, I, ITURB,
     1             Q, RMU, RMUT, S, VOL, IBCDAT, NBCS,
     2             T, U, V, W, RMUJ, RMUTJ, AP, AM)
C
C     Finished with implicit Thin Layer Viscous Terms in the J direction
      RETURN
      END
      SUBROUTINE DFVISK (IDIM, JDIM, KDIM, I, ITURB,
     1                   Q, RMU, RMUT, S, VOL, IBCDAT, NBCS,
     2                   T, U, V, W, RMUK, RMUTK, AP, AM)
C
C     Routine to calculate the thin layer Navier-Stokes terms for
C     the K direction.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Current I Plane
C     ITURB          : Turbulence model
C     Q              : Primitive variables at cell centers
C     RMU            : Molecular viscosity at cell centers
C     RMUT           : Turbulent eddy viscosity at cell centers
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     T              : Temporary storage of Temperature
C     U,V,W          : Temporary storage of U,V,W velocities
C     RMUK           : Temporary storage of Viscosity at cell interfaces
C     RMUTK          : Temporary storage of turbulent eddy viscosity
C                      at cell interfaces
C     AP,AM          : Implicit terms
C                      AP = dF(i+1/2)/dQ(i+1)
C                      AM = dF(i+1/2)/dQ(i)
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMU   (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     2          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION T     (KDIM+1,2:JDIM),
     1          RMUK  (KDIM,2:JDIM),
     2          RMUTK (KDIM,2:JDIM),
     3          U     (KDIM,2:JDIM),
     4          V     (KDIM,2:JDIM),
     5          W     (KDIM,2:JDIM)
C
      DIMENSION AP    (KDIM,2:JDIM,NRANK,NRANK),
     1          AM    (KDIM,2:JDIM,NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Zero the matrices
C
      DO 114 L = 1, NRANK
         DO 113 M = 1, NRANK
            DO 112 J = 2, JDIM
               DO 111 K = 1, KDIM
                  AP(K,J,L,M) = 0.E0
                  AM(K,J,L,M) = 0.E0
  111          CONTINUE
  112       CONTINUE
  113    CONTINUE
  114 CONTINUE
C
C     Calculate the implicit thin-layer Navier-Stokes terms for the mean eqns
C
      CALL DFVTLK (IDIM, JDIM, KDIM, I,
     1             Q, RMU, RMUT, S, VOL, IBCDAT, NBCS,
     2             T, U, V, W, RMUK, RMUTK, AP, AM)
C
C     Finished
      RETURN
      END
      SUBROUTINE DFVTLI (IDIM, JDIM, KDIM, K, IPSTRT, IPEND,
     1                   Q, RMUT, S, VOL, IBCDAT, NBCS,
     2                   T, U, V, W, RMU, RMUI, RMUTI, AP, AM)
C
C     Routine to calculate the implicit thin layer Navier-Stokes terms
C     for the I direction.
C
C     This routine is not presently suited for the multiblock
C     approach.  It is close to being ready but is not.  The problem
C     lies that the metrics for one cell into the adjacent block
C     are needed to be completely general.  These are currently not available.
C     The routine metbc needs to be completed.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     K              : Current K Plane
C     IPSTRT         : I Plane (cell center) to start calculations at
C                      (Minimum Value: 2)
C     IPEND          : I Plane (cell center) to end caclulations at
C                      (Maximum Value: IDIM)
C     Q              : Primitive variables at cell centers
C     RMUT           : Turbulent eddy viscosity at cell centers
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     T              : Temporary storage of Temperature
C     U,V,W          : Temporary storage of U,V,W velocities
C     RMU            : Temporary storage of Viscosity at cell centers
C     RMUI           : Temporary storage of Viscosity at cell interfaces
C     RMUTI          : Temporary storage of turbulent eddy viscosity
C                      at cell interfaces
C     AP,AM          : Implicit terms
C                      AP = dF(i+1/2)/dQ(i+1)
C                      AM = dF(i+1/2)/dQ(i)
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION T     (IPSTRT-1:IPEND+1,2:JDIM),
     1          RMU   (IPSTRT-1:IPEND+1,2:JDIM),
     2          RMUI  (IPSTRT-1:IPEND,2:JDIM),
     3          RMUTI (IPSTRT-1:IPEND,2:JDIM),
     4          U     (IPSTRT-1:IPEND,2:JDIM),
     5          V     (IPSTRT-1:IPEND,2:JDIM),
     6          W     (IPSTRT-1:IPEND,2:JDIM)
C
      DIMENSION AP    (IPSTRT-1:IPEND,2:JDIM,NRANK,NRANK),
     1          AM    (IPSTRT-1:IPEND,2:JDIM,NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Two-Thirds
C     Four-Thirds
C
      T23 = 2.E0 / 3.E0
      T43 = 4.E0 / 3.E0
C
C     Calculate T = T / TINF  at the cell centers
C
      DO 120 J = 2, JDIM
         DO 110 I = IPSTRT - 1, IPEND + 1
            T(I,J) = GAMMA * Q(J,K,I,5) / Q(J,K,I,1)
  110    CONTINUE
  120 CONTINUE
C
C     Calculate molecular viscosity at cell centers
C
      NPTS = (IPEND - IPSTRT + 1) * (JDIM - 1)
      CALL VSCSTY (NPTS, T, RMU)
C
C     Calculate U,V,W,RMUI,RMUTI at cell interfaces as averages of cell centers
C
      DO 220 J = 2, JDIM
         DO 210 I = IPSTRT - 1, IPEND
            U(I,J)     = 0.5E0 * ( Q(J,K,I,2)  + Q(J,K,I+1,2) )
            V(I,J)     = 0.5E0 * ( Q(J,K,I,3)  + Q(J,K,I+1,3) )
            W(I,J)     = 0.5E0 * ( Q(J,K,I,4)  + Q(J,K,I+1,4) )
            RMUI(I,J)  = 0.5E0 * ( RMU(I,J)    + RMU(I+1,J) )
            RMUTI(I,J) = 0.5E0 * ( RMUT(J,K,I) + RMUT(J,K,I+1) )
  210    CONTINUE
  220 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 350 IBC = 1, NBCS
         IF (IBCDAT(1,IBC) .EQ. IWALL .AND.
     1       IBCDAT(2,IBC) .EQ. 1) THEN
            INROUT = IBCDAT(3,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
            IF (INROUT .EQ. 1) THEN
               IBCPT = 1
               INTR  = 1
            ELSE
               IBCPT = IDIM + 1
               INTR  = IDIM
            ENDIF
            IF (IBCPT .GE. IPSTRT-1 .AND. IBCPT .LE. IPEND .AND.
     1              K .GE. KSTRT    .AND.     K .LE. KEND      ) THEN
               DO 320 J = JSTRT, JEND
                  U(INTR,J)     = 0.E0
                  V(INTR,J)     = 0.E0
                  W(INTR,J)     = 0.E0
                  RMUI(INTR,J)  = RMU(IBCPT,J)
                  RMUTI(INTR,J) = RMUT(J,K,IBCPT)
  320          CONTINUE
            ENDIF
         ENDIF
  350 CONTINUE
C
C     Loop over J forming viscous terms along the I direction
C     on the I = IPSTRT - 1, IPEND faces
C
      DO 520 J = 2, JDIM
         DO 510 I = IPSTRT - 1, IPEND
C
            AREAMR = S(J,K,I,4,1) * FSMACH / RE
C
C     Average metrics and cell volume
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
            VOLAUX = 2.0E0 / ( VOL(J,K,I) + VOL(J,K,I+1) )
            SPI1   = 0.5E0 * ( S(J,K,I,1,1)*S(J,K,I,4,1)
     1                       + S(J,K,I+1,1,1)*S(J,K,I+1,4,1) )
            SPI2   = 0.5E0 * ( S(J,K,I,2,1)*S(J,K,I,4,1)
     1                       + S(J,K,I+1,2,1)*S(J,K,I+1,4,1) )
            SPI3   = 0.5E0 * ( S(J,K,I,3,1)*S(J,K,I,4,1)
     1                       + S(J,K,I+1,3,1)*S(J,K,I+1,4,1) )
            SMI1   = 0.5E0 * ( S(J,K,I,1,1)*S(J,K,I,4,1)
     1                       + S(J,K,I-1,1,1)*S(J,K,I-1,4,1) )
            SMI2   = 0.5E0 * ( S(J,K,I,2,1)*S(J,K,I,4,1)
     1                       + S(J,K,I-1,2,1)*S(J,K,I-1,4,1) )
            SMI3   = 0.5E0 * ( S(J,K,I,3,1)*S(J,K,I,4,1)
     1                       + S(J,K,I-1,3,1)*S(J,K,I-1,4,1) )
C
            DUDX = VOLAUX * ( Q(J,K,I+1,2)*SPI1 - Q(J,K,I,2)*SMI1 )
            DUDY = VOLAUX * ( Q(J,K,I+1,2)*SPI2 - Q(J,K,I,2)*SMI2 )
            DUDZ = VOLAUX * ( Q(J,K,I+1,2)*SPI3 - Q(J,K,I,2)*SMI3 )
C
            DVDX = VOLAUX * ( Q(J,K,I+1,3)*SPI1 - Q(J,K,I,3)*SMI1 )
            DVDY = VOLAUX * ( Q(J,K,I+1,3)*SPI2 - Q(J,K,I,3)*SMI2 )
            DVDZ = VOLAUX * ( Q(J,K,I+1,3)*SPI3 - Q(J,K,I,3)*SMI3 )
C
            DWDX = VOLAUX * ( Q(J,K,I+1,4)*SPI1 - Q(J,K,I,4)*SMI1 )
            DWDY = VOLAUX * ( Q(J,K,I+1,4)*SPI2 - Q(J,K,I,4)*SMI2 )
            DWDZ = VOLAUX * ( Q(J,K,I+1,4)*SPI3 - Q(J,K,I,4)*SMI3 )
C
            DTDX = VOLAUX * ( T(I+1,J)*SPI1 - T(I,J)*SMI1 )
            DTDY = VOLAUX * ( T(I+1,J)*SPI2 - T(I,J)*SMI2 )
            DTDZ = VOLAUX * ( T(I+1,J)*SPI3 - T(I,J)*SMI3 )
C
C     Calculate Shear Terms
C     Use molecular viscosity (RMUI) and turbulent eddy viscosity (RMUTI)
C     averaged from cell centers to get viscosity at cell interface.
C     T23 is two-thirds
C
            VISC  = RMUI(I,J) + RMUTI(I,J)
            TAUXX = T23 * VISC * ( 2.E0*DUDX - DVDY - DWDZ )
            TAUYY = T23 * VISC * ( 2.E0*DVDY - DUDX - DWDZ )
            TAUZZ = T23 * VISC * ( 2.E0*DWDZ - DUDX - DVDY )
            TAUXY = VISC * ( DUDY + DVDX )
            TAUXZ = VISC * ( DWDX + DUDZ )
            TAUYZ = VISC * ( DWDY + DVDZ )
C
C     Heat Flux terms are not used in the current implementation of the
C     implicit viscous terms.  This is kept for compatibility reasons
C     and in case they are later included in d(RMU) terms.
C     Calculate Heat Flux Terms
C
C           CNDCT = (RMUI(I,J)/PR + RMUTI(I,J)/PRT) / GAMM1
C           QDOTX = - CNDCT * DTDX
C           QDOTY = - CNDCT * DTDY
C           QDOTZ = - CNDCT * DTDZ
C
C     Region to calculate AM = dF(i+1/2)/dQ(i)  terms
C
C     Calculate DTau(xx,xy,xz,...)/DQ(1,2,3,...) terms
C
            RMRV   = VISC * VOLAUX / Q(J,K,I,1)
C
C     DTau(xx)
C
            DTXXD1 =   T23 * RMRV * ( 2.E0*SMI1*Q(J,K,I,2)
     1                       - SMI2*Q(J,K,I,3) - SMI3*Q(J,K,I,4) )
            DTXXD2 = - T43 * RMRV * SMI1
            DTXXD3 =   T23 * RMRV * SMI2
            DTXXD4 =   T23 * RMRV * SMI3
C
C     DTau(yy)
C
            DTYYD1 =   T23 * RMRV * ( 2.E0*SMI2*Q(J,K,I,3)
     1                       - SMI1*Q(J,K,I,2) - SMI3*Q(J,K,I,4) )
            DTYYD2 =   T23 * RMRV * SMI1
            DTYYD3 = - T43 * RMRV * SMI2
            DTYYD4 =   T23 * RMRV * SMI3
C
C     DTau(zz)
C
            DTZZD1 =   T23 * RMRV * ( 2.E0*SMI3*Q(J,K,I,4)
     1                       - SMI1*Q(J,K,I,2) - SMI2*Q(J,K,I,3) )
            DTZZD2 =   T23 * RMRV * SMI1
            DTZZD3 =   T23 * RMRV * SMI2
            DTZZD4 = - T43 * RMRV * SMI3
C
C     DTau(xy)
C
            DTXYD1 =   RMRV * ( SMI1*Q(J,K,I,3) + SMI2*Q(J,K,I,2) )
            DTXYD2 = - RMRV * SMI2
            DTXYD3 = - RMRV * SMI1
C
C     DTau(xz)
C
            DTXZD1 =   RMRV * ( SMI1*Q(J,K,I,4) + SMI3*Q(J,K,I,2) )
            DTXZD2 = - RMRV * SMI3
            DTXZD4 = - RMRV * SMI1
C
C     DTau(yz)
C
            DTYZD1 =   RMRV * ( SMI2*Q(J,K,I,4) + SMI3*Q(J,K,I,3) )
            DTYZD3 = - RMRV * SMI3
            DTYZD4 = - RMRV * SMI2
C
C     DQdot(x)
C
            TEMP   = (RMUI(I,J)/PR + RMUTI(I,J)/PRT) * GAMMA * VOLAUX
     1               / Q(J,K,I,1)
C
            DQDXD1 = - TEMP * SMI1 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDXD2 = - TEMP * SMI1 * Q(J,K,I,2)
            DQDXD3 = - TEMP * SMI1 * Q(J,K,I,3)
            DQDXD4 = - TEMP * SMI1 * Q(J,K,I,4)
            DQDXD5 =   TEMP * SMI1
C
C     DQdot(y)
C
            DQDYD1 = - TEMP * SMI2 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDYD2 = - TEMP * SMI2 * Q(J,K,I,2)
            DQDYD3 = - TEMP * SMI2 * Q(J,K,I,3)
            DQDYD4 = - TEMP * SMI2 * Q(J,K,I,4)
            DQDYD5 =   TEMP * SMI2
C
C     DQdot(z)
C
            DQDZD1 = - TEMP * SMI3 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDZD2 = - TEMP * SMI3 * Q(J,K,I,2)
            DQDZD3 = - TEMP * SMI3 * Q(J,K,I,3)
            DQDZD4 = - TEMP * SMI3 * Q(J,K,I,4)
            DQDZD5 =   TEMP * SMI3
C
C     Calculate AM = dF(i+1/2)/dQ(i)
C
            AM(I,J,1,1) = 0.E0
            AM(I,J,1,2) = 0.E0
            AM(I,J,1,3) = 0.E0
            AM(I,J,1,4) = 0.E0
            AM(I,J,1,5) = 0.E0
C
            AM(I,J,2,1) = ( S(J,K,I,1,1)*DTXXD1 + S(J,K,I,2,1)*DTXYD1
     1                    + S(J,K,I,3,1)*DTXZD1 ) * AREAMR
            AM(I,J,2,2) = ( S(J,K,I,1,1)*DTXXD2 + S(J,K,I,2,1)*DTXYD2
     1                    + S(J,K,I,3,1)*DTXZD2 ) * AREAMR
            AM(I,J,2,3) = ( S(J,K,I,1,1)*DTXXD3 + S(J,K,I,2,1)*DTXYD3 )
     1                                            * AREAMR
            AM(I,J,2,4) = ( S(J,K,I,1,1)*DTXXD4 + S(J,K,I,3,1)*DTXZD4 )
     1                                            * AREAMR
            AM(I,J,2,5) = 0.E0
C
            AM(I,J,3,1) = ( S(J,K,I,1,1)*DTXYD1 + S(J,K,I,2,1)*DTYYD1
     1                    + S(J,K,I,3,1)*DTYZD1 ) * AREAMR
            AM(I,J,3,2) = ( S(J,K,I,1,1)*DTXYD2 + S(J,K,I,2,1)*DTYYD2 )
     1                                            * AREAMR
            AM(I,J,3,3) = ( S(J,K,I,1,1)*DTXYD3 + S(J,K,I,2,1)*DTYYD3
     1                    + S(J,K,I,3,1)*DTYZD3 ) * AREAMR
            AM(I,J,3,4) = ( S(J,K,I,2,1)*DTYYD4 + S(J,K,I,3,1)*DTYZD4 )
     1                                            * AREAMR
            AM(I,J,3,5) = 0.E0
C
            AM(I,J,4,1) = ( S(J,K,I,1,1)*DTXZD1 + S(J,K,I,2,1)*DTYZD1
     1                    + S(J,K,I,3,1)*DTZZD1 ) * AREAMR
            AM(I,J,4,2) = ( S(J,K,I,1,1)*DTXZD2 + S(J,K,I,3,1)*DTZZD2 )
     1                                            * AREAMR
            AM(I,J,4,3) = ( S(J,K,I,2,1)*DTYZD3 + S(J,K,I,3,1)*DTZZD3 )
     1                                            * AREAMR
            AM(I,J,4,4) = ( S(J,K,I,1,1)*DTXZD4 + S(J,K,I,2,1)*DTYZD4
     1                    + S(J,K,I,3,1)*DTZZD4 ) * AREAMR
            AM(I,J,4,5) = 0.E0
C
            AM(I,J,5,1) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD1+V(I,J)*DTXYD1+W(I,J)*DTXZD1-DQDXD1)
     2 + S(J,K,I,2,1)*(U(I,J)*DTXYD1+V(I,J)*DTYYD1+W(I,J)*DTYZD1-DQDYD1)
     3 + S(J,K,I,3,1)*(U(I,J)*DTXZD1+V(I,J)*DTYZD1+W(I,J)*DTZZD1-DQDZD1)
     4 - 0.5E0*Q(J,K,I,2)/Q(J,K,I,1)*(S(J,K,I,1,1)*TAUXX
     5                    +S(J,K,I,2,1)*TAUXY+S(J,K,I,3,1)*TAUXZ)
     6 - 0.5E0*Q(J,K,I,3)/Q(J,K,I,1)*(S(J,K,I,1,1)*TAUXY
     7                    +S(J,K,I,2,1)*TAUYY+S(J,K,I,3,1)*TAUYZ)
     8 - 0.5E0*Q(J,K,I,4)/Q(J,K,I,1)*(S(J,K,I,1,1)*TAUXZ
     9                    +S(J,K,I,2,1)*TAUYZ+S(J,K,I,3,1)*TAUZZ) )
            AM(I,J,5,2) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD2+V(I,J)*DTXYD2+W(I,J)*DTXZD2-DQDXD2)
     2 + S(J,K,I,2,1)*(U(I,J)*DTXYD2+V(I,J)*DTYYD2              -DQDYD2)
     3 + S(J,K,I,3,1)*(U(I,J)*DTXZD2              +W(I,J)*DTZZD2-DQDZD2)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,1)*TAUXX
     5                    +S(J,K,I,2,1)*TAUXY+S(J,K,I,3,1)*TAUXZ) )
            AM(I,J,5,3) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD3+V(I,J)*DTXYD3              -DQDXD3)
     2 + S(J,K,I,2,1)*(U(I,J)*DTXYD3+V(I,J)*DTYYD3+W(I,J)*DTYZD3-DQDYD3)
     3 + S(J,K,I,3,1)*(              V(I,J)*DTYZD3+W(I,J)*DTZZD3-DQDZD3)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,1)*TAUXY
     5                    +S(J,K,I,2,1)*TAUYY+S(J,K,I,3,1)*TAUYZ) )
            AM(I,J,5,4) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD4              +W(I,J)*DTXZD4-DQDXD4)
     2 + S(J,K,I,2,1)*(              V(I,J)*DTYYD4+W(I,J)*DTYZD4-DQDYD4)
     3 + S(J,K,I,3,1)*(U(I,J)*DTXZD4+V(I,J)*DTYZD4+W(I,J)*DTZZD4-DQDZD4)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,1)*TAUXZ
     5                    +S(J,K,I,2,1)*TAUYZ+S(J,K,I,3,1)*TAUZZ) )
            AM(I,J,5,5) = - AREAMR *
     1                      ( S(J,K,I,1,1)*DQDXD5 + S(J,K,I,2,1)*DQDYD5
     2                      + S(J,K,I,3,1)*DQDZD5 )
C
C     Region to calculate AP = dF(i+1/2)/dQ(i)  terms
C
C     Calculate DTau(xx,xy,xz,...)/DQ(1,2,3,...) terms
C
            RMRV   = VISC * VOLAUX / Q(J,K,I+1,1)
C
C     DTau(xx)
C
            DTXXD1 = - T23 * RMRV * ( 2.E0*SPI1*Q(J,K,I+1,2)
     1                     - SPI2*Q(J,K,I+1,3) - SPI3*Q(J,K,I+1,4) )
            DTXXD2 =   T43 * RMRV * SPI1
            DTXXD3 = - T23 * RMRV * SPI2
            DTXXD4 = - T23 * RMRV * SPI3
C
C     DTau(yy)
C
            DTYYD1 = - T23 * RMRV * ( 2.E0*SPI2*Q(J,K,I+1,3)
     1                     - SPI1*Q(J,K,I+1,2) - SPI3*Q(J,K,I+1,4) )
            DTYYD2 = - T23 * RMRV * SPI1
            DTYYD3 =   T43 * RMRV * SPI2
            DTYYD4 = - T23 * RMRV * SPI3
C
C     DTau(zz)
C
            DTZZD1 = - T23 * RMRV * ( 2.E0*SPI3*Q(J,K,I+1,4)
     1                     - SPI1*Q(J,K,I+1,2) - SPI2*Q(J,K,I+1,3) )
            DTZZD2 = - T23 * RMRV * SPI1
            DTZZD3 = - T23 * RMRV * SPI2
            DTZZD4 =   T43 * RMRV * SPI3
C
C     DTau(xy)
C
            DTXYD1 = - RMRV * ( SPI1*Q(J,K,I+1,3) + SPI2*Q(J,K,I+1,2) )
            DTXYD2 =   RMRV * SPI2
            DTXYD3 =   RMRV * SPI1
C
C     DTau(xz)
C
            DTXZD1 = - RMRV * ( SPI1*Q(J,K,I+1,4) + SPI3*Q(J,K,I+1,2) )
            DTXZD2 =   RMRV * SPI3
            DTXZD4 =   RMRV * SPI1
C
C     DTau(yz)
C
            DTYZD1 = - RMRV * ( SPI2*Q(J,K,I+1,4) + SPI3*Q(J,K,I+1,3) )
            DTYZD3 =   RMRV * SPI3
            DTYZD4 =   RMRV * SPI2
C
C     DQdot(x)
C
            TEMP   = (RMUI(I,J)/PR + RMUTI(I,J)/PRT) * GAMMA * VOLAUX
     1               / Q(J,K,I+1,1)
C
            DQDXD1 =   TEMP * SPI1 * ( Q(J,K,I+1,5)/GAMM1
     1             - 0.5E0*Q(J,K,I+1,1)*( Q(J,K,I+1,2)*Q(J,K,I+1,2)
     2         +Q(J,K,I+1,3)*Q(J,K,I+1,3)+Q(J,K,I+1,4)*Q(J,K,I+1,4) ) )
     3                    / Q(J,K,I+1,1)
            DQDXD2 =   TEMP * SPI1 * Q(J,K,I+1,2)
            DQDXD3 =   TEMP * SPI1 * Q(J,K,I+1,3)
            DQDXD4 =   TEMP * SPI1 * Q(J,K,I+1,4)
            DQDXD5 = - TEMP * SPI1
C
C     DQdot(y)
C
            DQDYD1 =   TEMP * SPI2 * ( Q(J,K,I+1,5)/GAMM1
     1             - 0.5E0*Q(J,K,I+1,1)*( Q(J,K,I+1,2)*Q(J,K,I+1,2)
     2         +Q(J,K,I+1,3)*Q(J,K,I+1,3)+Q(J,K,I+1,4)*Q(J,K,I+1,4) ) )
     3                    / Q(J,K,I+1,1)
            DQDYD2 =   TEMP * SPI2 * Q(J,K,I+1,2)
            DQDYD3 =   TEMP * SPI2 * Q(J,K,I+1,3)
            DQDYD4 =   TEMP * SPI2 * Q(J,K,I+1,4)
            DQDYD5 = - TEMP * SPI2
C
C     DQdot(z)
C
            DQDZD1 =   TEMP * SPI3 * ( Q(J,K,I+1,5)/GAMM1
     1             - 0.5E0*Q(J,K,I+1,1)*( Q(J,K,I+1,2)*Q(J,K,I+1,2)
     2         +Q(J,K,I+1,3)*Q(J,K,I+1,3)+Q(J,K,I+1,4)*Q(J,K,I+1,4) ) )
     3                    / Q(J,K,I+1,1)
            DQDZD2 =   TEMP * SPI3 * Q(J,K,I+1,2)
            DQDZD3 =   TEMP * SPI3 * Q(J,K,I+1,3)
            DQDZD4 =   TEMP * SPI3 * Q(J,K,I+1,4)
            DQDZD5 = - TEMP * SPI3
C
C     Calculate AP = dF(i+1/2)/dQ(i+1)
C
            AP(I,J,1,1) = 0.E0
            AP(I,J,1,2) = 0.E0
            AP(I,J,1,3) = 0.E0
            AP(I,J,1,4) = 0.E0
            AP(I,J,1,5) = 0.E0
C
            AP(I,J,2,1) = ( S(J,K,I,1,1)*DTXXD1 + S(J,K,I,2,1)*DTXYD1
     1                    + S(J,K,I,3,1)*DTXZD1 ) * AREAMR
            AP(I,J,2,2) = ( S(J,K,I,1,1)*DTXXD2 + S(J,K,I,2,1)*DTXYD2
     1                    + S(J,K,I,3,1)*DTXZD2 ) * AREAMR
            AP(I,J,2,3) = ( S(J,K,I,1,1)*DTXXD3 + S(J,K,I,2,1)*DTXYD3 )
     1                                            * AREAMR
            AP(I,J,2,4) = ( S(J,K,I,1,1)*DTXXD4 + S(J,K,I,3,1)*DTXZD4 )
     1                                            * AREAMR
            AP(I,J,2,5) = 0.E0
C
            AP(I,J,3,1) = ( S(J,K,I,1,1)*DTXYD1 + S(J,K,I,2,1)*DTYYD1
     1                    + S(J,K,I,3,1)*DTYZD1 ) * AREAMR
            AP(I,J,3,2) = ( S(J,K,I,1,1)*DTXYD2 + S(J,K,I,2,1)*DTYYD2 )
     1                                            * AREAMR
            AP(I,J,3,3) = ( S(J,K,I,1,1)*DTXYD3 + S(J,K,I,2,1)*DTYYD3
     1                    + S(J,K,I,3,1)*DTYZD3 ) * AREAMR
            AP(I,J,3,4) = ( S(J,K,I,2,1)*DTYYD4 + S(J,K,I,3,1)*DTYZD4 )
     1                                            * AREAMR
            AP(I,J,3,5) = 0.E0
C
            AP(I,J,4,1) = ( S(J,K,I,1,1)*DTXZD1 + S(J,K,I,2,1)*DTYZD1
     1                    + S(J,K,I,3,1)*DTZZD1 ) * AREAMR
            AP(I,J,4,2) = ( S(J,K,I,1,1)*DTXZD2 + S(J,K,I,3,1)*DTZZD2 )
     1                                            * AREAMR
            AP(I,J,4,3) = ( S(J,K,I,2,1)*DTYZD3 + S(J,K,I,3,1)*DTZZD3 )
     1                                            * AREAMR
            AP(I,J,4,4) = ( S(J,K,I,1,1)*DTXZD4 + S(J,K,I,2,1)*DTYZD4
     1                    + S(J,K,I,3,1)*DTZZD4 ) * AREAMR
            AP(I,J,4,5) = 0.E0
C
            AP(I,J,5,1) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD1+V(I,J)*DTXYD1+W(I,J)*DTXZD1-DQDXD1)
     2 + S(J,K,I,2,1)*(U(I,J)*DTXYD1+V(I,J)*DTYYD1+W(I,J)*DTYZD1-DQDYD1)
     3 + S(J,K,I,3,1)*(U(I,J)*DTXZD1+V(I,J)*DTYZD1+W(I,J)*DTZZD1-DQDZD1)
     4 - 0.5E0*Q(J,K,I+1,2)/Q(J,K,I+1,1)*(S(J,K,I,1,1)*TAUXX
     5                    +S(J,K,I,2,1)*TAUXY+S(J,K,I,3,1)*TAUXZ)
     6 - 0.5E0*Q(J,K,I+1,3)/Q(J,K,I+1,1)*(S(J,K,I,1,1)*TAUXY
     7                    +S(J,K,I,2,1)*TAUYY+S(J,K,I,3,1)*TAUYZ)
     8 - 0.5E0*Q(J,K,I+1,4)/Q(J,K,I+1,1)*(S(J,K,I,1,1)*TAUXZ
     9                    +S(J,K,I,2,1)*TAUYZ+S(J,K,I,3,1)*TAUZZ) )
            AP(I,J,5,2) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD2+V(I,J)*DTXYD2+W(I,J)*DTXZD2-DQDXD2)
     2 + S(J,K,I,2,1)*(U(I,J)*DTXYD2+V(I,J)*DTYYD2              -DQDYD2)
     3 + S(J,K,I,3,1)*(U(I,J)*DTXZD2              +W(I,J)*DTZZD2-DQDZD2)
     4 + 0.5E0/Q(J,K,I+1,1)*(S(J,K,I,1,1)*TAUXX
     5                      +S(J,K,I,2,1)*TAUXY+S(J,K,I,3,1)*TAUXZ) )
            AP(I,J,5,3) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD3+V(I,J)*DTXYD3              -DQDXD3)
     2 + S(J,K,I,2,1)*(U(I,J)*DTXYD3+V(I,J)*DTYYD3+W(I,J)*DTYZD3-DQDYD3)
     3 + S(J,K,I,3,1)*(              V(I,J)*DTYZD3+W(I,J)*DTZZD3-DQDZD3)
     4 + 0.5E0/Q(J,K,I+1,1)*(S(J,K,I,1,1)*TAUXY
     5                      +S(J,K,I,2,1)*TAUYY+S(J,K,I,3,1)*TAUYZ) )
            AP(I,J,5,4) = AREAMR *
     1 ( S(J,K,I,1,1)*(U(I,J)*DTXXD4              +W(I,J)*DTXZD4-DQDXD4)
     2 + S(J,K,I,2,1)*(              V(I,J)*DTYYD4+W(I,J)*DTYZD4-DQDYD4)
     3 + S(J,K,I,3,1)*(U(I,J)*DTXZD4+V(I,J)*DTYZD4+W(I,J)*DTZZD4-DQDZD4)
     4 + 0.5E0/Q(J,K,I+1,1)*(S(J,K,I,1,1)*TAUXZ
     5                      +S(J,K,I,2,1)*TAUYZ+S(J,K,I,3,1)*TAUZZ) )
            AP(I,J,5,5) = - AREAMR *
     1                      ( S(J,K,I,1,1)*DQDXD5 + S(J,K,I,2,1)*DQDYD5
     2                      + S(J,K,I,3,1)*DQDZD5 )
  510    CONTINUE
  520 CONTINUE
C
C     Finished with implicit Thin Layer Viscous Terms in the I direction
      RETURN
      END
      SUBROUTINE DFVTLJ (IDIM, JDIM, KDIM, I, ITURB,
     1                   Q, RMU, RMUT, S, VOL, IBCDAT, NBCS,
     2                   T, U, V, W, RMUJ, RMUTJ, AP, AM)
C
C     Routine to calculate the Jacobians of the thin layer Navier-Stokes
C     terms for the J direction.
C
C     This routine is not presently suited for the multiblock
C     approach.  It is close to being ready but is not.  The problem
C     lies that the metrics for one cell into the adjacent block
C     are needed to be completely general.  These are currently not available.
C     The routine metbc needs to be completed.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Current I Plane
C     ITURB          : Turbulence model
C     Q              : Primitive variables at cell centers
C     RMU            : Molecular viscosity at cell centers
C     RMUT           : Turbulent eddy viscosity at cell centers
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     T              : Temporary storage of Temperature
C     U,V,W          : Temporary storage of U,V,W velocities
C     RMUJ           : Temporary storage of Viscosity at cell interfaces
C     RMUTJ          : Temporary storage of turbulent eddy viscosity
C                      at cell interfaces
C     AP,AM          : Implicit terms
C                      AP = dF(i+1/2)/dQ(i+1)
C                      AM = dF(i+1/2)/dQ(i)
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMU   (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     2          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION T     (JDIM+1,2:KDIM),
     1          RMUJ  (JDIM,2:KDIM),
     2          RMUTJ (JDIM,2:KDIM),
     3          U     (JDIM,2:KDIM),
     4          V     (JDIM,2:KDIM),
     5          W     (JDIM,2:KDIM)
C
      DIMENSION AP    (JDIM,2:KDIM,NRANK,NRANK),
     1          AM    (JDIM,2:KDIM,NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Two-Thirds
C     Four-Thirds
C
      T23 = 2.E0 / 3.E0
      T43 = 4.E0 / 3.E0
C
C     Calculate T = T / TINF  at the cell centers
C
      DO 120 K = 2, KDIM
         DO 110 J = 1, JDIM + 1
            T(J,K) = GAMMA * Q(J,K,I,5) / Q(J,K,I,1)
  110    CONTINUE
  120 CONTINUE
C
C     Calculate U,V,W,RMUJ,RMUTJ at cell interfaces as averages of cell centers
C
      DO 220 K = 2, KDIM
         DO 210 J = 1, JDIM
            U(J,K)     = 0.5E0 * ( Q(J,K,I,2)  + Q(J+1,K,I,2) )
            V(J,K)     = 0.5E0 * ( Q(J,K,I,3)  + Q(J+1,K,I,3) )
            W(J,K)     = 0.5E0 * ( Q(J,K,I,4)  + Q(J+1,K,I,4) )
            RMUJ(J,K)  = 0.5E0 * ( RMU(J,K,I)  + RMU(J+1,K,I) )
            RMUTJ(J,K) = 0.5E0 * ( RMUT(J,K,I) + RMUT(J+1,K,I) )
  210    CONTINUE
  220 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 350 IBC = 1, NBCS
         IF (IBCDAT(1,IBC) .EQ. IWALL .AND.
     1       IBCDAT(2,IBC) .EQ. 2) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
            IF (INROUT .EQ. 1) THEN
               JBCPT = 1
               JNTR  = 1
            ELSE
               JBCPT = JDIM + 1
               JNTR  = JDIM
            ENDIF
            IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
               DO 330 K = KSTRT, KEND
                  U(JNTR,K)     = 0.E0
                  V(JNTR,K)     = 0.E0
                  W(JNTR,K)     = 0.E0
                  RMUJ(JNTR,K)  = RMU(JBCPT,K,I)
                  RMUTJ(JNTR,K) = RMUT(JBCPT,K,I)
  330          CONTINUE
            ENDIF
         ENDIF
  350 CONTINUE
C
C     Loop over K forming viscous terms along the J direction
C     on the J = 1, JDIM faces
C
      DO 520 K = 2, KDIM
         DO 510 J = 1, JDIM
C
            AREAMR = S(J,K,I,4,2) * FSMACH / RE
C
C     Average metrics and cell volume
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
            VOLAUX = 2.0E0 / ( VOL(J,K,I) + VOL(J+1,K,I) )
            SPJ1   = 0.5E0 * ( S(J+1,K,I,1,2)*S(J+1,K,I,4,2)
     1                       + S(J,K,I,1,2)*S(J,K,I,4,2) )
            SPJ2   = 0.5E0 * ( S(J+1,K,I,2,2)*S(J+1,K,I,4,2)
     1                       + S(J,K,I,2,2)*S(J,K,I,4,2) )
            SPJ3   = 0.5E0 * ( S(J+1,K,I,3,2)*S(J+1,K,I,4,2)
     1                       + S(J,K,I,3,2)*S(J,K,I,4,2) )
            SMJ1   = 0.5E0 * ( S(J-1,K,I,1,2)*S(J-1,K,I,4,2)
     1                       + S(J,K,I,1,2)*S(J,K,I,4,2) )
            SMJ2   = 0.5E0 * ( S(J-1,K,I,2,2)*S(J-1,K,I,4,2)
     1                       + S(J,K,I,2,2)*S(J,K,I,4,2) )
            SMJ3   = 0.5E0 * ( S(J-1,K,I,3,2)*S(J-1,K,I,4,2)
     1                       + S(J,K,I,3,2)*S(J,K,I,4,2) )
C
C     Calculate first derivative terms using Divergence Theorem
C
            DUDX = VOLAUX * (Q(J+1,K,I,2)*SPJ1 - Q(J,K,I,2)*SMJ1)
            DUDY = VOLAUX * (Q(J+1,K,I,2)*SPJ2 - Q(J,K,I,2)*SMJ2)
            DUDZ = VOLAUX * (Q(J+1,K,I,2)*SPJ3 - Q(J,K,I,2)*SMJ3)
C
            DVDX = VOLAUX * (Q(J+1,K,I,3)*SPJ1 - Q(J,K,I,3)*SMJ1)
            DVDY = VOLAUX * (Q(J+1,K,I,3)*SPJ2 - Q(J,K,I,3)*SMJ2)
            DVDZ = VOLAUX * (Q(J+1,K,I,3)*SPJ3 - Q(J,K,I,3)*SMJ3)
C
            DWDX = VOLAUX * (Q(J+1,K,I,4)*SPJ1 - Q(J,K,I,4)*SMJ1)
            DWDY = VOLAUX * (Q(J+1,K,I,4)*SPJ2 - Q(J,K,I,4)*SMJ2)
            DWDZ = VOLAUX * (Q(J+1,K,I,4)*SPJ3 - Q(J,K,I,4)*SMJ3)
C
            DTDX = VOLAUX * (T(J+1,K)*SPJ1 - T(J,K)*SMJ1)
            DTDY = VOLAUX * (T(J+1,K)*SPJ2 - T(J,K)*SMJ2)
            DTDZ = VOLAUX * (T(J+1,K)*SPJ3 - T(J,K)*SMJ3)
C
C     Calculate Shear Terms
C     Use molecular viscosity (RMUJ) and turbulent eddy viscosity (RMUTJ)
C     averaged from cell centers to get viscosity at cell interface.
C     T23 is two-thirds.
C
            VISC  = RMUJ(J,K) + RMUTJ(J,K)
            TAUXX = T23 * VISC * ( 2.E0*DUDX - DVDY - DWDZ )
            TAUYY = T23 * VISC * ( 2.E0*DVDY - DUDX - DWDZ )
            TAUZZ = T23 * VISC * ( 2.E0*DWDZ - DUDX - DVDY )
            TAUXY = VISC * ( DUDY + DVDX )
            TAUXZ = VISC * ( DWDX + DUDZ )
            TAUYZ = VISC * ( DWDY + DVDZ )
C
C     Heat Flux terms are not used in the current implementation of the
C     implicit viscous terms.  This is kept for compatibility reasons
C     and in case they are later included in d(RMU) terms.
C     Calculate Heat Flux Terms
C
C           CNDCT = (RMUJ(J,K)/PR + RMUTJ(J,K)/PRT) / GAMM1
C           QDOTX = - CNDCT * DTDX
C           QDOTY = - CNDCT * DTDY
C           QDOTZ = - CNDCT * DTDZ
C
C     Region to calculate AM = dF(i+1/2)/dQ(i)  terms
C
C     Calculate DTau(xx,xy,xz,...)/DQ(1,2,3,...) terms
C
            RMRV    = VISC * VOLAUX / Q(J,K,I,1)
C
C     DTau(xx)
C
            DTXXD1 =   T23 * RMRV * ( 2.E0*SMJ1*Q(J,K,I,2)
     1                       - SMJ2*Q(J,K,I,3) - SMJ3*Q(J,K,I,4) )
            DTXXD2 = - T43 * RMRV * SMJ1
            DTXXD3 =   T23 * RMRV * SMJ2
            DTXXD4 =   T23 * RMRV * SMJ3
C
C     DTau(yy)
C
            DTYYD1 =   T23 * RMRV * ( 2.E0*SMJ2*Q(J,K,I,3)
     1                       - SMJ1*Q(J,K,I,2) - SMJ3*Q(J,K,I,4) )
            DTYYD2 =   T23 * RMRV * SMJ1
            DTYYD3 = - T43 * RMRV * SMJ2
            DTYYD4 =   T23 * RMRV * SMJ3
C
C     DTau(zz)
C
            DTZZD1 =   T23 * RMRV * ( 2.E0*SMJ3*Q(J,K,I,4)
     1                       - SMJ1*Q(J,K,I,2) - SMJ2*Q(J,K,I,3) )
            DTZZD2 =   T23 * RMRV * SMJ1
            DTZZD3 =   T23 * RMRV * SMJ2
            DTZZD4 = - T43 * RMRV * SMJ3
C
C     DTau(xy)
C
            DTXYD1 =   RMRV * ( SMJ1*Q(J,K,I,3) + SMJ2*Q(J,K,I,2) )
            DTXYD2 = - RMRV * SMJ2
            DTXYD3 = - RMRV * SMJ1
C
C     DTau(xz)
C
            DTXZD1 =   RMRV * ( SMJ1*Q(J,K,I,4) + SMJ3*Q(J,K,I,2) )
            DTXZD2 = - RMRV * SMJ3
            DTXZD4 = - RMRV * SMJ1
C
C     DTau(yz)
C
            DTYZD1 =   RMRV * ( SMJ2*Q(J,K,I,4) + SMJ3*Q(J,K,I,3) )
            DTYZD3 = - RMRV * SMJ3
            DTYZD4 = - RMRV * SMJ2
C
C     DQdot(x)
C
            TEMP   =   (RMUJ(J,K)/PR + RMUTJ(J,K)/PRT) * GAMMA * VOLAUX
     1                  / Q(J,K,I,1)
C
            DQDXD1 = - TEMP * SMJ1 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDXD2 = - TEMP * SMJ1 * Q(J,K,I,2)
            DQDXD3 = - TEMP * SMJ1 * Q(J,K,I,3)
            DQDXD4 = - TEMP * SMJ1 * Q(J,K,I,4)
            DQDXD5 =   TEMP * SMJ1
C
C     DQdot(y)
C
            DQDYD1 = - TEMP * SMJ2 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDYD2 = - TEMP * SMJ2 * Q(J,K,I,2)
            DQDYD3 = - TEMP * SMJ2 * Q(J,K,I,3)
            DQDYD4 = - TEMP * SMJ2 * Q(J,K,I,4)
            DQDYD5 =   TEMP * SMJ2
C
C     DQdot(z)
C
            DQDZD1 = - TEMP * SMJ3 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDZD2 = - TEMP * SMJ3 * Q(J,K,I,2)
            DQDZD3 = - TEMP * SMJ3 * Q(J,K,I,3)
            DQDZD4 = - TEMP * SMJ3 * Q(J,K,I,4)
            DQDZD5 =   TEMP * SMJ3
C
C     Calculate AM = dF(i+1/2)/dQ(i)
C
            AM(J,K,1,1) = 0.E0
            AM(J,K,1,2) = 0.E0
            AM(J,K,1,3) = 0.E0
            AM(J,K,1,4) = 0.E0
            AM(J,K,1,5) = 0.E0
C
            AM(J,K,2,1) = ( S(J,K,I,1,2)*DTXXD1 + S(J,K,I,2,2)*DTXYD1
     1                    + S(J,K,I,3,2)*DTXZD1 ) * AREAMR
            AM(J,K,2,2) = ( S(J,K,I,1,2)*DTXXD2 + S(J,K,I,2,2)*DTXYD2
     1                    + S(J,K,I,3,2)*DTXZD2 ) * AREAMR
            AM(J,K,2,3) = ( S(J,K,I,1,2)*DTXXD3 + S(J,K,I,2,2)*DTXYD3 )
     1                                            * AREAMR
            AM(J,K,2,4) = ( S(J,K,I,1,2)*DTXXD4 + S(J,K,I,3,2)*DTXZD4 )
     1                                            * AREAMR
            AM(J,K,2,5) = 0.E0
C
            AM(J,K,3,1) = ( S(J,K,I,1,2)*DTXYD1 + S(J,K,I,2,2)*DTYYD1
     1                    + S(J,K,I,3,2)*DTYZD1 ) * AREAMR
            AM(J,K,3,2) = ( S(J,K,I,1,2)*DTXYD2 + S(J,K,I,2,2)*DTYYD2 )
     1                                            * AREAMR
            AM(J,K,3,3) = ( S(J,K,I,1,2)*DTXYD3 + S(J,K,I,2,2)*DTYYD3
     1                    + S(J,K,I,3,2)*DTYZD3 ) * AREAMR
            AM(J,K,3,4) = ( S(J,K,I,2,2)*DTYYD4 + S(J,K,I,3,2)*DTYZD4 )
     1                                            * AREAMR
            AM(J,K,3,5) = 0.E0
C
            AM(J,K,4,1) = ( S(J,K,I,1,2)*DTXZD1 + S(J,K,I,2,2)*DTYZD1
     1                    + S(J,K,I,3,2)*DTZZD1 ) * AREAMR
            AM(J,K,4,2) = ( S(J,K,I,1,2)*DTXZD2 + S(J,K,I,3,2)*DTZZD2 )
     1                                            * AREAMR
            AM(J,K,4,3) = ( S(J,K,I,2,2)*DTYZD3 + S(J,K,I,3,2)*DTZZD3 )
     1                                            * AREAMR
            AM(J,K,4,4) = ( S(J,K,I,1,2)*DTXZD4 + S(J,K,I,2,2)*DTYZD4
     1                    + S(J,K,I,3,2)*DTZZD4 ) * AREAMR
            AM(J,K,4,5) = 0.E0
C
            AM(J,K,5,1) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD1+V(J,K)*DTXYD1+W(J,K)*DTXZD1-DQDXD1)
     2 + S(J,K,I,2,2)*(U(J,K)*DTXYD1+V(J,K)*DTYYD1+W(J,K)*DTYZD1-DQDYD1)
     3 + S(J,K,I,3,2)*(U(J,K)*DTXZD1+V(J,K)*DTYZD1+W(J,K)*DTZZD1-DQDZD1)
     4 - 0.5E0*Q(J,K,I,2)/Q(J,K,I,1)*(S(J,K,I,1,2)*TAUXX
     5                    +S(J,K,I,2,2)*TAUXY+S(J,K,I,3,2)*TAUXZ)
     6 - 0.5E0*Q(J,K,I,3)/Q(J,K,I,1)*(S(J,K,I,1,2)*TAUXY
     7                    +S(J,K,I,2,2)*TAUYY+S(J,K,I,3,2)*TAUYZ)
     8 - 0.5E0*Q(J,K,I,4)/Q(J,K,I,1)*(S(J,K,I,1,2)*TAUXZ
     9                    +S(J,K,I,2,2)*TAUYZ+S(J,K,I,3,2)*TAUZZ) )
            AM(J,K,5,2) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD2+V(J,K)*DTXYD2+W(J,K)*DTXZD2-DQDXD2)
     2 + S(J,K,I,2,2)*(U(J,K)*DTXYD2+V(J,K)*DTYYD2              -DQDYD2)
     3 + S(J,K,I,3,2)*(U(J,K)*DTXZD2              +W(J,K)*DTZZD2-DQDZD2)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,2)*TAUXX
     5                    +S(J,K,I,2,2)*TAUXY+S(J,K,I,3,2)*TAUXZ) )
            AM(J,K,5,3) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD3+V(J,K)*DTXYD3              -DQDXD3)
     2 + S(J,K,I,2,2)*(U(J,K)*DTXYD3+V(J,K)*DTYYD3+W(J,K)*DTYZD3-DQDYD3)
     3 + S(J,K,I,3,2)*(              V(J,K)*DTYZD3+W(J,K)*DTZZD3-DQDZD3)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,2)*TAUXY
     5                    +S(J,K,I,2,2)*TAUYY+S(J,K,I,3,2)*TAUYZ) )
            AM(J,K,5,4) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD4              +W(J,K)*DTXZD4-DQDXD4)
     2 + S(J,K,I,2,2)*(              V(J,K)*DTYYD4+W(J,K)*DTYZD4-DQDYD4)
     3 + S(J,K,I,3,2)*(U(J,K)*DTXZD4+V(J,K)*DTYZD4+W(J,K)*DTZZD4-DQDZD4)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,2)*TAUXZ
     5                    +S(J,K,I,2,2)*TAUYZ+S(J,K,I,3,2)*TAUZZ) )
            AM(J,K,5,5) = - AREAMR *
     1                      ( S(J,K,I,1,2)*DQDXD5 + S(J,K,I,2,2)*DQDYD5
     2                      + S(J,K,I,3,2)*DQDZD5 )
  510    CONTINUE
         DO 515 J = 1, JDIM
C
            AREAMR = S(J,K,I,4,2) * FSMACH / RE
C
C     Average metrics and cell volume
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
            VOLAUX = 2.0E0 / ( VOL(J,K,I) + VOL(J+1,K,I) )
            SPJ1   = 0.5E0 * ( S(J+1,K,I,1,2)*S(J+1,K,I,4,2)
     1                       + S(J,K,I,1,2)*S(J,K,I,4,2) )
            SPJ2   = 0.5E0 * ( S(J+1,K,I,2,2)*S(J+1,K,I,4,2)
     1                       + S(J,K,I,2,2)*S(J,K,I,4,2) )
            SPJ3   = 0.5E0 * ( S(J+1,K,I,3,2)*S(J+1,K,I,4,2)
     1                       + S(J,K,I,3,2)*S(J,K,I,4,2) )
            SMJ1   = 0.5E0 * ( S(J-1,K,I,1,2)*S(J-1,K,I,4,2)
     1                       + S(J,K,I,1,2)*S(J,K,I,4,2) )
            SMJ2   = 0.5E0 * ( S(J-1,K,I,2,2)*S(J-1,K,I,4,2)
     1                       + S(J,K,I,2,2)*S(J,K,I,4,2) )
            SMJ3   = 0.5E0 * ( S(J-1,K,I,3,2)*S(J-1,K,I,4,2)
     1                       + S(J,K,I,3,2)*S(J,K,I,4,2) )
C
C     Calculate first derivative terms using Divergence Theorem
C
            DUDX = VOLAUX * (Q(J+1,K,I,2)*SPJ1 - Q(J,K,I,2)*SMJ1)
            DUDY = VOLAUX * (Q(J+1,K,I,2)*SPJ2 - Q(J,K,I,2)*SMJ2)
            DUDZ = VOLAUX * (Q(J+1,K,I,2)*SPJ3 - Q(J,K,I,2)*SMJ3)
C
            DVDX = VOLAUX * (Q(J+1,K,I,3)*SPJ1 - Q(J,K,I,3)*SMJ1)
            DVDY = VOLAUX * (Q(J+1,K,I,3)*SPJ2 - Q(J,K,I,3)*SMJ2)
            DVDZ = VOLAUX * (Q(J+1,K,I,3)*SPJ3 - Q(J,K,I,3)*SMJ3)
C
            DWDX = VOLAUX * (Q(J+1,K,I,4)*SPJ1 - Q(J,K,I,4)*SMJ1)
            DWDY = VOLAUX * (Q(J+1,K,I,4)*SPJ2 - Q(J,K,I,4)*SMJ2)
            DWDZ = VOLAUX * (Q(J+1,K,I,4)*SPJ3 - Q(J,K,I,4)*SMJ3)
C
            DTDX = VOLAUX * (T(J+1,K)*SPJ1 - T(J,K)*SMJ1)
            DTDY = VOLAUX * (T(J+1,K)*SPJ2 - T(J,K)*SMJ2)
            DTDZ = VOLAUX * (T(J+1,K)*SPJ3 - T(J,K)*SMJ3)
C
C     Calculate Shear Terms
C     Use molecular viscosity (RMUJ) and turbulent eddy viscosity (RMUTJ)
C     averaged from cell centers to get viscosity at cell interface.
C     T23 is two-thirds.
C
            VISC  = RMUJ(J,K) + RMUTJ(J,K)
            TAUXX = T23 * VISC * ( 2.E0*DUDX - DVDY - DWDZ )
            TAUYY = T23 * VISC * ( 2.E0*DVDY - DUDX - DWDZ )
            TAUZZ = T23 * VISC * ( 2.E0*DWDZ - DUDX - DVDY )
            TAUXY = VISC * ( DUDY + DVDX )
            TAUXZ = VISC * ( DWDX + DUDZ )
            TAUYZ = VISC * ( DWDY + DVDZ )
C
C     Heat Flux terms are not used in the current implementation of the
C     implicit viscous terms.  This is kept for compatibility reasons
C     and in case they are later included in d(RMU) terms.
C     Calculate Heat Flux Terms
C
C           CNDCT = (RMUJ(J,K)/PR + RMUTJ(J,K)/PRT) / GAMM1
C           QDOTX = - CNDCT * DTDX
C           QDOTY = - CNDCT * DTDY
C           QDOTZ = - CNDCT * DTDZ
C
C     Region to calculate AP = dF(i+1/2)/dQ(i)  terms
C
C     Calculate DTau(xx,xy,xz,...)/DQ(1,2,3,...) terms
C
            RMRV    = VISC * VOLAUX / Q(J+1,K,I,1)
C
C     DTau(xx)
C
            DTXXD1 = - T23 * RMRV * ( 2.E0*SPJ1*Q(J+1,K,I,2)
     1                     - SPJ2*Q(J+1,K,I,3) - SPJ3*Q(J+1,K,I,4) )
            DTXXD2 =   T43 * RMRV * SPJ1
            DTXXD3 = - T23 * RMRV * SPJ2
            DTXXD4 = - T23 * RMRV * SPJ3
C
C     DTau(yy)
C
            DTYYD1 = - T23 * RMRV * ( 2.E0*SPJ2*Q(J+1,K,I,3)
     1                     - SPJ1*Q(J+1,K,I,2) - SPJ3*Q(J+1,K,I,4) )
            DTYYD2 = - T23 * RMRV * SPJ1
            DTYYD3 =   T43 * RMRV * SPJ2
            DTYYD4 = - T23 * RMRV * SPJ3
C
C     DTau(zz)
C
            DTZZD1 = - T23 * RMRV * ( 2.E0*SPJ3*Q(J+1,K,I,4)
     1                     - SPJ1*Q(J+1,K,I,2) - SPJ2*Q(J+1,K,I,3) )
            DTZZD2 = - T23 * RMRV * SPJ1
            DTZZD3 = - T23 * RMRV * SPJ2
            DTZZD4 =   T43 * RMRV * SPJ3
C
C     DTau(xy)
C
            DTXYD1 = - RMRV * ( SPJ1*Q(J+1,K,I,3) + SPJ2*Q(J+1,K,I,2) )
            DTXYD2 =   RMRV * SPJ2
            DTXYD3 =   RMRV * SPJ1
C
C     DTau(xz)
C
            DTXZD1 = - RMRV * ( SPJ1*Q(J+1,K,I,4) + SPJ3*Q(J+1,K,I,2) )
            DTXZD2 =   RMRV * SPJ3
            DTXZD4 =   RMRV * SPJ1
C
C     DTau(yz)
C
            DTYZD1 = - RMRV * ( SPJ2*Q(J+1,K,I,4) + SPJ3*Q(J+1,K,I,3) )
            DTYZD3 =   RMRV * SPJ3
            DTYZD4 =   RMRV * SPJ2
C
C     DQdot(x)
C
            TEMP   =   (RMUJ(J,K)/PR + RMUTJ(J,K)/PRT) * GAMMA * VOLAUX
     1                  / Q(J+1,K,I,1)
C
            DQDXD1 =   TEMP * SPJ1 * ( Q(J+1,K,I,5)/GAMM1
     1             - 0.5E0*Q(J+1,K,I,1)*( Q(J+1,K,I,2)*Q(J+1,K,I,2)
     2         +Q(J+1,K,I,3)*Q(J+1,K,I,3)+Q(J+1,K,I,4)*Q(J+1,K,I,4) ) )
     3                    / Q(J+1,K,I,1)
            DQDXD2 =   TEMP * SPJ1 * Q(J+1,K,I,2)
            DQDXD3 =   TEMP * SPJ1 * Q(J+1,K,I,3)
            DQDXD4 =   TEMP * SPJ1 * Q(J+1,K,I,4)
            DQDXD5 = - TEMP * SPJ1
C
C     DQdot(y)
C
            DQDYD1 =   TEMP * SPJ2 * ( Q(J+1,K,I,5)/GAMM1
     1             - 0.5E0*Q(J+1,K,I,1)*( Q(J+1,K,I,2)*Q(J+1,K,I,2)
     2         +Q(J+1,K,I,3)*Q(J+1,K,I,3)+Q(J+1,K,I,4)*Q(J+1,K,I,4) ) )
     3                    / Q(J+1,K,I,1)
            DQDYD2 =   TEMP * SPJ2 * Q(J+1,K,I,2)
            DQDYD3 =   TEMP * SPJ2 * Q(J+1,K,I,3)
            DQDYD4 =   TEMP * SPJ2 * Q(J+1,K,I,4)
            DQDYD5 = - TEMP * SPJ2
C
C     DQdot(z)
C
            DQDZD1 =   TEMP * SPJ3 * ( Q(J+1,K,I,5)/GAMM1
     1             - 0.5E0*Q(J+1,K,I,1)*( Q(J+1,K,I,2)*Q(J+1,K,I,2)
     2         +Q(J+1,K,I,3)*Q(J+1,K,I,3)+Q(J+1,K,I,4)*Q(J+1,K,I,4) ) )
     3                    / Q(J+1,K,I,1)
            DQDZD2 =   TEMP * SPJ3 * Q(J+1,K,I,2)
            DQDZD3 =   TEMP * SPJ3 * Q(J+1,K,I,3)
            DQDZD4 =   TEMP * SPJ3 * Q(J+1,K,I,4)
            DQDZD5 = - TEMP * SPJ3
C
C     Calculate AP = dF(i+1/2)/dQ(i+1)
C
            AP(J,K,1,1) = 0.E0
            AP(J,K,1,2) = 0.E0
            AP(J,K,1,3) = 0.E0
            AP(J,K,1,4) = 0.E0
            AP(J,K,1,5) = 0.E0
C
            AP(J,K,2,1) = ( S(J,K,I,1,2)*DTXXD1 + S(J,K,I,2,2)*DTXYD1
     1                    + S(J,K,I,3,2)*DTXZD1 ) * AREAMR
            AP(J,K,2,2) = ( S(J,K,I,1,2)*DTXXD2 + S(J,K,I,2,2)*DTXYD2
     1                    + S(J,K,I,3,2)*DTXZD2 ) * AREAMR
            AP(J,K,2,3) = ( S(J,K,I,1,2)*DTXXD3 + S(J,K,I,2,2)*DTXYD3 )
     1                                            * AREAMR
            AP(J,K,2,4) = ( S(J,K,I,1,2)*DTXXD4 + S(J,K,I,3,2)*DTXZD4 )
     1                                            * AREAMR
            AP(J,K,2,5) = 0.E0
C
            AP(J,K,3,1) = ( S(J,K,I,1,2)*DTXYD1 + S(J,K,I,2,2)*DTYYD1
     1                    + S(J,K,I,3,2)*DTYZD1 ) * AREAMR
            AP(J,K,3,2) = ( S(J,K,I,1,2)*DTXYD2 + S(J,K,I,2,2)*DTYYD2 )
     1                                            * AREAMR
            AP(J,K,3,3) = ( S(J,K,I,1,2)*DTXYD3 + S(J,K,I,2,2)*DTYYD3
     1                    + S(J,K,I,3,2)*DTYZD3 ) * AREAMR
            AP(J,K,3,4) = ( S(J,K,I,2,2)*DTYYD4 + S(J,K,I,3,2)*DTYZD4 )
     1                                            * AREAMR
            AP(J,K,3,5) = 0.E0
C
            AP(J,K,4,1) = ( S(J,K,I,1,2)*DTXZD1 + S(J,K,I,2,2)*DTYZD1
     1                    + S(J,K,I,3,2)*DTZZD1 ) * AREAMR
            AP(J,K,4,2) = ( S(J,K,I,1,2)*DTXZD2 + S(J,K,I,3,2)*DTZZD2 )
     1                                            * AREAMR
            AP(J,K,4,3) = ( S(J,K,I,2,2)*DTYZD3 + S(J,K,I,3,2)*DTZZD3 )
     1                                            * AREAMR
            AP(J,K,4,4) = ( S(J,K,I,1,2)*DTXZD4 + S(J,K,I,2,2)*DTYZD4
     1                    + S(J,K,I,3,2)*DTZZD4 ) * AREAMR
            AP(J,K,4,5) = 0.E0
C
            AP(J,K,5,1) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD1+V(J,K)*DTXYD1+W(J,K)*DTXZD1-DQDXD1)
     2 + S(J,K,I,2,2)*(U(J,K)*DTXYD1+V(J,K)*DTYYD1+W(J,K)*DTYZD1-DQDYD1)
     3 + S(J,K,I,3,2)*(U(J,K)*DTXZD1+V(J,K)*DTYZD1+W(J,K)*DTZZD1-DQDZD1)
     4 - 0.5E0*Q(J+1,K,I,2)/Q(J+1,K,I,1)*(S(J,K,I,1,2)*TAUXX
     5                    +S(J,K,I,2,2)*TAUXY+S(J,K,I,3,2)*TAUXZ)
     6 - 0.5E0*Q(J+1,K,I,3)/Q(J+1,K,I,1)*(S(J,K,I,1,2)*TAUXY
     7                    +S(J,K,I,2,2)*TAUYY+S(J,K,I,3,2)*TAUYZ)
     8 - 0.5E0*Q(J+1,K,I,4)/Q(J+1,K,I,1)*(S(J,K,I,1,2)*TAUXZ
     9                    +S(J,K,I,2,2)*TAUYZ+S(J,K,I,3,2)*TAUZZ) )
            AP(J,K,5,2) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD2+V(J,K)*DTXYD2+W(J,K)*DTXZD2-DQDXD2)
     2 + S(J,K,I,2,2)*(U(J,K)*DTXYD2+V(J,K)*DTYYD2              -DQDYD2)
     3 + S(J,K,I,3,2)*(U(J,K)*DTXZD2              +W(J,K)*DTZZD2-DQDZD2)
     4 + 0.5E0/Q(J+1,K,I,1)*(S(J,K,I,1,2)*TAUXX
     5                      +S(J,K,I,2,2)*TAUXY+S(J,K,I,3,2)*TAUXZ) )
            AP(J,K,5,3) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD3+V(J,K)*DTXYD3              -DQDXD3)
     2 + S(J,K,I,2,2)*(U(J,K)*DTXYD3+V(J,K)*DTYYD3+W(J,K)*DTYZD3-DQDYD3)
     3 + S(J,K,I,3,2)*(              V(J,K)*DTYZD3+W(J,K)*DTZZD3-DQDZD3)
     4 + 0.5E0/Q(J+1,K,I,1)*(S(J,K,I,1,2)*TAUXY
     5                      +S(J,K,I,2,2)*TAUYY+S(J,K,I,3,2)*TAUYZ) )
            AP(J,K,5,4) = AREAMR *
     1 ( S(J,K,I,1,2)*(U(J,K)*DTXXD4              +W(J,K)*DTXZD4-DQDXD4)
     2 + S(J,K,I,2,2)*(              V(J,K)*DTYYD4+W(J,K)*DTYZD4-DQDYD4)
     3 + S(J,K,I,3,2)*(U(J,K)*DTXZD4+V(J,K)*DTYZD4+W(J,K)*DTZZD4-DQDZD4)
     4 + 0.5E0/Q(J+1,K,I,1)*(S(J,K,I,1,2)*TAUXZ
     5                      +S(J,K,I,2,2)*TAUYZ+S(J,K,I,3,2)*TAUZZ) )
            AP(J,K,5,5) = - AREAMR *
     1                      ( S(J,K,I,1,2)*DQDXD5 + S(J,K,I,2,2)*DQDYD5
     2                      + S(J,K,I,3,2)*DQDZD5 )
  515    CONTINUE
  520 CONTINUE
C
C     Add additional terms for turbulence model
C
C     2-i.  Two-Equation models
C           N.B. This is an approximation for the Jacobian including only
C                the terms on the diagonal!
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 820 K = 2, KDIM
            DO 810 J = 1, JDIM
C
               VOLAUX = 2.0E0 / ( VOL(J,K,I) + VOL(J+1,K,I) )
               TERM   = S(J,K,I,4,2) * S(J,K,I,4,2) * VOLAUX
     1                  * FSMACH / RE
C
               AM(J,K,6,6) = - (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                         / Q(J  ,K,I,1)
               AP(J,K,6,6) =   (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                         / Q(J+1,K,I,1)
               AM(J,K,7,7) = - (RMUJ(J,K) + SIGT2 * RMUTJ(J,K)) * TERM
     1                         / Q(J  ,K,I,1)
               AP(J,K,7,7) =   (RMUJ(J,K) + SIGT2 * RMUTJ(J,K)) * TERM
     1                         / Q(J+1,K,I,1)
  810       CONTINUE
  820    CONTINUE
C
C     2-ii. Reynolds Stress model
C           N.B. This is an approximation for the Jacobian including only
C                the terms on the diagonal!
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 920 K = 2, KDIM
            DO 910 J = 1, JDIM
C
               VOLAUX = 2.0E0 / ( VOL(J,K,I) + VOL(J+1,K,I) )
               TERM   = S(J,K,I,4,2) * S(J,K,I,4,2) * VOLAUX
     1                  * FSMACH / RE
C
               AM(J,K, 6, 6) = - (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J  ,K,I,1)
               AP(J,K, 6, 6) =   (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J+1,K,I,1)
               AM(J,K, 7, 7) = - (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J  ,K,I,1)
               AP(J,K, 7, 7) =   (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J+1,K,I,1)
               AM(J,K, 8, 8) = - (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J  ,K,I,1)
               AP(J,K, 8, 8) =   (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J+1,K,I,1)
               AM(J,K, 9, 9) = - (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J  ,K,I,1)
               AP(J,K, 9, 9) =   (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J+1,K,I,1)
               AM(J,K,10,10) = - (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J  ,K,I,1)
               AP(J,K,10,10) =   (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J+1,K,I,1)
               AM(J,K,11,11) = - (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J  ,K,I,1)
               AP(J,K,11,11) =   (RMUJ(J,K) + SIGK  * RMUTJ(J,K)) * TERM
     1                           / Q(J+1,K,I,1)
C
               AM(J,K,12,12) = - (RMUJ(J,K) + SIGT2 * RMUTJ(J,K)) * TERM
     1                           / Q(J  ,K,I,1)
               AP(J,K,12,12) =   (RMUJ(J,K) + SIGT2 * RMUTJ(J,K)) * TERM
     1                           / Q(J+1,K,I,1)
  910       CONTINUE
  920    CONTINUE
      ENDIF
C
C     Finished with implicit Thin Layer Viscous Terms in the J direction
      RETURN
      END
      SUBROUTINE DFVTLK (IDIM, JDIM, KDIM, I,
     1                   Q, RMU, RMUT, S, VOL, IBCDAT, NBCS,
     2                   T, U, V, W, RMUK, RMUTK, AP, AM)
C
C     Routine to calculate the thin layer Navier-Stokes terms for
C     the K direction.
C
C     This routine is not presently suited for the multiblock
C     approach.  It is close to being ready but is not.  The problem
C     lies that the metrics for one cell into the adjacent block
C     are needed to be completely general.  These are currently not available.
C     The routine metbc needs to be completed.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Current I Plane
C     Q              : Primitive variables at cell centers
C     RMU            : Molecular viscosity at cell centers
C     RMUT           : Turbulent eddy viscosity at cell centers
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     T              : Temporary storage of Temperature
C     U,V,W          : Temporary storage of U,V,W velocities
C     RMUK           : Temporary storage of Viscosity at cell interfaces
C     RMUTK          : Temporary storage of turbulent eddy viscosity
C                      at cell interfaces
C     AP,AM          : Implicit terms
C                      AP = dF(i+1/2)/dQ(i+1)
C                      AM = dF(i+1/2)/dQ(i)
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMU   (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     2          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     3          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     4          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION T     (KDIM+1,2:JDIM),
     1          RMUK  (KDIM,2:JDIM),
     2          RMUTK (KDIM,2:JDIM),
     3          U     (KDIM,2:JDIM),
     4          V     (KDIM,2:JDIM),
     5          W     (KDIM,2:JDIM)
C
      DIMENSION AP    (KDIM,2:JDIM,NRANK,NRANK),
     1          AM    (KDIM,2:JDIM,NRANK,NRANK)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Two-Thirds
C     Four-Thirds
C
      T23 = 2.E0 / 3.E0
      T43 = 4.E0 / 3.E0
C
C     Calculate T = T / TINF  at the cell centers
C
      DO 120 J = 2, JDIM
         DO 110 K = 1, KDIM + 1
            T(K,J) = GAMMA * Q(J,K,I,5) / Q(J,K,I,1)
  110    CONTINUE
  120 CONTINUE
C
C     Calculate U,V,W,RMUK,RMUTK at cell interfaces as averages of cell centers
C
      DO 220 J = 2, JDIM
         DO 210 K = 1, KDIM
            U(K,J)     = 0.5E0 * ( Q(J,K,I,2)  + Q(J,K+1,I,2) )
            V(K,J)     = 0.5E0 * ( Q(J,K,I,3)  + Q(J,K+1,I,3) )
            W(K,J)     = 0.5E0 * ( Q(J,K,I,4)  + Q(J,K+1,I,4) )
            RMUK(K,J)  = 0.5E0 * ( RMU(J,K,I)  + RMU(J,K+1,I) )
            RMUTK(K,J) = 0.5E0 * ( RMUT(J,K,I) + RMUT(J,K+1,I) )
  210    CONTINUE
  220 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 350 IBC = 1, NBCS
         IF (IBCDAT(1,IBC) .EQ. IWALL .AND.
     1       IBCDAT(2,IBC) .EQ. 3) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            IF (INROUT .EQ. 1) THEN
               KBCPT = 1
               KNTR  = 1
            ELSE
               KBCPT = KDIM + 1
               KNTR  = KDIM
            ENDIF
            IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
               DO 330 J = JSTRT, JEND
                  U(KNTR,J)     = 0.E0
                  V(KNTR,J)     = 0.E0
                  W(KNTR,J)     = 0.E0
                  RMUK(KNTR,J)  = RMU(J,KBCPT,I)
                  RMUTK(KNTR,J) = RMUT(J,KBCPT,I)
  330          CONTINUE
            ENDIF
         ENDIF
  350 CONTINUE
C
C     Loop over J forming viscous terms along the K direction
C     on the K = 1, KDIM faces
C
      DO 520 J = 2, JDIM
         DO 510 K = 1, KDIM
C
            AREAMR = S(J,K,I,4,3) * FSMACH / RE
C
C     Average metrics and cell volume
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
            VOLAUX = 2.0E0 / ( VOL(J,K,I) + VOL(J,K+1,I) )
            SPK1   = 0.5E0 * ( S(J,K+1,I,1,3)*S(J,K+1,I,4,3)
     1                       + S(J,K,I,1,3)*S(J,K,I,4,3) )
            SPK2   = 0.5E0 * ( S(J,K+1,I,2,3)*S(J,K+1,I,4,3)
     1                       + S(J,K,I,2,3)*S(J,K,I,4,3) )
            SPK3   = 0.5E0 * ( S(J,K+1,I,3,3)*S(J,K+1,I,4,3)
     1                       + S(J,K,I,3,3)*S(J,K,I,4,3) )
            SMK1   = 0.5E0 * ( S(J,K-1,I,1,3)*S(J,K-1,I,4,3)
     1                       + S(J,K,I,1,3)*S(J,K,I,4,3) )
            SMK2   = 0.5E0 * ( S(J,K-1,I,2,3)*S(J,K-1,I,4,3)
     1                       + S(J,K,I,2,3)*S(J,K,I,4,3) )
            SMK3   = 0.5E0 * ( S(J,K-1,I,3,3)*S(J,K-1,I,4,3)
     1                       + S(J,K,I,3,3)*S(J,K,I,4,3) )
C
C     Calculate first derivative terms using Divergence Theorem
C
            DUDX = VOLAUX * (Q(J,K+1,I,2)*SPK1 - Q(J,K,I,2)*SMK1)
            DUDY = VOLAUX * (Q(J,K+1,I,2)*SPK2 - Q(J,K,I,2)*SMK2)
            DUDZ = VOLAUX * (Q(J,K+1,I,2)*SPK3 - Q(J,K,I,2)*SMK3)
C
            DVDX = VOLAUX * (Q(J,K+1,I,3)*SPK1 - Q(J,K,I,3)*SMK1)
            DVDY = VOLAUX * (Q(J,K+1,I,3)*SPK2 - Q(J,K,I,3)*SMK2)
            DVDZ = VOLAUX * (Q(J,K+1,I,3)*SPK3 - Q(J,K,I,3)*SMK3)
C
            DWDX = VOLAUX * (Q(J,K+1,I,4)*SPK1 - Q(J,K,I,4)*SMK1)
            DWDY = VOLAUX * (Q(J,K+1,I,4)*SPK2 - Q(J,K,I,4)*SMK2)
            DWDZ = VOLAUX * (Q(J,K+1,I,4)*SPK3 - Q(J,K,I,4)*SMK3)
C
            DTDX = VOLAUX * (T(K+1,J)*SPK1 - T(K,J)*SMK1)
            DTDY = VOLAUX * (T(K+1,J)*SPK2 - T(K,J)*SMK2)
            DTDZ = VOLAUX * (T(K+1,J)*SPK3 - T(K,J)*SMK3)
C
C     Calculate Shear Terms
C     Use molecular viscosity (RMUK) and turbulent eddy viscosity (RMUTK)
C     averaged from cell centers to get viscosity at cell interface.
C     T23 is two-thirds.
C
            VISC  = RMUK(K,J) + RMUTK(K,J)
            TAUXX = T23 * VISC * ( 2.E0*DUDX - DVDY - DWDZ )
            TAUYY = T23 * VISC * ( 2.E0*DVDY - DUDX - DWDZ )
            TAUZZ = T23 * VISC * ( 2.E0*DWDZ - DUDX - DVDY )
            TAUXY = VISC * ( DUDY + DVDX )
            TAUXZ = VISC * ( DWDX + DUDZ )
            TAUYZ = VISC * ( DWDY + DVDZ )
C
C     Heat Flux terms are not used in the current implementation of the
C     implicit viscous terms.  This is kept for compatibility reasons
C     and in case they are later included in d(RMU) terms.
C     Calculate Heat Flux Terms
C
C           CNDCT = (RMUK(K,J)/PR + RMUTK(K,J)/PRT) / GAMM1
C           QDOTX = - CNDCT * DTDX
C           QDOTY = - CNDCT * DTDY
C           QDOTZ = - CNDCT * DTDZ
C
C     Region to calculate AM = dF(i+1/2)/dQ(i)  terms
C
C     Calculate DTau(xx,xy,xz,...)/DQ(1,2,3,...) terms
C
            RMRV   = VISC * VOLAUX / Q(J,K,I,1)
C
C     DTau(xx)
C
            DTXXD1 =   T23 * RMRV * ( 2.E0*SMK1*Q(J,K,I,2)
     1                       - SMK2*Q(J,K,I,3) - SMK3*Q(J,K,I,4) )
            DTXXD2 = - T43 * RMRV * SMK1
            DTXXD3 =   T23 * RMRV * SMK2
            DTXXD4 =   T23 * RMRV * SMK3
C
C     DTau(yy)
C
            DTYYD1 =   T23 * RMRV * ( 2.E0*SMK2*Q(J,K,I,3)
     1                       - SMK1*Q(J,K,I,2) - SMK3*Q(J,K,I,4) )
            DTYYD2 =   T23 * RMRV * SMK1
            DTYYD3 = - T43 * RMRV * SMK2
            DTYYD4 =   T23 * RMRV * SMK3
C
C     DTau(zz)
C
            DTZZD1 =   T23 * RMRV * ( 2.E0*SMK3*Q(J,K,I,4)
     1                       - SMK1*Q(J,K,I,2) - SMK2*Q(J,K,I,3) )
            DTZZD2 =   T23 * RMRV * SMK1
            DTZZD3 =   T23 * RMRV * SMK2
            DTZZD4 = - T43 * RMRV * SMK3
C
C     DTau(xy)
C
            DTXYD1 =   RMRV * ( SMK1*Q(J,K,I,3) + SMK2*Q(J,K,I,2) )
            DTXYD2 = - RMRV * SMK2
            DTXYD3 = - RMRV * SMK1
C
C     DTau(xz)
C
            DTXZD1 =   RMRV * ( SMK1*Q(J,K,I,4) + SMK3*Q(J,K,I,2) )
            DTXZD2 = - RMRV * SMK3
            DTXZD4 = - RMRV * SMK1
C
C     DTau(yz)
C
            DTYZD1 =   RMRV * ( SMK2*Q(J,K,I,4) + SMK3*Q(J,K,I,3) )
            DTYZD3 = - RMRV * SMK3
            DTYZD4 = - RMRV * SMK2
C
C     DQdot(x)
C
            TEMP   =   (RMUK(K,J)/PR + RMUTK(K,J)/PRT) * GAMMA * VOLAUX
     1                  / Q(J,K,I,1)
C
            DQDXD1 = - TEMP * SMK1 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDXD2 = - TEMP * SMK1 * Q(J,K,I,2)
            DQDXD3 = - TEMP * SMK1 * Q(J,K,I,3)
            DQDXD4 = - TEMP * SMK1 * Q(J,K,I,4)
            DQDXD5 =   TEMP * SMK1
C
C     DQdot(y)
C
            DQDYD1 = - TEMP * SMK2 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDYD2 = - TEMP * SMK2 * Q(J,K,I,2)
            DQDYD3 = - TEMP * SMK2 * Q(J,K,I,3)
            DQDYD4 = - TEMP * SMK2 * Q(J,K,I,4)
            DQDYD5 =   TEMP * SMK2
C
C     DQdot(z)
C
            DQDZD1 = - TEMP * SMK3 * ( Q(J,K,I,5)/GAMM1
     1                   - 0.5E0*Q(J,K,I,1)*( Q(J,K,I,2)*Q(J,K,I,2)
     2                 +Q(J,K,I,3)*Q(J,K,I,3)+Q(J,K,I,4)*Q(J,K,I,4) ) )
     3                    / Q(J,K,I,1)
            DQDZD2 = - TEMP * SMK3 * Q(J,K,I,2)
            DQDZD3 = - TEMP * SMK3 * Q(J,K,I,3)
            DQDZD4 = - TEMP * SMK3 * Q(J,K,I,4)
            DQDZD5 =   TEMP * SMK3
C
C     Calculate AM = dF(i+1/2)/dQ(i)
C
            AM(K,J,1,1) = 0.E0
            AM(K,J,1,2) = 0.E0
            AM(K,J,1,3) = 0.E0
            AM(K,J,1,4) = 0.E0
            AM(K,J,1,5) = 0.E0
C
            AM(K,J,2,1) = ( S(J,K,I,1,3)*DTXXD1 + S(J,K,I,2,3)*DTXYD1
     1                    + S(J,K,I,3,3)*DTXZD1 ) * AREAMR
            AM(K,J,2,2) = ( S(J,K,I,1,3)*DTXXD2 + S(J,K,I,2,3)*DTXYD2
     1                    + S(J,K,I,3,3)*DTXZD2 ) * AREAMR
            AM(K,J,2,3) = ( S(J,K,I,1,3)*DTXXD3 + S(J,K,I,2,3)*DTXYD3 )
     1                                            * AREAMR
            AM(K,J,2,4) = ( S(J,K,I,1,3)*DTXXD4 + S(J,K,I,3,3)*DTXZD4 )
     1                                            * AREAMR
            AM(K,J,2,5) = 0.E0
C
            AM(K,J,3,1) = ( S(J,K,I,1,3)*DTXYD1 + S(J,K,I,2,3)*DTYYD1
     1                    + S(J,K,I,3,3)*DTYZD1 ) * AREAMR
            AM(K,J,3,2) = ( S(J,K,I,1,3)*DTXYD2 + S(J,K,I,2,3)*DTYYD2 )
     1                                            * AREAMR
            AM(K,J,3,3) = ( S(J,K,I,1,3)*DTXYD3 + S(J,K,I,2,3)*DTYYD3
     1                    + S(J,K,I,3,3)*DTYZD3 ) * AREAMR
            AM(K,J,3,4) = ( S(J,K,I,2,3)*DTYYD4 + S(J,K,I,3,3)*DTYZD4 )
     1                                            * AREAMR
            AM(K,J,3,5) = 0.E0
C
            AM(K,J,4,1) = ( S(J,K,I,1,3)*DTXZD1 + S(J,K,I,2,3)*DTYZD1
     1                    + S(J,K,I,3,3)*DTZZD1 ) * AREAMR
            AM(K,J,4,2) = ( S(J,K,I,1,3)*DTXZD2 + S(J,K,I,3,3)*DTZZD2 )
     1                                            * AREAMR
            AM(K,J,4,3) = ( S(J,K,I,2,3)*DTYZD3 + S(J,K,I,3,3)*DTZZD3 )
     1                                            * AREAMR
            AM(K,J,4,4) = ( S(J,K,I,1,3)*DTXZD4 + S(J,K,I,2,3)*DTYZD4
     1                    + S(J,K,I,3,3)*DTZZD4 ) * AREAMR
            AM(K,J,4,5) = 0.E0
C
            AM(K,J,5,1) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD1+V(K,J)*DTXYD1+W(K,J)*DTXZD1-DQDXD1)
     2 + S(J,K,I,2,3)*(U(K,J)*DTXYD1+V(K,J)*DTYYD1+W(K,J)*DTYZD1-DQDYD1)
     3 + S(J,K,I,3,3)*(U(K,J)*DTXZD1+V(K,J)*DTYZD1+W(K,J)*DTZZD1-DQDZD1)
     4 - 0.5E0*Q(J,K,I,2)/Q(J,K,I,1)*(S(J,K,I,1,3)*TAUXX
     5                    +S(J,K,I,2,3)*TAUXY+S(J,K,I,3,3)*TAUXZ)
     6 - 0.5E0*Q(J,K,I,3)/Q(J,K,I,1)*(S(J,K,I,1,3)*TAUXY
     7                    +S(J,K,I,2,3)*TAUYY+S(J,K,I,3,3)*TAUYZ)
     8 - 0.5E0*Q(J,K,I,4)/Q(J,K,I,1)*(S(J,K,I,1,3)*TAUXZ
     9                    +S(J,K,I,2,3)*TAUYZ+S(J,K,I,3,3)*TAUZZ) )
            AM(K,J,5,2) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD2+V(K,J)*DTXYD2+W(K,J)*DTXZD2-DQDXD2)
     2 + S(J,K,I,2,3)*(U(K,J)*DTXYD2+V(K,J)*DTYYD2              -DQDYD2)
     3 + S(J,K,I,3,3)*(U(K,J)*DTXZD2              +W(K,J)*DTZZD2-DQDZD2)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,3)*TAUXX
     5                    +S(J,K,I,2,3)*TAUXY+S(J,K,I,3,3)*TAUXZ) )
            AM(K,J,5,3) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD3+V(K,J)*DTXYD3              -DQDXD3)
     2 + S(J,K,I,2,3)*(U(K,J)*DTXYD3+V(K,J)*DTYYD3+W(K,J)*DTYZD3-DQDYD3)
     3 + S(J,K,I,3,3)*(              V(K,J)*DTYZD3+W(K,J)*DTZZD3-DQDZD3)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,3)*TAUXY
     5                    +S(J,K,I,2,3)*TAUYY+S(J,K,I,3,3)*TAUYZ) )
            AM(K,J,5,4) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD4              +W(K,J)*DTXZD4-DQDXD4)
     2 + S(J,K,I,2,3)*(              V(K,J)*DTYYD4+W(K,J)*DTYZD4-DQDYD4)
     3 + S(J,K,I,3,3)*(U(K,J)*DTXZD4+V(K,J)*DTYZD4+W(K,J)*DTZZD4-DQDZD4)
     4 + 0.5E0/Q(J,K,I,1)*(S(J,K,I,1,3)*TAUXZ
     5                    +S(J,K,I,2,3)*TAUYZ+S(J,K,I,3,3)*TAUZZ) )
            AM(K,J,5,5) = - AREAMR *
     1                      ( S(J,K,I,1,3)*DQDXD5 + S(J,K,I,2,3)*DQDYD5
     2                      + S(J,K,I,3,3)*DQDZD5 )
  510    CONTINUE
         DO 515 K = 1, KDIM
C
            AREAMR = S(J,K,I,4,3) * FSMACH / RE
C
C     Average metrics and cell volume
C
C     VOLAUX is the inverse of the average auxilliary cell volume
C
            VOLAUX = 2.0E0 / ( VOL(J,K,I) + VOL(J,K+1,I) )
            SPK1   = 0.5E0 * ( S(J,K+1,I,1,3)*S(J,K+1,I,4,3)
     1                       + S(J,K,I,1,3)*S(J,K,I,4,3) )
            SPK2   = 0.5E0 * ( S(J,K+1,I,2,3)*S(J,K+1,I,4,3)
     1                       + S(J,K,I,2,3)*S(J,K,I,4,3) )
            SPK3   = 0.5E0 * ( S(J,K+1,I,3,3)*S(J,K+1,I,4,3)
     1                       + S(J,K,I,3,3)*S(J,K,I,4,3) )
            SMK1   = 0.5E0 * ( S(J,K-1,I,1,3)*S(J,K-1,I,4,3)
     1                       + S(J,K,I,1,3)*S(J,K,I,4,3) )
            SMK2   = 0.5E0 * ( S(J,K-1,I,2,3)*S(J,K-1,I,4,3)
     1                       + S(J,K,I,2,3)*S(J,K,I,4,3) )
            SMK3   = 0.5E0 * ( S(J,K-1,I,3,3)*S(J,K-1,I,4,3)
     1                       + S(J,K,I,3,3)*S(J,K,I,4,3) )
C
C     Calculate first derivative terms using Divergence Theorem
C
            DUDX = VOLAUX * (Q(J,K+1,I,2)*SPK1 - Q(J,K,I,2)*SMK1)
            DUDY = VOLAUX * (Q(J,K+1,I,2)*SPK2 - Q(J,K,I,2)*SMK2)
            DUDZ = VOLAUX * (Q(J,K+1,I,2)*SPK3 - Q(J,K,I,2)*SMK3)
C
            DVDX = VOLAUX * (Q(J,K+1,I,3)*SPK1 - Q(J,K,I,3)*SMK1)
            DVDY = VOLAUX * (Q(J,K+1,I,3)*SPK2 - Q(J,K,I,3)*SMK2)
            DVDZ = VOLAUX * (Q(J,K+1,I,3)*SPK3 - Q(J,K,I,3)*SMK3)
C
            DWDX = VOLAUX * (Q(J,K+1,I,4)*SPK1 - Q(J,K,I,4)*SMK1)
            DWDY = VOLAUX * (Q(J,K+1,I,4)*SPK2 - Q(J,K,I,4)*SMK2)
            DWDZ = VOLAUX * (Q(J,K+1,I,4)*SPK3 - Q(J,K,I,4)*SMK3)
C
            DTDX = VOLAUX * (T(K+1,J)*SPK1 - T(K,J)*SMK1)
            DTDY = VOLAUX * (T(K+1,J)*SPK2 - T(K,J)*SMK2)
            DTDZ = VOLAUX * (T(K+1,J)*SPK3 - T(K,J)*SMK3)
C
C     Calculate Shear Terms
C     Use molecular viscosity (RMUK) and turbulent eddy viscosity (RMUTK)
C     averaged from cell centers to get viscosity at cell interface.
C     T23 is two-thirds.
C
            VISC  = RMUK(K,J) + RMUTK(K,J)
            TAUXX = T23 * VISC * ( 2.E0*DUDX - DVDY - DWDZ )
            TAUYY = T23 * VISC * ( 2.E0*DVDY - DUDX - DWDZ )
            TAUZZ = T23 * VISC * ( 2.E0*DWDZ - DUDX - DVDY )
            TAUXY = VISC * ( DUDY + DVDX )
            TAUXZ = VISC * ( DWDX + DUDZ )
            TAUYZ = VISC * ( DWDY + DVDZ )
C
C     Heat Flux terms are not used in the current implementation of the
C     implicit viscous terms.  This is kept for compatibility reasons
C     and in case they are later included in d(RMU) terms.
C     Calculate Heat Flux Terms
C
C           CNDCT = (RMUK(K,J)/PR + RMUTK(K,J)/PRT) / GAMM1
C           QDOTX = - CNDCT * DTDX
C           QDOTY = - CNDCT * DTDY
C           QDOTZ = - CNDCT * DTDZ
C
C     Region to calculate AP = dF(i+1/2)/dQ(i)  terms
C
C     Calculate DTau(xx,xy,xz,...)/DQ(1,2,3,...) terms
C
            RMRV   = VISC * VOLAUX / Q(J,K+1,I,1)
C
C     DTau(xx)
C
            DTXXD1 = - T23 * RMRV * ( 2.E0*SPK1*Q(J,K+1,I,2)
     1                     - SPK2*Q(J,K+1,I,3) - SPK3*Q(J,K+1,I,4) )
            DTXXD2 =   T43 * RMRV * SPK1
            DTXXD3 = - T23 * RMRV * SPK2
            DTXXD4 = - T23 * RMRV * SPK3
C
C     DTau(yy)
C
            DTYYD1 = - T23 * RMRV * ( 2.E0*SPK2*Q(J,K+1,I,3)
     1                     - SPK1*Q(J,K+1,I,2) - SPK3*Q(J,K+1,I,4) )
            DTYYD2 = - T23 * RMRV * SPK1
            DTYYD3 =   T43 * RMRV * SPK2
            DTYYD4 = - T23 * RMRV * SPK3
C
C     DTau(zz)
C
            DTZZD1 = - T23 * RMRV * ( 2.E0*SPK3*Q(J,K+1,I,4)
     1                     - SPK1*Q(J,K+1,I,2) - SPK2*Q(J,K+1,I,3) )
            DTZZD2 = - T23 * RMRV * SPK1
            DTZZD3 = - T23 * RMRV * SPK2
            DTZZD4 =   T43 * RMRV * SPK3
C
C     DTau(xy)
C
            DTXYD1 = - RMRV * ( SPK1*Q(J,K+1,I,3) + SPK2*Q(J,K+1,I,2) )
            DTXYD2 =   RMRV * SPK2
            DTXYD3 =   RMRV * SPK1
C
C     DTau(xz)
C
            DTXZD1 = - RMRV * ( SPK1*Q(J,K+1,I,4) + SPK3*Q(J,K+1,I,2) )
            DTXZD2 =   RMRV * SPK3
            DTXZD4 =   RMRV * SPK1
C
C     DTau(yz)
C
            DTYZD1 = - RMRV * ( SPK2*Q(J,K+1,I,4) + SPK3*Q(J,K+1,I,3) )
            DTYZD3 =   RMRV * SPK3
            DTYZD4 =   RMRV * SPK2
C
C     DQdot(x)
C
            TEMP   =   (RMUK(K,J)/PR + RMUTK(K,J)/PRT) * GAMMA * VOLAUX
     1                  / Q(J,K+1,I,1)
C
            DQDXD1 =   TEMP * SPK1 * ( Q(J,K+1,I,5)/GAMM1
     1             - 0.5E0*Q(J,K+1,I,1)*( Q(J,K+1,I,2)*Q(J,K+1,I,2)
     2         +Q(J,K+1,I,3)*Q(J,K+1,I,3)+Q(J,K+1,I,4)*Q(J,K+1,I,4) ) )
     3                    / Q(J,K+1,I,1)
            DQDXD2 =   TEMP * SPK1 * Q(J,K+1,I,2)
            DQDXD3 =   TEMP * SPK1 * Q(J,K+1,I,3)
            DQDXD4 =   TEMP * SPK1 * Q(J,K+1,I,4)
            DQDXD5 = - TEMP * SPK1
C
C     DQdot(y)
C
            DQDYD1 =   TEMP * SPK2 * ( Q(J,K+1,I,5)/GAMM1
     1             - 0.5E0*Q(J,K+1,I,1)*( Q(J,K+1,I,2)*Q(J,K+1,I,2)
     2         +Q(J,K+1,I,3)*Q(J,K+1,I,3)+Q(J,K+1,I,4)*Q(J,K+1,I,4) ) )
     3                    / Q(J,K+1,I,1)
            DQDYD2 =   TEMP * SPK2 * Q(J,K+1,I,2)
            DQDYD3 =   TEMP * SPK2 * Q(J,K+1,I,3)
            DQDYD4 =   TEMP * SPK2 * Q(J,K+1,I,4)
            DQDYD5 = - TEMP * SPK2
C
C     DQdot(z)
C
            DQDZD1 =   TEMP * SPK3 * ( Q(J,K+1,I,5)/GAMM1
     1             - 0.5E0*Q(J,K+1,I,1)*( Q(J,K+1,I,2)*Q(J,K+1,I,2)
     2         +Q(J,K+1,I,3)*Q(J,K+1,I,3)+Q(J,K+1,I,4)*Q(J,K+1,I,4) ) )
     3                    / Q(J,K+1,I,1)
            DQDZD2 =   TEMP * SPK3 * Q(J,K+1,I,2)
            DQDZD3 =   TEMP * SPK3 * Q(J,K+1,I,3)
            DQDZD4 =   TEMP * SPK3 * Q(J,K+1,I,4)
            DQDZD5 = - TEMP * SPK3
C
C     Calculate AP = dF(i+1/2)/dQ(i+1)
C
            AP(K,J,1,1) = 0.E0
            AP(K,J,1,2) = 0.E0
            AP(K,J,1,3) = 0.E0
            AP(K,J,1,4) = 0.E0
            AP(K,J,1,5) = 0.E0
C
            AP(K,J,2,1) = ( S(J,K,I,1,3)*DTXXD1 + S(J,K,I,2,3)*DTXYD1
     1                    + S(J,K,I,3,3)*DTXZD1 ) * AREAMR
            AP(K,J,2,2) = ( S(J,K,I,1,3)*DTXXD2 + S(J,K,I,2,3)*DTXYD2
     1                    + S(J,K,I,3,3)*DTXZD2 ) * AREAMR
            AP(K,J,2,3) = ( S(J,K,I,1,3)*DTXXD3 + S(J,K,I,2,3)*DTXYD3 )
     1                                            * AREAMR
            AP(K,J,2,4) = ( S(J,K,I,1,3)*DTXXD4 + S(J,K,I,3,3)*DTXZD4 )
     1                                            * AREAMR
            AP(K,J,2,5) = 0.E0
C
            AP(K,J,3,1) = ( S(J,K,I,1,3)*DTXYD1 + S(J,K,I,2,3)*DTYYD1
     1                    + S(J,K,I,3,3)*DTYZD1 ) * AREAMR
            AP(K,J,3,2) = ( S(J,K,I,1,3)*DTXYD2 + S(J,K,I,2,3)*DTYYD2 )
     1                                            * AREAMR
            AP(K,J,3,3) = ( S(J,K,I,1,3)*DTXYD3 + S(J,K,I,2,3)*DTYYD3
     1                    + S(J,K,I,3,3)*DTYZD3 ) * AREAMR
            AP(K,J,3,4) = ( S(J,K,I,2,3)*DTYYD4 + S(J,K,I,3,3)*DTYZD4 )
     1                                            * AREAMR
            AP(K,J,3,5) = 0.E0
C
            AP(K,J,4,1) = ( S(J,K,I,1,3)*DTXZD1 + S(J,K,I,2,3)*DTYZD1
     1                    + S(J,K,I,3,3)*DTZZD1 ) * AREAMR
            AP(K,J,4,2) = ( S(J,K,I,1,3)*DTXZD2 + S(J,K,I,3,3)*DTZZD2 )
     1                                            * AREAMR
            AP(K,J,4,3) = ( S(J,K,I,2,3)*DTYZD3 + S(J,K,I,3,3)*DTZZD3 )
     1                                            * AREAMR
            AP(K,J,4,4) = ( S(J,K,I,1,3)*DTXZD4 + S(J,K,I,2,3)*DTYZD4
     1                    + S(J,K,I,3,3)*DTZZD4 ) * AREAMR
            AP(K,J,4,5) = 0.E0
C
            AP(K,J,5,1) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD1+V(K,J)*DTXYD1+W(K,J)*DTXZD1-DQDXD1)
     2 + S(J,K,I,2,3)*(U(K,J)*DTXYD1+V(K,J)*DTYYD1+W(K,J)*DTYZD1-DQDYD1)
     3 + S(J,K,I,3,3)*(U(K,J)*DTXZD1+V(K,J)*DTYZD1+W(K,J)*DTZZD1-DQDZD1)
     4 - 0.5E0*Q(J,K+1,I,2)/Q(J,K+1,I,1)*(S(J,K,I,1,3)*TAUXX
     5                    +S(J,K,I,2,3)*TAUXY+S(J,K,I,3,3)*TAUXZ)
     6 - 0.5E0*Q(J,K+1,I,3)/Q(J,K+1,I,1)*(S(J,K,I,1,3)*TAUXY
     7                    +S(J,K,I,2,3)*TAUYY+S(J,K,I,3,3)*TAUYZ)
     8 - 0.5E0*Q(J,K+1,I,4)/Q(J,K+1,I,1)*(S(J,K,I,1,3)*TAUXZ
     9                    +S(J,K,I,2,3)*TAUYZ+S(J,K,I,3,3)*TAUZZ) )
            AP(K,J,5,2) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD2+V(K,J)*DTXYD2+W(K,J)*DTXZD2-DQDXD2)
     2 + S(J,K,I,2,3)*(U(K,J)*DTXYD2+V(K,J)*DTYYD2              -DQDYD2)
     3 + S(J,K,I,3,3)*(U(K,J)*DTXZD2              +W(K,J)*DTZZD2-DQDZD2)
     4 + 0.5E0/Q(J,K+1,I,1)*(S(J,K,I,1,3)*TAUXX
     5                      +S(J,K,I,2,3)*TAUXY+S(J,K,I,3,3)*TAUXZ) )
            AP(K,J,5,3) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD3+V(K,J)*DTXYD3              -DQDXD3)
     2 + S(J,K,I,2,3)*(U(K,J)*DTXYD3+V(K,J)*DTYYD3+W(K,J)*DTYZD3-DQDYD3)
     3 + S(J,K,I,3,3)*(              V(K,J)*DTYZD3+W(K,J)*DTZZD3-DQDZD3)
     4 + 0.5E0/Q(J,K+1,I,1)*(S(J,K,I,1,3)*TAUXY
     5                      +S(J,K,I,2,3)*TAUYY+S(J,K,I,3,3)*TAUYZ) )
            AP(K,J,5,4) = AREAMR *
     1 ( S(J,K,I,1,3)*(U(K,J)*DTXXD4              +W(K,J)*DTXZD4-DQDXD4)
     2 + S(J,K,I,2,3)*(              V(K,J)*DTYYD4+W(K,J)*DTYZD4-DQDYD4)
     3 + S(J,K,I,3,3)*(U(K,J)*DTXZD4+V(K,J)*DTYZD4+W(K,J)*DTZZD4-DQDZD4)
     4 + 0.5E0/Q(J,K+1,I,1)*(S(J,K,I,1,3)*TAUXZ
     5                      +S(J,K,I,2,3)*TAUYZ+S(J,K,I,3,3)*TAUZZ) )
            AP(K,J,5,5) = - AREAMR *
     1                      ( S(J,K,I,1,3)*DQDXD5 + S(J,K,I,2,3)*DQDYD5
     2                      + S(J,K,I,3,3)*DQDZD5 )
  515    CONTINUE
  520 CONTINUE
C
C     Finished with implicit Thin Layer Viscous Terms in the K direction
      RETURN
      END
      SUBROUTINE DSRCDQ (IDIM, JDIM, KDIM, I, IMODEL,
     1                   Q, PROPS, NPPTS, S, VOL,
     2                   QC, PROPSC, DQDX, DQDY, DQDZ, DEL2K,
     3                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     4                   TAU, SRC, IBCDAT, NBCS, ASRC)
C
C Routine to calculate Jacobians for the source terms.  The source terms have
C previously been calculated and are passed into this routine.
C
C This routine is organized as follows:
C     1.   Initialize source Jacobians to zero and update non-zero elements.
C     2.   Call the appropriate source term Jacobian routine
C          a. k-epsilon Two-Equation turbulence model
C          b. k-omega   Two-Equation turbulence model
C          c. Reynolds Stress turbulence model
C          d. Error
C     3.   Scale Jacobian by the volume
C
C IDIM,JDIM,KDIM : Dimensions of current block
C I              : The current plane
C IMODEL         : Turbulence model array
C Q              : Primitive variables at cell centers
C PROPS          : Properties at cell centers
C                  PROPS(1) = molecular viscosity
C                  PROPS(2) = turbulent eddy viscosity
C                  PROPS(3) = Y+
C NPPTS          : Number of points at which PROPS are stored.  This allows
C                  the storage of PROPS for viscous flows and the avoidance
C                  of the additional storage for inviscid flows.
C S              : Metrics
C VOL            : Cell volumes
C QC             : Storage for Q in one-dimensional array
C PROPSC         : Storage for PROPS array in one-dimensional array
C DQDX,DQDY,DQDZ : Storage for derivatives of Q at cell centers
C DEL2K          : Laplacian of turbulent kinetic energy
C TKE            : Turbulnet kinetic energy
C ETILDE         : Epsilon^tilde
C XSIW           :
C FDAMP          : Damping functions F1, F2
C EPSC           :
C PDIL           :
C SIJ            :
C WIJ            :
C TAU            : Storage for Reynolds stress terms
C SRC            : Source terms for cell (J,K)
C IBCDAT         : Data controlling boundary conditions
C NBCS           : Number of boundary conditions for current block
C ASRC           : The Jacobian matrix for the source terms
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          PROPS (NPPTS,NP),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION QC    (2:JDIM,2:KDIM,NQ),
     1          PROPSC(2:JDIM,2:KDIM,NP),
     2          DQDX  (2:JDIM,2:KDIM,NQ),
     3          DQDY  (2:JDIM,2:KDIM,NQ),
     4          DQDZ  (2:JDIM,2:KDIM,NQ),
     5          DEL2K (2:JDIM,2:KDIM),
     6          TKE   (2:JDIM,2:KDIM),
     7          ETILDE(2:JDIM,2:KDIM),
     8          XSIW  (2:JDIM,2:KDIM),
     9          FDAMP (2:JDIM,2:KDIM,2),
     A          EPSC  (2:JDIM,2:KDIM),
     B          PDIL  (2:JDIM,2:KDIM),
     C          SIJ   (2:JDIM,2:KDIM,6),
     D          WIJ   (2:JDIM,2:KDIM,6),
     E          TAU   (2:JDIM,2:KDIM,6),
     F          SRC   (2:JDIM,2:KDIM,NF)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION ASRC  (2:JDIM,2:KDIM,NRANK,NRANK)
C
      ITURB  = IMODEL(1)
C
C     Number of points in a cross-section to calculate source terms Jacobians
C
      NPTS   = (JDIM - 1) * (KDIM - 1)
C
C 1.   Initialize source Jacobians to zero and update only non-zero elements.
C
      DO 140 M = 1, NRANK
         DO 130 L = 1, NRANK
            DO 120 K = 2, KDIM
               DO 110 J = 2, JDIM
                  ASRC(J,K,L,M) = 0.E0
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
  140 CONTINUE
C
C 2.   Call the appropriate source term Jacobian routine
C 2-a. k-epsilon Two-Equation turbulence model
C
      IF (ITURB .EQ. ITKE) THEN
         CALL DSRCKE (NPTS, QC, PROPSC, DQDX, DQDY, DQDZ, TAU,
     1                TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     2                SRC, ASRC)
C
C 2-b. k-omega Two-Equation turbulence model
C
      ELSE IF (ITURB .EQ. ITKW) THEN
         CALL DSRCKW (NPTS, QC, PROPSC, DQDX, DQDY, DQDZ, TAU, ASRC)
C
C 2-c. Reynolds Stress turbulence model
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         CALL DSRCRS (IMODEL, NPTS, QC, PROPSC, DQDX, DQDY, DQDZ, TAU,
     1                TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     2                SRC, ASRC)
C
C 2-d. Error
C
      ELSE
         WRITE (IOUT,1000) ITURB
         STOP
      ENDIF
C
C 3.   Scale Jacobian by the volume
C
      DO 340 M = 1, NRANK
         DO 330 L = 1, NRANK
            DO 320 K = 2, KDIM
               DO 310 J = 2, JDIM
                  ASRC(J,K,L,M) = ASRC(J,K,L,M) * VOL(J,K,I)
  310          CONTINUE
  320       CONTINUE
  330    CONTINUE
  340 CONTINUE
C
C     Finished calculating Jacobians
      RETURN
 1000 FORMAT (' ','DSRCDQ: ERROR-> Invalid turbulence model: ',I5,
     1       /' ',8X,'RUN ABORTING!')
      END
      SUBROUTINE DSRCKE (NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU,
     1                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     2                   SRC, ASRC)
C
C Routine to calculate the implicit source term Jacobians for the
C k-epsilon turbulence model.
C
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C TAU            : Reynolds stresses
C TKE            : Turbulent kinetic energy
C ETILDE         : Epsilon^tilde
C XSIW           :
C FDAMP          : Damping functions F1, F2
C EPSC           :
C PDIL           :
C SIJ            :
C WIJ            :
C SRC            :
C ASRC           : Source terms for the k-omega model at the cell centers
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          TAU   (NPTS,6),
     4          TKE   (NPTS),
     5          ETILDE(NPTS),
     6          XSIW  (NPTS),
     7          FDAMP (NPTS,2),
     8          EPSC  (NPTS),
     9          PDIL  (NPTS),
     A          SIJ   (NPTS,6),
     B          WIJ   (NPTS,6),
     C          SRC   (NPTS,NF),
     D          ASRC  (NPTS,NRANK,NRANK)
C
C     One-Third
C     Two-Thirds
C
      T13 = 1.E0 / 3.E0
      T23 = 2.E0 / 3.E0
C
C     Form the source Jacobians for the k-epsilon model.
C     Update only the non-zero elements.
C
      DO 100 I = 1, NPTS
C
         RHO   = Q    (I,1)
         P     = Q    (I,5)
         EPSLN = Q    (I,7)
C
         RMU   = PROPS(I,1)
         RMUT  = PROPS(I,2)
         YPLUS = PROPS(I,3)
C
         SXX   = SIJ  (I,1)
         SYY   = SIJ  (I,2)
         SZZ   = SIJ  (I,3)
         SXY   = SIJ  (I,4)
         SXZ   = SIJ  (I,5)
         SYZ   = SIJ  (I,6)
C
         SKK   = SXX + SYY + SZZ
         TERM  =         SXX*SXX + SYY*SYY + SZZ*SZZ
     1           + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ) - T13*SKK*SKK
C
         DPDK  =   4.E0*RMUT/(RHO*TKE(I))*TERM*FSMACH/RE - T23*SKK
         DPDE  = - 2.E0*RMUT/(RHO*EPSLN )*TERM*FSMACH/RE
C
C     Calculate Implicit Source Term
C
C        write (iout,'(a,i5,2(1pe14.4))') ' SRC : i,', i,
C    1               src(i,6), src(i,7)
C-----Begin DS/DQ (complete)------------------------------
C        ASRC(I,6,6) = DPDK
C        ASRC(I,6,7) = DPDE - 1.E0
C
C        ASRC(I,7,6) = CEPS1*FDAMP(I,1)*EPSLN/TKE(I)*DPDK
C    1                 - SRC(I,7) / (RHO*TKE(I))
C        ASRC(I,7,7) = EPSLN/TKE(I)*( CEPS1*FDAMP(I,1)*DPDE
C    1                              - CEPS2*FDAMP(I,2) )
C    2                 + SRC(I,7) / (RHO*EPSLN)
C        write (iout,'(a,i5,4(1pe14.4))') ' Full: i,', i,
C    1               asrc(i,6,6), asrc(i,6,7), asrc(i,7,6), asrc(i,7,7)
C-----End   DS/DQ (complete)------------------------------
C
C-----Begin DS/DQ (van Drommme)---------------------------
         TIMSCL      =   EPSLN / TKE(I)
         ASRC(I,6,6) = - 2.E0 * TIMSCL
         ASRC(I,6,7) =   0.E0
C
         ASRC(I,7,6) =          CEPS2 * FDAMP(I,2) * TIMSCL * TIMSCL
         ASRC(I,7,7) = - 2.E0 * CEPS2 * FDAMP(I,2) * TIMSCL
C        write (iout,'(a,i5,4(1pe14.4))') ' VanD: i,', i,
C    1               asrc(i,6,6), asrc(i,6,7), asrc(i,7,6), asrc(i,7,7)
C-----End   DS/DQ (van Drommme)---------------------------
C-----Begin DS/DQ (Blended DS(-)/DQ always + DS(+)/DQ if SRC < 0)-----
C        S6          = 0.5E0 * (1.E0 - SIGN (1.E0, SRC(I,6)))
C        S7          = 0.5E0 * (1.E0 - SIGN (1.E0, SRC(I,7)))
C
C        TIMSCL      =   EPSLN / TKE(I)
C        ASRC(I,6,6) = S6 * DPDK - 2.E0 * TIMSCL
C        ASRC(I,6,7) = S6 * DPDE
C
C        ASRC(I,7,6) = S7 * ( CEPS1*FDAMP(I,1)*EPSLN/TKE(I)*DPDK
C    1                      - SRC(I,7) / (RHO*TKE(I)) )
C    2               + (1.E0-S7) * CEPS2 * FDAMP(I,2) * TIMSCL * TIMSCL
C        ASRC(I,7,7) = S7 * ( EPSLN/TKE(I)*( CEPS1*FDAMP(I,1)*DPDE
C    1                                   - CEPS2*FDAMP(I,2) )
C    2                      + SRC(I,7) / (RHO*EPSLN) )
C    3               + (1.E0-S7) * (-2.E0 * CEPS2 * FDAMP(I,2) * TIMSCL)
C        write (iout,'(a,i5,4(1pe14.4))') ' Blen: i,', i,
C    1               asrc(i,6,6), asrc(i,6,7), asrc(i,7,6), asrc(i,7,7)
C-----End   DS/DQ (Blended DS(-)/DQ always + DS(+)/DQ if SRC < 0)-----
C
  100 CONTINUE
C
C     Finished with implicit k-epsilon source terms
      RETURN
      END
      SUBROUTINE DSRCKW (NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU, ASRC)
C
C     Routine to calculate the implicit source Jacobians for the k-omega
C     turbulence model.
C
C     NPTS           : Number of points to calculate source terms at
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties stored at cell centers
C                      PROPS(1) = RMU   molecular viscosity
C                      PROPS(2) = RMUT  turbulent eddy viscosity
C                      PROPS(3) = YPLUS Y+
C     DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C     TAU            : Reynolds stresses
C     ASRC           : Source Jacobians for the k-omega model at cell centers
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          TAU   (NPTS,6),
     4          ASRC  (NPTS,NRANK,NRANK)
C
C     Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
C     Form the implicit source Jacobians for the k-omega model.
C     Modify only the non-zero elements.
C
      DO 100 I = 1, NPTS
C
         RHO   = Q(I,1)
         TKE   = Q(I,6)
         OMEGA = Q(I,7)
C
C     Production term:
C        PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C               TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
         PROD  =   TAU(I,1) * DQDX(I,2)
     1           + TAU(I,2) * DQDY(I,3)
     2           + TAU(I,3) * DQDZ(I,4)
     3           + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4           + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5           + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
C     Calculate Implicit Source Term
C
         ASRC(I,6,1) =   BSTRKW * TKE * OMEGA
         ASRC(I,6,6) = - BSTRKW * OMEGA
         ASRC(I,6,7) = - BSTRKW * TKE
C
         ASRC(I,7,1) =   BKW * OMEGA * OMEGA
         ASRC(I,7,7) = - 2.E0 * BKW * OMEGA
  100 CONTINUE
C
C     Finished with implicit k-omega source terms
      RETURN
      END
      SUBROUTINE DSRCRS (IMODEL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU,
     1                   TKE, ETILDE, XSIW, FDAMP, EPSC, PDIL, SIJ, WIJ,
     2                   SRC, ASRC)
C
C Routine to calculate the source term Jacobians for the Reynolds stress
C turbulence model.
C
C IMODEL         : Turbulence model array
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C TAU            : Reynolds stresses
C TKE            : Turbulent kinetic energy
C ETILDE         : Epsilon^tilde
C XSIW           :
C FDAMP          : Damping functions F1, F2
C EPSC           :
C PDIL           :
C SIJ            :
C WIJ            :
C SRC            :
C ASRC           : Source terms for the k-omega model at the cell centers
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          TAU   (NPTS,6),
     4          TKE   (NPTS),
     5          ETILDE(NPTS),
     6          XSIW  (NPTS),
     7          FDAMP (NPTS,2),
     8          EPSC  (NPTS),
     9          PDIL  (NPTS),
     A          SIJ   (NPTS,6),
     B          WIJ   (NPTS,6),
     C          SRC   (NPTS,NF),
     D          ASRC  (NPTS,NRANK,NRANK)
C
C     Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
      ITURB  = IMODEL(1)
      IPSMDL = IMODEL(6)
      IEPSIJ = IMODEL(7)
C
C     Call routine to calculate Pressure-Strain Correlation Jacobians
C
      CALL DPSTRN (IPSMDL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, ASRC)
C
C     Form the source terms for the Reynolds stress model
C
      DO 100 I = 1, NPTS
C
         RHO    = Q(I,1)
         P      = Q(I,5)
         TAUXX  = Q(I,6)
         TAUYY  = Q(I,7)
         TAUZZ  = Q(I,8)
         TAUXY  = Q(I,9)
         TAUXZ  = Q(I,10)
         TAUYZ  = Q(I,11)
         EPSLN  = Q(I,12)
C
         RMU    = PROPS(I,1)
         RMUT   = PROPS(I,2)
         YPLUS  = PROPS(I,3)
         YNORML = ABS (PROPS(I,4))
C
C     DU_k/DX_k = (DU/DX + DV/DY + DW/DZ) / 3
C
         DUKDXK = (DQDX(I,2) + DQDY(I,3) + DQDZ(I,4)) / 3.E0
C
C     Production term for epsilon:
C        PRODE = - CEPS1*epsilon/k*rho*tau_ij*(Du_i/Dx_j-Du_k/Dx_k*delta_ij/3)
C                - 4/3*rho*epsilon*Du_k/Dx_k
C        from: Speziale and Sarkar, ICASE 91-9
C        wall damping from: Shima, F. Fluids Eng., Vol 111
C
         ARG    = RHO * SQRT(TKE(I)) * YNORML / RMU * RE / FSMACH
         FW     = EXP( -(0.015E0 * ARG)**4 )
         CEPSTR = CEPS1 * (1.E0 + CEPS4*FW)
         CTAUDU = CEPSTR * RHO *
     1             ( TAUXX * (DQDX(I,2) - DUKDXK)
     2             + TAUYY * (DQDY(I,3) - DUKDXK)
     3             + TAUZZ * (DQDZ(I,4) - DUKDXK)
     4             + TAUXY * (DQDY(I,2) + DQDX(I,3))
     5             + TAUXZ * (DQDZ(I,2) + DQDX(I,4))
     6             + TAUYZ * (DQDZ(I,3) + DQDY(I,4)) )
C
C     Turbulent Mach Number (from Sarkar et al.) for compressibility
C     correction to dissipation rate
C
         ASQ    = GAMMA * P / RHO
         RMTSQ  = 2.E0 * TKE(I) / ASQ
C
C     Dissipation
C
         CDISS  = T23 * (1.E0 + ALF1 * RMTSQ)
         DISS   = T23 * (1.E0 + ALF1 * RMTSQ) * RHO * EPSLN
C
C     Dissipation for epsilon from Shima
C
         DISSE  = CEPS2 * RHO * EPSLN * EPSLN / TKE(I) - RHO * XSIW(I)
C
C     Calculate the Pressure-Dilatation from Sarkar, ICASE 91-42
C
C        PDIL  = T23 * (-ALF2*PROD + ALF3*RHO*EPSLN) * RMTSQ
C
C     Calculate Source Jacobians due to Production (P_ij)
C     and Dissipation terms
C     Calculate only non-zero terms.  Add these to terms calculated in
C     the pressure-strain Jacobian routine.
C
         ASRC(I, 6, 6) = ASRC(I, 6, 6) - 2.E0 * DQDX(I,2)
         ASRC(I, 6, 9) = ASRC(I, 6, 9) - 2.E0 * DQDY(I,2)
         ASRC(I, 6,10) = ASRC(I, 6,10) - 2.E0 * DQDZ(I,2)
         ASRC(I, 6,12) = ASRC(I, 6,12) - CDISS
C
         ASRC(I, 7, 7) = ASRC(I, 7, 7) - 2.E0 * DQDY(I,3)
         ASRC(I, 7, 9) = ASRC(I, 7, 9) - 2.E0 * DQDX(I,3)
         ASRC(I, 7,11) = ASRC(I, 7,11) - 2.E0 * DQDZ(I,3)
         ASRC(I, 7,12) = ASRC(I, 7,12) - CDISS
C
         ASRC(I, 8, 8) = ASRC(I, 8, 8) - 2.E0 * DQDZ(I,4)
         ASRC(I, 8,10) = ASRC(I, 8,10) - 2.E0 * DQDX(I,4)
         ASRC(I, 8,11) = ASRC(I, 8,11) - 2.E0 * DQDY(I,4)
         ASRC(I, 8,12) = ASRC(I, 8,12) - CDISS
C
         ASRC(I, 9, 6) = ASRC(I, 9, 6) -  DQDX(I,3)
         ASRC(I, 9, 7) = ASRC(I, 9, 7) -  DQDY(I,2)
         ASRC(I, 9, 9) = ASRC(I, 9, 9) - (DQDY(I,3) + DQDX(I,2))
         ASRC(I, 9,10) = ASRC(I, 9,10) -  DQDZ(I,3)
         ASRC(I, 9,11) = ASRC(I, 9,11) -  DQDZ(I,2)
C
         ASRC(I,10, 6) = ASRC(I,10, 6) -  DQDX(I,4)
         ASRC(I,10, 8) = ASRC(I,10, 8) -  DQDZ(I,2)
         ASRC(I,10, 9) = ASRC(I,10, 9) -  DQDY(I,4)
         ASRC(I,10,10) = ASRC(I,10,10) - (DQDZ(I,4) + DQDX(I,2))
         ASRC(I,10,11) = ASRC(I,10,11) -  DQDY(I,2)
C
         ASRC(I,11, 7) = ASRC(I,11, 7) -  DQDY(I,4)
         ASRC(I,11, 8) = ASRC(I,11, 8) -  DQDZ(I,3)
         ASRC(I,11, 9) = ASRC(I,11, 9) -  DQDX(I,4)
         ASRC(I,11,10) = ASRC(I,11,10) -  DQDX(I,3)
         ASRC(I,11,11) = ASRC(I,11,11) - (DQDZ(I,4) + DQDY(I,3))
C
         ASRC(I,12, 6) = ASRC(I,12, 6)
     1              - CEPSTR * EPSLN / TKE(I) * (DQDX(I,2) - DUKDXK)
     2              + 0.5E0 * CTAUDU * EPSLN / (RHO * TKE(I) * TKE(I))
     3              + 0.5E0 * CEPS2 * EPSLN * EPSLN / (TKE(I) * TKE(I))
         ASRC(I,12, 7) = ASRC(I,12, 7)
     1              - CEPSTR * EPSLN / TKE(I) * (DQDY(I,3) - DUKDXK)
     2              + 0.5E0 * CTAUDU * EPSLN / (RHO * TKE(I) * TKE(I))
     3              + 0.5E0 * CEPS2 * EPSLN * EPSLN / (TKE(I) * TKE(I))
         ASRC(I,12, 8) = ASRC(I,12, 8)
     1              - CEPSTR * EPSLN / TKE(I) * (DQDZ(I,4) - DUKDXK)
     2              + 0.5E0 * CTAUDU * EPSLN / (RHO * TKE(I) * TKE(I))
     3              + 0.5E0 * CEPS2 * EPSLN * EPSLN / (TKE(I) * TKE(I))
         ASRC(I,12, 9) = ASRC(I,12, 9)
     1              - CEPSTR * EPSLN / TKE(I) * (DQDY(I,2)+DQDX(I,3))
         ASRC(I,12,10) = ASRC(I,12,10)
     1              - CEPSTR * EPSLN / TKE(I) * (DQDZ(I,2)+DQDX(I,4))
         ASRC(I,12,11) = ASRC(I,12,11)
     1              - CEPSTR * EPSLN / TKE(I) * (DQDZ(I,3)+DQDY(I,4))
         ASRC(I,12,12) = ASRC(I,12,12)
     1              - CTAUDU / (RHO * TKE(I))
     2              - 4.E0 * DUKDXK
     3              - 2.E0 * CEPS2 * EPSLN / TKE(I)
  100 CONTINUE
C
C     Finished with Reynolds Stress source terms
      RETURN
      END
      SUBROUTINE DPSTRN (IPSMDL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, ASRC)
C
C     Routine to calculate the Pressure-Strain Correlation Jacobians for a
C     Reynolds stress turbulence model.
C
C     IPSMDL         : Pressure-strain model
C     NPTS           : Number of points to calculate source terms at
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties stored at cell centers
C                      PROPS(1) = RMU   molecular viscosity
C                      PROPS(2) = RMUT  turbulent eddy viscosity
C                      PROPS(3) = YPLUS Y+
C     DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          ASRC  (NPTS,NRANK,NRANK)
C
C     One-Third
C     Two-Thirds
C     Four-Thirds
C
      T13 = 1.E0 / 3.E0
      T23 = 2.E0 / 3.E0
      T43 = 4.E0 / 3.E0
C
C     Calculate Pressure-Strain Correlation
C
      IF (IPSMDL .EQ. IPGL) THEN
C
C     Gison-Launder Pressure-Strain Correlation
C     Launder-Reece-Rodi "Basic Model" Pressure-Strain Correlation.
C     The form for this model is from Sarkar&Balakrishnan, ICASE 90-18
C
         write (iout,'(a)') ' Implicit Gibson-Launder not supported '
         stop
C
C     Shima Pressure Strain Correlation
C     J. Fluids Engineering, Vol. 110
C*NOTE ALSO USE FOR LAI-SO, SSG, FLT FOR NOW
C
      ELSE IF (ipsmdl .eq. ipls .or.
     1         ipsmdl .eq. iplrr1 .or. ipsmdl .eq. ipssg .or.
     2         ipsmdl .eq. ipflt ) THEN
         CPHI2A = (PSC2 + 8.E0) / 11.E0
         CPHI2B = (30.E0*PSC2 - 2.E0) / 55.E0
         CPHI2C = (8.E0 *PSC2 - 2.E0) / 11.E0
         DO 200 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU    = PROPS(I,1)
            YNORML = ABS (PROPS(I,4))
C
C     Anisotropy tensor
C
            BXX    = 0.5E0 * TAUXX / TKE - T13
            BYY    = 0.5E0 * TAUYY / TKE - T13
            BZZ    = 0.5E0 * TAUZZ / TKE - T13
            BXY    = 0.5E0 * TAUXY / TKE
            BXZ    = 0.5E0 * TAUXZ / TKE
            BYZ    = 0.5E0 * TAUYZ / TKE
C
C     DU_k/DX_k = DU/DX + DV/DY + DW/DZ
C
            DUKDXK = DQDX(I,2) + DQDY(I,3) + DQDZ(I,4)
C
C      Wall damping
C
            ARG    = RHO * SQRT(TKE) * YNORML / RMU * RE / FSMACH
            FW     = EXP( -(0.015E0 * ARG)**4 )
            C1STAR = PSC1 * (1.E0 - (1.E0-1.E0/PSC1)*FW)
            CROTTA = 0.25E0 * C1STAR * EPSLN / TKE / TKE
C
C      Add implicit Jacobian for pressure-strain to source Jacobian.
C      DPI_ij = DPhi*_ij,1 + DPhi_ij,2 + DPhi*_ij,w
C
            ASRC(I, 6, 6) = ASRC(I, 6, 6) - CROTTA * (2.E0*TKE - TAUXX)
     1                      - (PSALFA*FW - CPHI2A) * T43 * DQDX(I,2)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDX(I,2) - T23 * DUKDXK)
     4                      - (PSBETA*FW - CPHI2C) * T43 * DQDX(I,2)
            ASRC(I, 6, 7) = ASRC(I, 6, 7) + CROTTA * TAUXX
     1                      + (PSALFA*FW - CPHI2A) * T23 * DQDY(I,3)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDX(I,2) - T23 * DUKDXK)
     4                      + (PSBETA*FW - CPHI2C) * T23 * DQDY(I,3)
            ASRC(I, 6, 8) = ASRC(I, 6, 8) + CROTTA * TAUXX
     1                      + (PSALFA*FW - CPHI2A) * T23 * DQDZ(I,4)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDX(I,2) - T23 * DUKDXK)
     4                      + (PSBETA*FW - CPHI2C) * T23 * DQDZ(I,4)
            ASRC(I, 6, 9) = ASRC(I, 6, 9)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDX(I,3) - 2.E0 * DQDY(I,2))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDY(I,2) - 2.E0 * DQDX(I,3))
            ASRC(I, 6,10) = ASRC(I, 6,10)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDX(I,4) - 2.E0 * DQDZ(I,2))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDZ(I,2) - 2.E0 * DQDX(I,4))
            ASRC(I, 6,11) = ASRC(I, 6,11)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDZ(I,3) + DQDY(I,4))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDZ(I,3) + DQDY(I,4))
            ASRC(I, 6,12) = ASRC(I, 6,12) - C1STAR * BXX
C
            ASRC(I, 7, 6) = ASRC(I, 7, 6) + CROTTA * TAUYY
     1                      + (PSALFA*FW - CPHI2A) * T23 * DQDX(I,2)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDY(I,3) - T23 * DUKDXK)
     4                      + (PSBETA*FW - CPHI2C) * T23 * DQDX(I,2)
            ASRC(I, 7, 7) = ASRC(I, 7, 7) - CROTTA * (2.E0*TKE - TAUYY)
     1                      - (PSALFA*FW - CPHI2A) * T43 * DQDY(I,3)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDY(I,3) - T23 * DUKDXK)
     4                      - (PSBETA*FW - CPHI2C) * T43 * DQDY(I,3)
            ASRC(I, 7, 8) = ASRC(I, 7, 8) + CROTTA * TAUYY
     1                      + (PSALFA*FW - CPHI2A) * T23 * DQDZ(I,4)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDY(I,3) - T23 * DUKDXK)
     4                      + (PSBETA*FW - CPHI2C) * T23 * DQDZ(I,4)
            ASRC(I, 7, 9) = ASRC(I, 7, 9)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDY(I,2) - 2.E0 * DQDX(I,3))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDX(I,3) - 2.E0 * DQDY(I,2))
            ASRC(I, 7,10) = ASRC(I, 7,10)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDZ(I,2) + DQDX(I,4))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDZ(I,2) + DQDX(I,4))
            ASRC(I, 7,11) = ASRC(I, 7,11)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDY(I,4) - 2.E0 * DQDZ(I,3))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDZ(I,3) - 2.E0 * DQDY(I,4))
            ASRC(I, 7,12) = ASRC(I, 7,12) - C1STAR * BYY
C
            ASRC(I, 8, 6) = ASRC(I, 8, 6) + CROTTA * TAUZZ
     1                      + (PSALFA*FW - CPHI2A) * T23 * DQDX(I,2)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDZ(I,4) - T23 * DUKDXK)
     4                      + (PSBETA*FW - CPHI2C) * T23 * DQDX(I,2)
            ASRC(I, 8, 7) = ASRC(I, 8, 7) + CROTTA * TAUZZ
     1                      + (PSALFA*FW - CPHI2A) * T23 * DQDY(I,3)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDZ(I,4) - T23 * DUKDXK)
     4                      + (PSBETA*FW - CPHI2C) * T23 * DQDY(I,3)
            ASRC(I, 8, 8) = ASRC(I, 8, 8) - CROTTA * (2.E0*TKE - TAUZZ)
     1                      - (PSALFA*FW - CPHI2A) * T43 * DQDZ(I,4)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (2.E0 * DQDZ(I,4) - T23 * DUKDXK)
     4                      - (PSBETA*FW - CPHI2C) * T43 * DQDZ(I,4)
            ASRC(I, 8, 9) = ASRC(I, 8, 9)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDY(I,2) + DQDX(I,3))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDX(I,3) + DQDY(I,2))
            ASRC(I, 8,10) = ASRC(I, 8,10)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDZ(I,2) - 2.E0 * DQDX(I,4))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDX(I,4) - 2.E0 * DQDZ(I,2))
            ASRC(I, 8,11) = ASRC(I, 8,11)
     1                      + (PSALFA*FW - CPHI2A) * T23 *
     2                                 (DQDZ(I,3) - 2.E0 * DQDY(I,4))
     3                      + (PSBETA*FW - CPHI2C) * T23 *
     4                                 (DQDY(I,4) - 2.E0 * DQDZ(I,3))
            ASRC(I, 8,12) = ASRC(I, 8,12) - C1STAR * BZZ
C
            ASRC(I, 9, 6) = ASRC(I, 9, 6) + CROTTA * TAUXY
     1                      - (PSALFA*FW - CPHI2A) * DQDX(I,3)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDY(I,2) + DQDX(I,3))
     4                      - (PSBETA*FW - CPHI2C) * DQDY(I,2)
            ASRC(I, 9, 7) = ASRC(I, 9, 7) + CROTTA * TAUXY
     1                      - (PSALFA*FW - CPHI2A) * DQDY(I,2)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDY(I,2) + DQDX(I,3))
     4                      - (PSBETA*FW - CPHI2C) * DQDX(I,3)
            ASRC(I, 9, 8) = ASRC(I, 9, 8) + CROTTA * TAUXY
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDY(I,2) + DQDX(I,3))
            ASRC(I, 9, 9) = ASRC(I, 9, 9) - 0.5E0 * C1STAR / TKE / TKE
     1                      - (PSALFA*FW - CPHI2A) *
     2                                 (DQDY(I,3) + DQDX(I,2))
     3                      - (PSBETA*FW - CPHI2C) *
     4                                 (DQDY(I,3) + DQDX(I,2))
            ASRC(I, 9,10) = ASRC(I, 9,10)
     1                      + (PSALFA*FW - CPHI2A) * DQDZ(I,3)
     2                      + (PSBETA*FW - CPHI2C) * DQDY(I,4)
            ASRC(I, 9,11) = ASRC(I, 9,11)
     1                      + (PSALFA*FW - CPHI2A) * DQDZ(I,2)
     2                      + (PSBETA*FW - CPHI2C) * DQDX(I,4)
            ASRC(I, 9,12) = ASRC(I, 9,12) - C1STAR * BXY
C
            ASRC(I,10, 6) = ASRC(I,10, 6) + CROTTA * TAUXZ
     1                      - (PSALFA*FW - CPHI2A) * DQDX(I,4)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDZ(I,2) + DQDX(I,4))
     4                      - (PSBETA*FW - CPHI2C) * DQDZ(I,2)
            ASRC(I,10, 7) = ASRC(I,10, 7) + CROTTA * TAUXZ
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDZ(I,2) + DQDX(I,4))
            ASRC(I,10, 8) = ASRC(I,10, 8) + CROTTA * TAUXZ
     1                      - (PSALFA*FW - CPHI2A) * DQDZ(I,2)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDZ(I,2) + DQDX(I,4))
     4                      - (PSBETA*FW - CPHI2C) * DQDX(I,4)
            ASRC(I,10, 9) = ASRC(I,10, 9)
     1                      + (PSALFA*FW - CPHI2A) * DQDY(I,4)
     2                      + (PSBETA*FW - CPHI2C) * DQDZ(I,3)
            ASRC(I,10,10) = ASRC(I,10,10) - 0.5E0 * C1STAR / TKE / TKE
     1                      - (PSALFA*FW - CPHI2A) *
     2                                 (DQDZ(I,4) + DQDX(I,2))
     3                      - (PSBETA*FW - CPHI2C) *
     4                                 (DQDZ(I,4) + DQDX(I,2))
            ASRC(I,10,11) = ASRC(I,10,11)
     1                      + (PSALFA*FW - CPHI2A) * DQDY(I,2)
     2                      + (PSBETA*FW - CPHI2C) * DQDX(I,3)
            ASRC(I,10,12) = ASRC(I,10,12) - C1STAR * BXZ
C
            ASRC(I,11, 6) = ASRC(I,11, 6) + CROTTA * TAUYZ
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDZ(I,3) + DQDY(I,4))
            ASRC(I,11, 7) = ASRC(I,11, 7) + CROTTA * TAUYZ
     1                      - (PSALFA*FW - CPHI2A) * DQDY(I,4)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDZ(I,3) + DQDY(I,4))
     4                      - (PSBETA*FW - CPHI2C) * DQDZ(I,3)
            ASRC(I,11, 8) = ASRC(I,11, 8) + CROTTA * TAUYZ
     1                      - (PSALFA*FW - CPHI2A) * DQDZ(I,3)
     2                      + 0.5E0*(PSGAMA*FW - CPHI2B) *
     3                                 (DQDZ(I,3) + DQDY(I,4))
     4                      - (PSBETA*FW - CPHI2C) * DQDY(I,4)
            ASRC(I,11, 9) = ASRC(I,11, 9)
     1                      + (PSALFA*FW - CPHI2A) * DQDX(I,4)
     2                      + (PSBETA*FW - CPHI2C) * DQDZ(I,2)
            ASRC(I,11,10) = ASRC(I,11,10)
     1                      + (PSALFA*FW - CPHI2A) * DQDX(I,3)
     2                      + (PSBETA*FW - CPHI2C) * DQDY(I,2)
            ASRC(I,11,11) = ASRC(I,11,11) - 0.5E0 * C1STAR / TKE / TKE
     1                      - (PSALFA*FW - CPHI2A) *
     2                                 (DQDZ(I,4) + DQDY(I,3))
     3                      - (PSBETA*FW - CPHI2C) *
     4                                 (DQDZ(I,4) + DQDY(I,3))
            ASRC(I,11,12) = ASRC(I,11,12) - C1STAR * BYZ
C
  200    CONTINUE
C
C     Error
C
      ELSE
         WRITE (IOUT,1000) IPSMDL
         STOP
      ENDIF
C
C     Finished calculating pressure-strain correlation Jacobians
      RETURN
 1000 FORMAT (' ','ERROR - RUN ABORTING',
     1       /' ','Incorrect Pressure-Strain Correlation ',
     2            'Specified in routine DPSTRN = ',I10)
      END
      SUBROUTINE TLTROE (ITURB, NPTS, QP, QM, S, TKEP, TKEM,
     1                   HP, HM, A)
C
C     Routine to calculate T |Lambda| T(inverse) using
C     Roe averaged variables at the interface for the mean equations
C     with either a two equation turbulence model of the form k-psi
C     or a Reynolds stress closure.
C
C     ITURB     : Turbulence model
C     NPTS      : Number of points to calculate T*LAMBDA*T(-1)
C     QP,QM     : Q(+),Q(-) at a cell interface for the MUSCL scheme
C     S         : Metrics
C     TKEP,TKEM : Turbulent kinetic energy for QP,QM
C     HP,HM     : Total enthalpy for QP,QM
C     A         : The T*LAMBDA*T(-1) matrix
C
C     The two-equation and Reynolds stress models require the turbulent
C     kinetic energy in the mean flow equations.  Therefore, this routine
C     is organized into the following sections:
C
C          1. Calculate the Turbulent Kinetic Energy (TKE)
C             a. Inviscid, laminar, algebraic model => TKE = 0
C             b. Two-Equation model                 => TKE = Q(6)
C             c. Reynolds stress model              => TKE = (Q(7)+Q(8)+Q(9))/2
C          2. Calculate Total Enthalpy
C             a. Perfect Gas   => H = gamma P / (RHO(gamma-1)) + (q^2)/2 + TKE
C          3. Calculate Flux Jacobians for the Mean Flow Equations
C          4. Calculate Additional Flux Jacobians
C             a. Inviscid, laminar, algebraic model => No additional Jacobians
C             b. Two-Equation model                 => Jacobians for TKE, phi
C             c. Reynolds stress model              => Jacobians for Tau_ij,phi
C
      include 'common.inc'
C
      DIMENSION QP    (NPTS,NQ),
     1          QM    (NPTS,NQ),
     2          S     (NPTS,4),
     3          TKEP  (NPTS),
     4          TKEM  (NPTS),
     5          HP    (NPTS),
     6          HM    (NPTS),
     7          A     (NPTS,NRANK,NRANK)
C
C     1. Calculate Turbulent Kinetic Energy (TKEP,TKEM)
C
C     1-b. Turbulent Kinetic Energy for Two-Equation models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 100 I = 1, NPTS
            TKEP(I) = QP(I,6)
            TKEM(I) = QM(I,6)
  100    CONTINUE
C
C     1-c. Turbulent Kinetic Energy for Reynolds Stress models
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 110 I = 1, NPTS
            TKEP(I) = 0.5E0 * (QP(I,6) + QP(I,7) + QP(I,8))
            TKEM(I) = 0.5E0 * (QM(I,6) + QM(I,7) + QM(I,8))
  110    CONTINUE
C
C     1-a. Turbulent Kinetic Energy = 0 for inviscid, laminar, algebraic models
C
      ELSE
         DO 120 I = 1, NPTS
            TKEP(I) = 0.E0
            TKEM(I) = 0.E0
  120    CONTINUE
      ENDIF
C
C     2. Calculate Total Enthalpy
C
C     2-a. Perfect Gas
C
      DO 200 I = 1, NPTS
         RHOP  = QP(I,1)
         UP    = QP(I,2)
         VP    = QP(I,3)
         WP    = QP(I,4)
         PP    = QP(I,5)
         HP(I) = GAMMA * PP / (RHOP * GAMM1)
     1          + 0.5E0 * (UP*UP + VP*VP + WP*WP) + TKEP(I)
C
         RHOM  = QM(I,1)
         UM    = QM(I,2)
         VM    = QM(I,3)
         WM    = QM(I,4)
         PM    = QM(I,5)
         HM(I) = GAMMA * PM / (RHOM * GAMM1)
     1          + 0.5E0 * (UM*UM + VM*VM + WM*WM) + TKEM(I)
  200 CONTINUE
C
C     3. Calculate T |Lambda| T(inverse) at the cell interfaces
C        for Mean Flow Equations
C
      DO 300 I = 1, NPTS
C
C     Calculate +
C
         RHOP   = QP(I,1)
         UP     = QP(I,2)
         VP     = QP(I,3)
         WP     = QP(I,4)
         PP     = QP(I,5)
C
         UBARP  = S(I,1)*UP + S(I,2)*VP + S(I,3)*WP
         ASQP   = GAMMA * PP / RHOP
C
C     Calculate -
C
         RHOM   = QM(I,1)
         UM     = QM(I,2)
         VM     = QM(I,3)
         WM     = QM(I,4)
         PM     = QM(I,5)
C
         UBARM  = S(I,1)*UM + S(I,2)*VM + S(I,3)*WM
         ASQM   = GAMMA * PM / RHOM
C
C     Roe averaging
C
         RHOMSR = SQRT (RHOM)
         RHOPSR = SQRT (RHOP)
         RHOAV  = RHOMSR + RHOPSR
         UR     = ( RHOMSR*UM + RHOPSR*UP ) / RHOAV
         VR     = ( RHOMSR*VM + RHOPSR*VP ) / RHOAV
         WR     = ( RHOMSR*WM + RHOPSR*WP ) / RHOAV
         UBARR  = S(I,1)*UR + S(I,2)*VR + S(I,3)*WR
         HR     = ( RHOMSR*HM(I) + RHOPSR*HP(I) ) / RHOAV
C
         TKER   = ( RHOMSR*TKEM(I) + RHOPSR*TKEP(I) ) / RHOAV
C
         QSQR   = UR*UR + VR*VR + WR*WR
         ASQR   = GAMM1 * (HR - 0.5E0*QSQR - TKER)
         AR     = SQRT (ASQR)
         RHOR   = RHOMSR*RHOPSR
C
C     Calculate the eigenvalues.
C
         ALAM1  = ABS (UBARR)
         ALAM4  = ABS (UBARR + AR)
         ALAM5  = ABS (UBARR - AR)
C
C     Add the contribution due to the fourth eigenvalue.
C
C     TLT41  - contribution to T |Lambda| T(-1) from 4th eigenvalue to
C              the first column
C     TEMP42 - factor to multiply TLT4 by on the 2nd row
C
         TLT41  =   ALAM4 * (0.25E0*GAMM1*QSQR/ASQR - 0.5E0*UBARR/AR)
         TLT42  =   ALAM4 * 0.5E0 * (S(I,1)/AR - GAMM1*UR/ASQR)
         TLT43  =   ALAM4 * 0.5E0 * (S(I,2)/AR - GAMM1*VR/ASQR)
         TLT44  =   ALAM4 * 0.5E0 * (S(I,3)/AR - GAMM1*WR/ASQR)
         TLT45  =   ALAM4 * 0.5E0 * GAMM1 / ASQR
C
         TEMP42 =   UR + AR*S(I,1)
         TEMP43 =   VR + AR*S(I,2)
         TEMP44 =   WR + AR*S(I,3)
         TEMP45 =   HR + AR*UBARR
C
C     Add the contribution due to the fifth eigenvalue.
C
         TLT51  =   ALAM5 * (0.25E0*GAMM1*QSQR/ASQR + 0.5E0*UBARR/AR)
         TLT52  = - ALAM5 * 0.5E0 * (S(I,1)/AR + GAMM1*UR/ASQR)
         TLT53  = - ALAM5 * 0.5E0 * (S(I,2)/AR + GAMM1*VR/ASQR)
         TLT54  = - ALAM5 * 0.5E0 * (S(I,3)/AR + GAMM1*WR/ASQR)
         TLT55  =   ALAM5 * 0.5E0 * GAMM1 / ASQR
C
         TEMP52 =   UR - AR*S(I,1)
         TEMP53 =   VR - AR*S(I,2)
         TEMP54 =   WR - AR*S(I,3)
         TEMP55 =   HR - AR*UBARR
C
         A(I,1,1) = ( (1.E0 - 0.5E0 * GAMM1 * QSQR / ASQR) * ALAM1
     1                + TLT41 + TLT51 ) * S(I,4)
         A(I,1,2) = ( GAMM1 * UR / ASQR * ALAM1
     1                + TLT42 + TLT52 ) * S(I,4)
         A(I,1,3) = ( GAMM1 * VR / ASQR * ALAM1
     1                + TLT43 + TLT53 ) * S(I,4)
         A(I,1,4) = ( GAMM1 * WR / ASQR * ALAM1
     1                + TLT44 + TLT54 ) * S(I,4)
         A(I,1,5) = ( - GAMM1 / ASQR * ALAM1
     1                + TLT45 + TLT55 ) * S(I,4)
C
         A(I,2,1) = ( (S(I,1)*UBARR - 0.5E0*GAMM1*UR*QSQR/ASQR) * ALAM1
     1                + TLT41*TEMP42 + TLT51*TEMP52 ) * S(I,4)
         A(I,2,2) = ( (GAMM1*UR*UR/ASQR - S(I,1)*S(I,1) + 1.E0) * ALAM1
     1                + TLT42*TEMP42 + TLT52*TEMP52 ) * S(I,4)
         A(I,2,3) = ( (GAMM1*UR*VR/ASQR - S(I,1)*S(I,2)) * ALAM1
     1                + TLT43*TEMP42 + TLT53*TEMP52 ) * S(I,4)
         A(I,2,4) = ( (GAMM1*UR*WR/ASQR - S(I,1)*S(I,3)) * ALAM1
     1                + TLT44*TEMP42 + TLT54*TEMP52 ) * S(I,4)
         A(I,2,5) = ( - GAMM1 * UR / ASQR * ALAM1
     1                + TLT45*TEMP42 + TLT55*TEMP52 ) * S(I,4)
C
         A(I,3,1) = ( (S(I,2)*UBARR - 0.5E0*GAMM1*VR*QSQR/ASQR) * ALAM1
     1                + TLT41*TEMP43 + TLT51*TEMP53 ) * S(I,4)
         A(I,3,2) = ( (GAMM1*VR*UR/ASQR - S(I,2)*S(I,1)) * ALAM1
     1                + TLT42*TEMP43 + TLT52*TEMP53 ) * S(I,4)
         A(I,3,3) = ( (GAMM1*VR*VR/ASQR - S(I,2)*S(I,2) + 1.E0) * ALAM1
     1                + TLT43*TEMP43 + TLT53*TEMP53 ) * S(I,4)
         A(I,3,4) = ( (GAMM1*VR*WR/ASQR - S(I,2)*S(I,3)) * ALAM1
     1                + TLT44*TEMP43 + TLT54*TEMP53 ) * S(I,4)
         A(I,3,5) = ( - GAMM1 * VR / ASQR * ALAM1
     1                + TLT45*TEMP43 + TLT55*TEMP53 ) * S(I,4)
C
         A(I,4,1) = ( (S(I,3)*UBARR - 0.5E0*GAMM1*WR*QSQR/ASQR) * ALAM1
     1                + TLT41*TEMP44 + TLT51*TEMP54 ) * S(I,4)
         A(I,4,2) = ( (GAMM1*WR*UR/ASQR - S(I,3)*S(I,1)) * ALAM1
     1                + TLT42*TEMP44 + TLT52*TEMP54 ) * S(I,4)
         A(I,4,3) = ( (GAMM1*WR*VR/ASQR - S(I,3)*S(I,2)) * ALAM1
     1                + TLT43*TEMP44 + TLT53*TEMP54 ) * S(I,4)
         A(I,4,4) = ( (GAMM1*WR*WR/ASQR - S(I,3)*S(I,3) + 1.E0) * ALAM1
     1                + TLT44*TEMP44 + TLT54*TEMP54 ) * S(I,4)
         A(I,4,5) = ( - GAMM1 * WR / ASQR * ALAM1
     1                + TLT45*TEMP44 + TLT55*TEMP54 ) * S(I,4)
C
         A(I,5,1) = ( (UBARR*UBARR - 0.50E0*QSQR
     1                             - 0.5E0*GAMM1*QSQR*TKER/ASQR
     2                            - 0.25E0*GAMM1*QSQR*QSQR/ASQR)*ALAM1
     3                + TLT41*TEMP45 + TLT51*TEMP55 ) * S(I,4)
         A(I,5,2) = ( (0.5E0*GAMM1*QSQR*UR/ASQR + UR
     1                 - S(I,1)*UBARR + GAMM1*UR*TKER/ASQR) * ALAM1
     2                + TLT42*TEMP45 + TLT52*TEMP55 ) * S(I,4)
         A(I,5,3) = ( (0.5E0*GAMM1*QSQR*VR/ASQR + VR
     1                 - S(I,2)*UBARR + GAMM1*VR*TKER/ASQR) * ALAM1
     2                + TLT43*TEMP45 + TLT53*TEMP55 ) * S(I,4)
         A(I,5,4) = ( (0.5E0*GAMM1*QSQR*WR/ASQR + WR
     1                 - S(I,3)*UBARR + GAMM1*WR*TKER/ASQR) * ALAM1
     2                + TLT44*TEMP45 + TLT54*TEMP55 ) * S(I,4)
         A(I,5,5) = ( - (0.5E0*GAMM1*QSQR/ASQR + GAMM1*TKER/ASQR)*ALAM1
     1                + TLT45*TEMP45 + TLT55*TEMP55 ) * S(I,4)
  300 CONTINUE
C
C     4. Additional Jacobians
C
C     4-b. Two-Equation Models
C
      IF (ITURB .EQ. ITKE .OR. ITURB .EQ. ITKW) THEN
         DO 410 I = 1, NPTS
C
C     Calculate +
C
            RHOP   = QP(I,1)
            UP     = QP(I,2)
            VP     = QP(I,3)
            WP     = QP(I,4)
            PP     = QP(I,5)
C
            T2P    = QP(I,7)
C
            UBARP  = S(I,1)*UP + S(I,2)*VP + S(I,3)*WP
            ASQP   = GAMMA * PP / RHOP
C
C     Calculate -
C
            RHOM   = QM(I,1)
            UM     = QM(I,2)
            VM     = QM(I,3)
            WM     = QM(I,4)
            PM     = QM(I,5)
C
            T2M    = QM(I,7)
C
            UBARM  = S(I,1)*UM + S(I,2)*VM + S(I,3)*WM
            ASQM   = GAMMA * PM / RHOM
C
C     Roe averaging
C
            RHOMSR = SQRT (RHOM)
            RHOPSR = SQRT (RHOP)
            RHOAV  = RHOMSR + RHOPSR
            UR     = ( RHOMSR*UM + RHOPSR*UP ) / RHOAV
            VR     = ( RHOMSR*VM + RHOPSR*VP ) / RHOAV
            WR     = ( RHOMSR*WM + RHOPSR*WP ) / RHOAV
            UBARR  = S(I,1)*UR + S(I,2)*VR + S(I,3)*WR
            HR     = ( RHOMSR*HM(I) + RHOPSR*HP(I) ) / RHOAV
C
            TKER   = ( RHOMSR*TKEM(I) + RHOPSR*TKEP(I) ) / RHOAV
            T2R    = ( RHOMSR*T2M + RHOPSR*T2P ) / RHOAV
C
            QSQR   = UR*UR + VR*VR + WR*WR
            ASQR   = GAMM1 * (HR - 0.5E0*QSQR - TKER)
            AR     = SQRT (ASQR)
            RHOR   = RHOMSR*RHOPSR
C
C     Calculate the eigenvalues.
C
            ALAM1  = ABS (UBARR)
            ALAM4  = ABS (UBARR + AR)
            ALAM5  = ABS (UBARR - AR)
C
C     Add the contribution due to the fourth eigenvalue.
C
C     TLT41  - contribution to T |Lambda| T(-1) from 4th eigenvalue to
C              the first column
C     TEMP42 - factor to multiply TLT4 by on the 2nd row
C
            TLT41  =   ALAM4 * (0.25E0*GAMM1*QSQR/ASQR - 0.5E0*UBARR/AR)
            TLT42  =   ALAM4 * 0.5E0 * (S(I,1)/AR - GAMM1*UR/ASQR)
            TLT43  =   ALAM4 * 0.5E0 * (S(I,2)/AR - GAMM1*VR/ASQR)
            TLT44  =   ALAM4 * 0.5E0 * (S(I,3)/AR - GAMM1*WR/ASQR)
            TLT45  =   ALAM4 * 0.5E0 * GAMM1 / ASQR
            TLT46  = - ALAM4 * 0.5E0 * GAMM1 / ASQR
C
            TEMP42 =   UR + AR*S(I,1)
            TEMP43 =   VR + AR*S(I,2)
            TEMP44 =   WR + AR*S(I,3)
            TEMP45 =   HR + AR*UBARR
            TEMP46 =   TKER
            TEMP47 =   T2R
C
C     Add the contribution due to the fifth eigenvalue.
C
            TLT51  =   ALAM5 * (0.25E0*GAMM1*QSQR/ASQR + 0.5E0*UBARR/AR)
            TLT52  = - ALAM5 * 0.5E0 * (S(I,1)/AR + GAMM1*UR/ASQR)
            TLT53  = - ALAM5 * 0.5E0 * (S(I,2)/AR + GAMM1*VR/ASQR)
            TLT54  = - ALAM5 * 0.5E0 * (S(I,3)/AR + GAMM1*WR/ASQR)
            TLT55  =   ALAM5 * 0.5E0 * GAMM1 / ASQR
            TLT56  = - ALAM5 * 0.5E0 * GAMM1 / ASQR
C
            TEMP52 =   UR - AR*S(I,1)
            TEMP53 =   VR - AR*S(I,2)
            TEMP54 =   WR - AR*S(I,3)
            TEMP55 =   HR - AR*UBARR
            TEMP56 =   TKER
            TEMP57 =   T2R
C
            A(I,1,6) = ( GAMM1 / ASQR * ALAM1
     1                   + TLT46 + TLT56 ) * S(I,4)
            A(I,1,7) = 0.0E0
C
            A(I,2,6) = ( GAMM1 * UR / ASQR * ALAM1
     1                   + TLT46*TEMP42 + TLT56*TEMP52 ) * S(I,4)
            A(I,2,7) = 0.0E0
C
            A(I,3,6) = ( GAMM1 * VR / ASQR * ALAM1
     1                   + TLT46*TEMP43 + TLT56*TEMP53 ) * S(I,4)
            A(I,3,7) = 0.0E0
C
            A(I,4,6) = ( GAMM1 * WR / ASQR * ALAM1
     1                   + TLT46*TEMP44 + TLT56*TEMP54 ) * S(I,4)
            A(I,4,7) = 0.0E0
C
            A(I,5,6) = ( (1.E0+0.5E0*GAMM1*QSQR/ASQR+GAMM1*TKER/ASQR)*
     1                   ALAM1 + TLT45*TEMP45 + TLT55*TEMP55 ) * S(I,4)
            A(I,5,7) = 0.0E0
C
            A(I,6,1) = ( ( - 0.5E0 * GAMM1 * QSQR * TKER / ASQR) * ALAM1
     1                   + TLT41*TEMP46 + TLT51*TEMP56 ) * S(I,4)
            A(I,6,2) = ( GAMM1 * UR * TKER / ASQR * ALAM1
     1                   + TLT42*TEMP46 + TLT52*TEMP56 ) * S(I,4)
            A(I,6,3) = ( GAMM1 * VR * TKER / ASQR * ALAM1
     1                   + TLT43*TEMP46 + TLT53*TEMP56 ) * S(I,4)
            A(I,6,4) = ( GAMM1 * WR * TKER / ASQR * ALAM1
     1                   + TLT44*TEMP46 + TLT54*TEMP56 ) * S(I,4)
            A(I,6,5) = ( - GAMM1 * TKER / ASQR * ALAM1
     1                   + TLT45*TEMP46 + TLT55*TEMP56 ) * S(I,4)
            A(I,6,6) = ( (1.E0 + GAMM1 * TKER / ASQR) * ALAM1
     1                   + TLT46*TEMP46 + TLT56*TEMP56 ) * S(I,4)
            A(I,6,7) = 0.0E0
C
            A(I,7,1) = ( ( - 0.5E0 * GAMM1 * QSQR * T2R / ASQR) * ALAM1
     1                   + TLT41*TEMP47 + TLT51*TEMP57 ) * S(I,4)
            A(I,7,2) = ( GAMM1 * UR * T2R / ASQR * ALAM1
     1                   + TLT42*TEMP47 + TLT52*TEMP57 ) * S(I,4)
            A(I,7,3) = ( GAMM1 * VR * T2R / ASQR * ALAM1
     1                   + TLT43*TEMP47 + TLT53*TEMP57 ) * S(I,4)
            A(I,7,4) = ( GAMM1 * WR * T2R / ASQR * ALAM1
     1                   + TLT44*TEMP47 + TLT54*TEMP57 ) * S(I,4)
            A(I,7,5) = ( - GAMM1 * T2R / ASQR * ALAM1
     1                   + TLT45*TEMP47 + TLT55*TEMP57 ) * S(I,4)
            A(I,7,6) = ( GAMM1 * T2R / ASQR * ALAM1
     1                   + TLT46*TEMP47 + TLT56*TEMP57 ) * S(I,4)
            A(I,7,7) = ALAM1 * S(I,4)
  410    CONTINUE
C
C     4-c. Additional Jacobians for Reynolds Stress models
C
      ELSE IF (ITURB .EQ. ITRS) THEN
         DO 420 I = 1, NPTS
C
C     Calculate +
C
            RHOP   = QP(I, 1)
            UP     = QP(I, 2)
            VP     = QP(I, 3)
            WP     = QP(I, 4)
            PP     = QP(I, 5)
C
            TAUXXP = QP(I, 6)
            TAUYYP = QP(I, 7)
            TAUZZP = QP(I, 8)
            TAUXYP = QP(I, 9)
            TAUXZP = QP(I,10)
            TAUYZP = QP(I,11)
            T2P    = QP(I,12)
C
            UBARP  = S(I,1)*UP + S(I,2)*VP + S(I,3)*WP
            ASQP   = GAMMA * PP / RHOP
C
C     Calculate -
C
            RHOM   = QM(I, 1)
            UM     = QM(I, 2)
            VM     = QM(I, 3)
            WM     = QM(I, 4)
            PM     = QM(I, 5)
C
            TAUXXM = QM(I, 6)
            TAUYYM = QM(I, 7)
            TAUZZM = QM(I, 8)
            TAUXYM = QM(I, 9)
            TAUXZM = QM(I,10)
            TAUYZM = QM(I,11)
            T2M    = QM(I,12)
C
            UBARM  = S(I,1)*UM + S(I,2)*VM + S(I,3)*WM
            ASQM   = GAMMA * PM / RHOM
C
C     Roe averaging
C
            RHOMSR = SQRT (RHOM)
            RHOPSR = SQRT (RHOP)
            RHOAV  = RHOMSR + RHOPSR
            UR     = ( RHOMSR*UM + RHOPSR*UP ) / RHOAV
            VR     = ( RHOMSR*VM + RHOPSR*VP ) / RHOAV
            WR     = ( RHOMSR*WM + RHOPSR*WP ) / RHOAV
            UBARR  = S(I,1)*UR + S(I,2)*VR + S(I,3)*WR
            HR     = ( RHOMSR*HM(I) + RHOPSR*HP(I) ) / RHOAV
C
            TKER   = ( RHOMSR*TKEM(I) + RHOPSR*TKEP(I) ) / RHOAV
            TAUXXR = ( RHOMSR*TAUXXM  + RHOPSR*TAUXXP  ) / RHOAV
            TAUYYR = ( RHOMSR*TAUYYM  + RHOPSR*TAUYYP  ) / RHOAV
            TAUZZR = ( RHOMSR*TAUZZM  + RHOPSR*TAUZZP  ) / RHOAV
            TAUXYR = ( RHOMSR*TAUXYM  + RHOPSR*TAUXYP  ) / RHOAV
            TAUXZR = ( RHOMSR*TAUXZM  + RHOPSR*TAUXZP  ) / RHOAV
            TAUYZR = ( RHOMSR*TAUYZM  + RHOPSR*TAUYZP  ) / RHOAV
            T2R    = ( RHOMSR*T2M     + RHOPSR*T2P     ) / RHOAV
C
            QSQR   = UR*UR + VR*VR + WR*WR
            ASQR   = GAMM1 * (HR - 0.5E0*QSQR - TKER)
            AR     = SQRT (ASQR)
            RHOR   = RHOMSR*RHOPSR
C
C     Calculate the eigenvalues.
C
            ALAM1  = ABS (UBARR)
            ALAM4  = ABS (UBARR + AR)
            ALAM5  = ABS (UBARR - AR)
C
C     Add the contribution due to the fourth eigenvalue.
C
C     TLT41  - contribution to T |Lambda| T(-1) from 4th eigenvalue to
C              the first column
C     TEMP42 - factor to multiply TLT4 by on the 2nd row
C
            TLT41  =   ALAM4 * (0.25E0*GAMM1*QSQR/ASQR - 0.5E0*UBARR/AR)
            TLT42  =   ALAM4 * 0.50E0 * (S(I,1)/AR - GAMM1*UR/ASQR)
            TLT43  =   ALAM4 * 0.50E0 * (S(I,2)/AR - GAMM1*VR/ASQR)
            TLT44  =   ALAM4 * 0.50E0 * (S(I,3)/AR - GAMM1*WR/ASQR)
            TLT45  =   ALAM4 * 0.50E0 * GAMM1 / ASQR
            TLT46  = - ALAM4 * 0.25E0 * GAMM1 / ASQR
C
            TEMP42 =   UR + AR*S(I,1)
            TEMP43 =   VR + AR*S(I,2)
            TEMP44 =   WR + AR*S(I,3)
            TEMP45 =   HR + AR*UBARR
C
C     Add the contribution due to the fifth eigenvalue.
C
            TLT51  =   ALAM5 * (0.25E0*GAMM1*QSQR/ASQR + 0.5E0*UBARR/AR)
            TLT52  = - ALAM5 * 0.50E0 * (S(I,1)/AR + GAMM1*UR/ASQR)
            TLT53  = - ALAM5 * 0.50E0 * (S(I,2)/AR + GAMM1*VR/ASQR)
            TLT54  = - ALAM5 * 0.50E0 * (S(I,3)/AR + GAMM1*WR/ASQR)
            TLT55  =   ALAM5 * 0.50E0 * GAMM1 / ASQR
            TLT56  = - ALAM5 * 0.25E0 * GAMM1 / ASQR
C
            TEMP52 =   UR - AR*S(I,1)
            TEMP53 =   VR - AR*S(I,2)
            TEMP54 =   WR - AR*S(I,3)
            TEMP55 =   HR - AR*UBARR
C
            A(I, 1, 6) = ( 0.5E0 * GAMM1 / ASQR * ALAM1
     1                   + TLT46 + TLT56 ) * S(I,4)
            A(I, 1, 7) = A(I, 1, 6)
            A(I, 1, 8) = A(I, 1, 6)
            A(I, 1, 9) = 0.0E0
            A(I, 1,10) = 0.0E0
            A(I, 1,11) = 0.0E0
            A(I, 1,12) = 0.0E0
C
            A(I, 2, 6) = ( 0.5E0 * GAMM1 * UR / ASQR * ALAM1
     1                   + TLT46*TEMP42 + TLT56*TEMP52 ) * S(I,4)
            A(I, 2, 7) = A(I, 2, 6)
            A(I, 2, 8) = A(I, 2, 6)
            A(I, 2, 9) = 0.0E0
            A(I, 2,10) = 0.0E0
            A(I, 2,11) = 0.0E0
            A(I, 2,12) = 0.0E0
C
            A(I, 3, 6) = ( 0.5E0 * GAMM1 * VR / ASQR * ALAM1
     1                   + TLT46*TEMP43 + TLT56*TEMP53 ) * S(I,4)
            A(I, 3, 7) = A(I, 3, 6)
            A(I, 3, 8) = A(I, 3, 6)
            A(I, 3, 9) = 0.0E0
            A(I, 3,10) = 0.0E0
            A(I, 3,11) = 0.0E0
            A(I, 3,12) = 0.0E0
C
            A(I, 4, 6) = ( 0.5E0 * GAMM1 * WR / ASQR * ALAM1
     1                   + TLT46*TEMP44 + TLT56*TEMP54 ) * S(I,4)
            A(I, 4, 7) = A(I, 4, 6)
            A(I, 4, 8) = A(I, 4, 6)
            A(I, 4, 9) = 0.0E0
            A(I, 4,10) = 0.0E0
            A(I, 4,11) = 0.0E0
            A(I, 4,12) = 0.0E0
C
            A(I, 5, 6) = ( (0.5E0+0.25E0*GAMM1*QSQR/ASQR
     1                     +0.5E0*GAMM1*TKER/ASQR)* ALAM1
     2                   + TLT46*TEMP45 + TLT56*TEMP55 ) * S(I,4)
            A(I, 5, 7) = A(I, 5, 6)
            A(I, 5, 8) = A(I, 5, 6)
            A(I, 5, 9) = 0.0E0
            A(I, 5,10) = 0.0E0
            A(I, 5,11) = 0.0E0
            A(I, 5,12) = 0.0E0
C
            A(I, 6, 1) = ( ( - 0.5E0 * GAMM1 * QSQR * TAUXXR/ASQR)*ALAM1
     1                   + TLT41*TAUXXR + TLT51*TAUXXR ) * S(I,4)
            A(I, 6, 2) = ( GAMM1 * UR * TAUXXR / ASQR * ALAM1
     1                   + TLT42*TAUXXR + TLT52*TAUXXR ) * S(I,4)
            A(I, 6, 3) = ( GAMM1 * VR * TAUXXR / ASQR * ALAM1
     1                   + TLT43*TAUXXR + TLT53*TAUXXR ) * S(I,4)
            A(I, 6, 4) = ( GAMM1 * WR * TAUXXR / ASQR * ALAM1
     1                   + TLT44*TAUXXR + TLT54*TAUXXR ) * S(I,4)
            A(I, 6, 5) = ( - GAMM1 * TAUXXR / ASQR * ALAM1
     1                   + TLT45*TAUXXR + TLT55*TAUXXR ) * S(I,4)
            A(I, 6, 6) = ( (1.E0 + 0.5E0 * GAMM1 * TAUXXR / ASQR)*ALAM1
     1                   + TLT46*TAUXXR + TLT56*TAUXXR ) * S(I,4)
            A(I, 6, 7) = ( 0.5E0 * GAMM1 * TAUXXR / ASQR * ALAM1
     1                   + TLT46*TAUXXR + TLT56*TAUXXR ) * S(I,4)
            A(I, 6, 8) = ( 0.5E0 * GAMM1 * TAUXXR / ASQR * ALAM1
     1                   + TLT46*TAUXXR + TLT56*TAUXXR ) * S(I,4)
            A(I, 6, 9) = 0.0E0
            A(I, 6,10) = 0.0E0
            A(I, 6,11) = 0.0E0
            A(I, 6,12) = 0.0E0
C
            A(I, 7, 1) = ( ( - 0.5E0 * GAMM1 * QSQR * TAUYYR/ASQR)*ALAM1
     1                   + TLT41*TAUYYR + TLT51*TAUYYR ) * S(I,4)
            A(I, 7, 2) = ( GAMM1 * UR * TAUYYR / ASQR * ALAM1
     1                   + TLT42*TAUYYR + TLT52*TAUYYR ) * S(I,4)
            A(I, 7, 3) = ( GAMM1 * VR * TAUYYR / ASQR * ALAM1
     1                   + TLT43*TAUYYR + TLT53*TAUYYR ) * S(I,4)
            A(I, 7, 4) = ( GAMM1 * WR * TAUYYR / ASQR * ALAM1
     1                   + TLT44*TAUYYR + TLT54*TAUYYR ) * S(I,4)
            A(I, 7, 5) = ( - GAMM1 * TAUYYR / ASQR * ALAM1
     1                   + TLT45*TAUYYR + TLT55*TAUYYR ) * S(I,4)
            A(I, 7, 6) = ( 0.5E0 * GAMM1 * TAUYYR / ASQR * ALAM1
     1                   + TLT46*TAUYYR + TLT56*TAUYYR ) * S(I,4)
            A(I, 7, 7) = ( (1.E0 + 0.5E0 * GAMM1 * TAUYYR / ASQR)*ALAM1
     1                   + TLT46*TAUYYR + TLT56*TAUYYR ) * S(I,4)
            A(I, 7, 8) = ( 0.5E0 * GAMM1 * TAUYYR / ASQR * ALAM1
     1                   + TLT46*TAUYYR + TLT56*TAUYYR ) * S(I,4)
            A(I, 7, 9) = 0.0E0
            A(I, 7,10) = 0.0E0
            A(I, 7,11) = 0.0E0
            A(I, 7,12) = 0.0E0
C
            A(I, 8, 1) = ( ( - 0.5E0 * GAMM1 * QSQR * TAUZZR/ASQR)*ALAM1
     1                   + TLT41*TAUZZR + TLT51*TAUZZR ) * S(I,4)
            A(I, 8, 2) = ( GAMM1 * UR * TAUZZR / ASQR * ALAM1
     1                   + TLT42*TAUZZR + TLT52*TAUZZR ) * S(I,4)
            A(I, 8, 3) = ( GAMM1 * VR * TAUZZR / ASQR * ALAM1
     1                   + TLT43*TAUZZR + TLT53*TAUZZR ) * S(I,4)
            A(I, 8, 4) = ( GAMM1 * WR * TAUZZR / ASQR * ALAM1
     1                   + TLT44*TAUZZR + TLT54*TAUZZR ) * S(I,4)
            A(I, 8, 5) = ( - GAMM1 * TAUZZR / ASQR * ALAM1
     1                   + TLT45*TAUZZR + TLT55*TAUZZR ) * S(I,4)
            A(I, 8, 6) = ( 0.5E0 * GAMM1 * TAUZZR / ASQR * ALAM1
     1                   + TLT46*TAUZZR + TLT56*TAUZZR ) * S(I,4)
            A(I, 8, 7) = ( 0.5E0 * GAMM1 * TAUZZR / ASQR * ALAM1
     1                   + TLT46*TAUZZR + TLT56*TAUZZR ) * S(I,4)
            A(I, 8, 8) = ( (1.E0 + 0.5E0 * GAMM1 * TAUZZR / ASQR)*ALAM1
     1                   + TLT46*TAUZZR + TLT56*TAUZZR ) * S(I,4)
            A(I, 8, 9) = 0.0E0
            A(I, 8,10) = 0.0E0
            A(I, 8,11) = 0.0E0
            A(I, 8,12) = 0.0E0
C
            A(I, 9, 1) = ( ( - 0.5E0 * GAMM1 * QSQR * TAUXYR/ASQR)*ALAM1
     1                   + TLT41*TAUXYR + TLT51*TAUXYR ) * S(I,4)
            A(I, 9, 2) = ( GAMM1 * UR * TAUXYR / ASQR * ALAM1
     1                   + TLT42*TAUXYR + TLT52*TAUXYR ) * S(I,4)
            A(I, 9, 3) = ( GAMM1 * VR * TAUXYR / ASQR * ALAM1
     1                   + TLT43*TAUXYR + TLT53*TAUXYR ) * S(I,4)
            A(I, 9, 4) = ( GAMM1 * WR * TAUXYR / ASQR * ALAM1
     1                   + TLT44*TAUXYR + TLT54*TAUXYR ) * S(I,4)
            A(I, 9, 5) = ( - GAMM1 * TAUXYR / ASQR * ALAM1
     1                   + TLT45*TAUXYR + TLT55*TAUXYR ) * S(I,4)
            A(I, 9, 6) = ( 0.5E0 * GAMM1 * TAUXYR / ASQR * ALAM1
     1                   + TLT46*TAUXYR + TLT56*TAUXYR ) * S(I,4)
            A(I, 9, 7) = ( 0.5E0 * GAMM1 * TAUXYR / ASQR * ALAM1
     1                   + TLT46*TAUXYR + TLT56*TAUXYR ) * S(I,4)
            A(I, 9, 8) = ( 0.5E0 * GAMM1 * TAUXYR / ASQR * ALAM1
     1                   + TLT46*TAUXYR + TLT56*TAUXYR ) * S(I,4)
            A(I, 9, 9) = ALAM1 * S(I,4)
            A(I, 9,10) = 0.0E0
            A(I, 9,11) = 0.0E0
            A(I, 9,12) = 0.0E0
C
            A(I,10, 1) = ( ( - 0.5E0 * GAMM1 * QSQR * TAUXZR/ASQR)*ALAM1
     1                   + TLT41*TAUXZR + TLT51*TAUXZR ) * S(I,4)
            A(I,10, 2) = ( GAMM1 * UR * TAUXZR / ASQR * ALAM1
     1                   + TLT42*TAUXZR + TLT52*TAUXZR ) * S(I,4)
            A(I,10, 3) = ( GAMM1 * VR * TAUXZR / ASQR * ALAM1
     1                   + TLT43*TAUXZR + TLT53*TAUXZR ) * S(I,4)
            A(I,10, 4) = ( GAMM1 * WR * TAUXZR / ASQR * ALAM1
     1                   + TLT44*TAUXZR + TLT54*TAUXZR ) * S(I,4)
            A(I,10, 5) = ( - GAMM1 * TAUXZR / ASQR * ALAM1
     1                   + TLT45*TAUXZR + TLT55*TAUXZR ) * S(I,4)
            A(I,10, 6) = ( 0.5E0 * GAMM1 * TAUXZR / ASQR * ALAM1
     1                   + TLT46*TAUXZR + TLT56*TAUXZR ) * S(I,4)
            A(I,10, 7) = ( 0.5E0 * GAMM1 * TAUXZR / ASQR * ALAM1
     1                   + TLT46*TAUXZR + TLT56*TAUXZR ) * S(I,4)
            A(I,10, 8) = ( 0.5E0 * GAMM1 * TAUXZR / ASQR * ALAM1
     1                   + TLT46*TAUXZR + TLT56*TAUXZR ) * S(I,4)
            A(I,10, 9) = 0.0E0
            A(I,10,10) = ALAM1 * S(I,4)
            A(I,10,11) = 0.0E0
            A(I,10,12) = 0.0E0
C
            A(I,11, 1) = ( ( - 0.5E0 * GAMM1 * QSQR * TAUYZR/ASQR)*ALAM1
     1                   + TLT41*TAUYZR + TLT51*TAUYZR ) * S(I,4)
            A(I,11, 2) = ( GAMM1 * UR * TAUYZR / ASQR * ALAM1
     1                   + TLT42*TAUYZR + TLT52*TAUYZR ) * S(I,4)
            A(I,11, 3) = ( GAMM1 * VR * TAUYZR / ASQR * ALAM1
     1                   + TLT43*TAUYZR + TLT53*TAUYZR ) * S(I,4)
            A(I,11, 4) = ( GAMM1 * WR * TAUYZR / ASQR * ALAM1
     1                   + TLT44*TAUYZR + TLT54*TAUYZR ) * S(I,4)
            A(I,11, 5) = ( - GAMM1 * TAUYZR / ASQR * ALAM1
     1                   + TLT45*TAUYZR + TLT55*TAUYZR ) * S(I,4)
            A(I,11, 6) = ( 0.5E0 * GAMM1 * TAUYZR / ASQR * ALAM1
     1                   + TLT46*TAUYZR + TLT56*TAUYZR ) * S(I,4)
            A(I,11, 7) = ( 0.5E0 * GAMM1 * TAUYZR / ASQR * ALAM1
     1                   + TLT46*TAUYZR + TLT56*TAUYZR ) * S(I,4)
            A(I,11, 8) = ( 0.5E0 * GAMM1 * TAUYZR / ASQR * ALAM1
     1                   + TLT46*TAUYZR + TLT56*TAUYZR ) * S(I,4)
            A(I,11, 9) = 0.0E0
            A(I,11,10) = 0.0E0
            A(I,11,11) = ALAM1 * S(I,4)
            A(I,11,12) = 0.0E0
C
            A(I,12, 1) = ( ( - 0.5E0 * GAMM1 * QSQR * T2R/ASQR)*ALAM1
     1                   + TLT41*T2R + TLT51*T2R ) * S(I,4)
            A(I,12, 2) = ( GAMM1 * UR * T2R / ASQR * ALAM1
     1                   + TLT42*T2R + TLT52*T2R ) * S(I,4)
            A(I,12, 3) = ( GAMM1 * VR * T2R / ASQR * ALAM1
     1                   + TLT43*T2R + TLT53*T2R ) * S(I,4)
            A(I,12, 4) = ( GAMM1 * WR * T2R / ASQR * ALAM1
     1                   + TLT44*T2R + TLT54*T2R ) * S(I,4)
            A(I,12, 5) = ( - GAMM1 * T2R / ASQR * ALAM1
     1                   + TLT45*T2R + TLT55*T2R ) * S(I,4)
            A(I,12, 6) = ( 0.5E0 * GAMM1 * T2R / ASQR * ALAM1
     1                   + TLT46*T2R + TLT56*T2R ) * S(I,4)
            A(I,12, 7) = ( 0.5E0 * GAMM1 * T2R / ASQR * ALAM1
     1                   + TLT46*T2R + TLT56*T2R ) * S(I,4)
            A(I,12, 8) = ( 0.5E0 * GAMM1 * T2R / ASQR * ALAM1
     1                   + TLT46*T2R + TLT56*T2R ) * S(I,4)
            A(I,12, 9) = 0.0E0
            A(I,12,10) = 0.0E0
            A(I,12,11) = 0.0E0
            A(I,12,12) = ALAM1 * S(I,4)
C
  420    CONTINUE
      ENDIF
C
C     Finished with T*LAMBDA*T(-1) calculation.
      RETURN
      END
      SUBROUTINE VBTRI (NPTS, NSIM, IRANK, A, B, C, R)
C
C     Routine to perform the Block Tridiagonal Inversion
C     a block tridiagonal system where A, B and C contain
C     the (i-1), (i) and (i+1) of the block tridiagonal system
C     and R is the right hand side which is returned as the solution
C     vector.  A, B and C are overwritten.
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     IRANK:     The rank of the system to invert
C     A:         The supra-diagonal block 7x7 of L
C     B:         The lu decomposition of the diagonal block 7x7 of L
C     C:         The super-diagonal block 7x7 of U
C     R:         The right hand side
C
      include 'common.inc'
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK),
     3          R (NSIM,NPTS,NRANK)
C
      IF (IRANK .EQ. 5) THEN
         CALL VB5TRI (NPTS, NSIM, A, B, C, R)
      ELSE IF (IRANK .EQ. 7) THEN
         CALL VB7TRI (NPTS, NSIM, NRANK, A, B, C, R)
      ELSE IF (IRANK .EQ. 12) THEN
         CALL VB12TR (NPTS, NSIM, NRANK, A, B, C, R)
      ELSE
         WRITE (IOUT,1000) IRANK, IRANK
         STOP
      ENDIF
C
C     Finished
      RETURN
 1000 FORMAT (' ','Block solver required for a ',I3,' x ',I3,' block.',
     1       /' ','This solver does not exist.  Run Aborting.')
      END
      SUBROUTINE VB5TRI (NPTS, NSIM, A, B, C, R)
C
C     Routine to invert a 5x5 block tridiagonal system
C     Inversion is by Upper Triangularization with a
C     unity diagonal followed by a backsubstitution step.
C     Vectorization is attained by inverting multiple systems
C     at one time with the recursive inverrsion algorithm.
C     The A, B, C arrays are destroyed in the solution
C     procedure.
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     A:         The supra-diagonal block 5x5
C     B:         The       diagonal block 5x5
C     C:         The super-diagonal block 5x5
C     R:         The right hand side
C
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS,5,5),
     1          B (NSIM,NPTS,5,5),
     2          C (NSIM,NPTS,5,5),
     3          R (NSIM,NPTS,5)
C
C     Storage for the LU decomposition of a block 5x5
C
      REAL L11,
     1     L21, L22,
     2     L31, L32, L33,
     3     L41, L42, L43, L44,
     4     L51, L52, L53, L54, L55
C
C     Forward Substitution Loop - Upper Triangularization
C     Loop only to NPTS-1 to optimize vectorization while avoiding unnecessary
C     calculations of the L terms
C
      DO 200 J = 1, NPTS - 1
C
C     Eliminate A
C
C     B = B - A*C(j-1)
C
         IF (J .GT. 1) THEN
            DO 160 L = 1, 5
               DO 140 M = 1, 5
                  DO 130 I = 1, NSIM
                     B(I,J,L,M) = B(I,J,L,M)
     1                          - A(I,J,L,1)*C(I,J-1,1,M)
     2                          - A(I,J,L,2)*C(I,J-1,2,M)
     3                          - A(I,J,L,3)*C(I,J-1,3,M)
     4                          - A(I,J,L,4)*C(I,J-1,4,M)
     5                          - A(I,J,L,5)*C(I,J-1,5,M)
  130          CONTINUE
  140       CONTINUE
C
C     R = R - A*R(j-1)
C
               DO 150 I = 1, NSIM
                  R(I,J,L) = R(I,J,L)
     1                     - A(I,J,L,1)*R(I,J-1,1)
     2                     - A(I,J,L,2)*R(I,J-1,2)
     3                     - A(I,J,L,3)*R(I,J-1,3)
     4                     - A(I,J,L,4)*R(I,J-1,4)
     5                     - A(I,J,L,5)*R(I,J-1,5)
  150          CONTINUE
  160       CONTINUE
         ENDIF
C
C     Normalize row by multiplication of B(-1) to get unity diagonal
C
C     Form the LU of B(1)
C
         DO 190 I = 1, NSIM
            L11 =  B(I,J,1,1)
            U12 =  B(I,J,1,2) / L11
            U13 =  B(I,J,1,3) / L11
            U14 =  B(I,J,1,4) / L11
            U15 =  B(I,J,1,5) / L11
C
            L21 =  B(I,J,2,1)
            L22 =  B(I,J,2,2) - L21*U12
            U23 = (B(I,J,2,3) - L21*U13) / L22
            U24 = (B(I,J,2,4) - L21*U14) / L22
            U25 = (B(I,J,2,5) - L21*U15) / L22
C
            L31 =  B(I,J,3,1)
            L32 =  B(I,J,3,2) - L31*U12
            L33 =  B(I,J,3,3) - L31*U13 - L32*U23
            U34 = (B(I,J,3,4) - L31*U14 - L32*U24) / L33
            U35 = (B(I,J,3,5) - L31*U15 - L32*U25) / L33
C
            L41 =  B(I,J,4,1)
            L42 =  B(I,J,4,2) - L41*U12
            L43 =  B(I,J,4,3) - L41*U13 - L42*U23
            L44 =  B(I,J,4,4) - L41*U14 - L42*U24 - L43*U34
            U45 = (B(I,J,4,5) - L41*U15 - L42*U25 - L43*U35) / L44
C
            L51 =  B(I,J,5,1)
            L52 =  B(I,J,5,2) - L51*U12
            L53 =  B(I,J,5,3) - L51*U13 - L52*U23
            L54 =  B(I,J,5,4) - L51*U14 - L52*U24 - L53*U34
            L55 =  B(I,J,5,5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
C
C     Calculate B(-1) * R
C
            R1       =  R(I,J,1) / L11
            R2       = (R(I,J,2) - L21*R1) / L22
            R3       = (R(I,J,3) - L31*R1 - L32*R2) / L33
            R4       = (R(I,J,4) - L41*R1 - L42*R2 - L43*R3) / L44
            R(I,J,5) = (R(I,J,5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1                 / L55
            R(I,J,4) =  R4-U45*R(I,J,5)
            R(I,J,3) =  R3-U35*R(I,J,5)-U34*R(I,J,4)
            R(I,J,2) =  R2-U25*R(I,J,5)-U24*R(I,J,4)-U23*R(I,J,3)
            R(I,J,1) =  R1-U15*R(I,J,5)-U14*R(I,J,4)-U13*R(I,J,3)
     1                    -U12*R(I,J,2)
C
C     Calculate B(-1) * C
C
            C1         =  C(I,J,1,1) / L11
            C2         = (C(I,J,2,1) - L21*C1) / L22
            C3         = (C(I,J,3,1) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,1) - L41*C1 - L42*C2 - L43*C3)/L44
            C(I,J,5,1) = (C(I,J,5,1) - L51*C1 - L52*C2 - L53*C3 -
     1                                                   L54*C4)/L55
            C(I,J,4,1) =  C4-U45*C(I,J,5,1)
            C(I,J,3,1) =  C3-U35*C(I,J,5,1)-U34*C(I,J,4,1)
            C(I,J,2,1) =  C2-U25*C(I,J,5,1)-U24*C(I,J,4,1)
     1                      -U23*C(I,J,3,1)
            C(I,J,1,1) =  C1-U15*C(I,J,5,1)-U14*C(I,J,4,1)
     1                      -U13*C(I,J,3,1)-U12*C(I,J,2,1)
C
            C1         =  C(I,J,1,2) / L11
            C2         = (C(I,J,2,2) - L21*C1) / L22
            C3         = (C(I,J,3,2) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,2) - L41*C1 - L42*C2 - L43*C3)/L44
            C(I,J,5,2) = (C(I,J,5,2) - L51*C1 - L52*C2 - L53*C3 -
     1                                                   L54*C4)/L55
            C(I,J,4,2) =  C4-U45*C(I,J,5,2)
            C(I,J,3,2) =  C3-U35*C(I,J,5,2)-U34*C(I,J,4,2)
            C(I,J,2,2) =  C2-U25*C(I,J,5,2)-U24*C(I,J,4,2)
     1                      -U23*C(I,J,3,2)
            C(I,J,1,2) =  C1-U15*C(I,J,5,2)-U14*C(I,J,4,2)
     1                      -U13*C(I,J,3,2)-U12*C(I,J,2,2)
C
            C1         =  C(I,J,1,3) / L11
            C2         = (C(I,J,2,3) - L21*C1) / L22
            C3         = (C(I,J,3,3) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,3) - L41*C1 - L42*C2 - L43*C3)/L44
            C(I,J,5,3) = (C(I,J,5,3) - L51*C1 - L52*C2 - L53*C3 -
     1                                                   L54*C4)/L55
            C(I,J,4,3) =  C4-U45*C(I,J,5,3)
            C(I,J,3,3) =  C3-U35*C(I,J,5,3)-U34*C(I,J,4,3)
            C(I,J,2,3) =  C2-U25*C(I,J,5,3)-U24*C(I,J,4,3)
     1                      -U23*C(I,J,3,3)
            C(I,J,1,3) =  C1-U15*C(I,J,5,3)-U14*C(I,J,4,3)
     1                      -U13*C(I,J,3,3)-U12*C(I,J,2,3)
C
            C1         =  C(I,J,1,4) / L11
            C2         = (C(I,J,2,4) - L21*C1) / L22
            C3         = (C(I,J,3,4) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,4) - L41*C1 - L42*C2 - L43*C3)/L44
            C(I,J,5,4) = (C(I,J,5,4) - L51*C1 - L52*C2 - L53*C3 -
     1                                                   L54*C4)/L55
            C(I,J,4,4) =  C4-U45*C(I,J,5,4)
            C(I,J,3,4) =  C3-U35*C(I,J,5,4)-U34*C(I,J,4,4)
            C(I,J,2,4) =  C2-U25*C(I,J,5,4)-U24*C(I,J,4,4)
     1                      -U23*C(I,J,3,4)
            C(I,J,1,4) =  C1-U15*C(I,J,5,4)-U14*C(I,J,4,4)
     1                      -U13*C(I,J,3,4)-U12*C(I,J,2,4)
C
            C1         =  C(I,J,1,5) / L11
            C2         = (C(I,J,2,5) - L21*C1) / L22
            C3         = (C(I,J,3,5) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,5) - L41*C1 - L42*C2 - L43*C3)/L44
            C(I,J,5,5) = (C(I,J,5,5) - L51*C1 - L52*C2 - L53*C3 -
     1                                                   L54*C4)/L55
            C(I,J,4,5) =  C4-U45*C(I,J,5,5)
            C(I,J,3,5) =  C3-U35*C(I,J,5,5)-U34*C(I,J,4,5)
            C(I,J,2,5) =  C2-U25*C(I,J,5,5)-U24*C(I,J,4,5)
     1                      -U23*C(I,J,3,5)
            C(I,J,1,5) =  C1-U15*C(I,J,5,5)-U14*C(I,J,4,5)
     1                      -U13*C(I,J,3,5)-U12*C(I,J,2,5)
  190    CONTINUE
  200 CONTINUE
C
C     J = NPTS Elimination
C     Do not do this loop if NPTS = 1
C
C     Eliminate A
C
C     B = B - A*C(j-1)
C
      J = NPTS
      IF (NPTS .GT. 1) THEN
         DO 260 L = 1, 5
            DO 240 M = 1, 5
               DO 230 I = 1, NSIM
                  B(I,J,L,M) = B(I,J,L,M)
     1                       - A(I,J,L,1)*C(I,J-1,1,M)
     2                       - A(I,J,L,2)*C(I,J-1,2,M)
     3                       - A(I,J,L,3)*C(I,J-1,3,M)
     4                       - A(I,J,L,4)*C(I,J-1,4,M)
     5                       - A(I,J,L,5)*C(I,J-1,5,M)
  230          CONTINUE
  240       CONTINUE
C
C     R = R - A*R(j-1)
C
            DO 250 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - A(I,J,L,1)*R(I,J-1,1)
     2                  - A(I,J,L,2)*R(I,J-1,2)
     3                  - A(I,J,L,3)*R(I,J-1,3)
     4                  - A(I,J,L,4)*R(I,J-1,4)
     5                  - A(I,J,L,5)*R(I,J-1,5)
  250       CONTINUE
  260    CONTINUE
      ENDIF
C
C     Normalize row by multiplication of B(-1) to get unity diagonal
C
C     Form the LU of B(1)
C
      DO 300 I = 1, NSIM
         L11 =  B(I,J,1,1)
         U12 =  B(I,J,1,2) / L11
         U13 =  B(I,J,1,3) / L11
         U14 =  B(I,J,1,4) / L11
         U15 =  B(I,J,1,5) / L11
C
         L21 =  B(I,J,2,1)
         L22 =  B(I,J,2,2) - L21*U12
         U23 = (B(I,J,2,3) - L21*U13) / L22
         U24 = (B(I,J,2,4) - L21*U14) / L22
         U25 = (B(I,J,2,5) - L21*U15) / L22
C
         L31 =  B(I,J,3,1)
         L32 =  B(I,J,3,2) - L31*U12
         L33 =  B(I,J,3,3) - L31*U13 - L32*U23
         U34 = (B(I,J,3,4) - L31*U14 - L32*U24) / L33
         U35 = (B(I,J,3,5) - L31*U15 - L32*U25) / L33
C
         L41 =  B(I,J,4,1)
         L42 =  B(I,J,4,2) - L41*U12
         L43 =  B(I,J,4,3) - L41*U13 - L42*U23
         L44 =  B(I,J,4,4) - L41*U14 - L42*U24 - L43*U34
         U45 = (B(I,J,4,5) - L41*U15 - L42*U25 - L43*U35) / L44
C
         L51 =  B(I,J,5,1)
         L52 =  B(I,J,5,2) - L51*U12
         L53 =  B(I,J,5,3) - L51*U13 - L52*U23
         L54 =  B(I,J,5,4) - L51*U14 - L52*U24 - L53*U34
         L55 =  B(I,J,5,5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
C
C     Calculate B(-1) * R
C
         R1       =  R(I,J,1) / L11
         R2       = (R(I,J,2) - L21*R1) / L22
         R3       = (R(I,J,3) - L31*R1 - L32*R2) / L33
         R4       = (R(I,J,4) - L41*R1 - L42*R2 - L43*R3) / L44
         R(I,J,5) = (R(I,J,5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1              / L55
         R(I,J,4) =  R4-U45*R(I,J,5)
         R(I,J,3) =  R3-U35*R(I,J,5)-U34*R(I,J,4)
         R(I,J,2) =  R2-U25*R(I,J,5)-U24*R(I,J,4)-U23*R(I,J,3)
         R(I,J,1) =  R1-U15*R(I,J,5)-U14*R(I,J,4)-U13*R(I,J,3)
     1                    -U12*R(I,J,2)
  300 CONTINUE
C
C     Backward Substitution Sweep
C
      DO 400 J = NPTS-1, 1, -1
         DO 390 L = 1, 5
            DO 380 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - C(I,J,L,1)*R(I,J+1,1)
     2                  - C(I,J,L,2)*R(I,J+1,2)
     3                  - C(I,J,L,3)*R(I,J+1,3)
     4                  - C(I,J,L,4)*R(I,J+1,4)
     5                  - C(I,J,L,5)*R(I,J+1,5)
  380       CONTINUE
  390    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VB7TRI (NPTS, NSIM, NRANK, A, B, C, R)
C
C     Routine to invert a 7x7 block tridiagonal system
C     Inversion is by Upper Triangularization with a
C     unity diagonal followed by a backsubstitution step.
C     Vectorization is attained by inverting multiple systems
C     at one time with the recursive inverrsion algorithm.
C     The A, B, C arrays are destroyed in the solution
C     procedure.
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage
C     A:         The supra-diagonal block 7x7
C     B:         The       diagonal block 7x7
C     C:         The super-diagonal block 7x7
C     R:         The right hand side
C
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK),
     3          R (NSIM,NPTS,NRANK)
C
C     Storage for the LU decomposition of a block 7x7
C
      REAL L11,
     1     L21, L22,
     2     L31, L32, L33,
     3     L41, L42, L43, L44,
     4     L51, L52, L53, L54, L55,
     5     L61, L62, L63, L64, L65, L66,
     6     L71, L72, L73, L74, L75, L76, L77
C
C     Forward Substitution Loop - Upper Triangularization
C     Loop only to NPTS-1 to optimize vectorization while avoiding unnecessary
C     calculations of the L terms
C
      DO 200 J = 1, NPTS - 1
C
C     Eliminate A
C
C     B = B - A*C(j-1)
C
         IF (J .GT. 1) THEN
            DO 160 L = 1, 7
               DO 140 M = 1, 7
                  DO 130 I = 1, NSIM
                     B(I,J,L,M) = B(I,J,L,M)
     1                          - A(I,J,L,1)*C(I,J-1,1,M)
     2                          - A(I,J,L,2)*C(I,J-1,2,M)
     3                          - A(I,J,L,3)*C(I,J-1,3,M)
     4                          - A(I,J,L,4)*C(I,J-1,4,M)
     5                          - A(I,J,L,5)*C(I,J-1,5,M)
     6                          - A(I,J,L,6)*C(I,J-1,6,M)
     7                          - A(I,J,L,7)*C(I,J-1,7,M)
  130             CONTINUE
  140          CONTINUE
C
C     R = R - A*R(j-1)
C
               DO 150 I = 1, NSIM
                  R(I,J,L) = R(I,J,L)
     1                     - A(I,J,L,1)*R(I,J-1,1)
     2                     - A(I,J,L,2)*R(I,J-1,2)
     3                     - A(I,J,L,3)*R(I,J-1,3)
     4                     - A(I,J,L,4)*R(I,J-1,4)
     5                     - A(I,J,L,5)*R(I,J-1,5)
     6                     - A(I,J,L,6)*R(I,J-1,6)
     7                     - A(I,J,L,7)*R(I,J-1,7)
  150          CONTINUE
  160       CONTINUE
         ENDIF
C
C     Normalize row by multiplication of B(-1) to get unity diagonal
C
C     Form the LU of B(1)
C
         DO 190 I = 1, NSIM
            L11 =  B(I,J,1,1)
            U12 =  B(I,J,1,2) / L11
            U13 =  B(I,J,1,3) / L11
            U14 =  B(I,J,1,4) / L11
            U15 =  B(I,J,1,5) / L11
            U16 =  B(I,J,1,6) / L11
            U17 =  B(I,J,1,7) / L11
C
            L21 =  B(I,J,2,1)
            L22 =  B(I,J,2,2) - L21*U12
            U23 = (B(I,J,2,3) - L21*U13) / L22
            U24 = (B(I,J,2,4) - L21*U14) / L22
            U25 = (B(I,J,2,5) - L21*U15) / L22
            U26 = (B(I,J,2,6) - L21*U16) / L22
            U27 = (B(I,J,2,7) - L21*U17) / L22
C
            L31 =  B(I,J,3,1)
            L32 =  B(I,J,3,2) - L31*U12
            L33 =  B(I,J,3,3) - L31*U13 - L32*U23
            U34 = (B(I,J,3,4) - L31*U14 - L32*U24) / L33
            U35 = (B(I,J,3,5) - L31*U15 - L32*U25) / L33
            U36 = (B(I,J,3,6) - L31*U16 - L32*U26) / L33
            U37 = (B(I,J,3,7) - L31*U17 - L32*U27) / L33
C
            L41 =  B(I,J,4,1)
            L42 =  B(I,J,4,2) - L41*U12
            L43 =  B(I,J,4,3) - L41*U13 - L42*U23
            L44 =  B(I,J,4,4) - L41*U14 - L42*U24 - L43*U34
            U45 = (B(I,J,4,5) - L41*U15 - L42*U25 - L43*U35) / L44
            U46 = (B(I,J,4,6) - L41*U16 - L42*U26 - L43*U36) / L44
            U47 = (B(I,J,4,7) - L41*U17 - L42*U27 - L43*U37) / L44
C
            L51 =  B(I,J,5,1)
            L52 =  B(I,J,5,2) - L51*U12
            L53 =  B(I,J,5,3) - L51*U13 - L52*U23
            L54 =  B(I,J,5,4) - L51*U14 - L52*U24 - L53*U34
            L55 =  B(I,J,5,5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
            U56 = (B(I,J,5,6) - L51*U16 - L52*U26 - L53*U36 - L54*U46)
     1            / L55
            U57 = (B(I,J,5,7) - L51*U17 - L52*U27 - L53*U37 - L54*U47)
     1            / L55
C
            L61 =  B(I,J,6,1)
            L62 =  B(I,J,6,2) - L61*U12
            L63 =  B(I,J,6,3) - L61*U13 - L62*U23
            L64 =  B(I,J,6,4) - L61*U14 - L62*U24 - L63*U34
            L65 =  B(I,J,6,5) - L61*U15 - L62*U25 - L63*U35 - L64*U45
            L66 =  B(I,J,6,6) - L61*U16 - L62*U26 - L63*U36 - L64*U46
     1                        - L65*U56
            U67 = (B(I,J,6,7) - L61*U17 - L62*U27 - L63*U37 - L64*U47
     1                        - L65*U57) / L66
C
            L71 =  B(I,J,7,1)
            L72 =  B(I,J,7,2) - L71*U12
            L73 =  B(I,J,7,3) - L71*U13 - L72*U23
            L74 =  B(I,J,7,4) - L71*U14 - L72*U24 - L73*U34
            L75 =  B(I,J,7,5) - L71*U15 - L72*U25 - L73*U35 - L74*U45
            L76 =  B(I,J,7,6) - L71*U16 - L72*U26 - L73*U36 - L74*U46
     1                        - L75*U56
            L77 =  B(I,J,7,7) - L71*U17 - L72*U27 - L73*U37 - L74*U47
     1                        - L75*U57 - L76*U67
C
C     Calculate B(-1) * R
C
            R1       =  R(I,J,1) / L11
            R2       = (R(I,J,2) - L21*R1) / L22
            R3       = (R(I,J,3) - L31*R1 - L32*R2) / L33
            R4       = (R(I,J,4) - L41*R1 - L42*R2 - L43*R3) / L44
            R5       = (R(I,J,5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1                 / L55
            R6       = (R(I,J,6) - L61*R1 - L62*R2 - L63*R3 - L64*R4
     1                           - L65*R5) / L66
            R(I,J,7) = (R(I,J,7) - L71*R1 - L72*R2 - L73*R3 - L74*R4
     1                           - L75*R5 - L76*R6) / L77
            R(I,J,6) =  R6-U67*R(I,J,7)
            R(I,J,5) =  R5-U57*R(I,J,7)-U56*R(I,J,6)
            R(I,J,4) =  R4-U47*R(I,J,7)-U46*R(I,J,6)-U45*R(I,J,5)
            R(I,J,3) =  R3-U37*R(I,J,7)-U36*R(I,J,6)-U35*R(I,J,5)
     1                    -U34*R(I,J,4)
            R(I,J,2) =  R2-U27*R(I,J,7)-U26*R(I,J,6)-U25*R(I,J,5)
     1                    -U24*R(I,J,4)-U23*R(I,J,3)
            R(I,J,1) =  R1-U17*R(I,J,7)-U16*R(I,J,6)-U15*R(I,J,5)
     1                    -U14*R(I,J,4)-U13*R(I,J,3)-U12*R(I,J,2)
C
C     Calculate B(-1) * C
C
            C1         =  C(I,J,1,1) / L11
            C2         = (C(I,J,2,1) - L21*C1) / L22
            C3         = (C(I,J,3,1) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,1) - L41*C1 - L42*C2 - L43*C3)/L44
            C5         = (C(I,J,5,1) - L51*C1 - L52*C2 - L53*C3
     1                               - L54*C4)/L55
            C6         = (C(I,J,6,1) - L61*C1 - L62*C2 - L63*C3
     1                               - L64*C4 - L65*C5)/L66
            C(I,J,7,1) = (C(I,J,7,1) - L71*C1 - L72*C2 - L73*C3
     1                               - L74*C4 - L75*C5 - L76*C6)/L77
            C(I,J,6,1) = C6-U67*C(I,J,7,1)
            C(I,J,5,1) = C5-U57*C(I,J,7,1)-U56*C(I,J,6,1)
            C(I,J,4,1) = C4-U47*C(I,J,7,1)-U46*C(I,J,6,1)-U45*C(I,J,5,1)
            C(I,J,3,1) = C3-U37*C(I,J,7,1)-U36*C(I,J,6,1)-U35*C(I,J,5,1)
     1                     -U34*C(I,J,4,1)
            C(I,J,2,1) = C2-U27*C(I,J,7,1)-U26*C(I,J,6,1)-U25*C(I,J,5,1)
     1                     -U24*C(I,J,4,1)-U23*C(I,J,3,1)
            C(I,J,1,1) = C1-U17*C(I,J,7,1)-U16*C(I,J,6,1)-U15*C(I,J,5,1)
     1                     -U14*C(I,J,4,1)-U13*C(I,J,3,1)-U12*C(I,J,2,1)
C
            C1         =  C(I,J,1,2) / L11
            C2         = (C(I,J,2,2) - L21*C1) / L22
            C3         = (C(I,J,3,2) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,2) - L41*C1 - L42*C2 - L43*C3)/L44
            C5         = (C(I,J,5,2) - L51*C1 - L52*C2 - L53*C3
     1                               - L54*C4)/L55
            C6         = (C(I,J,6,2) - L61*C1 - L62*C2 - L63*C3
     1                               - L64*C4 - L65*C5)/L66
            C(I,J,7,2) = (C(I,J,7,2) - L71*C1 - L72*C2 - L73*C3
     1                               - L74*C4 - L75*C5 - L76*C6)/L77
            C(I,J,6,2) = C6-U67*C(I,J,7,2)
            C(I,J,5,2) = C5-U57*C(I,J,7,2)-U56*C(I,J,6,2)
            C(I,J,4,2) = C4-U47*C(I,J,7,2)-U46*C(I,J,6,2)-U45*C(I,J,5,2)
            C(I,J,3,2) = C3-U37*C(I,J,7,2)-U36*C(I,J,6,2)-U35*C(I,J,5,2)
     1                     -U34*C(I,J,4,2)
            C(I,J,2,2) = C2-U27*C(I,J,7,2)-U26*C(I,J,6,2)-U25*C(I,J,5,2)
     1                     -U24*C(I,J,4,2)-U23*C(I,J,3,2)
            C(I,J,1,2) = C1-U17*C(I,J,7,2)-U16*C(I,J,6,2)-U15*C(I,J,5,2)
     1                     -U14*C(I,J,4,2)-U13*C(I,J,3,2)-U12*C(I,J,2,2)
C
            C1         =  C(I,J,1,3) / L11
            C2         = (C(I,J,2,3) - L21*C1) / L22
            C3         = (C(I,J,3,3) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,3) - L41*C1 - L42*C2 - L43*C3)/L44
            C5         = (C(I,J,5,3) - L51*C1 - L52*C2 - L53*C3
     1                               - L54*C4)/L55
            C6         = (C(I,J,6,3) - L61*C1 - L62*C2 - L63*C3
     1                               - L64*C4 - L65*C5)/L66
            C(I,J,7,3) = (C(I,J,7,3) - L71*C1 - L72*C2 - L73*C3
     1                               - L74*C4 - L75*C5 - L76*C6)/L77
            C(I,J,6,3) = C6-U67*C(I,J,7,3)
            C(I,J,5,3) = C5-U57*C(I,J,7,3)-U56*C(I,J,6,3)
            C(I,J,4,3) = C4-U47*C(I,J,7,3)-U46*C(I,J,6,3)-U45*C(I,J,5,3)
            C(I,J,3,3) = C3-U37*C(I,J,7,3)-U36*C(I,J,6,3)-U35*C(I,J,5,3)
     1                     -U34*C(I,J,4,3)
            C(I,J,2,3) = C2-U27*C(I,J,7,3)-U26*C(I,J,6,3)-U25*C(I,J,5,3)
     1                     -U24*C(I,J,4,3)-U23*C(I,J,3,3)
            C(I,J,1,3) = C1-U17*C(I,J,7,3)-U16*C(I,J,6,3)-U15*C(I,J,5,3)
     1                     -U14*C(I,J,4,3)-U13*C(I,J,3,3)-U12*C(I,J,2,3)
C
            C1         =  C(I,J,1,4) / L11
            C2         = (C(I,J,2,4) - L21*C1) / L22
            C3         = (C(I,J,3,4) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,4) - L41*C1 - L42*C2 - L43*C3)/L44
            C5         = (C(I,J,5,4) - L51*C1 - L52*C2 - L53*C3
     1                               - L54*C4)/L55
            C6         = (C(I,J,6,4) - L61*C1 - L62*C2 - L63*C3
     1                               - L64*C4 - L65*C5)/L66
            C(I,J,7,4) = (C(I,J,7,4) - L71*C1 - L72*C2 - L73*C3
     1                               - L74*C4 - L75*C5 - L76*C6)/L77
            C(I,J,6,4) = C6-U67*C(I,J,7,4)
            C(I,J,5,4) = C5-U57*C(I,J,7,4)-U56*C(I,J,6,4)
            C(I,J,4,4) = C4-U47*C(I,J,7,4)-U46*C(I,J,6,4)-U45*C(I,J,5,4)
            C(I,J,3,4) = C3-U37*C(I,J,7,4)-U36*C(I,J,6,4)-U35*C(I,J,5,4)
     1                     -U34*C(I,J,4,4)
            C(I,J,2,4) = C2-U27*C(I,J,7,4)-U26*C(I,J,6,4)-U25*C(I,J,5,4)
     1                     -U24*C(I,J,4,4)-U23*C(I,J,3,4)
            C(I,J,1,4) = C1-U17*C(I,J,7,4)-U16*C(I,J,6,4)-U15*C(I,J,5,4)
     1                     -U14*C(I,J,4,4)-U13*C(I,J,3,4)-U12*C(I,J,2,4)
C
            C1         =  C(I,J,1,5) / L11
            C2         = (C(I,J,2,5) - L21*C1) / L22
            C3         = (C(I,J,3,5) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,5) - L41*C1 - L42*C2 - L43*C3)/L44
            C5         = (C(I,J,5,5) - L51*C1 - L52*C2 - L53*C3
     1                               - L54*C4)/L55
            C6         = (C(I,J,6,5) - L61*C1 - L62*C2 - L63*C3
     1                               - L64*C4 - L65*C5)/L66
            C(I,J,7,5) = (C(I,J,7,5) - L71*C1 - L72*C2 - L73*C3
     1                               - L74*C4 - L75*C5 - L76*C6)/L77
            C(I,J,6,5) = C6-U67*C(I,J,7,5)
            C(I,J,5,5) = C5-U57*C(I,J,7,5)-U56*C(I,J,6,5)
            C(I,J,4,5) = C4-U47*C(I,J,7,5)-U46*C(I,J,6,5)-U45*C(I,J,5,5)
            C(I,J,3,5) = C3-U37*C(I,J,7,5)-U36*C(I,J,6,5)-U35*C(I,J,5,5)
     1                     -U34*C(I,J,4,5)
            C(I,J,2,5) = C2-U27*C(I,J,7,5)-U26*C(I,J,6,5)-U25*C(I,J,5,5)
     1                     -U24*C(I,J,4,5)-U23*C(I,J,3,5)
            C(I,J,1,5) = C1-U17*C(I,J,7,5)-U16*C(I,J,6,5)-U15*C(I,J,5,5)
     1                     -U14*C(I,J,4,5)-U13*C(I,J,3,5)-U12*C(I,J,2,5)
C
            C1         =  C(I,J,1,6) / L11
            C2         = (C(I,J,2,6) - L21*C1) / L22
            C3         = (C(I,J,3,6) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,6) - L41*C1 - L42*C2 - L43*C3)/L44
            C5         = (C(I,J,5,6) - L51*C1 - L52*C2 - L53*C3
     1                               - L54*C4)/L55
            C6         = (C(I,J,6,6) - L61*C1 - L62*C2 - L63*C3
     1                               - L64*C4 - L65*C5)/L66
            C(I,J,7,6) = (C(I,J,7,6) - L71*C1 - L72*C2 - L73*C3
     1                               - L74*C4 - L75*C5 - L76*C6)/L77
            C(I,J,6,6) = C6-U67*C(I,J,7,6)
            C(I,J,5,6) = C5-U57*C(I,J,7,6)-U56*C(I,J,6,6)
            C(I,J,4,6) = C4-U47*C(I,J,7,6)-U46*C(I,J,6,6)-U45*C(I,J,5,6)
            C(I,J,3,6) = C3-U37*C(I,J,7,6)-U36*C(I,J,6,6)-U35*C(I,J,5,6)
     1                     -U34*C(I,J,4,6)
            C(I,J,2,6) = C2-U27*C(I,J,7,6)-U26*C(I,J,6,6)-U25*C(I,J,5,6)
     1                     -U24*C(I,J,4,6)-U23*C(I,J,3,6)
            C(I,J,1,6) = C1-U17*C(I,J,7,6)-U16*C(I,J,6,6)-U15*C(I,J,5,6)
     1                     -U14*C(I,J,4,6)-U13*C(I,J,3,6)-U12*C(I,J,2,6)
C
            C1         =  C(I,J,1,7) / L11
            C2         = (C(I,J,2,7) - L21*C1) / L22
            C3         = (C(I,J,3,7) - L31*C1 - L32*C2) / L33
            C4         = (C(I,J,4,7) - L41*C1 - L42*C2 - L43*C3)/L44
            C5         = (C(I,J,5,7) - L51*C1 - L52*C2 - L53*C3
     1                               - L54*C4)/L55
            C6         = (C(I,J,6,7) - L61*C1 - L62*C2 - L63*C3
     1                               - L64*C4 - L65*C5)/L66
            C(I,J,7,7) = (C(I,J,7,7) - L71*C1 - L72*C2 - L73*C3
     1                               - L74*C4 - L75*C5 - L76*C6)/L77
            C(I,J,6,7) = C6-U67*C(I,J,7,7)
            C(I,J,5,7) = C5-U57*C(I,J,7,7)-U56*C(I,J,6,7)
            C(I,J,4,7) = C4-U47*C(I,J,7,7)-U46*C(I,J,6,7)-U45*C(I,J,5,7)
            C(I,J,3,7) = C3-U37*C(I,J,7,7)-U36*C(I,J,6,7)-U35*C(I,J,5,7)
     1                     -U34*C(I,J,4,7)
            C(I,J,2,7) = C2-U27*C(I,J,7,7)-U26*C(I,J,6,7)-U25*C(I,J,5,7)
     1                     -U24*C(I,J,4,7)-U23*C(I,J,3,7)
            C(I,J,1,7) = C1-U17*C(I,J,7,7)-U16*C(I,J,6,7)-U15*C(I,J,5,7)
     1                     -U14*C(I,J,4,7)-U13*C(I,J,3,7)-U12*C(I,J,2,7)
  190    CONTINUE
  200 CONTINUE
C
C     J = NPTS Elimination
C     Do not do this loop if NPTS = 1
C
C     Eliminate A
C
C     B = B - A*C(j-1)
C
      J = NPTS
      IF (NPTS .GT. 1) THEN
         DO 260 L = 1, 7
            DO 240 M = 1, 7
               DO 230 I = 1, NSIM
                  B(I,J,L,M) = B(I,J,L,M)
     1                       - A(I,J,L,1)*C(I,J-1,1,M)
     2                       - A(I,J,L,2)*C(I,J-1,2,M)
     3                       - A(I,J,L,3)*C(I,J-1,3,M)
     4                       - A(I,J,L,4)*C(I,J-1,4,M)
     5                       - A(I,J,L,5)*C(I,J-1,5,M)
     6                       - A(I,J,L,6)*C(I,J-1,6,M)
     7                       - A(I,J,L,7)*C(I,J-1,7,M)
  230          CONTINUE
  240       CONTINUE
C
C     R = R - A*R(j-1)
C
            DO 250 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - A(I,J,L,1)*R(I,J-1,1)
     2                  - A(I,J,L,2)*R(I,J-1,2)
     3                  - A(I,J,L,3)*R(I,J-1,3)
     4                  - A(I,J,L,4)*R(I,J-1,4)
     5                  - A(I,J,L,5)*R(I,J-1,5)
     6                  - A(I,J,L,6)*R(I,J-1,6)
     7                  - A(I,J,L,7)*R(I,J-1,7)
  250       CONTINUE
  260    CONTINUE
      ENDIF
C
C     Normalize row by multiplication of B(-1) to get unity diagonal
C
C     Form the LU of B(1)
C
      DO 300 I = 1, NSIM
         L11 =  B(I,J,1,1)
         U12 =  B(I,J,1,2) / L11
         U13 =  B(I,J,1,3) / L11
         U14 =  B(I,J,1,4) / L11
         U15 =  B(I,J,1,5) / L11
         U16 =  B(I,J,1,6) / L11
         U17 =  B(I,J,1,7) / L11
C
         L21 =  B(I,J,2,1)
         L22 =  B(I,J,2,2) - L21*U12
         U23 = (B(I,J,2,3) - L21*U13) / L22
         U24 = (B(I,J,2,4) - L21*U14) / L22
         U25 = (B(I,J,2,5) - L21*U15) / L22
         U26 = (B(I,J,2,6) - L21*U16) / L22
         U27 = (B(I,J,2,7) - L21*U17) / L22
C
         L31 =  B(I,J,3,1)
         L32 =  B(I,J,3,2) - L31*U12
         L33 =  B(I,J,3,3) - L31*U13 - L32*U23
         U34 = (B(I,J,3,4) - L31*U14 - L32*U24) / L33
         U35 = (B(I,J,3,5) - L31*U15 - L32*U25) / L33
         U36 = (B(I,J,3,6) - L31*U16 - L32*U26) / L33
         U37 = (B(I,J,3,7) - L31*U17 - L32*U27) / L33
C
         L41 =  B(I,J,4,1)
         L42 =  B(I,J,4,2) - L41*U12
         L43 =  B(I,J,4,3) - L41*U13 - L42*U23
         L44 =  B(I,J,4,4) - L41*U14 - L42*U24 - L43*U34
         U45 = (B(I,J,4,5) - L41*U15 - L42*U25 - L43*U35) / L44
         U46 = (B(I,J,4,6) - L41*U16 - L42*U26 - L43*U36) / L44
         U47 = (B(I,J,4,7) - L41*U17 - L42*U27 - L43*U37) / L44
C
         L51 =  B(I,J,5,1)
         L52 =  B(I,J,5,2) - L51*U12
         L53 =  B(I,J,5,3) - L51*U13 - L52*U23
         L54 =  B(I,J,5,4) - L51*U14 - L52*U24 - L53*U34
         L55 =  B(I,J,5,5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
         U56 = (B(I,J,5,6) - L51*U16 - L52*U26 - L53*U36 - L54*U46)
     1         / L55
         U57 = (B(I,J,5,7) - L51*U17 - L52*U27 - L53*U37 - L54*U47)
     1         / L55
C
         L61 =  B(I,J,6,1)
         L62 =  B(I,J,6,2) - L61*U12
         L63 =  B(I,J,6,3) - L61*U13 - L62*U23
         L64 =  B(I,J,6,4) - L61*U14 - L62*U24 - L63*U34
         L65 =  B(I,J,6,5) - L61*U15 - L62*U25 - L63*U35 - L64*U45
         L66 =  B(I,J,6,6) - L61*U16 - L62*U26 - L63*U36 - L64*U46
     1                     - L65*U56
         U67 = (B(I,J,6,7) - L61*U17 - L62*U27 - L63*U37 - L64*U47
     1                     - L65*U57) / L66
C
         L71 =  B(I,J,7,1)
         L72 =  B(I,J,7,2) - L71*U12
         L73 =  B(I,J,7,3) - L71*U13 - L72*U23
         L74 =  B(I,J,7,4) - L71*U14 - L72*U24 - L73*U34
         L75 =  B(I,J,7,5) - L71*U15 - L72*U25 - L73*U35 - L74*U45
         L76 =  B(I,J,7,6) - L71*U16 - L72*U26 - L73*U36 - L74*U46
     1                     - L75*U56
         L77 =  B(I,J,7,7) - L71*U17 - L72*U27 - L73*U37 - L74*U47
     1                     - L75*U57 - L76*U67
C
C     Calculate B(-1) * R
C
         R1       =  R(I,J,1) / L11
         R2       = (R(I,J,2) - L21*R1) / L22
         R3       = (R(I,J,3) - L31*R1 - L32*R2) / L33
         R4       = (R(I,J,4) - L41*R1 - L42*R2 - L43*R3) / L44
         R5       = (R(I,J,5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1              / L55
         R6       = (R(I,J,6) - L61*R1 - L62*R2 - L63*R3 - L64*R4
     1                        - L65*R5) / L66
         R(I,J,7) = (R(I,J,7) - L71*R1 - L72*R2 - L73*R3 - L74*R4
     1                        - L75*R5 - L76*R6) / L77
         R(I,J,6) =  R6-U67*R(I,J,7)
         R(I,J,5) =  R5-U57*R(I,J,7)-U56*R(I,J,6)
         R(I,J,4) =  R4-U47*R(I,J,7)-U46*R(I,J,6)-U45*R(I,J,5)
         R(I,J,3) =  R3-U37*R(I,J,7)-U36*R(I,J,6)-U35*R(I,J,5)
     1                 -U34*R(I,J,4)
         R(I,J,2) =  R2-U27*R(I,J,7)-U26*R(I,J,6)-U25*R(I,J,5)
     1                 -U24*R(I,J,4)-U23*R(I,J,3)
         R(I,J,1) =  R1-U17*R(I,J,7)-U16*R(I,J,6)-U15*R(I,J,5)
     1                 -U14*R(I,J,4)-U13*R(I,J,3)-U12*R(I,J,2)
  300 CONTINUE
C
C     Backward Substitution Sweep
C
      DO 400 J = NPTS-1, 1, -1
         DO 390 L = 1, 7
            DO 380 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - C(I,J,L,1)*R(I,J+1,1)
     2                  - C(I,J,L,2)*R(I,J+1,2)
     3                  - C(I,J,L,3)*R(I,J+1,3)
     4                  - C(I,J,L,4)*R(I,J+1,4)
     5                  - C(I,J,L,5)*R(I,J+1,5)
     6                  - C(I,J,L,6)*R(I,J+1,6)
     7                  - C(I,J,L,7)*R(I,J+1,7)
  380       CONTINUE
  390    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VB12TR (NPTS, NSIM, NRANK, A, B, C, R)
C
C     Routine to invert a 12x12 block tridiagonal system
C     Inversion is by Upper Triangularization with a
C     unity diagonal followed by a backsubstitution step.
C     Vectorization is attained by inverting multiple systems
C     at one time with the recursive inversion algorithm.
C     The A, B, C arrays are destroyed in the solution
C     procedure.
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage
C     A:         The supra-diagonal block 12x12
C     B:         The       diagonal block 12x12
C     C:         The super-diagonal block 12x12
C     R:         The right hand side
C
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK),
     3          R (NSIM,NPTS,NRANK)
C
C     Storage for the LU decomposition of a block 12x12
C
      REAL L11,
     1     L21, L22,
     2     L31, L32, L33,
     3     L41, L42, L43, L44,
     4     L51, L52, L53, L54, L55,
     5     L61, L62, L63, L64, L65, L66,
     6     L71, L72, L73, L74, L75, L76, L77,
     7     L81, L82, L83, L84, L85, L86, L87, L88,
     8     L91, L92, L93, L94, L95, L96, L97, L98, L99,
     9     LA1, LA2, LA3, LA4, LA5, LA6, LA7, LA8, LA9, LAA,
     A     LB1, LB2, LB3, LB4, LB5, LB6, LB7, LB8, LB9, LBA, LBB,
     B     LC1, LC2, LC3, LC4, LC5, LC6, LC7, LC8, LC9, LCA, LCB, LCC
C
C     Forward Substitution Loop - Upper Triangularization
C     Loop only to NPTS-1 to optimize vectorization while avoiding unnecessary
C     calculations of the L terms
C
      DO 200 J = 1, NPTS - 1
C
C     Eliminate A
C
C     B = B - A*C(j-1)
C
         IF (J .GT. 1) THEN
            DO 160 L = 1, 12
               DO 140 M = 1, 12
                  DO 130 I = 1, NSIM
                     B(I,J,L,M) = B(I,J,L,M)
     1                          - A(I,J,L, 1)*C(I,J-1, 1,M)
     2                          - A(I,J,L, 2)*C(I,J-1, 2,M)
     3                          - A(I,J,L, 3)*C(I,J-1, 3,M)
     4                          - A(I,J,L, 4)*C(I,J-1, 4,M)
     5                          - A(I,J,L, 5)*C(I,J-1, 5,M)
     6                          - A(I,J,L, 6)*C(I,J-1, 6,M)
     7                          - A(I,J,L, 7)*C(I,J-1, 7,M)
     8                          - A(I,J,L, 8)*C(I,J-1, 8,M)
     9                          - A(I,J,L, 9)*C(I,J-1, 9,M)
     A                          - A(I,J,L,10)*C(I,J-1,10,M)
     B                          - A(I,J,L,11)*C(I,J-1,11,M)
     C                          - A(I,J,L,12)*C(I,J-1,12,M)
  130          CONTINUE
  140       CONTINUE
C
C     R = R - A*R(j-1)
C
               DO 150 I = 1, NSIM
                  R(I,J,L) = R(I,J,L)
     1                     - A(I,J,L, 1)*R(I,J-1, 1)
     2                     - A(I,J,L, 2)*R(I,J-1, 2)
     3                     - A(I,J,L, 3)*R(I,J-1, 3)
     4                     - A(I,J,L, 4)*R(I,J-1, 4)
     5                     - A(I,J,L, 5)*R(I,J-1, 5)
     6                     - A(I,J,L, 6)*R(I,J-1, 6)
     7                     - A(I,J,L, 7)*R(I,J-1, 7)
     8                     - A(I,J,L, 8)*R(I,J-1, 8)
     9                     - A(I,J,L, 9)*R(I,J-1, 9)
     A                     - A(I,J,L,10)*R(I,J-1,10)
     B                     - A(I,J,L,11)*R(I,J-1,11)
     C                     - A(I,J,L,12)*R(I,J-1,12)
  150          CONTINUE
  160       CONTINUE
         ENDIF
C
C     Normalize row by multiplication of B(-1) to get unity diagonal
C
C     Form the LU of B(1)
C
C     The IVDEP compiler directive is necessary to overcome a difficulty with
C     overflowing dependency checking tables in the Cray compiler 5.0.4.7
CDIR$ IVDEP
         DO 190 I = 1, NSIM
            L11 =  B(I,J,1, 1)
            U12 =  B(I,J,1, 2) / L11
            U13 =  B(I,J,1, 3) / L11
            U14 =  B(I,J,1, 4) / L11
            U15 =  B(I,J,1, 5) / L11
            U16 =  B(I,J,1, 6) / L11
            U17 =  B(I,J,1, 7) / L11
            U18 =  B(I,J,1, 8) / L11
            U19 =  B(I,J,1, 9) / L11
            U1A =  B(I,J,1,10) / L11
            U1B =  B(I,J,1,11) / L11
            U1C =  B(I,J,1,12) / L11
C
            L21 =  B(I,J,2, 1)
            L22 =  B(I,J,2, 2) - L21*U12
            U23 = (B(I,J,2, 3) - L21*U13) / L22
            U24 = (B(I,J,2, 4) - L21*U14) / L22
            U25 = (B(I,J,2, 5) - L21*U15) / L22
            U26 = (B(I,J,2, 6) - L21*U16) / L22
            U27 = (B(I,J,2, 7) - L21*U17) / L22
            U28 = (B(I,J,2, 8) - L21*U18) / L22
            U29 = (B(I,J,2, 9) - L21*U19) / L22
            U2A = (B(I,J,2,10) - L21*U1A) / L22
            U2B = (B(I,J,2,11) - L21*U1B) / L22
            U2C = (B(I,J,2,12) - L21*U1C) / L22
C
            L31 =  B(I,J,3, 1)
            L32 =  B(I,J,3, 2) - L31*U12
            L33 =  B(I,J,3, 3) - L31*U13 - L32*U23
            U34 = (B(I,J,3, 4) - L31*U14 - L32*U24) / L33
            U35 = (B(I,J,3, 5) - L31*U15 - L32*U25) / L33
            U36 = (B(I,J,3, 6) - L31*U16 - L32*U26) / L33
            U37 = (B(I,J,3, 7) - L31*U17 - L32*U27) / L33
            U38 = (B(I,J,3, 8) - L31*U18 - L32*U28) / L33
            U39 = (B(I,J,3, 9) - L31*U19 - L32*U29) / L33
            U3A = (B(I,J,3,10) - L31*U1A - L32*U2A) / L33
            U3B = (B(I,J,3,11) - L31*U1B - L32*U2B) / L33
            U3C = (B(I,J,3,12) - L31*U1C - L32*U2C) / L33
C
            L41 =  B(I,J,4, 1)
            L42 =  B(I,J,4, 2) - L41*U12
            L43 =  B(I,J,4, 3) - L41*U13 - L42*U23
            L44 =  B(I,J,4, 4) - L41*U14 - L42*U24 - L43*U34
            U45 = (B(I,J,4, 5) - L41*U15 - L42*U25 - L43*U35) / L44
            U46 = (B(I,J,4, 6) - L41*U16 - L42*U26 - L43*U36) / L44
            U47 = (B(I,J,4, 7) - L41*U17 - L42*U27 - L43*U37) / L44
            U48 = (B(I,J,4, 8) - L41*U18 - L42*U28 - L43*U38) / L44
            U49 = (B(I,J,4, 9) - L41*U19 - L42*U29 - L43*U39) / L44
            U4A = (B(I,J,4,10) - L41*U1A - L42*U2A - L43*U3A) / L44
            U4B = (B(I,J,4,11) - L41*U1B - L42*U2B - L43*U3B) / L44
            U4C = (B(I,J,4,12) - L41*U1C - L42*U2C - L43*U3C) / L44
C
            L51 =  B(I,J,5, 1)
            L52 =  B(I,J,5, 2) - L51*U12
            L53 =  B(I,J,5, 3) - L51*U13 - L52*U23
            L54 =  B(I,J,5, 4) - L51*U14 - L52*U24 - L53*U34
            L55 =  B(I,J,5, 5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
            U56 = (B(I,J,5, 6) - L51*U16 - L52*U26 - L53*U36 - L54*U46)
     1            / L55
            U57 = (B(I,J,5, 7) - L51*U17 - L52*U27 - L53*U37 - L54*U47)
     1            / L55
            U58 = (B(I,J,5, 8) - L51*U18 - L52*U28 - L53*U38 - L54*U48)
     1            / L55
            U59 = (B(I,J,5, 9) - L51*U19 - L52*U29 - L53*U39 - L54*U49)
     1            / L55
            U5A = (B(I,J,5,10) - L51*U1A - L52*U2A - L53*U3A - L54*U4A)
     1            / L55
            U5B = (B(I,J,5,11) - L51*U1B - L52*U2B - L53*U3B - L54*U4B)
     1            / L55
            U5C = (B(I,J,5,12) - L51*U1C - L52*U2C - L53*U3C - L54*U4C)
     1            / L55
C
            L61 =  B(I,J,6, 1)
            L62 =  B(I,J,6, 2) - L61*U12
            L63 =  B(I,J,6, 3) - L61*U13 - L62*U23
            L64 =  B(I,J,6, 4) - L61*U14 - L62*U24 - L63*U34
            L65 =  B(I,J,6, 5) - L61*U15 - L62*U25 - L63*U35 - L64*U45
            L66 =  B(I,J,6, 6) - L61*U16 - L62*U26 - L63*U36 - L64*U46
     1                         - L65*U56
            U67 = (B(I,J,6, 7) - L61*U17 - L62*U27 - L63*U37 - L64*U47
     1                         - L65*U57) / L66
            U68 = (B(I,J,6, 8) - L61*U18 - L62*U28 - L63*U38 - L64*U48
     1                         - L65*U58) / L66
            U69 = (B(I,J,6, 9) - L61*U19 - L62*U29 - L63*U39 - L64*U49
     1                         - L65*U59) / L66
            U6A = (B(I,J,6,10) - L61*U1A - L62*U2A - L63*U3A - L64*U4A
     1                         - L65*U5A) / L66
            U6B = (B(I,J,6,11) - L61*U1B - L62*U2B - L63*U3B - L64*U4B
     1                         - L65*U5B) / L66
            U6C = (B(I,J,6,12) - L61*U1C - L62*U2C - L63*U3C - L64*U4C
     1                         - L65*U5C) / L66
C
            L71 =  B(I,J,7, 1)
            L72 =  B(I,J,7, 2) - L71*U12
            L73 =  B(I,J,7, 3) - L71*U13 - L72*U23
            L74 =  B(I,J,7, 4) - L71*U14 - L72*U24 - L73*U34
            L75 =  B(I,J,7, 5) - L71*U15 - L72*U25 - L73*U35 - L74*U45
            L76 =  B(I,J,7, 6) - L71*U16 - L72*U26 - L73*U36 - L74*U46
     1                         - L75*U56
            L77 =  B(I,J,7, 7) - L71*U17 - L72*U27 - L73*U37 - L74*U47
     1                         - L75*U57 - L76*U67
            U78 = (B(I,J,7, 8) - L71*U18 - L72*U28 - L73*U38 - L74*U48
     1                         - L75*U58 - L76*U68) / L77
            U79 = (B(I,J,7, 9) - L71*U19 - L72*U29 - L73*U39 - L74*U49
     1                         - L75*U59 - L76*U69) / L77
            U7A = (B(I,J,7,10) - L71*U1A - L72*U2A - L73*U3A - L74*U4A
     1                         - L75*U5A - L76*U6A) / L77
            U7B = (B(I,J,7,11) - L71*U1B - L72*U2B - L73*U3B - L74*U4B
     1                         - L75*U5B - L76*U6B) / L77
            U7C = (B(I,J,7,12) - L71*U1C - L72*U2C - L73*U3C - L74*U4C
     1                         - L75*U5C - L76*U6C) / L77
C
            L81 =  B(I,J,8, 1)
            L82 =  B(I,J,8, 2) - L81*U12
            L83 =  B(I,J,8, 3) - L81*U13 - L82*U23
            L84 =  B(I,J,8, 4) - L81*U14 - L82*U24 - L83*U34
            L85 =  B(I,J,8, 5) - L81*U15 - L82*U25 - L83*U35 - L84*U45
            L86 =  B(I,J,8, 6) - L81*U16 - L82*U26 - L83*U36 - L84*U46
     1                         - L85*U56
            L87 =  B(I,J,8, 7) - L81*U17 - L82*U27 - L83*U37 - L84*U47
     1                         - L85*U57 - L86*U67
            L88 =  B(I,J,8, 8) - L81*U18 - L82*U28 - L83*U38 - L84*U48
     1                         - L85*U58 - L86*U68 - L87*U78
            U89 = (B(I,J,8, 9) - L81*U19 - L82*U29 - L83*U39 - L84*U49
     1                         - L85*U59 - L86*U69 - L87*U79) / L88
            U8A = (B(I,J,8,10) - L81*U1A - L82*U2A - L83*U3A - L84*U4A
     1                         - L85*U5A - L86*U6A - L87*U7A) / L88
            U8B = (B(I,J,8,11) - L81*U1B - L82*U2B - L83*U3B - L84*U4B
     1                         - L85*U5B - L86*U6B - L87*U7B) / L88
            U8C = (B(I,J,8,12) - L81*U1C - L82*U2C - L83*U3C - L84*U4C
     1                         - L85*U5C - L86*U6C - L87*U7C) / L88
C
            L91 =  B(I,J,9, 1)
            L92 =  B(I,J,9, 2) - L91*U12
            L93 =  B(I,J,9, 3) - L91*U13 - L92*U23
            L94 =  B(I,J,9, 4) - L91*U14 - L92*U24 - L93*U34
            L95 =  B(I,J,9, 5) - L91*U15 - L92*U25 - L93*U35 - L94*U45
            L96 =  B(I,J,9, 6) - L91*U16 - L92*U26 - L93*U36 - L94*U46
     1                         - L95*U56
            L97 =  B(I,J,9, 7) - L91*U17 - L92*U27 - L93*U37 - L94*U47
     1                         - L95*U57 - L96*U67
            L98 =  B(I,J,9, 8) - L91*U18 - L92*U28 - L93*U38 - L94*U48
     1                         - L95*U58 - L96*U68 - L97*U78
            L99 =  B(I,J,9, 9) - L91*U19 - L92*U29 - L93*U39 - L94*U49
     1                         - L95*U59 - L96*U69 - L97*U79 - L98*U89
            U9A = (B(I,J,9,10) - L91*U1A - L92*U2A - L93*U3A - L94*U4A
     1                         - L95*U5A - L96*U6A - L97*U7A - L98*U8A)
     2            / L99
            U9B = (B(I,J,9,11) - L91*U1B - L92*U2B - L93*U3B - L94*U4B
     1                         - L95*U5B - L96*U6B - L97*U7B - L98*U8B)
     2            / L99
            U9C = (B(I,J,9,12) - L91*U1C - L92*U2C - L93*U3C - L94*U4C
     1                         - L95*U5C - L96*U6C - L97*U7C - L98*U8C)
     2            / L99
C
            LA1 =  B(I,J,10, 1)
            LA2 =  B(I,J,10, 2) - LA1*U12
            LA3 =  B(I,J,10, 3) - LA1*U13 - LA2*U23
            LA4 =  B(I,J,10, 4) - LA1*U14 - LA2*U24 - LA3*U34
            LA5 =  B(I,J,10, 5) - LA1*U15 - LA2*U25 - LA3*U35 - LA4*U45
            LA6 =  B(I,J,10, 6) - LA1*U16 - LA2*U26 - LA3*U36 - LA4*U46
     1                          - LA5*U56
            LA7 =  B(I,J,10, 7) - LA1*U17 - LA2*U27 - LA3*U37 - LA4*U47
     1                          - LA5*U57 - LA6*U67
            LA8 =  B(I,J,10, 8) - LA1*U18 - LA2*U28 - LA3*U38 - LA4*U48
     1                          - LA5*U58 - LA6*U68 - LA7*U78
            LA9 =  B(I,J,10, 9) - LA1*U19 - LA2*U29 - LA3*U39 - LA4*U49
     1                          - LA5*U59 - LA6*U69 - LA7*U79 - LA8*U89
            LAA =  B(I,J,10,10) - LA1*U1A - LA2*U2A - LA3*U3A - LA4*U4A
     1                          - LA5*U5A - LA6*U6A - LA7*U7A - LA8*U8A
     2                          - LA9*U9A
            UAB = (B(I,J,10,11) - LA1*U1B - LA2*U2B - LA3*U3B - LA4*U4B
     1                          - LA5*U5B - LA6*U6B - LA7*U7B - LA8*U8B
     2                          - LA9*U9B) / LAA
            UAC = (B(I,J,10,12) - LA1*U1C - LA2*U2C - LA3*U3C - LA4*U4C
     1                          - LA5*U5C - LA6*U6C - LA7*U7C - LA8*U8C
     2                          - LA9*U9C) / LAA
C
            LB1 =  B(I,J,11, 1)
            LB2 =  B(I,J,11, 2) - LB1*U12
            LB3 =  B(I,J,11, 3) - LB1*U13 - LB2*U23
            LB4 =  B(I,J,11, 4) - LB1*U14 - LB2*U24 - LB3*U34
            LB5 =  B(I,J,11, 5) - LB1*U15 - LB2*U25 - LB3*U35 - LB4*U45
            LB6 =  B(I,J,11, 6) - LB1*U16 - LB2*U26 - LB3*U36 - LB4*U46
     1                          - LB5*U56
            LB7 =  B(I,J,11, 7) - LB1*U17 - LB2*U27 - LB3*U37 - LB4*U47
     1                          - LB5*U57 - LB6*U67
            LB8 =  B(I,J,11, 8) - LB1*U18 - LB2*U28 - LB3*U38 - LB4*U48
     1                          - LB5*U58 - LB6*U68 - LB7*U78
            LB9 =  B(I,J,11, 9) - LB1*U19 - LB2*U29 - LB3*U39 - LB4*U49
     1                          - LB5*U59 - LB6*U69 - LB7*U79 - LB8*U89
            LBA =  B(I,J,11,10) - LB1*U1A - LB2*U2A - LB3*U3A - LB4*U4A
     1                          - LB5*U5A - LB6*U6A - LB7*U7A - LB8*U8A
     2                          - LB9*U9A
            LBB =  B(I,J,11,11) - LB1*U1B - LB2*U2B - LB3*U3B - LB4*U4B
     1                          - LB5*U5B - LB6*U6B - LB7*U7B - LB8*U8B
     2                          - LB9*U9B - LBA*UAB
            UBC = (B(I,J,11,12) - LB1*U1C - LB2*U2C - LB3*U3C - LB4*U4C
     1                          - LB5*U5C - LB6*U6C - LB7*U7C - LB8*U8C
     2                          - LB9*U9C - LBA*UAC) / LAA
C
            LC1 =  B(I,J,12, 1)
            LC2 =  B(I,J,12, 2) - LC1*U12
            LC3 =  B(I,J,12, 3) - LC1*U13 - LC2*U23
            LC4 =  B(I,J,12, 4) - LC1*U14 - LC2*U24 - LC3*U34
            LC5 =  B(I,J,12, 5) - LC1*U15 - LC2*U25 - LC3*U35 - LC4*U45
            LC6 =  B(I,J,12, 6) - LC1*U16 - LC2*U26 - LC3*U36 - LC4*U46
     1                          - LC5*U56
            LC7 =  B(I,J,12, 7) - LC1*U17 - LC2*U27 - LC3*U37 - LC4*U47
     1                          - LC5*U57 - LC6*U67
            LC8 =  B(I,J,12, 8) - LC1*U18 - LC2*U28 - LC3*U38 - LC4*U48
     1                          - LC5*U58 - LC6*U68 - LC7*U78
            LC9 =  B(I,J,12, 9) - LC1*U19 - LC2*U29 - LC3*U39 - LC4*U49
     1                          - LC5*U59 - LC6*U69 - LC7*U79 - LC8*U89
            LCA =  B(I,J,12,10) - LC1*U1A - LC2*U2A - LC3*U3A - LC4*U4A
     1                          - LC5*U5A - LC6*U6A - LC7*U7A - LC8*U8A
     2                          - LC9*U9A
            LCB =  B(I,J,12,11) - LC1*U1B - LC2*U2B - LC3*U3B - LC4*U4B
     1                          - LC5*U5B - LC6*U6B - LC7*U7B - LC8*U8B
     2                          - LC9*U9B - LCA*UAB
            LCC =  B(I,J,12,12) - LC1*U1C - LC2*U2C - LC3*U3C - LC4*U4C
     1                          - LC5*U5C - LC6*U6C - LC7*U7C - LC8*U8C
     2                          - LC9*U9C - LCA*UAC - LCB*UBC
C
C     Calculate B(-1) * R
C
            R1        =  R(I,J, 1) / L11
            R2        = (R(I,J, 2) - L21*R1) / L22
            R3        = (R(I,J, 3) - L31*R1 - L32*R2) / L33
            R4        = (R(I,J, 4) - L41*R1 - L42*R2 - L43*R3) / L44
            R5        = (R(I,J, 5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1                  / L55
            R6        = (R(I,J, 6) - L61*R1 - L62*R2 - L63*R3 - L64*R4
     1                             - L65*R5) / L66
            R7        = (R(I,J, 7) - L71*R1 - L72*R2 - L73*R3 - L74*R4
     1                             - L75*R5 - L76*R6) / L77
            R8        = (R(I,J, 8) - L81*R1 - L82*R2 - L83*R3 - L84*R4
     1                             - L85*R5 - L86*R6 - L87*R7) / L88
            R9        = (R(I,J, 9) - L91*R1 - L92*R2 - L93*R3 - L94*R4
     1                             - L95*R5 - L96*R6 - L97*R7 - L98*R8)
     2                  / L99
            RA        = (R(I,J,10) - LA1*R1 - LA2*R2 - LA3*R3 - LA4*R4
     1                             - LA5*R5 - LA6*R6 - LA7*R7 - LA8*R8
     2                             - LA9*R9) / LAA
            RB        = (R(I,J,11) - LB1*R1 - LB2*R2 - LB3*R3 - LB4*R4
     1                             - LB5*R5 - LB6*R6 - LB7*R7 - LB8*R8
     2                             - LB9*R9 - LBA*RA) / LBB
            R(I,J,12) = (R(I,J,12) - LC1*R1 - LC2*R2 - LC3*R3 - LC4*R4
     1                             - LC5*R5 - LC6*R6 - LC7*R7 - LC8*R8
     2                             - LC9*R9 - LCA*RA - LCB*RB) / LCC
            R(I,J,11) = RB-UBC*R(I,J,12)
            R(I,J,10) = RA-UAC*R(I,J,12)-UAB*R(I,J,11)
            R(I,J, 9) = R9-U9C*R(I,J,12)-U9B*R(I,J,11)-U9A*R(I,J,10)
            R(I,J, 8) = R8-U8C*R(I,J,12)-U8B*R(I,J,11)-U8A*R(I,J,10)
     1                    -U89*R(I,J, 9)
            R(I,J, 7) = R7-U7C*R(I,J,12)-U7B*R(I,J,11)-U7A*R(I,J,10)
     1                    -U79*R(I,J, 9)-U78*R(I,J, 8)
            R(I,J, 6) = R6-U6C*R(I,J,12)-U6B*R(I,J,11)-U6A*R(I,J,10)
     1                    -U69*R(I,J, 9)-U68*R(I,J, 8)-U67*R(I,J, 7)
            R(I,J, 5) = R5-U5C*R(I,J,12)-U5B*R(I,J,11)-U5A*R(I,J,10)
     1                    -U59*R(I,J, 9)-U58*R(I,J, 8)-U57*R(I,J, 7)
     2                    -U56*R(I,J, 6)
            R(I,J, 4) = R4-U4C*R(I,J,12)-U4B*R(I,J,11)-U4A*R(I,J,10)
     1                    -U49*R(I,J, 9)-U48*R(I,J, 8)-U47*R(I,J, 7)
     2                    -U46*R(I,J, 6)-U45*R(I,J, 5)
            R(I,J, 3) = R3-U3C*R(I,J,12)-U3B*R(I,J,11)-U3A*R(I,J,10)
     1                    -U39*R(I,J, 9)-U38*R(I,J, 8)-U37*R(I,J, 7)
     2                    -U36*R(I,J, 6)-U35*R(I,J, 5)-U34*R(I,J, 4)
            R(I,J, 2) = R2-U2C*R(I,J,12)-U2B*R(I,J,11)-U2A*R(I,J,10)
     1                    -U29*R(I,J, 9)-U28*R(I,J, 8)-U27*R(I,J, 7)
     2                    -U26*R(I,J, 6)-U25*R(I,J, 5)-U24*R(I,J, 4)
     3                    -U23*R(I,J, 3)
            R(I,J, 1) = R1-U1C*R(I,J,12)-U1B*R(I,J,11)-U1A*R(I,J,10)
     1                    -U19*R(I,J, 9)-U18*R(I,J, 8)-U17*R(I,J, 7)
     2                    -U16*R(I,J, 6)-U15*R(I,J, 5)-U14*R(I,J, 4)
     3                    -U13*R(I,J, 3)-U12*R(I,J, 2)
C
C     Calculate B(-1) * C
C
C     Column 1
C
            C1           =  C(I,J, 1, 1) / L11
            C2           = (C(I,J, 2, 1)-L21*C1) / L22
            C3           = (C(I,J, 3, 1)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 1)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 1)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 1)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 1)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 1)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 1)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 1)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 1)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 1) = (C(I,J,12, 1)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 1) = CB-UBC*C(I,J,12, 1)
            C(I,J,10, 1) = CA-UAC*C(I,J,12, 1)-UAB*C(I,J,11, 1)
            C(I,J, 9, 1) = C9-U9C*C(I,J,12, 1)-U9B*C(I,J,11, 1)
     1                       -U9A*C(I,J,10, 1)
            C(I,J, 8, 1) = C8-U8C*C(I,J,12, 1)-U8B*C(I,J,11, 1)
     1                       -U8A*C(I,J,10, 1)-U89*C(I,J, 9, 1)
            C(I,J, 7, 1) = C7-U7C*C(I,J,12, 1)-U7B*C(I,J,11, 1)
     1                       -U7A*C(I,J,10, 1)-U79*C(I,J, 9, 1)
     2                       -U78*C(I,J, 8, 1)
            C(I,J, 6, 1) = C6-U6C*C(I,J,12, 1)-U6B*C(I,J,11, 1)
     1                       -U6A*C(I,J,10, 1)-U69*C(I,J, 9, 1)
     2                       -U68*C(I,J, 8, 1)-U67*C(I,J, 7, 1)
            C(I,J, 5, 1) = C5-U5C*C(I,J,12, 1)-U5B*C(I,J,11, 1)
     1                       -U5A*C(I,J,10, 1)-U59*C(I,J, 9, 1)
     2                       -U58*C(I,J, 8, 1)-U57*C(I,J, 7, 1)
     3                       -U56*C(I,J, 6, 1)
            C(I,J, 4, 1) = C4-U4C*C(I,J,12, 1)-U4B*C(I,J,11, 1)
     1                       -U4A*C(I,J,10, 1)-U49*C(I,J, 9, 1)
     2                       -U48*C(I,J, 8, 1)-U47*C(I,J, 7, 1)
     3                       -U46*C(I,J, 6, 1)-U45*C(I,J, 5, 1)
            C(I,J, 3, 1) = C3-U3C*C(I,J,12, 1)-U3B*C(I,J,11, 1)
     1                       -U3A*C(I,J,10, 1)-U39*C(I,J, 9, 1)
     2                       -U38*C(I,J, 8, 1)-U37*C(I,J, 7, 1)
     3                       -U36*C(I,J, 6, 1)-U35*C(I,J, 5, 1)
     4                       -U34*C(I,J, 4, 1)
            C(I,J, 2, 1) = C2-U2C*C(I,J,12, 1)-U2B*C(I,J,11, 1)
     1                       -U2A*C(I,J,10, 1)-U29*C(I,J, 9, 1)
     2                       -U28*C(I,J, 8, 1)-U27*C(I,J, 7, 1)
     3                       -U26*C(I,J, 6, 1)-U25*C(I,J, 5, 1)
     4                       -U24*C(I,J, 4, 1)-U23*C(I,J, 3, 1)
            C(I,J, 1, 1) = C1-U1C*C(I,J,12, 1)-U1B*C(I,J,11, 1)
     1                       -U1A*C(I,J,10, 1)-U19*C(I,J, 9, 1)
     2                       -U18*C(I,J, 8, 1)-U17*C(I,J, 7, 1)
     3                       -U16*C(I,J, 6, 1)-U15*C(I,J, 5, 1)
     4                       -U14*C(I,J, 4, 1)-U13*C(I,J, 3, 1)
     5                       -U12*C(I,J, 2, 1)
C
C     Column 2
C
            C1           =  C(I,J, 1, 2) / L11
            C2           = (C(I,J, 2, 2)-L21*C1) / L22
            C3           = (C(I,J, 3, 2)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 2)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 2)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 2)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 2)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 2)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 2)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 2)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 2)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 2) = (C(I,J,12, 2)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 2) = CB-UBC*C(I,J,12, 2)
            C(I,J,10, 2) = CA-UAC*C(I,J,12, 2)-UAB*C(I,J,11, 2)
            C(I,J, 9, 2) = C9-U9C*C(I,J,12, 2)-U9B*C(I,J,11, 2)
     1                       -U9A*C(I,J,10, 2)
            C(I,J, 8, 2) = C8-U8C*C(I,J,12, 2)-U8B*C(I,J,11, 2)
     1                       -U8A*C(I,J,10, 2)-U89*C(I,J, 9, 2)
            C(I,J, 7, 2) = C7-U7C*C(I,J,12, 2)-U7B*C(I,J,11, 2)
     1                       -U7A*C(I,J,10, 2)-U79*C(I,J, 9, 2)
     2                       -U78*C(I,J, 8, 2)
            C(I,J, 6, 2) = C6-U6C*C(I,J,12, 2)-U6B*C(I,J,11, 2)
     1                       -U6A*C(I,J,10, 2)-U69*C(I,J, 9, 2)
     2                       -U68*C(I,J, 8, 2)-U67*C(I,J, 7, 2)
            C(I,J, 5, 2) = C5-U5C*C(I,J,12, 2)-U5B*C(I,J,11, 2)
     1                       -U5A*C(I,J,10, 2)-U59*C(I,J, 9, 2)
     2                       -U58*C(I,J, 8, 2)-U57*C(I,J, 7, 2)
     3                       -U56*C(I,J, 6, 2)
            C(I,J, 4, 2) = C4-U4C*C(I,J,12, 2)-U4B*C(I,J,11, 2)
     1                       -U4A*C(I,J,10, 2)-U49*C(I,J, 9, 2)
     2                       -U48*C(I,J, 8, 2)-U47*C(I,J, 7, 2)
     3                       -U46*C(I,J, 6, 2)-U45*C(I,J, 5, 2)
            C(I,J, 3, 2) = C3-U3C*C(I,J,12, 2)-U3B*C(I,J,11, 2)
     1                       -U3A*C(I,J,10, 2)-U39*C(I,J, 9, 2)
     2                       -U38*C(I,J, 8, 2)-U37*C(I,J, 7, 2)
     3                       -U36*C(I,J, 6, 2)-U35*C(I,J, 5, 2)
     4                       -U34*C(I,J, 4, 2)
            C(I,J, 2, 2) = C2-U2C*C(I,J,12, 2)-U2B*C(I,J,11, 2)
     1                       -U2A*C(I,J,10, 2)-U29*C(I,J, 9, 2)
     2                       -U28*C(I,J, 8, 2)-U27*C(I,J, 7, 2)
     3                       -U26*C(I,J, 6, 2)-U25*C(I,J, 5, 2)
     4                       -U24*C(I,J, 4, 2)-U23*C(I,J, 3, 2)
            C(I,J, 1, 2) = C1-U1C*C(I,J,12, 2)-U1B*C(I,J,11, 2)
     1                       -U1A*C(I,J,10, 2)-U19*C(I,J, 9, 2)
     2                       -U18*C(I,J, 8, 2)-U17*C(I,J, 7, 2)
     3                       -U16*C(I,J, 6, 2)-U15*C(I,J, 5, 2)
     4                       -U14*C(I,J, 4, 2)-U13*C(I,J, 3, 2)
     5                       -U12*C(I,J, 2, 2)
C
C     Column 3
C
            C1           =  C(I,J, 1, 3) / L11
            C2           = (C(I,J, 2, 3)-L21*C1) / L22
            C3           = (C(I,J, 3, 3)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 3)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 3)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 3)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 3)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 3)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 3)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 3)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 3)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 3) = (C(I,J,12, 3)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 3) = CB-UBC*C(I,J,12, 3)
            C(I,J,10, 3) = CA-UAC*C(I,J,12, 3)-UAB*C(I,J,11, 3)
            C(I,J, 9, 3) = C9-U9C*C(I,J,12, 3)-U9B*C(I,J,11, 3)
     1                       -U9A*C(I,J,10, 3)
            C(I,J, 8, 3) = C8-U8C*C(I,J,12, 3)-U8B*C(I,J,11, 3)
     1                       -U8A*C(I,J,10, 3)-U89*C(I,J, 9, 3)
            C(I,J, 7, 3) = C7-U7C*C(I,J,12, 3)-U7B*C(I,J,11, 3)
     1                       -U7A*C(I,J,10, 3)-U79*C(I,J, 9, 3)
     2                       -U78*C(I,J, 8, 3)
            C(I,J, 6, 3) = C6-U6C*C(I,J,12, 3)-U6B*C(I,J,11, 3)
     1                       -U6A*C(I,J,10, 3)-U69*C(I,J, 9, 3)
     2                       -U68*C(I,J, 8, 3)-U67*C(I,J, 7, 3)
            C(I,J, 5, 3) = C5-U5C*C(I,J,12, 3)-U5B*C(I,J,11, 3)
     1                       -U5A*C(I,J,10, 3)-U59*C(I,J, 9, 3)
     2                       -U58*C(I,J, 8, 3)-U57*C(I,J, 7, 3)
     3                       -U56*C(I,J, 6, 3)
            C(I,J, 4, 3) = C4-U4C*C(I,J,12, 3)-U4B*C(I,J,11, 3)
     1                       -U4A*C(I,J,10, 3)-U49*C(I,J, 9, 3)
     2                       -U48*C(I,J, 8, 3)-U47*C(I,J, 7, 3)
     3                       -U46*C(I,J, 6, 3)-U45*C(I,J, 5, 3)
            C(I,J, 3, 3) = C3-U3C*C(I,J,12, 3)-U3B*C(I,J,11, 3)
     1                       -U3A*C(I,J,10, 3)-U39*C(I,J, 9, 3)
     2                       -U38*C(I,J, 8, 3)-U37*C(I,J, 7, 3)
     3                       -U36*C(I,J, 6, 3)-U35*C(I,J, 5, 3)
     4                       -U34*C(I,J, 4, 3)
            C(I,J, 2, 3) = C2-U2C*C(I,J,12, 3)-U2B*C(I,J,11, 3)
     1                       -U2A*C(I,J,10, 3)-U29*C(I,J, 9, 3)
     2                       -U28*C(I,J, 8, 3)-U27*C(I,J, 7, 3)
     3                       -U26*C(I,J, 6, 3)-U25*C(I,J, 5, 3)
     4                       -U24*C(I,J, 4, 3)-U23*C(I,J, 3, 3)
            C(I,J, 1, 3) = C1-U1C*C(I,J,12, 3)-U1B*C(I,J,11, 3)
     1                       -U1A*C(I,J,10, 3)-U19*C(I,J, 9, 3)
     2                       -U18*C(I,J, 8, 3)-U17*C(I,J, 7, 3)
     3                       -U16*C(I,J, 6, 3)-U15*C(I,J, 5, 3)
     4                       -U14*C(I,J, 4, 3)-U13*C(I,J, 3, 3)
     5                       -U12*C(I,J, 2, 3)
C
C     Column 4
C
            C1           =  C(I,J, 1, 4) / L11
            C2           = (C(I,J, 2, 4)-L21*C1) / L22
            C3           = (C(I,J, 3, 4)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 4)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 4)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 4)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 4)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 4)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 4)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 4)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 4)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 4) = (C(I,J,12, 4)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 4) = CB-UBC*C(I,J,12, 4)
            C(I,J,10, 4) = CA-UAC*C(I,J,12, 4)-UAB*C(I,J,11, 4)
            C(I,J, 9, 4) = C9-U9C*C(I,J,12, 4)-U9B*C(I,J,11, 4)
     1                       -U9A*C(I,J,10, 4)
            C(I,J, 8, 4) = C8-U8C*C(I,J,12, 4)-U8B*C(I,J,11, 4)
     1                       -U8A*C(I,J,10, 4)-U89*C(I,J, 9, 4)
            C(I,J, 7, 4) = C7-U7C*C(I,J,12, 4)-U7B*C(I,J,11, 4)
     1                       -U7A*C(I,J,10, 4)-U79*C(I,J, 9, 4)
     2                       -U78*C(I,J, 8, 4)
            C(I,J, 6, 4) = C6-U6C*C(I,J,12, 4)-U6B*C(I,J,11, 4)
     1                       -U6A*C(I,J,10, 4)-U69*C(I,J, 9, 4)
     2                       -U68*C(I,J, 8, 4)-U67*C(I,J, 7, 4)
            C(I,J, 5, 4) = C5-U5C*C(I,J,12, 4)-U5B*C(I,J,11, 4)
     1                       -U5A*C(I,J,10, 4)-U59*C(I,J, 9, 4)
     2                       -U58*C(I,J, 8, 4)-U57*C(I,J, 7, 4)
     3                       -U56*C(I,J, 6, 4)
            C(I,J, 4, 4) = C4-U4C*C(I,J,12, 4)-U4B*C(I,J,11, 4)
     1                       -U4A*C(I,J,10, 4)-U49*C(I,J, 9, 4)
     2                       -U48*C(I,J, 8, 4)-U47*C(I,J, 7, 4)
     3                       -U46*C(I,J, 6, 4)-U45*C(I,J, 5, 4)
            C(I,J, 3, 4) = C3-U3C*C(I,J,12, 4)-U3B*C(I,J,11, 4)
     1                       -U3A*C(I,J,10, 4)-U39*C(I,J, 9, 4)
     2                       -U38*C(I,J, 8, 4)-U37*C(I,J, 7, 4)
     3                       -U36*C(I,J, 6, 4)-U35*C(I,J, 5, 4)
     4                       -U34*C(I,J, 4, 4)
            C(I,J, 2, 4) = C2-U2C*C(I,J,12, 4)-U2B*C(I,J,11, 4)
     1                       -U2A*C(I,J,10, 4)-U29*C(I,J, 9, 4)
     2                       -U28*C(I,J, 8, 4)-U27*C(I,J, 7, 4)
     3                       -U26*C(I,J, 6, 4)-U25*C(I,J, 5, 4)
     4                       -U24*C(I,J, 4, 4)-U23*C(I,J, 3, 4)
            C(I,J, 1, 4) = C1-U1C*C(I,J,12, 4)-U1B*C(I,J,11, 4)
     1                       -U1A*C(I,J,10, 4)-U19*C(I,J, 9, 4)
     2                       -U18*C(I,J, 8, 4)-U17*C(I,J, 7, 4)
     3                       -U16*C(I,J, 6, 4)-U15*C(I,J, 5, 4)
     4                       -U14*C(I,J, 4, 4)-U13*C(I,J, 3, 4)
     5                       -U12*C(I,J, 2, 4)
C
C     Column 5
C
            C1           =  C(I,J, 1, 5) / L11
            C2           = (C(I,J, 2, 5)-L21*C1) / L22
            C3           = (C(I,J, 3, 5)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 5)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 5)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 5)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 5)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 5)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 5)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 5)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 5)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 5) = (C(I,J,12, 5)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 5) = CB-UBC*C(I,J,12, 5)
            C(I,J,10, 5) = CA-UAC*C(I,J,12, 5)-UAB*C(I,J,11, 5)
            C(I,J, 9, 5) = C9-U9C*C(I,J,12, 5)-U9B*C(I,J,11, 5)
     1                       -U9A*C(I,J,10, 5)
            C(I,J, 8, 5) = C8-U8C*C(I,J,12, 5)-U8B*C(I,J,11, 5)
     1                       -U8A*C(I,J,10, 5)-U89*C(I,J, 9, 5)
            C(I,J, 7, 5) = C7-U7C*C(I,J,12, 5)-U7B*C(I,J,11, 5)
     1                       -U7A*C(I,J,10, 5)-U79*C(I,J, 9, 5)
     2                       -U78*C(I,J, 8, 5)
            C(I,J, 6, 5) = C6-U6C*C(I,J,12, 5)-U6B*C(I,J,11, 5)
     1                       -U6A*C(I,J,10, 5)-U69*C(I,J, 9, 5)
     2                       -U68*C(I,J, 8, 5)-U67*C(I,J, 7, 5)
            C(I,J, 5, 5) = C5-U5C*C(I,J,12, 5)-U5B*C(I,J,11, 5)
     1                       -U5A*C(I,J,10, 5)-U59*C(I,J, 9, 5)
     2                       -U58*C(I,J, 8, 5)-U57*C(I,J, 7, 5)
     3                       -U56*C(I,J, 6, 5)
            C(I,J, 4, 5) = C4-U4C*C(I,J,12, 5)-U4B*C(I,J,11, 5)
     1                       -U4A*C(I,J,10, 5)-U49*C(I,J, 9, 5)
     2                       -U48*C(I,J, 8, 5)-U47*C(I,J, 7, 5)
     3                       -U46*C(I,J, 6, 5)-U45*C(I,J, 5, 5)
            C(I,J, 3, 5) = C3-U3C*C(I,J,12, 5)-U3B*C(I,J,11, 5)
     1                       -U3A*C(I,J,10, 5)-U39*C(I,J, 9, 5)
     2                       -U38*C(I,J, 8, 5)-U37*C(I,J, 7, 5)
     3                       -U36*C(I,J, 6, 5)-U35*C(I,J, 5, 5)
     4                       -U34*C(I,J, 4, 5)
            C(I,J, 2, 5) = C2-U2C*C(I,J,12, 5)-U2B*C(I,J,11, 5)
     1                       -U2A*C(I,J,10, 5)-U29*C(I,J, 9, 5)
     2                       -U28*C(I,J, 8, 5)-U27*C(I,J, 7, 5)
     3                       -U26*C(I,J, 6, 5)-U25*C(I,J, 5, 5)
     4                       -U24*C(I,J, 4, 5)-U23*C(I,J, 3, 5)
            C(I,J, 1, 5) = C1-U1C*C(I,J,12, 5)-U1B*C(I,J,11, 5)
     1                       -U1A*C(I,J,10, 5)-U19*C(I,J, 9, 5)
     2                       -U18*C(I,J, 8, 5)-U17*C(I,J, 7, 5)
     3                       -U16*C(I,J, 6, 5)-U15*C(I,J, 5, 5)
     4                       -U14*C(I,J, 4, 5)-U13*C(I,J, 3, 5)
     5                       -U12*C(I,J, 2, 5)
C
C     Column 6
C
            C1           =  C(I,J, 1, 6) / L11
            C2           = (C(I,J, 2, 6)-L21*C1) / L22
            C3           = (C(I,J, 3, 6)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 6)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 6)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 6)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 6)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 6)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 6)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 6)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 6)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 6) = (C(I,J,12, 6)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 6) = CB-UBC*C(I,J,12, 6)
            C(I,J,10, 6) = CA-UAC*C(I,J,12, 6)-UAB*C(I,J,11, 6)
            C(I,J, 9, 6) = C9-U9C*C(I,J,12, 6)-U9B*C(I,J,11, 6)
     1                       -U9A*C(I,J,10, 6)
            C(I,J, 8, 6) = C8-U8C*C(I,J,12, 6)-U8B*C(I,J,11, 6)
     1                       -U8A*C(I,J,10, 6)-U89*C(I,J, 9, 6)
            C(I,J, 7, 6) = C7-U7C*C(I,J,12, 6)-U7B*C(I,J,11, 6)
     1                       -U7A*C(I,J,10, 6)-U79*C(I,J, 9, 6)
     2                       -U78*C(I,J, 8, 6)
            C(I,J, 6, 6) = C6-U6C*C(I,J,12, 6)-U6B*C(I,J,11, 6)
     1                       -U6A*C(I,J,10, 6)-U69*C(I,J, 9, 6)
     2                       -U68*C(I,J, 8, 6)-U67*C(I,J, 7, 6)
            C(I,J, 5, 6) = C5-U5C*C(I,J,12, 6)-U5B*C(I,J,11, 6)
     1                       -U5A*C(I,J,10, 6)-U59*C(I,J, 9, 6)
     2                       -U58*C(I,J, 8, 6)-U57*C(I,J, 7, 6)
     3                       -U56*C(I,J, 6, 6)
            C(I,J, 4, 6) = C4-U4C*C(I,J,12, 6)-U4B*C(I,J,11, 6)
     1                       -U4A*C(I,J,10, 6)-U49*C(I,J, 9, 6)
     2                       -U48*C(I,J, 8, 6)-U47*C(I,J, 7, 6)
     3                       -U46*C(I,J, 6, 6)-U45*C(I,J, 5, 6)
            C(I,J, 3, 6) = C3-U3C*C(I,J,12, 6)-U3B*C(I,J,11, 6)
     1                       -U3A*C(I,J,10, 6)-U39*C(I,J, 9, 6)
     2                       -U38*C(I,J, 8, 6)-U37*C(I,J, 7, 6)
     3                       -U36*C(I,J, 6, 6)-U35*C(I,J, 5, 6)
     4                       -U34*C(I,J, 4, 6)
            C(I,J, 2, 6) = C2-U2C*C(I,J,12, 6)-U2B*C(I,J,11, 6)
     1                       -U2A*C(I,J,10, 6)-U29*C(I,J, 9, 6)
     2                       -U28*C(I,J, 8, 6)-U27*C(I,J, 7, 6)
     3                       -U26*C(I,J, 6, 6)-U25*C(I,J, 5, 6)
     4                       -U24*C(I,J, 4, 6)-U23*C(I,J, 3, 6)
            C(I,J, 1, 6) = C1-U1C*C(I,J,12, 6)-U1B*C(I,J,11, 6)
     1                       -U1A*C(I,J,10, 6)-U19*C(I,J, 9, 6)
     2                       -U18*C(I,J, 8, 6)-U17*C(I,J, 7, 6)
     3                       -U16*C(I,J, 6, 6)-U15*C(I,J, 5, 6)
     4                       -U14*C(I,J, 4, 6)-U13*C(I,J, 3, 6)
     5                       -U12*C(I,J, 2, 6)
C
C     Column 7
C
            C1           =  C(I,J, 1, 7) / L11
            C2           = (C(I,J, 2, 7)-L21*C1) / L22
            C3           = (C(I,J, 3, 7)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 7)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 7)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 7)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 7)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 7)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 7)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 7)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 7)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 7) = (C(I,J,12, 7)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 7) = CB-UBC*C(I,J,12, 7)
            C(I,J,10, 7) = CA-UAC*C(I,J,12, 7)-UAB*C(I,J,11, 7)
            C(I,J, 9, 7) = C9-U9C*C(I,J,12, 7)-U9B*C(I,J,11, 7)
     1                       -U9A*C(I,J,10, 7)
            C(I,J, 8, 7) = C8-U8C*C(I,J,12, 7)-U8B*C(I,J,11, 7)
     1                       -U8A*C(I,J,10, 7)-U89*C(I,J, 9, 7)
            C(I,J, 7, 7) = C7-U7C*C(I,J,12, 7)-U7B*C(I,J,11, 7)
     1                       -U7A*C(I,J,10, 7)-U79*C(I,J, 9, 7)
     2                       -U78*C(I,J, 8, 7)
            C(I,J, 6, 7) = C6-U6C*C(I,J,12, 7)-U6B*C(I,J,11, 7)
     1                       -U6A*C(I,J,10, 7)-U69*C(I,J, 9, 7)
     2                       -U68*C(I,J, 8, 7)-U67*C(I,J, 7, 7)
            C(I,J, 5, 7) = C5-U5C*C(I,J,12, 7)-U5B*C(I,J,11, 7)
     1                       -U5A*C(I,J,10, 7)-U59*C(I,J, 9, 7)
     2                       -U58*C(I,J, 8, 7)-U57*C(I,J, 7, 7)
     3                       -U56*C(I,J, 6, 7)
            C(I,J, 4, 7) = C4-U4C*C(I,J,12, 7)-U4B*C(I,J,11, 7)
     1                       -U4A*C(I,J,10, 7)-U49*C(I,J, 9, 7)
     2                       -U48*C(I,J, 8, 7)-U47*C(I,J, 7, 7)
     3                       -U46*C(I,J, 6, 7)-U45*C(I,J, 5, 7)
            C(I,J, 3, 7) = C3-U3C*C(I,J,12, 7)-U3B*C(I,J,11, 7)
     1                       -U3A*C(I,J,10, 7)-U39*C(I,J, 9, 7)
     2                       -U38*C(I,J, 8, 7)-U37*C(I,J, 7, 7)
     3                       -U36*C(I,J, 6, 7)-U35*C(I,J, 5, 7)
     4                       -U34*C(I,J, 4, 7)
            C(I,J, 2, 7) = C2-U2C*C(I,J,12, 7)-U2B*C(I,J,11, 7)
     1                       -U2A*C(I,J,10, 7)-U29*C(I,J, 9, 7)
     2                       -U28*C(I,J, 8, 7)-U27*C(I,J, 7, 7)
     3                       -U26*C(I,J, 6, 7)-U25*C(I,J, 5, 7)
     4                       -U24*C(I,J, 4, 7)-U23*C(I,J, 3, 7)
            C(I,J, 1, 7) = C1-U1C*C(I,J,12, 7)-U1B*C(I,J,11, 7)
     1                       -U1A*C(I,J,10, 7)-U19*C(I,J, 9, 7)
     2                       -U18*C(I,J, 8, 7)-U17*C(I,J, 7, 7)
     3                       -U16*C(I,J, 6, 7)-U15*C(I,J, 5, 7)
     4                       -U14*C(I,J, 4, 7)-U13*C(I,J, 3, 7)
     5                       -U12*C(I,J, 2, 7)
C
C     Column 8
C
            C1           =  C(I,J, 1, 8) / L11
            C2           = (C(I,J, 2, 8)-L21*C1) / L22
            C3           = (C(I,J, 3, 8)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 8)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 8)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 8)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 8)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 8)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 8)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 8)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 8)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 8) = (C(I,J,12, 8)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 8) = CB-UBC*C(I,J,12, 8)
            C(I,J,10, 8) = CA-UAC*C(I,J,12, 8)-UAB*C(I,J,11, 8)
            C(I,J, 9, 8) = C9-U9C*C(I,J,12, 8)-U9B*C(I,J,11, 8)
     1                       -U9A*C(I,J,10, 8)
            C(I,J, 8, 8) = C8-U8C*C(I,J,12, 8)-U8B*C(I,J,11, 8)
     1                       -U8A*C(I,J,10, 8)-U89*C(I,J, 9, 8)
            C(I,J, 7, 8) = C7-U7C*C(I,J,12, 8)-U7B*C(I,J,11, 8)
     1                       -U7A*C(I,J,10, 8)-U79*C(I,J, 9, 8)
     2                       -U78*C(I,J, 8, 8)
            C(I,J, 6, 8) = C6-U6C*C(I,J,12, 8)-U6B*C(I,J,11, 8)
     1                       -U6A*C(I,J,10, 8)-U69*C(I,J, 9, 8)
     2                       -U68*C(I,J, 8, 8)-U67*C(I,J, 7, 8)
            C(I,J, 5, 8) = C5-U5C*C(I,J,12, 8)-U5B*C(I,J,11, 8)
     1                       -U5A*C(I,J,10, 8)-U59*C(I,J, 9, 8)
     2                       -U58*C(I,J, 8, 8)-U57*C(I,J, 7, 8)
     3                       -U56*C(I,J, 6, 8)
            C(I,J, 4, 8) = C4-U4C*C(I,J,12, 8)-U4B*C(I,J,11, 8)
     1                       -U4A*C(I,J,10, 8)-U49*C(I,J, 9, 8)
     2                       -U48*C(I,J, 8, 8)-U47*C(I,J, 7, 8)
     3                       -U46*C(I,J, 6, 8)-U45*C(I,J, 5, 8)
            C(I,J, 3, 8) = C3-U3C*C(I,J,12, 8)-U3B*C(I,J,11, 8)
     1                       -U3A*C(I,J,10, 8)-U39*C(I,J, 9, 8)
     2                       -U38*C(I,J, 8, 8)-U37*C(I,J, 7, 8)
     3                       -U36*C(I,J, 6, 8)-U35*C(I,J, 5, 8)
     4                       -U34*C(I,J, 4, 8)
            C(I,J, 2, 8) = C2-U2C*C(I,J,12, 8)-U2B*C(I,J,11, 8)
     1                       -U2A*C(I,J,10, 8)-U29*C(I,J, 9, 8)
     2                       -U28*C(I,J, 8, 8)-U27*C(I,J, 7, 8)
     3                       -U26*C(I,J, 6, 8)-U25*C(I,J, 5, 8)
     4                       -U24*C(I,J, 4, 8)-U23*C(I,J, 3, 8)
            C(I,J, 1, 8) = C1-U1C*C(I,J,12, 8)-U1B*C(I,J,11, 8)
     1                       -U1A*C(I,J,10, 8)-U19*C(I,J, 9, 8)
     2                       -U18*C(I,J, 8, 8)-U17*C(I,J, 7, 8)
     3                       -U16*C(I,J, 6, 8)-U15*C(I,J, 5, 8)
     4                       -U14*C(I,J, 4, 8)-U13*C(I,J, 3, 8)
     5                       -U12*C(I,J, 2, 8)
C
C     Column 9
C
            C1           =  C(I,J, 1, 9) / L11
            C2           = (C(I,J, 2, 9)-L21*C1) / L22
            C3           = (C(I,J, 3, 9)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4, 9)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5, 9)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6, 9)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7, 9)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8, 9)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9, 9)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10, 9)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11, 9)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12, 9) = (C(I,J,12, 9)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11, 9) = CB-UBC*C(I,J,12, 9)
            C(I,J,10, 9) = CA-UAC*C(I,J,12, 9)-UAB*C(I,J,11, 9)
            C(I,J, 9, 9) = C9-U9C*C(I,J,12, 9)-U9B*C(I,J,11, 9)
     1                       -U9A*C(I,J,10, 9)
            C(I,J, 8, 9) = C8-U8C*C(I,J,12, 9)-U8B*C(I,J,11, 9)
     1                       -U8A*C(I,J,10, 9)-U89*C(I,J, 9, 9)
            C(I,J, 7, 9) = C7-U7C*C(I,J,12, 9)-U7B*C(I,J,11, 9)
     1                       -U7A*C(I,J,10, 9)-U79*C(I,J, 9, 9)
     2                       -U78*C(I,J, 8, 9)
            C(I,J, 6, 9) = C6-U6C*C(I,J,12, 9)-U6B*C(I,J,11, 9)
     1                       -U6A*C(I,J,10, 9)-U69*C(I,J, 9, 9)
     2                       -U68*C(I,J, 8, 9)-U67*C(I,J, 7, 9)
            C(I,J, 5, 9) = C5-U5C*C(I,J,12, 9)-U5B*C(I,J,11, 9)
     1                       -U5A*C(I,J,10, 9)-U59*C(I,J, 9, 9)
     2                       -U58*C(I,J, 8, 9)-U57*C(I,J, 7, 9)
     3                       -U56*C(I,J, 6, 9)
            C(I,J, 4, 9) = C4-U4C*C(I,J,12, 9)-U4B*C(I,J,11, 9)
     1                       -U4A*C(I,J,10, 9)-U49*C(I,J, 9, 9)
     2                       -U48*C(I,J, 8, 9)-U47*C(I,J, 7, 9)
     3                       -U46*C(I,J, 6, 9)-U45*C(I,J, 5, 9)
            C(I,J, 3, 9) = C3-U3C*C(I,J,12, 9)-U3B*C(I,J,11, 9)
     1                       -U3A*C(I,J,10, 9)-U39*C(I,J, 9, 9)
     2                       -U38*C(I,J, 8, 9)-U37*C(I,J, 7, 9)
     3                       -U36*C(I,J, 6, 9)-U35*C(I,J, 5, 9)
     4                       -U34*C(I,J, 4, 9)
            C(I,J, 2, 9) = C2-U2C*C(I,J,12, 9)-U2B*C(I,J,11, 9)
     1                       -U2A*C(I,J,10, 9)-U29*C(I,J, 9, 9)
     2                       -U28*C(I,J, 8, 9)-U27*C(I,J, 7, 9)
     3                       -U26*C(I,J, 6, 9)-U25*C(I,J, 5, 9)
     4                       -U24*C(I,J, 4, 9)-U23*C(I,J, 3, 9)
            C(I,J, 1, 9) = C1-U1C*C(I,J,12, 9)-U1B*C(I,J,11, 9)
     1                       -U1A*C(I,J,10, 9)-U19*C(I,J, 9, 9)
     2                       -U18*C(I,J, 8, 9)-U17*C(I,J, 7, 9)
     3                       -U16*C(I,J, 6, 9)-U15*C(I,J, 5, 9)
     4                       -U14*C(I,J, 4, 9)-U13*C(I,J, 3, 9)
     5                       -U12*C(I,J, 2, 9)
C
C     Column 10
C
            C1           =  C(I,J, 1,10) / L11
            C2           = (C(I,J, 2,10)-L21*C1) / L22
            C3           = (C(I,J, 3,10)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4,10)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5,10)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6,10)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7,10)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8,10)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9,10)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10,10)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11,10)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12,10) = (C(I,J,12,10)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11,10) = CB-UBC*C(I,J,12,10)
            C(I,J,10,10) = CA-UAC*C(I,J,12,10)-UAB*C(I,J,11,10)
            C(I,J, 9,10) = C9-U9C*C(I,J,12,10)-U9B*C(I,J,11,10)
     1                       -U9A*C(I,J,10,10)
            C(I,J, 8,10) = C8-U8C*C(I,J,12,10)-U8B*C(I,J,11,10)
     1                       -U8A*C(I,J,10,10)-U89*C(I,J, 9,10)
            C(I,J, 7,10) = C7-U7C*C(I,J,12,10)-U7B*C(I,J,11,10)
     1                       -U7A*C(I,J,10,10)-U79*C(I,J, 9,10)
     2                       -U78*C(I,J, 8,10)
            C(I,J, 6,10) = C6-U6C*C(I,J,12,10)-U6B*C(I,J,11,10)
     1                       -U6A*C(I,J,10,10)-U69*C(I,J, 9,10)
     2                       -U68*C(I,J, 8,10)-U67*C(I,J, 7,10)
            C(I,J, 5,10) = C5-U5C*C(I,J,12,10)-U5B*C(I,J,11,10)
     1                       -U5A*C(I,J,10,10)-U59*C(I,J, 9,10)
     2                       -U58*C(I,J, 8,10)-U57*C(I,J, 7,10)
     3                       -U56*C(I,J, 6,10)
            C(I,J, 4,10) = C4-U4C*C(I,J,12,10)-U4B*C(I,J,11,10)
     1                       -U4A*C(I,J,10,10)-U49*C(I,J, 9,10)
     2                       -U48*C(I,J, 8,10)-U47*C(I,J, 7,10)
     3                       -U46*C(I,J, 6,10)-U45*C(I,J, 5,10)
            C(I,J, 3,10) = C3-U3C*C(I,J,12,10)-U3B*C(I,J,11,10)
     1                       -U3A*C(I,J,10,10)-U39*C(I,J, 9,10)
     2                       -U38*C(I,J, 8,10)-U37*C(I,J, 7,10)
     3                       -U36*C(I,J, 6,10)-U35*C(I,J, 5,10)
     4                       -U34*C(I,J, 4,10)
            C(I,J, 2,10) = C2-U2C*C(I,J,12,10)-U2B*C(I,J,11,10)
     1                       -U2A*C(I,J,10,10)-U29*C(I,J, 9,10)
     2                       -U28*C(I,J, 8,10)-U27*C(I,J, 7,10)
     3                       -U26*C(I,J, 6,10)-U25*C(I,J, 5,10)
     4                       -U24*C(I,J, 4,10)-U23*C(I,J, 3,10)
            C(I,J, 1,10) = C1-U1C*C(I,J,12,10)-U1B*C(I,J,11,10)
     1                       -U1A*C(I,J,10,10)-U19*C(I,J, 9,10)
     2                       -U18*C(I,J, 8,10)-U17*C(I,J, 7,10)
     3                       -U16*C(I,J, 6,10)-U15*C(I,J, 5,10)
     4                       -U14*C(I,J, 4,10)-U13*C(I,J, 3,10)
     5                       -U12*C(I,J, 2,10)
C
C     Column 11
C
            C1           =  C(I,J, 1,11) / L11
            C2           = (C(I,J, 2,11)-L21*C1) / L22
            C3           = (C(I,J, 3,11)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4,11)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5,11)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6,11)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7,11)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8,11)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9,11)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10,11)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11,11)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12,11) = (C(I,J,12,11)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11,11) = CB-UBC*C(I,J,12,11)
            C(I,J,10,11) = CA-UAC*C(I,J,12,11)-UAB*C(I,J,11,11)
            C(I,J, 9,11) = C9-U9C*C(I,J,12,11)-U9B*C(I,J,11,11)
     1                       -U9A*C(I,J,10,11)
            C(I,J, 8,11) = C8-U8C*C(I,J,12,11)-U8B*C(I,J,11,11)
     1                       -U8A*C(I,J,10,11)-U89*C(I,J, 9,11)
            C(I,J, 7,11) = C7-U7C*C(I,J,12,11)-U7B*C(I,J,11,11)
     1                       -U7A*C(I,J,10,11)-U79*C(I,J, 9,11)
     2                       -U78*C(I,J, 8,11)
            C(I,J, 6,11) = C6-U6C*C(I,J,12,11)-U6B*C(I,J,11,11)
     1                       -U6A*C(I,J,10,11)-U69*C(I,J, 9,11)
     2                       -U68*C(I,J, 8,11)-U67*C(I,J, 7,11)
            C(I,J, 5,11) = C5-U5C*C(I,J,12,11)-U5B*C(I,J,11,11)
     1                       -U5A*C(I,J,10,11)-U59*C(I,J, 9,11)
     2                       -U58*C(I,J, 8,11)-U57*C(I,J, 7,11)
     3                       -U56*C(I,J, 6,11)
            C(I,J, 4,11) = C4-U4C*C(I,J,12,11)-U4B*C(I,J,11,11)
     1                       -U4A*C(I,J,10,11)-U49*C(I,J, 9,11)
     2                       -U48*C(I,J, 8,11)-U47*C(I,J, 7,11)
     3                       -U46*C(I,J, 6,11)-U45*C(I,J, 5,11)
            C(I,J, 3,11) = C3-U3C*C(I,J,12,11)-U3B*C(I,J,11,11)
     1                       -U3A*C(I,J,10,11)-U39*C(I,J, 9,11)
     2                       -U38*C(I,J, 8,11)-U37*C(I,J, 7,11)
     3                       -U36*C(I,J, 6,11)-U35*C(I,J, 5,11)
     4                       -U34*C(I,J, 4,11)
            C(I,J, 2,11) = C2-U2C*C(I,J,12,11)-U2B*C(I,J,11,11)
     1                       -U2A*C(I,J,10,11)-U29*C(I,J, 9,11)
     2                       -U28*C(I,J, 8,11)-U27*C(I,J, 7,11)
     3                       -U26*C(I,J, 6,11)-U25*C(I,J, 5,11)
     4                       -U24*C(I,J, 4,11)-U23*C(I,J, 3,11)
            C(I,J, 1,11) = C1-U1C*C(I,J,12,11)-U1B*C(I,J,11,11)
     1                       -U1A*C(I,J,10,11)-U19*C(I,J, 9,11)
     2                       -U18*C(I,J, 8,11)-U17*C(I,J, 7,11)
     3                       -U16*C(I,J, 6,11)-U15*C(I,J, 5,11)
     4                       -U14*C(I,J, 4,11)-U13*C(I,J, 3,11)
     5                       -U12*C(I,J, 2,11)
C
C     Column 12
C
            C1           =  C(I,J, 1,12) / L11
            C2           = (C(I,J, 2,12)-L21*C1) / L22
            C3           = (C(I,J, 3,12)-L31*C1-L32*C2) / L33
            C4           = (C(I,J, 4,12)-L41*C1-L42*C2-L43*C3) / L44
            C5           = (C(I,J, 5,12)-L51*C1-L52*C2-L53*C3-L54*C4)
     1                     / L55
            C6           = (C(I,J, 6,12)-L61*C1-L62*C2-L63*C3-L64*C4
     1                                  -L65*C5) / L66
            C7           = (C(I,J, 7,12)-L71*C1-L72*C2-L73*C3-L74*C4
     1                                  -L75*C5-L76*C6) / L77
            C8           = (C(I,J, 8,12)-L81*C1-L82*C2-L83*C3-L84*C4
     1                                  -L85*C5-L86*C6-L87*C7) / L88
            C9           = (C(I,J, 9,12)-L91*C1-L92*C2-L93*C3-L94*C4
     1                                  -L95*C5-L96*C6-L97*C7-L98*C8)
     2                     / L99
            CA           = (C(I,J,10,12)-LA1*C1-LA2*C2-LA3*C3-LA4*C4
     1                                  -LA5*C5-LA6*C6-LA7*C7-LA8*C8
     2                                  -LA9*C9) / LAA
            CB           = (C(I,J,11,12)-LB1*C1-LB2*C2-LB3*C3-LB4*C4
     1                                  -LB5*C5-LB6*C6-LB7*C7-LB8*C8
     2                                  -LB9*C9-LBA*CA) / LBB
            C(I,J,12,12) = (C(I,J,12,12)-LC1*C1-LC2*C2-LC3*C3-LC4*C4
     1                                  -LC5*C5-LC6*C6-LC7*C7-LC8*C8
     2                                  -LC9*C9-LCA*CA-LCB*CB) / LCC
            C(I,J,11,12) = CB-UBC*C(I,J,12,12)
            C(I,J,10,12) = CA-UAC*C(I,J,12,12)-UAB*C(I,J,11,12)
            C(I,J, 9,12) = C9-U9C*C(I,J,12,12)-U9B*C(I,J,11,12)
     1                       -U9A*C(I,J,10,12)
            C(I,J, 8,12) = C8-U8C*C(I,J,12,12)-U8B*C(I,J,11,12)
     1                       -U8A*C(I,J,10,12)-U89*C(I,J, 9,12)
            C(I,J, 7,12) = C7-U7C*C(I,J,12,12)-U7B*C(I,J,11,12)
     1                       -U7A*C(I,J,10,12)-U79*C(I,J, 9,12)
     2                       -U78*C(I,J, 8,12)
            C(I,J, 6,12) = C6-U6C*C(I,J,12,12)-U6B*C(I,J,11,12)
     1                       -U6A*C(I,J,10,12)-U69*C(I,J, 9,12)
     2                       -U68*C(I,J, 8,12)-U67*C(I,J, 7,12)
            C(I,J, 5,12) = C5-U5C*C(I,J,12,12)-U5B*C(I,J,11,12)
     1                       -U5A*C(I,J,10,12)-U59*C(I,J, 9,12)
     2                       -U58*C(I,J, 8,12)-U57*C(I,J, 7,12)
     3                       -U56*C(I,J, 6,12)
            C(I,J, 4,12) = C4-U4C*C(I,J,12,12)-U4B*C(I,J,11,12)
     1                       -U4A*C(I,J,10,12)-U49*C(I,J, 9,12)
     2                       -U48*C(I,J, 8,12)-U47*C(I,J, 7,12)
     3                       -U46*C(I,J, 6,12)-U45*C(I,J, 5,12)
            C(I,J, 3,12) = C3-U3C*C(I,J,12,12)-U3B*C(I,J,11,12)
     1                       -U3A*C(I,J,10,12)-U39*C(I,J, 9,12)
     2                       -U38*C(I,J, 8,12)-U37*C(I,J, 7,12)
     3                       -U36*C(I,J, 6,12)-U35*C(I,J, 5,12)
     4                       -U34*C(I,J, 4,12)
            C(I,J, 2,12) = C2-U2C*C(I,J,12,12)-U2B*C(I,J,11,12)
     1                       -U2A*C(I,J,10,12)-U29*C(I,J, 9,12)
     2                       -U28*C(I,J, 8,12)-U27*C(I,J, 7,12)
     3                       -U26*C(I,J, 6,12)-U25*C(I,J, 5,12)
     4                       -U24*C(I,J, 4,12)-U23*C(I,J, 3,12)
            C(I,J, 1,12) = C1-U1C*C(I,J,12,12)-U1B*C(I,J,11,12)
     1                       -U1A*C(I,J,10,12)-U19*C(I,J, 9,12)
     2                       -U18*C(I,J, 8,12)-U17*C(I,J, 7,12)
     3                       -U16*C(I,J, 6,12)-U15*C(I,J, 5,12)
     4                       -U14*C(I,J, 4,12)-U13*C(I,J, 3,12)
     5                       -U12*C(I,J, 2,12)
C
  190    CONTINUE
  200 CONTINUE
C
C     J = NPTS Elimination
C     Do not do this loop if NPTS = 1
C
C     Eliminate A
C
C     B = B - A*C(j-1)
C
      J = NPTS
      IF (NPTS .GT. 1) THEN
         DO 260 L = 1, 12
            DO 240 M = 1, 12
               DO 230 I = 1, NSIM
                  B(I,J,L,M) = B(I,J,L,M)
     1                       - A(I,J,L, 1)*C(I,J-1, 1,M)
     2                       - A(I,J,L, 2)*C(I,J-1, 2,M)
     3                       - A(I,J,L, 3)*C(I,J-1, 3,M)
     4                       - A(I,J,L, 4)*C(I,J-1, 4,M)
     5                       - A(I,J,L, 5)*C(I,J-1, 5,M)
     6                       - A(I,J,L, 6)*C(I,J-1, 6,M)
     7                       - A(I,J,L, 7)*C(I,J-1, 7,M)
     8                       - A(I,J,L, 8)*C(I,J-1, 8,M)
     9                       - A(I,J,L, 9)*C(I,J-1, 9,M)
     A                       - A(I,J,L,10)*C(I,J-1,10,M)
     B                       - A(I,J,L,11)*C(I,J-1,11,M)
     C                       - A(I,J,L,12)*C(I,J-1,12,M)
  230          CONTINUE
  240       CONTINUE
C
C     R = R - A*R(j-1)
C
            DO 250 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - A(I,J,L, 1)*R(I,J-1, 1)
     2                  - A(I,J,L, 2)*R(I,J-1, 2)
     3                  - A(I,J,L, 3)*R(I,J-1, 3)
     4                  - A(I,J,L, 4)*R(I,J-1, 4)
     5                  - A(I,J,L, 5)*R(I,J-1, 5)
     6                  - A(I,J,L, 6)*R(I,J-1, 6)
     7                  - A(I,J,L, 7)*R(I,J-1, 7)
     8                  - A(I,J,L, 8)*R(I,J-1, 8)
     9                  - A(I,J,L, 9)*R(I,J-1, 9)
     A                  - A(I,J,L,10)*R(I,J-1,10)
     B                  - A(I,J,L,11)*R(I,J-1,11)
     C                  - A(I,J,L,12)*R(I,J-1,12)
  250       CONTINUE
  260    CONTINUE
      ENDIF
C
C     Normalize row by multiplication of B(-1) to get unity diagonal
C
C     Form the LU of B(1)
C
      DO 300 I = 1, NSIM
         L11 =  B(I,J,1, 1)
         U12 =  B(I,J,1, 2) / L11
         U13 =  B(I,J,1, 3) / L11
         U14 =  B(I,J,1, 4) / L11
         U15 =  B(I,J,1, 5) / L11
         U16 =  B(I,J,1, 6) / L11
         U17 =  B(I,J,1, 7) / L11
         U18 =  B(I,J,1, 8) / L11
         U19 =  B(I,J,1, 9) / L11
         U1A =  B(I,J,1,10) / L11
         U1B =  B(I,J,1,11) / L11
         U1C =  B(I,J,1,12) / L11
C
         L21 =  B(I,J,2, 1)
         L22 =  B(I,J,2, 2) - L21*U12
         U23 = (B(I,J,2, 3) - L21*U13) / L22
         U24 = (B(I,J,2, 4) - L21*U14) / L22
         U25 = (B(I,J,2, 5) - L21*U15) / L22
         U26 = (B(I,J,2, 6) - L21*U16) / L22
         U27 = (B(I,J,2, 7) - L21*U17) / L22
         U28 = (B(I,J,2, 8) - L21*U18) / L22
         U29 = (B(I,J,2, 9) - L21*U19) / L22
         U2A = (B(I,J,2,10) - L21*U1A) / L22
         U2B = (B(I,J,2,11) - L21*U1B) / L22
         U2C = (B(I,J,2,12) - L21*U1C) / L22
C
         L31 =  B(I,J,3, 1)
         L32 =  B(I,J,3, 2) - L31*U12
         L33 =  B(I,J,3, 3) - L31*U13 - L32*U23
         U34 = (B(I,J,3, 4) - L31*U14 - L32*U24) / L33
         U35 = (B(I,J,3, 5) - L31*U15 - L32*U25) / L33
         U36 = (B(I,J,3, 6) - L31*U16 - L32*U26) / L33
         U37 = (B(I,J,3, 7) - L31*U17 - L32*U27) / L33
         U38 = (B(I,J,3, 8) - L31*U18 - L32*U28) / L33
         U39 = (B(I,J,3, 9) - L31*U19 - L32*U29) / L33
         U3A = (B(I,J,3,10) - L31*U1A - L32*U2A) / L33
         U3B = (B(I,J,3,11) - L31*U1B - L32*U2B) / L33
         U3C = (B(I,J,3,12) - L31*U1C - L32*U2C) / L33
C
         L41 =  B(I,J,4, 1)
         L42 =  B(I,J,4, 2) - L41*U12
         L43 =  B(I,J,4, 3) - L41*U13 - L42*U23
         L44 =  B(I,J,4, 4) - L41*U14 - L42*U24 - L43*U34
         U45 = (B(I,J,4, 5) - L41*U15 - L42*U25 - L43*U35) / L44
         U46 = (B(I,J,4, 6) - L41*U16 - L42*U26 - L43*U36) / L44
         U47 = (B(I,J,4, 7) - L41*U17 - L42*U27 - L43*U37) / L44
         U48 = (B(I,J,4, 8) - L41*U18 - L42*U28 - L43*U38) / L44
         U49 = (B(I,J,4, 9) - L41*U19 - L42*U29 - L43*U39) / L44
         U4A = (B(I,J,4,10) - L41*U1A - L42*U2A - L43*U3A) / L44
         U4B = (B(I,J,4,11) - L41*U1B - L42*U2B - L43*U3B) / L44
         U4C = (B(I,J,4,12) - L41*U1C - L42*U2C - L43*U3C) / L44
C
         L51 =  B(I,J,5, 1)
         L52 =  B(I,J,5, 2) - L51*U12
         L53 =  B(I,J,5, 3) - L51*U13 - L52*U23
         L54 =  B(I,J,5, 4) - L51*U14 - L52*U24 - L53*U34
         L55 =  B(I,J,5, 5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
         U56 = (B(I,J,5, 6) - L51*U16 - L52*U26 - L53*U36 - L54*U46)
     1         / L55
         U57 = (B(I,J,5, 7) - L51*U17 - L52*U27 - L53*U37 - L54*U47)
     1         / L55
         U58 = (B(I,J,5, 8) - L51*U18 - L52*U28 - L53*U38 - L54*U48)
     1         / L55
         U59 = (B(I,J,5, 9) - L51*U19 - L52*U29 - L53*U39 - L54*U49)
     1         / L55
         U5A = (B(I,J,5,10) - L51*U1A - L52*U2A - L53*U3A - L54*U4A)
     1         / L55
         U5B = (B(I,J,5,11) - L51*U1B - L52*U2B - L53*U3B - L54*U4B)
     1         / L55
         U5C = (B(I,J,5,12) - L51*U1C - L52*U2C - L53*U3C - L54*U4C)
     1         / L55
C
         L61 =  B(I,J,6, 1)
         L62 =  B(I,J,6, 2) - L61*U12
         L63 =  B(I,J,6, 3) - L61*U13 - L62*U23
         L64 =  B(I,J,6, 4) - L61*U14 - L62*U24 - L63*U34
         L65 =  B(I,J,6, 5) - L61*U15 - L62*U25 - L63*U35 - L64*U45
         L66 =  B(I,J,6, 6) - L61*U16 - L62*U26 - L63*U36 - L64*U46
     1                      - L65*U56
         U67 = (B(I,J,6, 7) - L61*U17 - L62*U27 - L63*U37 - L64*U47
     1                      - L65*U57) / L66
         U68 = (B(I,J,6, 8) - L61*U18 - L62*U28 - L63*U38 - L64*U48
     1                      - L65*U58) / L66
         U69 = (B(I,J,6, 9) - L61*U19 - L62*U29 - L63*U39 - L64*U49
     1                      - L65*U59) / L66
         U6A = (B(I,J,6,10) - L61*U1A - L62*U2A - L63*U3A - L64*U4A
     1                      - L65*U5A) / L66
         U6B = (B(I,J,6,11) - L61*U1B - L62*U2B - L63*U3B - L64*U4B
     1                      - L65*U5B) / L66
         U6C = (B(I,J,6,12) - L61*U1C - L62*U2C - L63*U3C - L64*U4C
     1                      - L65*U5C) / L66
C
         L71 =  B(I,J,7, 1)
         L72 =  B(I,J,7, 2) - L71*U12
         L73 =  B(I,J,7, 3) - L71*U13 - L72*U23
         L74 =  B(I,J,7, 4) - L71*U14 - L72*U24 - L73*U34
         L75 =  B(I,J,7, 5) - L71*U15 - L72*U25 - L73*U35 - L74*U45
         L76 =  B(I,J,7, 6) - L71*U16 - L72*U26 - L73*U36 - L74*U46
     1                      - L75*U56
         L77 =  B(I,J,7, 7) - L71*U17 - L72*U27 - L73*U37 - L74*U47
     1                      - L75*U57 - L76*U67
         U78 = (B(I,J,7, 8) - L71*U18 - L72*U28 - L73*U38 - L74*U48
     1                      - L75*U58 - L76*U68) / L77
         U79 = (B(I,J,7, 9) - L71*U19 - L72*U29 - L73*U39 - L74*U49
     1                      - L75*U59 - L76*U69) / L77
         U7A = (B(I,J,7,10) - L71*U1A - L72*U2A - L73*U3A - L74*U4A
     1                      - L75*U5A - L76*U6A) / L77
         U7B = (B(I,J,7,11) - L71*U1B - L72*U2B - L73*U3B - L74*U4B
     1                      - L75*U5B - L76*U6B) / L77
         U7C = (B(I,J,7,12) - L71*U1C - L72*U2C - L73*U3C - L74*U4C
     1                      - L75*U5C - L76*U6C) / L77
C
         L81 =  B(I,J,8, 1)
         L82 =  B(I,J,8, 2) - L81*U12
         L83 =  B(I,J,8, 3) - L81*U13 - L82*U23
         L84 =  B(I,J,8, 4) - L81*U14 - L82*U24 - L83*U34
         L85 =  B(I,J,8, 5) - L81*U15 - L82*U25 - L83*U35 - L84*U45
         L86 =  B(I,J,8, 6) - L81*U16 - L82*U26 - L83*U36 - L84*U46
     1                      - L85*U56
         L87 =  B(I,J,8, 7) - L81*U17 - L82*U27 - L83*U37 - L84*U47
     1                      - L85*U57 - L86*U67
         L88 =  B(I,J,8, 8) - L81*U18 - L82*U28 - L83*U38 - L84*U48
     1                      - L85*U58 - L86*U68 - L87*U78
         U89 = (B(I,J,8, 9) - L81*U19 - L82*U29 - L83*U39 - L84*U49
     1                      - L85*U59 - L86*U69 - L87*U79) / L88
         U8A = (B(I,J,8,10) - L81*U1A - L82*U2A - L83*U3A - L84*U4A
     1                      - L85*U5A - L86*U6A - L87*U7A) / L88
         U8B = (B(I,J,8,11) - L81*U1B - L82*U2B - L83*U3B - L84*U4B
     1                      - L85*U5B - L86*U6B - L87*U7B) / L88
         U8C = (B(I,J,8,12) - L81*U1C - L82*U2C - L83*U3C - L84*U4C
     1                      - L85*U5C - L86*U6C - L87*U7C) / L88
C
         L91 =  B(I,J,9, 1)
         L92 =  B(I,J,9, 2) - L91*U12
         L93 =  B(I,J,9, 3) - L91*U13 - L92*U23
         L94 =  B(I,J,9, 4) - L91*U14 - L92*U24 - L93*U34
         L95 =  B(I,J,9, 5) - L91*U15 - L92*U25 - L93*U35 - L94*U45
         L96 =  B(I,J,9, 6) - L91*U16 - L92*U26 - L93*U36 - L94*U46
     1                      - L95*U56
         L97 =  B(I,J,9, 7) - L91*U17 - L92*U27 - L93*U37 - L94*U47
     1                      - L95*U57 - L96*U67
         L98 =  B(I,J,9, 8) - L91*U18 - L92*U28 - L93*U38 - L94*U48
     1                      - L95*U58 - L96*U68 - L97*U78
         L99 =  B(I,J,9, 9) - L91*U19 - L92*U29 - L93*U39 - L94*U49
     1                      - L95*U59 - L96*U69 - L97*U79 - L98*U89
         U9A = (B(I,J,9,10) - L91*U1A - L92*U2A - L93*U3A - L94*U4A
     1                      - L95*U5A - L96*U6A - L97*U7A - L98*U8A)
     2         / L99
         U9B = (B(I,J,9,11) - L91*U1B - L92*U2B - L93*U3B - L94*U4B
     1                      - L95*U5B - L96*U6B - L97*U7B - L98*U8B)
     2         / L99
         U9C = (B(I,J,9,12) - L91*U1C - L92*U2C - L93*U3C - L94*U4C
     1                      - L95*U5C - L96*U6C - L97*U7C - L98*U8C)
     2         / L99
C
         LA1 =  B(I,J,10, 1)
         LA2 =  B(I,J,10, 2) - LA1*U12
         LA3 =  B(I,J,10, 3) - LA1*U13 - LA2*U23
         LA4 =  B(I,J,10, 4) - LA1*U14 - LA2*U24 - LA3*U34
         LA5 =  B(I,J,10, 5) - LA1*U15 - LA2*U25 - LA3*U35 - LA4*U45
         LA6 =  B(I,J,10, 6) - LA1*U16 - LA2*U26 - LA3*U36 - LA4*U46
     1                       - LA5*U56
         LA7 =  B(I,J,10, 7) - LA1*U17 - LA2*U27 - LA3*U37 - LA4*U47
     1                       - LA5*U57 - LA6*U67
         LA8 =  B(I,J,10, 8) - LA1*U18 - LA2*U28 - LA3*U38 - LA4*U48
     1                       - LA5*U58 - LA6*U68 - LA7*U78
         LA9 =  B(I,J,10, 9) - LA1*U19 - LA2*U29 - LA3*U39 - LA4*U49
     1                       - LA5*U59 - LA6*U69 - LA7*U79 - LA8*U89
         LAA =  B(I,J,10,10) - LA1*U1A - LA2*U2A - LA3*U3A - LA4*U4A
     1                       - LA5*U5A - LA6*U6A - LA7*U7A - LA8*U8A
     2                       - LA9*U9A
         UAB = (B(I,J,10,11) - LA1*U1B - LA2*U2B - LA3*U3B - LA4*U4B
     1                       - LA5*U5B - LA6*U6B - LA7*U7B - LA8*U8B
     2                       - LA9*U9B) / LAA
         UAC = (B(I,J,10,12) - LA1*U1C - LA2*U2C - LA3*U3C - LA4*U4C
     1                       - LA5*U5C - LA6*U6C - LA7*U7C - LA8*U8C
     2                       - LA9*U9C) / LAA
C
         LB1 =  B(I,J,11, 1)
         LB2 =  B(I,J,11, 2) - LB1*U12
         LB3 =  B(I,J,11, 3) - LB1*U13 - LB2*U23
         LB4 =  B(I,J,11, 4) - LB1*U14 - LB2*U24 - LB3*U34
         LB5 =  B(I,J,11, 5) - LB1*U15 - LB2*U25 - LB3*U35 - LB4*U45
         LB6 =  B(I,J,11, 6) - LB1*U16 - LB2*U26 - LB3*U36 - LB4*U46
     1                       - LB5*U56
         LB7 =  B(I,J,11, 7) - LB1*U17 - LB2*U27 - LB3*U37 - LB4*U47
     1                       - LB5*U57 - LB6*U67
         LB8 =  B(I,J,11, 8) - LB1*U18 - LB2*U28 - LB3*U38 - LB4*U48
     1                       - LB5*U58 - LB6*U68 - LB7*U78
         LB9 =  B(I,J,11, 9) - LB1*U19 - LB2*U29 - LB3*U39 - LB4*U49
     1                       - LB5*U59 - LB6*U69 - LB7*U79 - LB8*U89
         LBA =  B(I,J,11,10) - LB1*U1A - LB2*U2A - LB3*U3A - LB4*U4A
     1                       - LB5*U5A - LB6*U6A - LB7*U7A - LB8*U8A
     2                       - LB9*U9A
         LBB =  B(I,J,11,11) - LB1*U1B - LB2*U2B - LB3*U3B - LB4*U4B
     1                       - LB5*U5B - LB6*U6B - LB7*U7B - LB8*U8B
     2                       - LB9*U9B - LBA*UAB
         UBC = (B(I,J,11,12) - LB1*U1C - LB2*U2C - LB3*U3C - LB4*U4C
     1                       - LB5*U5C - LB6*U6C - LB7*U7C - LB8*U8C
     2                       - LB9*U9C - LBA*UAC) / LAA
C
         LC1 =  B(I,J,12, 1)
         LC2 =  B(I,J,12, 2) - LC1*U12
         LC3 =  B(I,J,12, 3) - LC1*U13 - LC2*U23
         LC4 =  B(I,J,12, 4) - LC1*U14 - LC2*U24 - LC3*U34
         LC5 =  B(I,J,12, 5) - LC1*U15 - LC2*U25 - LC3*U35 - LC4*U45
         LC6 =  B(I,J,12, 6) - LC1*U16 - LC2*U26 - LC3*U36 - LC4*U46
     1                       - LC5*U56
         LC7 =  B(I,J,12, 7) - LC1*U17 - LC2*U27 - LC3*U37 - LC4*U47
     1                       - LC5*U57 - LC6*U67
         LC8 =  B(I,J,12, 8) - LC1*U18 - LC2*U28 - LC3*U38 - LC4*U48
     1                       - LC5*U58 - LC6*U68 - LC7*U78
         LC9 =  B(I,J,12, 9) - LC1*U19 - LC2*U29 - LC3*U39 - LC4*U49
     1                       - LC5*U59 - LC6*U69 - LC7*U79 - LC8*U89
         LCA =  B(I,J,12,10) - LC1*U1A - LC2*U2A - LC3*U3A - LC4*U4A
     1                       - LC5*U5A - LC6*U6A - LC7*U7A - LC8*U8A
     2                       - LC9*U9A
         LCB =  B(I,J,12,11) - LC1*U1B - LC2*U2B - LC3*U3B - LC4*U4B
     1                       - LC5*U5B - LC6*U6B - LC7*U7B - LC8*U8B
     2                       - LC9*U9B - LCA*UAB
         LCC =  B(I,J,12,12) - LC1*U1C - LC2*U2C - LC3*U3C - LC4*U4C
     1                       - LC5*U5C - LC6*U6C - LC7*U7C - LC8*U8C
     2                       - LC9*U9C - LCA*UAC - LCB*UBC
C
C     Calculate B(-1) * R
C
         R1        =  R(I,J, 1) / L11
         R2        = (R(I,J, 2) - L21*R1) / L22
         R3        = (R(I,J, 3) - L31*R1 - L32*R2) / L33
         R4        = (R(I,J, 4) - L41*R1 - L42*R2 - L43*R3) / L44
         R5        = (R(I,J, 5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1               / L55
         R6        = (R(I,J, 6) - L61*R1 - L62*R2 - L63*R3 - L64*R4
     1                          - L65*R5) / L66
         R7        = (R(I,J, 7) - L71*R1 - L72*R2 - L73*R3 - L74*R4
     1                          - L75*R5 - L76*R6) / L77
         R8        = (R(I,J, 8) - L81*R1 - L82*R2 - L83*R3 - L84*R4
     1                          - L85*R5 - L86*R6 - L87*R7) / L88
         R9        = (R(I,J, 9) - L91*R1 - L92*R2 - L93*R3 - L94*R4
     1                          - L95*R5 - L96*R6 - L97*R7 - L98*R8)
     2               / L99
         RA        = (R(I,J,10) - LA1*R1 - LA2*R2 - LA3*R3 - LA4*R4
     1                          - LA5*R5 - LA6*R6 - LA7*R7 - LA8*R8
     2                          - LA9*R9) / LAA
         RB        = (R(I,J,11) - LB1*R1 - LB2*R2 - LB3*R3 - LB4*R4
     1                          - LB5*R5 - LB6*R6 - LB7*R7 - LB8*R8
     2                          - LB9*R9 - LBA*RA) / LBB
         R(I,J,12) = (R(I,J,12) - LC1*R1 - LC2*R2 - LC3*R3 - LC4*R4
     1                          - LC5*R5 - LC6*R6 - LC7*R7 - LC8*R8
     2                          - LC9*R9 - LCA*RA - LCB*RB) / LCC
         R(I,J,11) = RB-UBC*R(I,J,12)
         R(I,J,10) = RA-UAC*R(I,J,12)-UAB*R(I,J,11)
         R(I,J, 9) = R9-U9C*R(I,J,12)-U9B*R(I,J,11)-U9A*R(I,J,10)
         R(I,J, 8) = R8-U8C*R(I,J,12)-U8B*R(I,J,11)-U8A*R(I,J,10)
     1                 -U89*R(I,J, 9)
         R(I,J, 7) = R7-U7C*R(I,J,12)-U7B*R(I,J,11)-U7A*R(I,J,10)
     1                 -U79*R(I,J, 9)-U78*R(I,J, 8)
         R(I,J, 6) = R6-U6C*R(I,J,12)-U6B*R(I,J,11)-U6A*R(I,J,10)
     1                 -U69*R(I,J, 9)-U68*R(I,J, 8)-U67*R(I,J, 7)
         R(I,J, 5) = R5-U5C*R(I,J,12)-U5B*R(I,J,11)-U5A*R(I,J,10)
     1                 -U59*R(I,J, 9)-U58*R(I,J, 8)-U57*R(I,J, 7)
     2                 -U56*R(I,J, 6)
         R(I,J, 4) = R4-U4C*R(I,J,12)-U4B*R(I,J,11)-U4A*R(I,J,10)
     1                 -U49*R(I,J, 9)-U48*R(I,J, 8)-U47*R(I,J, 7)
     2                 -U46*R(I,J, 6)-U45*R(I,J, 5)
         R(I,J, 3) = R3-U3C*R(I,J,12)-U3B*R(I,J,11)-U3A*R(I,J,10)
     1                 -U39*R(I,J, 9)-U38*R(I,J, 8)-U37*R(I,J, 7)
     2                 -U36*R(I,J, 6)-U35*R(I,J, 5)-U34*R(I,J, 4)
         R(I,J, 2) = R2-U2C*R(I,J,12)-U2B*R(I,J,11)-U2A*R(I,J,10)
     1                 -U29*R(I,J, 9)-U28*R(I,J, 8)-U27*R(I,J, 7)
     2                 -U26*R(I,J, 6)-U25*R(I,J, 5)-U24*R(I,J, 4)
     3                 -U23*R(I,J, 3)
         R(I,J, 1) = R1-U1C*R(I,J,12)-U1B*R(I,J,11)-U1A*R(I,J,10)
     1                 -U19*R(I,J, 9)-U18*R(I,J, 8)-U17*R(I,J, 7)
     2                 -U16*R(I,J, 6)-U15*R(I,J, 5)-U14*R(I,J, 4)
     3                 -U13*R(I,J, 3)-U12*R(I,J, 2)
  300 CONTINUE
C
C     Backward Substitution Sweep
C
      DO 400 J = NPTS-1, 1, -1
         DO 390 L = 1, 12
            DO 380 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - C(I,J,L, 1)*R(I,J+1, 1)
     2                  - C(I,J,L, 2)*R(I,J+1, 2)
     3                  - C(I,J,L, 3)*R(I,J+1, 3)
     4                  - C(I,J,L, 4)*R(I,J+1, 4)
     5                  - C(I,J,L, 5)*R(I,J+1, 5)
     6                  - C(I,J,L, 6)*R(I,J+1, 6)
     7                  - C(I,J,L, 7)*R(I,J+1, 7)
     8                  - C(I,J,L, 8)*R(I,J+1, 8)
     9                  - C(I,J,L, 9)*R(I,J+1, 9)
     A                  - C(I,J,L,10)*R(I,J+1,10)
     B                  - C(I,J,L,11)*R(I,J+1,11)
     C                  - C(I,J,L,12)*R(I,J+1,12)
  380       CONTINUE
  390    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VSTRI  (NPTS, NSIM, A, B, C, R)
C
C     Routine to perform the solve a scalar tridiagonal system
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     A:         The supra-diagonal element
C     B:         The diagonal element
C     C:         The super-diagonal element
C     R:         The right hand side
C
C     A, B and C are destroyed by this routine
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS),
     1          B (NSIM,NPTS),
     2          C (NSIM,NPTS),
     3          R (NSIM,NPTS)
C
C     Forward Substitution Loop
C
C     J = 1
C     Scale first row by B(1)
C
      J = 1
C---CMIC$ DO ALL AUTOSCOPE VECTOR
C---C$DOACROSS LOCAL(I)
      DO 10 I = 1, NSIM
         C(I,J) = C(I,J) / B(I,J)
         R(I,J) = R(I,J) / B(I,J)
   10 CONTINUE
C
C     Loop over the interior of the inversion - 2 to NPTS
C     Eliminate A
C
      DO 200 J = 2, NPTS
C
C     R = (R - L(i,i-1)*R(j-1)) / L(i,i)
C
C---CMIC$ DO ALL AUTOSCOPE VECTOR
C---C$DOACROSS LOCAL(I)
         DO 150 I = 1, NSIM
            B(I,J) = (B(I,J) - A(I,J)*C(I,J-1))
            C(I,J) =  C(I,J) / B(I,J)
            R(I,J) = (R(I,J) - A(I,J)*R(I,J-1)) / B(I,J)
  150    CONTINUE
  200 CONTINUE
C
C     Backward Substitution Sweep
C
      DO 400 J = NPTS-1, 1, -1
C---CMIC$ DO ALL AUTOSCOPE VECTOR
C---C$DOACROSS LOCAL(I)
         DO 350 I = 1, NSIM
            R(I,J) = R(I,J) - C(I,J)*R(I,J+1)
  350    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VBDIA (NPTS, NSIM, IRANK, B, R)
C
C     Routine to perform the Block Diagonal Inversion of
C     a block diagonal system where B is the block diagonal and
C     R is the right hand side which is returned as the solution
C     vector.  B is NOT overwritten.
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     IRANK:     The rank of the system to invert
C     B:         The lu decomposition of the diagonal block 7x7 of L
C     R:         The right hand side
C
      include 'common.inc'
C
      DIMENSION B (NSIM,NPTS,NRANK,NRANK),
     1          R (NSIM,NPTS,NRANK)
C
      IF (IRANK .EQ. 7) THEN
         CALL VB7DIA (NPTS, NSIM, NRANK, B, R)
      ELSE IF (IRANK .EQ. 12) THEN
         CALL VB12DI (NPTS, NSIM, NRANK, B, R)
      ELSE
         WRITE (IOUT,1000) IRANK, IRANK
         STOP
      ENDIF
C
C     Finished
      RETURN
 1000 FORMAT (' ','Block solver required for a ',I3,' x ',I3,' block.',
     1       /' ','This solver does not exist.  Run Aborting.')
      END
      SUBROUTINE VB7DIA (NPTS, NSIM, NRANK, B, R)
C
C     Routine to invert a 7x7 block diagonal system
C     Inversion is by Upper Triangularization with a
C     unity diagonal followed by a backsubstitution step.
C     Vectorization is attained by inverting multiple systems
C     at one time with the recursive inversion algorithm.
C     The B array is NOT destroyed in the solution procedure.
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage
C     B:         The diagonal block 7x7
C     R:         The right hand side
C
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION B (NSIM,NPTS,NRANK,NRANK),
     1          R (NSIM,NPTS,NRANK)
C
C     Storage for the LU decomposition of a block 7x7
C
      REAL L11,
     1     L21, L22,
     2     L31, L32, L33,
     3     L41, L42, L43, L44,
     4     L51, L52, L53, L54, L55,
     5     L61, L62, L63, L64, L65, L66,
     6     L71, L72, L73, L74, L75, L76, L77
C
C     Loop over all points
C
      DO 200 J = 1, NPTS
C
C     Form the LU of B(1)
C
         DO 190 I = 1, NSIM
            L11 =  B(I,J,1,1)
            U12 =  B(I,J,1,2) / L11
            U13 =  B(I,J,1,3) / L11
            U14 =  B(I,J,1,4) / L11
            U15 =  B(I,J,1,5) / L11
            U16 =  B(I,J,1,6) / L11
            U17 =  B(I,J,1,7) / L11
C
            L21 =  B(I,J,2,1)
            L22 =  B(I,J,2,2) - L21*U12
            U23 = (B(I,J,2,3) - L21*U13) / L22
            U24 = (B(I,J,2,4) - L21*U14) / L22
            U25 = (B(I,J,2,5) - L21*U15) / L22
            U26 = (B(I,J,2,6) - L21*U16) / L22
            U27 = (B(I,J,2,7) - L21*U17) / L22
C
            L31 =  B(I,J,3,1)
            L32 =  B(I,J,3,2) - L31*U12
            L33 =  B(I,J,3,3) - L31*U13 - L32*U23
            U34 = (B(I,J,3,4) - L31*U14 - L32*U24) / L33
            U35 = (B(I,J,3,5) - L31*U15 - L32*U25) / L33
            U36 = (B(I,J,3,6) - L31*U16 - L32*U26) / L33
            U37 = (B(I,J,3,7) - L31*U17 - L32*U27) / L33
C
            L41 =  B(I,J,4,1)
            L42 =  B(I,J,4,2) - L41*U12
            L43 =  B(I,J,4,3) - L41*U13 - L42*U23
            L44 =  B(I,J,4,4) - L41*U14 - L42*U24 - L43*U34
            U45 = (B(I,J,4,5) - L41*U15 - L42*U25 - L43*U35) / L44
            U46 = (B(I,J,4,6) - L41*U16 - L42*U26 - L43*U36) / L44
            U47 = (B(I,J,4,7) - L41*U17 - L42*U27 - L43*U37) / L44
C
            L51 =  B(I,J,5,1)
            L52 =  B(I,J,5,2) - L51*U12
            L53 =  B(I,J,5,3) - L51*U13 - L52*U23
            L54 =  B(I,J,5,4) - L51*U14 - L52*U24 - L53*U34
            L55 =  B(I,J,5,5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
            U56 = (B(I,J,5,6) - L51*U16 - L52*U26 - L53*U36 - L54*U46)
     1            / L55
            U57 = (B(I,J,5,7) - L51*U17 - L52*U27 - L53*U37 - L54*U47)
     1            / L55
C
            L61 =  B(I,J,6,1)
            L62 =  B(I,J,6,2) - L61*U12
            L63 =  B(I,J,6,3) - L61*U13 - L62*U23
            L64 =  B(I,J,6,4) - L61*U14 - L62*U24 - L63*U34
            L65 =  B(I,J,6,5) - L61*U15 - L62*U25 - L63*U35 - L64*U45
            L66 =  B(I,J,6,6) - L61*U16 - L62*U26 - L63*U36 - L64*U46
     1                        - L65*U56
            U67 = (B(I,J,6,7) - L61*U17 - L62*U27 - L63*U37 - L64*U47
     1                        - L65*U57) / L66
C
            L71 =  B(I,J,7,1)
            L72 =  B(I,J,7,2) - L71*U12
            L73 =  B(I,J,7,3) - L71*U13 - L72*U23
            L74 =  B(I,J,7,4) - L71*U14 - L72*U24 - L73*U34
            L75 =  B(I,J,7,5) - L71*U15 - L72*U25 - L73*U35 - L74*U45
            L76 =  B(I,J,7,6) - L71*U16 - L72*U26 - L73*U36 - L74*U46
     1                        - L75*U56
            L77 =  B(I,J,7,7) - L71*U17 - L72*U27 - L73*U37 - L74*U47
     1                        - L75*U57 - L76*U67
C
C     Calculate B(-1) * R
C
            R1       =  R(I,J,1) / L11
            R2       = (R(I,J,2) - L21*R1) / L22
            R3       = (R(I,J,3) - L31*R1 - L32*R2) / L33
            R4       = (R(I,J,4) - L41*R1 - L42*R2 - L43*R3) / L44
            R5       = (R(I,J,5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1                 / L55
            R6       = (R(I,J,6) - L61*R1 - L62*R2 - L63*R3 - L64*R4
     1                           - L65*R5) / L66
            R(I,J,7) = (R(I,J,7) - L71*R1 - L72*R2 - L73*R3 - L74*R4
     1                           - L75*R5 - L76*R6) / L77
            R(I,J,6) =  R6-U67*R(I,J,7)
            R(I,J,5) =  R5-U57*R(I,J,7)-U56*R(I,J,6)
            R(I,J,4) =  R4-U47*R(I,J,7)-U46*R(I,J,6)-U45*R(I,J,5)
            R(I,J,3) =  R3-U37*R(I,J,7)-U36*R(I,J,6)-U35*R(I,J,5)
     1                    -U34*R(I,J,4)
            R(I,J,2) =  R2-U27*R(I,J,7)-U26*R(I,J,6)-U25*R(I,J,5)
     1                    -U24*R(I,J,4)-U23*R(I,J,3)
            R(I,J,1) =  R1-U17*R(I,J,7)-U16*R(I,J,6)-U15*R(I,J,5)
     1                    -U14*R(I,J,4)-U13*R(I,J,3)-U12*R(I,J,2)
  190    CONTINUE
  200 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VB12DI (NPTS, NSIM, NRANK, B, R)
C
C     Routine to invert a 12x12 block diagonal system
C     Inversion is by Upper Triangularization with a
C     unity diagonal followed by a backsubstitution step.
C     Vectorization is attained by inverting multiple systems
C     at one time with the recursive inversion algorithm.
C     The B array is NOT destroyed in the solution procedure.
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage
C     B:         The diagonal block 12x12
C     R:         The right hand side
C
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION B (NSIM,NPTS,NRANK,NRANK),
     1          R (NSIM,NPTS,NRANK)
C
C     Storage for the LU decomposition of a block 12x12
C     Note: A = 10, B = 11, C = 12
C
      REAL L11,
     1     L21, L22,
     2     L31, L32, L33,
     3     L41, L42, L43, L44,
     4     L51, L52, L53, L54, L55,
     5     L61, L62, L63, L64, L65, L66,
     6     L71, L72, L73, L74, L75, L76, L77,
     7     L81, L82, L83, L84, L85, L86, L87, L88,
     8     L91, L92, L93, L94, L95, L96, L97, L98, L99,
     9     LA1, LA2, LA3, LA4, LA5, LA6, LA7, LA8, LA9, LAA,
     A     LB1, LB2, LB3, LB4, LB5, LB6, LB7, LB8, LB9, LBA, LBB,
     B     LC1, LC2, LC3, LC4, LC5, LC6, LC7, LC8, LC9, LCA, LCB, LCC
C
C     Loop over all points
C
      DO 200 J = 1, NPTS
C
C     Form the LU of B(1)
C
C Row 1
C
         DO 190 I = 1, NSIM
            L11 =  B(I,J,1, 1)
            U12 =  B(I,J,1, 2) / L11
            U13 =  B(I,J,1, 3) / L11
            U14 =  B(I,J,1, 4) / L11
            U15 =  B(I,J,1, 5) / L11
            U16 =  B(I,J,1, 6) / L11
            U17 =  B(I,J,1, 7) / L11
            U18 =  B(I,J,1, 8) / L11
            U19 =  B(I,J,1, 9) / L11
            U1A =  B(I,J,1,10) / L11
            U1B =  B(I,J,1,11) / L11
            U1C =  B(I,J,1,12) / L11
C
C Row 2
C
            L21 =  B(I,J,2, 1)
            L22 =  B(I,J,2, 2) - L21*U12
            U23 = (B(I,J,2, 3) - L21*U13) / L22
            U24 = (B(I,J,2, 4) - L21*U14) / L22
            U25 = (B(I,J,2, 5) - L21*U15) / L22
            U26 = (B(I,J,2, 6) - L21*U16) / L22
            U27 = (B(I,J,2, 7) - L21*U17) / L22
            U28 = (B(I,J,2, 8) - L21*U18) / L22
            U29 = (B(I,J,2, 9) - L21*U19) / L22
            U2A = (B(I,J,2,10) - L21*U1A) / L22
            U2B = (B(I,J,2,11) - L21*U1B) / L22
            U2C = (B(I,J,2,12) - L21*U1C) / L22
C
C Row 3
C
            L31 =  B(I,J,3, 1)
            L32 =  B(I,J,3, 2) - L31*U12
            L33 =  B(I,J,3, 3) - L31*U13 - L32*U23
            U34 = (B(I,J,3, 4) - L31*U14 - L32*U24) / L33
            U35 = (B(I,J,3, 5) - L31*U15 - L32*U25) / L33
            U36 = (B(I,J,3, 6) - L31*U16 - L32*U26) / L33
            U37 = (B(I,J,3, 7) - L31*U17 - L32*U27) / L33
            U38 = (B(I,J,3, 8) - L31*U18 - L32*U28) / L33
            U39 = (B(I,J,3, 9) - L31*U19 - L32*U29) / L33
            U3A = (B(I,J,3,10) - L31*U1A - L32*U2A) / L33
            U3B = (B(I,J,3,11) - L31*U1B - L32*U2B) / L33
            U3C = (B(I,J,3,12) - L31*U1C - L32*U2C) / L33
C
C Row 4
C
            L41 =  B(I,J,4, 1)
            L42 =  B(I,J,4, 2) - L41*U12
            L43 =  B(I,J,4, 3) - L41*U13 - L42*U23
            L44 =  B(I,J,4, 4) - L41*U14 - L42*U24 - L43*U34
            U45 = (B(I,J,4, 5) - L41*U15 - L42*U25 - L43*U35) / L44
            U46 = (B(I,J,4, 6) - L41*U16 - L42*U26 - L43*U36) / L44
            U47 = (B(I,J,4, 7) - L41*U17 - L42*U27 - L43*U37) / L44
            U48 = (B(I,J,4, 8) - L41*U18 - L42*U28 - L43*U38) / L44
            U49 = (B(I,J,4, 9) - L41*U19 - L42*U29 - L43*U39) / L44
            U4A = (B(I,J,4,10) - L41*U1A - L42*U2A - L43*U3A) / L44
            U4B = (B(I,J,4,11) - L41*U1B - L42*U2B - L43*U3B) / L44
            U4C = (B(I,J,4,12) - L41*U1C - L42*U2C - L43*U3C) / L44
C
C Row 5
C
            L51 =  B(I,J,5, 1)
            L52 =  B(I,J,5, 2) - L51*U12
            L53 =  B(I,J,5, 3) - L51*U13 - L52*U23
            L54 =  B(I,J,5, 4) - L51*U14 - L52*U24 - L53*U34
            L55 =  B(I,J,5, 5) - L51*U15 - L52*U25 - L53*U35 - L54*U45
            U56 = (B(I,J,5, 6) - L51*U16 - L52*U26 - L53*U36 - L54*U46)
     1            / L55
            U57 = (B(I,J,5, 7) - L51*U17 - L52*U27 - L53*U37 - L54*U47)
     1            / L55
            U58 = (B(I,J,5, 8) - L51*U18 - L52*U28 - L53*U38 - L54*U48)
     1            / L55
            U59 = (B(I,J,5, 9) - L51*U19 - L52*U29 - L53*U39 - L54*U49)
     1            / L55
            U5A = (B(I,J,5,10) - L51*U1A - L52*U2A - L53*U3A - L54*U4A)
     1            / L55
            U5B = (B(I,J,5,11) - L51*U1B - L52*U2B - L53*U3B - L54*U4B)
     1            / L55
            U5C = (B(I,J,5,12) - L51*U1C - L52*U2C - L53*U3C - L54*U4C)
     1            / L55
C
C Row 6
C
            L61 =  B(I,J,6, 1)
            L62 =  B(I,J,6, 2) - L61*U12
            L63 =  B(I,J,6, 3) - L61*U13 - L62*U23
            L64 =  B(I,J,6, 4) - L61*U14 - L62*U24 - L63*U34
            L65 =  B(I,J,6, 5) - L61*U15 - L62*U25 - L63*U35 - L64*U45
            L66 =  B(I,J,6, 6) - L61*U16 - L62*U26 - L63*U36 - L64*U46
     1                         - L65*U56
            U67 = (B(I,J,6, 7) - L61*U17 - L62*U27 - L63*U37 - L64*U47
     1                         - L65*U57) / L66
            U68 = (B(I,J,6, 8) - L61*U18 - L62*U28 - L63*U38 - L64*U48
     1                         - L65*U58) / L66
            U69 = (B(I,J,6, 9) - L61*U19 - L62*U29 - L63*U39 - L64*U49
     1                         - L65*U59) / L66
            U6A = (B(I,J,6,10) - L61*U1A - L62*U2A - L63*U3A - L64*U4A
     1                         - L65*U5A) / L66
            U6B = (B(I,J,6,11) - L61*U1B - L62*U2B - L63*U3B - L64*U4B
     1                         - L65*U5B) / L66
            U6C = (B(I,J,6,12) - L61*U1C - L62*U2C - L63*U3C - L64*U4C
     1                         - L65*U5C) / L66
C
C Row 7
C
            L71 =  B(I,J,7, 1)
            L72 =  B(I,J,7, 2) - L71*U12
            L73 =  B(I,J,7, 3) - L71*U13 - L72*U23
            L74 =  B(I,J,7, 4) - L71*U14 - L72*U24 - L73*U34
            L75 =  B(I,J,7, 5) - L71*U15 - L72*U25 - L73*U35 - L74*U45
            L76 =  B(I,J,7, 6) - L71*U16 - L72*U26 - L73*U36 - L74*U46
     1                         - L75*U56
            L77 =  B(I,J,7, 7) - L71*U17 - L72*U27 - L73*U37 - L74*U47
     1                         - L75*U57 - L76*U67
            U78 = (B(I,J,7, 8) - L71*U18 - L72*U28 - L73*U38 - L74*U48
     1                         - L75*U58 - L76*U68) / L77
            U79 = (B(I,J,7, 9) - L71*U19 - L72*U29 - L73*U39 - L74*U49
     1                         - L75*U59 - L76*U69) / L77
            U7A = (B(I,J,7,10) - L71*U1A - L72*U2A - L73*U3A - L74*U4A
     1                         - L75*U5A - L76*U6A) / L77
            U7B = (B(I,J,7,11) - L71*U1B - L72*U2B - L73*U3B - L74*U4B
     1                         - L75*U5B - L76*U6B) / L77
            U7C = (B(I,J,7,12) - L71*U1C - L72*U2C - L73*U3C - L74*U4C
     1                         - L75*U5C - L76*U6C) / L77
C
C Row 8
C
            L81 =  B(I,J,8, 1)
            L82 =  B(I,J,8, 2) - L81*U12
            L83 =  B(I,J,8, 3) - L81*U13 - L82*U23
            L84 =  B(I,J,8, 4) - L81*U14 - L82*U24 - L83*U34
            L85 =  B(I,J,8, 5) - L81*U15 - L82*U25 - L83*U35 - L84*U45
            L86 =  B(I,J,8, 6) - L81*U16 - L82*U26 - L83*U36 - L84*U46
     1                         - L85*U56
            L87 =  B(I,J,8, 7) - L81*U17 - L82*U27 - L83*U37 - L84*U47
     1                         - L85*U57 - L86*U67
            L88 =  B(I,J,8, 8) - L81*U18 - L82*U28 - L83*U38 - L84*U48
     1                         - L85*U58 - L86*U68 - L87*U78
            U89 = (B(I,J,8, 9) - L81*U19 - L82*U29 - L83*U39 - L84*U49
     1                         - L85*U59 - L86*U69 - L87*U79) / L88
            U8A = (B(I,J,8,10) - L81*U1A - L82*U2A - L83*U3A - L84*U4A
     1                         - L85*U5A - L86*U6A - L87*U7A) / L88
            U8B = (B(I,J,8,11) - L81*U1B - L82*U2B - L83*U3B - L84*U4B
     1                         - L85*U5B - L86*U6B - L87*U7B) / L88
            U8C = (B(I,J,8,12) - L81*U1C - L82*U2C - L83*U3C - L84*U4C
     1                         - L85*U5C - L86*U6C - L87*U7C) / L88
C
C Row 9
C
            L91 =  B(I,J,9, 1)
            L92 =  B(I,J,9, 2) - L91*U12
            L93 =  B(I,J,9, 3) - L91*U13 - L92*U23
            L94 =  B(I,J,9, 4) - L91*U14 - L92*U24 - L93*U34
            L95 =  B(I,J,9, 5) - L91*U15 - L92*U25 - L93*U35 - L94*U45
            L96 =  B(I,J,9, 6) - L91*U16 - L92*U26 - L93*U36 - L94*U46
     1                         - L95*U56
            L97 =  B(I,J,9, 7) - L91*U17 - L92*U27 - L93*U37 - L94*U47
     1                         - L95*U57 - L96*U67
            L98 =  B(I,J,9, 8) - L91*U18 - L92*U28 - L93*U38 - L94*U48
     1                         - L95*U58 - L96*U68 - L97*U78
            L99 =  B(I,J,9, 9) - L91*U19 - L92*U29 - L93*U39 - L94*U49
     1                         - L95*U59 - L96*U69 - L97*U79 - L98*U89
            U9A = (B(I,J,9,10) - L91*U1A - L92*U2A - L93*U3A - L94*U4A
     1                         - L95*U5A - L96*U6A - L97*U7A - L98*U8A)
     2            / L99
            U9B = (B(I,J,9,11) - L91*U1B - L92*U2B - L93*U3B - L94*U4B
     1                         - L95*U5B - L96*U6B - L97*U7B - L98*U8B)
     2            / L99
            U9C = (B(I,J,9,12) - L91*U1C - L92*U2C - L93*U3C - L94*U4C
     1                         - L95*U5C - L96*U6C - L97*U7C - L98*U8C)
     2            / L99
C
C Row 10
C
            LA1 =  B(I,J,10, 1)
            LA2 =  B(I,J,10, 2) - LA1*U12
            LA3 =  B(I,J,10, 3) - LA1*U13 - LA2*U23
            LA4 =  B(I,J,10, 4) - LA1*U14 - LA2*U24 - LA3*U34
            LA5 =  B(I,J,10, 5) - LA1*U15 - LA2*U25 - LA3*U35 - LA4*U45
            LA6 =  B(I,J,10, 6) - LA1*U16 - LA2*U26 - LA3*U36 - LA4*U46
     1                          - LA5*U56
            LA7 =  B(I,J,10, 7) - LA1*U17 - LA2*U27 - LA3*U37 - LA4*U47
     1                          - LA5*U57 - LA6*U67
            LA8 =  B(I,J,10, 8) - LA1*U18 - LA2*U28 - LA3*U38 - LA4*U48
     1                          - LA5*U58 - LA6*U68 - LA7*U78
            LA9 =  B(I,J,10, 9) - LA1*U19 - LA2*U29 - LA3*U39 - LA4*U49
     1                          - LA5*U59 - LA6*U69 - LA7*U79 - LA8*U89
            LAA =  B(I,J,10,10) - LA1*U1A - LA2*U2A - LA3*U3A - LA4*U4A
     1                          - LA5*U5A - LA6*U6A - LA7*U7A - LA8*U8A
     2                          - LA9*U9A
            UAB = (B(I,J,10,11) - LA1*U1B - LA2*U2B - LA3*U3B - LA4*U4B
     1                          - LA5*U5B - LA6*U6B - LA7*U7B - LA8*U8B
     2                          - LA9*U9B) / LAA
            UAC = (B(I,J,10,12) - LA1*U1C - LA2*U2C - LA3*U3C - LA4*U4C
     1                          - LA5*U5C - LA6*U6C - LA7*U7C - LA8*U8C
     2                          - LA9*U9C) / LAA
C
C Row 11
C
            LB1 =  B(I,J,11, 1)
            LB2 =  B(I,J,11, 2) - LB1*U12
            LB3 =  B(I,J,11, 3) - LB1*U13 - LB2*U23
            LB4 =  B(I,J,11, 4) - LB1*U14 - LB2*U24 - LB3*U34
            LB5 =  B(I,J,11, 5) - LB1*U15 - LB2*U25 - LB3*U35 - LB4*U45
            LB6 =  B(I,J,11, 6) - LB1*U16 - LB2*U26 - LB3*U36 - LB4*U46
     1                          - LB5*U56
            LB7 =  B(I,J,11, 7) - LB1*U17 - LB2*U27 - LB3*U37 - LB4*U47
     1                          - LB5*U57 - LB6*U67
            LB8 =  B(I,J,11, 8) - LB1*U18 - LB2*U28 - LB3*U38 - LB4*U48
     1                          - LB5*U58 - LB6*U68 - LB7*U78
            LB9 =  B(I,J,11, 9) - LB1*U19 - LB2*U29 - LB3*U39 - LB4*U49
     1                          - LB5*U59 - LB6*U69 - LB7*U79 - LB8*U89
            LBA =  B(I,J,11,10) - LB1*U1A - LB2*U2A - LB3*U3A - LB4*U4A
     1                          - LB5*U5A - LB6*U6A - LB7*U7A - LB8*U8A
     2                          - LB9*U9A
            LBB =  B(I,J,11,11) - LB1*U1B - LB2*U2B - LB3*U3B - LB4*U4B
     1                          - LB5*U5B - LB6*U6B - LB7*U7B - LB8*U8B
     2                          - LB9*U9B - LBA*UAB
            UBC = (B(I,J,11,12) - LB1*U1C - LB2*U2C - LB3*U3C - LB4*U4C
     1                          - LB5*U5C - LB6*U6C - LB7*U7C - LB8*U8C
     2                          - LB9*U9C - LBA*UAC) / LBB
C
C Row 12
C
            LC1 =  B(I,J,12, 1)
            LC2 =  B(I,J,12, 2) - LC1*U12
            LC3 =  B(I,J,12, 3) - LC1*U13 - LC2*U23
            LC4 =  B(I,J,12, 4) - LC1*U14 - LC2*U24 - LC3*U34
            LC5 =  B(I,J,12, 5) - LC1*U15 - LC2*U25 - LC3*U35 - LC4*U45
            LC6 =  B(I,J,12, 6) - LC1*U16 - LC2*U26 - LC3*U36 - LC4*U46
     1                          - LC5*U56
            LC7 =  B(I,J,12, 7) - LC1*U17 - LC2*U27 - LC3*U37 - LC4*U47
     1                          - LC5*U57 - LC6*U67
            LC8 =  B(I,J,12, 8) - LC1*U18 - LC2*U28 - LC3*U38 - LC4*U48
     1                          - LC5*U58 - LC6*U68 - LC7*U78
            LC9 =  B(I,J,12, 9) - LC1*U19 - LC2*U29 - LC3*U39 - LC4*U49
     1                          - LC5*U59 - LC6*U69 - LC7*U79 - LC8*U89
            LCA =  B(I,J,12,10) - LC1*U1A - LC2*U2A - LC3*U3A - LC4*U4A
     1                          - LC5*U5A - LC6*U6A - LC7*U7A - LC8*U8A
     2                          - LC9*U9A
            LCB =  B(I,J,12,11) - LC1*U1B - LC2*U2B - LC3*U3B - LC4*U4B
     1                          - LC5*U5B - LC6*U6B - LC7*U7B - LC8*U8B
     2                          - LC9*U9B - LCA*UAB
            LCC =  B(I,J,12,12) - LC1*U1C - LC2*U2C - LC3*U3C - LC4*U4C
     1                          - LC5*U5C - LC6*U6C - LC7*U7C - LC8*U8C
     2                          - LC9*U9C - LCA*UAC - LCB*UBC
C
C     Calculate B(-1) * R
C
            R1        =  R(I,J, 1) / L11
            R2        = (R(I,J, 2) - L21*R1) / L22
            R3        = (R(I,J, 3) - L31*R1 - L32*R2) / L33
            R4        = (R(I,J, 4) - L41*R1 - L42*R2 - L43*R3) / L44
            R5        = (R(I,J, 5) - L51*R1 - L52*R2 - L53*R3 - L54*R4)
     1                  / L55
            R6        = (R(I,J, 6) - L61*R1 - L62*R2 - L63*R3 - L64*R4
     1                             - L65*R5) / L66
            R7        = (R(I,J, 7) - L71*R1 - L72*R2 - L73*R3 - L74*R4
     1                             - L75*R5 - L76*R6) / L77
            R8        = (R(I,J, 8) - L81*R1 - L82*R2 - L83*R3 - L84*R4
     1                             - L85*R5 - L86*R6 - L87*R7) / L88
            R9        = (R(I,J, 9) - L91*R1 - L92*R2 - L93*R3 - L94*R4
     1                             - L95*R5 - L96*R6 - L97*R7 - L98*R8)
     2                  / L99
            RA        = (R(I,J,10) - LA1*R1 - LA2*R2 - LA3*R3 - LA4*R4
     1                             - LA5*R5 - LA6*R6 - LA7*R7 - LA8*R8
     2                             - LA9*R9) / LAA
            RB        = (R(I,J,11) - LB1*R1 - LB2*R2 - LB3*R3 - LB4*R4
     1                             - LB5*R5 - LB6*R6 - LB7*R7 - LB8*R8
     2                             - LB9*R9 - LBA*RA) / LBB
            RC        = (R(I,J,12) - LC1*R1 - LC2*R2 - LC3*R3 - LC4*R4
     1                             - LC5*R5 - LC6*R6 - LC7*R7 - LC8*R8
     2                             - LC9*R9 - LCA*RA - LCB*RB) / LCC
            R(I,J,12) = RC
            R(I,J,11) = RB-UBC*R(I,J,12)
            R(I,J,10) = RA-UAC*R(I,J,12)-UAB*R(I,J,11)
            R(I,J, 9) = R9-U9C*R(I,J,12)-U9B*R(I,J,11)-U9A*R(I,J,10)
            R(I,J, 8) = R8-U8C*R(I,J,12)-U8B*R(I,J,11)-U8A*R(I,J,10)
     1                    -U89*R(I,J, 9)
            R(I,J, 7) = R7-U7C*R(I,J,12)-U7B*R(I,J,11)-U7A*R(I,J,10)
     1                    -U79*R(I,J, 9)-U78*R(I,J, 8)
            R(I,J, 6) = R6-U6C*R(I,J,12)-U6B*R(I,J,11)-U6A*R(I,J,10)
     1                    -U69*R(I,J, 9)-U68*R(I,J, 8)-U67*R(I,J, 7)
            R(I,J, 5) = R5-U5C*R(I,J,12)-U5B*R(I,J,11)-U5A*R(I,J,10)
     1                    -U59*R(I,J, 9)-U58*R(I,J, 8)-U57*R(I,J, 7)
     2                    -U56*R(I,J, 6)
            R(I,J, 4) = R4-U4C*R(I,J,12)-U4B*R(I,J,11)-U4A*R(I,J,10)
     1                    -U49*R(I,J, 9)-U48*R(I,J, 8)-U47*R(I,J, 7)
     2                    -U46*R(I,J, 6)-U45*R(I,J, 5)
            R(I,J, 3) = R3-U3C*R(I,J,12)-U3B*R(I,J,11)-U3A*R(I,J,10)
     1                    -U39*R(I,J, 9)-U38*R(I,J, 8)-U37*R(I,J, 7)
     2                    -U36*R(I,J, 6)-U35*R(I,J, 5)-U34*R(I,J, 4)
            R(I,J, 2) = R2-U2C*R(I,J,12)-U2B*R(I,J,11)-U2A*R(I,J,10)
     1                    -U29*R(I,J, 9)-U28*R(I,J, 8)-U27*R(I,J, 7)
     2                    -U26*R(I,J, 6)-U25*R(I,J, 5)-U24*R(I,J, 4)
     3                    -U23*R(I,J, 3)
            R(I,J, 1) = R1-U1C*R(I,J,12)-U1B*R(I,J,11)-U1A*R(I,J,10)
     1                    -U19*R(I,J, 9)-U18*R(I,J, 8)-U17*R(I,J, 7)
     2                    -U16*R(I,J, 6)-U15*R(I,J, 5)-U14*R(I,J, 4)
     3                    -U13*R(I,J, 3)-U12*R(I,J, 2)
  190    CONTINUE
  200 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VFBTR (NPTS, NSIM, IRANK, A, B, C, R)
C
C     Routine to perform the Forward/Backward substitution sweeps on
C     a block tridiagonal system where A, B and C contain
C     the LU decomposition of the block tridiagonal system.
C
C     VLUTR5 calculates the LU decomposition of the block tridiagonal system
C     VFBTR5 performs the forward/backward sweeps to complete the inversion
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     IRANK:     The rank of the system to invert
C     A:         The supra-diagonal block 7x7 of L
C     B:         The lu decomposition of the diagonal block 7x7 of L
C     C:         The super-diagonal block 7x7 of U
C     R:         The right hand side
C
      include 'common.inc'
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK),
     3          R (NSIM,NPTS,NRANK)
C
      IF (IRANK .EQ. 5) THEN
         CALL VFBTR5 (NPTS, NSIM, A, B, C, R)
      ELSE IF (IRANK .EQ. 7) THEN
         CALL VFBTR7 (NPTS, NSIM, NRANK, A, B, C, R)
      ELSE IF (IRANK .EQ. 12) THEN
         CALL VFBT12 (NPTS, NSIM, NRANK, A, B, C, R)
      ELSE
         WRITE (IOUT,1000) IRANK, IRANK
         STOP
      ENDIF
C
C     Finished
      RETURN
 1000 FORMAT (' ','Block solver required for a ',I3,' x ',I3,' block.',
     1       /' ','This solver does not exist.  Run Aborting.')
      END
      SUBROUTINE VFBTR5 (NPTS, NSIM, A, B, C, R)
C
C     Routine to perform the Forward/Backward substitution sweeps on
C     a 5x5 block tridiagonal system where A, B and C contain
C     the LU decomposition of the block tridiagonal system.
C
C     VLUTR5 calculates the LU decomposition of the block tridiagonal system
C     VFBTR5 performs the forward/backward sweeps to complete the inversion
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     A:         The supra-diagonal block 5x5 of L
C     B:         The lu decomposition of the diagonal block 5x5 of L
C     C:         The super-diagonal block 5x5 of U
C     R:         The right hand side
C
C     A, B and C are unmodified by this routine
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS,5,5),
     1          B (NSIM,NPTS,5,5),
     2          C (NSIM,NPTS,5,5),
     3          R (NSIM,NPTS,5)
C
C     Forward Substitution Loop
C
C     J = 1
C
      J = 1
      DO 10 I = 1, NSIM
C
C     Calculate L[inverse](i,i) * R
C
         R1       =  R(I,J,1) / B(I,J,1,1)
         R2       = (R(I,J,2)-B(I,J,2,1)*R1) / B(I,J,2,2)
         R3       = (R(I,J,3)-B(I,J,3,1)*R1-B(I,J,3,2)*R2) / B(I,J,3,3)
         R4       = (R(I,J,4)-B(I,J,4,1)*R1-B(I,J,4,2)*R2
     1                       -B(I,J,4,3)*R3)               / B(I,J,4,4)
         R(I,J,5) = (R(I,J,5)-B(I,J,5,1)*R1-B(I,J,5,2)*R2
     1                       -B(I,J,5,3)*R3-B(I,J,5,4)*R4) / B(I,J,5,5)
         R(I,J,4) =  R4-B(I,J,4,5)*R(I,J,5)
         R(I,J,3) =  R3-B(I,J,3,5)*R(I,J,5)-B(I,J,3,4)*R(I,J,4)
         R(I,J,2) =  R2-B(I,J,2,5)*R(I,J,5)-B(I,J,2,4)*R(I,J,4)
     1                 -B(I,J,2,3)*R(I,J,3)
         R(I,J,1) =  R1-B(I,J,1,5)*R(I,J,5)-B(I,J,1,4)*R(I,J,4)
     1                 -B(I,J,1,3)*R(I,J,3)-B(I,J,1,2)*R(I,J,2)
   10 CONTINUE
C
C     Loop over the interior of the inversion - 2 to NPTS
C
      DO 200 J = 2, NPTS
C
C     R = R - L(i,i-1)*R(j-1)
C
         DO 160 l = 1, 5
            DO 150 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - A(I,J,L,1)*R(I,J-1,1) - A(I,J,L,2)*R(I,J-1,2)
     2                  - A(I,J,L,3)*R(I,J-1,3) - A(I,J,L,4)*R(I,J-1,4)
     3                  - A(I,J,L,5)*R(I,J-1,5)
  150       CONTINUE
  160    CONTINUE
C
C     Normalize row by multiplication of L[inverse](i,i) to get unity diagonal
C
         DO 190 I = 1, NSIM
C
C     Calculate L[inverse](i,i) * R
C
            R1       =  R(I,J,1) / B(I,J,1,1)
            R2       = (R(I,J,2)-B(I,J,2,1)*R1) / B(I,J,2,2)
            R3       = (R(I,J,3)-B(I,J,3,1)*R1-B(I,J,3,2)*R2)/B(I,J,3,3)
            R4       = (R(I,J,4)-B(I,J,4,1)*R1-B(I,J,4,2)*R2
     1                          -B(I,J,4,3)*R3)              /B(I,J,4,4)
            R(I,J,5) = (R(I,J,5)-B(I,J,5,1)*R1-B(I,J,5,2)*R2
     1                          -B(I,J,5,3)*R3-B(I,J,5,4)*R4)/B(I,J,5,5)
            R(I,J,4) =  R4-B(I,J,4,5)*R(I,J,5)
            R(I,J,3) =  R3-B(I,J,3,5)*R(I,J,5)-B(I,J,3,4)*R(I,J,4)
            R(I,J,2) =  R2-B(I,J,2,5)*R(I,J,5)-B(I,J,2,4)*R(I,J,4)
     1                    -B(I,J,2,3)*R(I,J,3)
            R(I,J,1) =  R1-B(I,J,1,5)*R(I,J,5)-B(I,J,1,4)*R(I,J,4)
     1                    -B(I,J,1,3)*R(I,J,3)-B(I,J,1,2)*R(I,J,2)
  190    CONTINUE
  200 CONTINUE
C
C     Backward Substitution Sweep - Invert U
C
      DO 400 J = NPTS-1, 1, -1
         DO 390 L = 1, 5
            DO 380 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - C(I,J,L,1)*R(I,J+1,1)
     2                  - C(I,J,L,2)*R(I,J+1,2)
     3                  - C(I,J,L,3)*R(I,J+1,3)
     4                  - C(I,J,L,4)*R(I,J+1,4)
     5                  - C(I,J,L,5)*R(I,J+1,5)
  380       CONTINUE
  390    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VFBTR7 (NPTS, NSIM, NRANK, A, B, C, R)
C
C     Routine to perform the Forward/Backward substitution sweeps on
C     a 7x7 block tridiagonal system where A, B and C contain
C     the LU decomposition of the block tridiagonal system.
C
C     VLUTR5 calculates the LU decomposition of the block tridiagonal system
C     VFBTR5 performs the forward/backward sweeps to complete the inversion
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage
C     A:         The supra-diagonal block 7x7 of L
C     B:         The lu decomposition of the diagonal block 7x7 of L
C     C:         The super-diagonal block 7x7 of U
C     R:         The right hand side
C
C     A, B and C are unmodified by this routine
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK),
     3          R (NSIM,NPTS,NRANK)
C
C     Forward Substitution Loop
C
C     J = 1
C
      J = 1
      DO 10 I = 1, NSIM
C
C     Calculate L[inverse](i,i) * R
C
         R1       =  R(I,J,1) / B(I,J,1,1)
         R2       = (R(I,J,2)-B(I,J,2,1)*R1) / B(I,J,2,2)
         R3       = (R(I,J,3)-B(I,J,3,1)*R1-B(I,J,3,2)*R2)/B(I,J,3,3)
         R4       = (R(I,J,4)-B(I,J,4,1)*R1-B(I,J,4,2)*R2
     1                       -B(I,J,4,3)*R3)              /B(I,J,4,4)
         R5       = (R(I,J,5)-B(I,J,5,1)*R1-B(I,J,5,2)*R2
     1                       -B(I,J,5,3)*R3-B(I,J,5,4)*R4)/B(I,J,5,5)
         R6       = (R(I,J,6)-B(I,J,6,1)*R1-B(I,J,6,2)*R2
     1                       -B(I,J,6,3)*R3-B(I,J,6,4)*R4
     2                       -B(I,J,6,5)*R5              )/B(I,J,6,6)
         R(I,J,7) = (R(I,J,7)-B(I,J,7,1)*R1-B(I,J,7,2)*R2
     1                       -B(I,J,7,3)*R3-B(I,J,7,4)*R4
     2                       -B(I,J,7,5)*R5-B(I,J,7,6)*R6)/B(I,J,7,7)
         R(I,J,6) =  R6-B(I,J,6,7)*R(I,J,7)
         R(I,J,5) =  R5-B(I,J,5,7)*R(I,J,7)-B(I,J,5,6)*R(I,J,6)
         R(I,J,4) =  R4-B(I,J,4,7)*R(I,J,7)-B(I,J,4,6)*R(I,J,6)
     1                 -B(I,J,4,5)*R(I,J,5)
         R(I,J,3) =  R3-B(I,J,3,7)*R(I,J,7)-B(I,J,3,6)*R(I,J,6)
     1                 -B(I,J,3,5)*R(I,J,5)-B(I,J,3,4)*R(I,J,4)
         R(I,J,2) =  R2-B(I,J,2,7)*R(I,J,7)-B(I,J,2,6)*R(I,J,6)
     1                 -B(I,J,2,5)*R(I,J,5)-B(I,J,2,4)*R(I,J,4)
     2                 -B(I,J,2,3)*R(I,J,3)
         R(I,J,1) =  R1-B(I,J,1,7)*R(I,J,7)-B(I,J,1,6)*R(I,J,6)
     1                 -B(I,J,1,5)*R(I,J,5)-B(I,J,1,4)*R(I,J,4)
     2                 -B(I,J,1,3)*R(I,J,3)-B(I,J,1,2)*R(I,J,2)
   10 CONTINUE
C
C     Loop over the interior of the inversion - 2 to NPTS
C
      DO 200 J = 2, NPTS
C
C     R = R - L(i,i-1)*R(j-1)
C
         DO 160 l = 1, 7
            DO 150 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - A(I,J,L,1)*R(I,J-1,1) - A(I,J,L,2)*R(I,J-1,2)
     2                  - A(I,J,L,3)*R(I,J-1,3) - A(I,J,L,4)*R(I,J-1,4)
     3                  - A(I,J,L,5)*R(I,J-1,5) - A(I,J,L,6)*R(I,J-1,6)
     4                  - A(I,J,L,7)*R(I,J-1,7)
  150       CONTINUE
  160    CONTINUE
C
C     Normalize row by multiplication of L[inverse](i,i) to get unity diagonal
C
         DO 190 I = 1, NSIM
C
C     Calculate L[inverse](i,i) * R
C
            R1       =  R(I,J,1) / B(I,J,1,1)
            R2       = (R(I,J,2)-B(I,J,2,1)*R1) / B(I,J,2,2)
            R3       = (R(I,J,3)-B(I,J,3,1)*R1-B(I,J,3,2)*R2)/B(I,J,3,3)
            R4       = (R(I,J,4)-B(I,J,4,1)*R1-B(I,J,4,2)*R2
     1                          -B(I,J,4,3)*R3)              /B(I,J,4,4)
            R5       = (R(I,J,5)-B(I,J,5,1)*R1-B(I,J,5,2)*R2
     1                          -B(I,J,5,3)*R3-B(I,J,5,4)*R4)/B(I,J,5,5)
            R6       = (R(I,J,6)-B(I,J,6,1)*R1-B(I,J,6,2)*R2
     1                          -B(I,J,6,3)*R3-B(I,J,6,4)*R4
     2                          -B(I,J,6,5)*R5              )/B(I,J,6,6)
            R(I,J,7) = (R(I,J,7)-B(I,J,7,1)*R1-B(I,J,7,2)*R2
     1                          -B(I,J,7,3)*R3-B(I,J,7,4)*R4
     2                          -B(I,J,7,5)*R5-B(I,J,7,6)*R6)/B(I,J,7,7)
            R(I,J,6) =  R6-B(I,J,6,7)*R(I,J,7)
            R(I,J,5) =  R5-B(I,J,5,7)*R(I,J,7)-B(I,J,5,6)*R(I,J,6)
            R(I,J,4) =  R4-B(I,J,4,7)*R(I,J,7)-B(I,J,4,6)*R(I,J,6)
     1                    -B(I,J,4,5)*R(I,J,5)
            R(I,J,3) =  R3-B(I,J,3,7)*R(I,J,7)-B(I,J,3,6)*R(I,J,6)
     1                    -B(I,J,3,5)*R(I,J,5)-B(I,J,3,4)*R(I,J,4)
            R(I,J,2) =  R2-B(I,J,2,7)*R(I,J,7)-B(I,J,2,6)*R(I,J,6)
     1                    -B(I,J,2,5)*R(I,J,5)-B(I,J,2,4)*R(I,J,4)
     2                    -B(I,J,2,3)*R(I,J,3)
            R(I,J,1) =  R1-B(I,J,1,7)*R(I,J,7)-B(I,J,1,6)*R(I,J,6)
     1                    -B(I,J,1,5)*R(I,J,5)-B(I,J,1,4)*R(I,J,4)
     2                    -B(I,J,1,3)*R(I,J,3)-B(I,J,1,2)*R(I,J,2)
  190    CONTINUE
  200 CONTINUE
C
C     Backward Substitution Sweep - Invert U
C
      DO 400 J = NPTS-1, 1, -1
         DO 390 L = 1, 7
            DO 380 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - C(I,J,L,1)*R(I,J+1,1)
     2                  - C(I,J,L,2)*R(I,J+1,2)
     3                  - C(I,J,L,3)*R(I,J+1,3)
     4                  - C(I,J,L,4)*R(I,J+1,4)
     5                  - C(I,J,L,5)*R(I,J+1,5)
     6                  - C(I,J,L,6)*R(I,J+1,6)
     7                  - C(I,J,L,7)*R(I,J+1,7)
  380       CONTINUE
  390    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VFBT12 (NPTS, NSIM, NRANK, A, B, C, R)
C
C     Routine to perform the Forward/Backward substitution sweeps on
C     a 12x12 block tridiagonal system where A, B and C contain
C     the LU decomposition of the block tridiagonal system.
C
C     VLUTR5 calculates the LU decomposition of the block tridiagonal system
C     VFBTR5 performs the forward/backward sweeps to complete the inversion
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage
C     A:         The supra-diagonal block 12x12 of L
C     B:         The lu decomposition of the diagonal block 12x12 of L
C     C:         The super-diagonal block 12x12 of U
C     R:         The right hand side
C
C     A, B and C are unmodified by this routine
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK),
     3          R (NSIM,NPTS,NRANK)
C
C     Forward Substitution Loop
C
C     Loop over the number of points - 1 to NPTS
C
      DO 200 J = 1, NPTS
C
C     R = R - L(i,i-1)*R(j-1)
C
         IF (J .NE. 1) THEN
            DO 160 l = 1, 12
               DO 150 I = 1, NSIM
                  R(I,J,L) = R(I,J,L)
     1              - A(I,J,L, 1)*R(I,J-1, 1) - A(I,J,L, 2)*R(I,J-1, 2)
     2              - A(I,J,L, 3)*R(I,J-1, 3) - A(I,J,L, 4)*R(I,J-1, 4)
     3              - A(I,J,L, 5)*R(I,J-1, 5) - A(I,J,L, 6)*R(I,J-1, 6)
     4              - A(I,J,L, 7)*R(I,J-1, 7) - A(I,J,L, 8)*R(I,J-1, 8)
     5              - A(I,J,L, 9)*R(I,J-1, 9) - A(I,J,L,10)*R(I,J-1,10)
     6              - A(I,J,L,11)*R(I,J-1,11) - A(I,J,L,12)*R(I,J-1,12)
  150          CONTINUE
  160       CONTINUE
         ENDIF
C
C     Normalize row by multiplication of L[inverse](i,i) to get unity diagonal
C
         DO 190 I = 1, NSIM
C
C     Calculate L[inverse](i,i) * R
C
            R1       =  R(I,J,1) / B(I,J,1,1)
            R2       = (R(I,J,2)-B(I,J,2,1)*R1) / B(I,J,2,2)
            R3       = (R(I,J,3)-B(I,J,3,1)*R1-B(I,J,3,2)*R2)/B(I,J,3,3)
            R4       = (R(I,J,4)-B(I,J,4,1)*R1-B(I,J,4,2)*R2
     1                          -B(I,J,4,3)*R3)              /B(I,J,4,4)
            R5       = (R(I,J,5)-B(I,J,5,1)*R1-B(I,J,5,2)*R2
     1                          -B(I,J,5,3)*R3-B(I,J,5,4)*R4)/B(I,J,5,5)
            R6       = (R(I,J,6)-B(I,J,6,1)*R1-B(I,J,6,2)*R2
     1                          -B(I,J,6,3)*R3-B(I,J,6,4)*R4
     2                          -B(I,J,6,5)*R5              )/B(I,J,6,6)
            R7       = (R(I,J,7)-B(I,J,7,1)*R1-B(I,J,7,2)*R2
     1                          -B(I,J,7,3)*R3-B(I,J,7,4)*R4
     2                          -B(I,J,7,5)*R5-B(I,J,7,6)*R6)/B(I,J,7,7)
            R8       = (R(I,J,8)-B(I,J,8,1)*R1-B(I,J,8,2)*R2
     1                          -B(I,J,8,3)*R3-B(I,J,8,4)*R4
     2                          -B(I,J,8,5)*R5-B(I,J,8,6)*R6
     3                          -B(I,J,8,7)*R7              )/B(I,J,8,8)
            R9       = (R(I,J,9)-B(I,J,9,1)*R1-B(I,J,9,2)*R2
     1                          -B(I,J,9,3)*R3-B(I,J,9,4)*R4
     2                          -B(I,J,9,5)*R5-B(I,J,9,6)*R6
     3                          -B(I,J,9,7)*R7-B(I,J,9,8)*R8)/B(I,J,9,9)
            R10      = (R(I,J,10)-B(I,J,10,1)*R1-B(I,J,10,2)*R2
     1                           -B(I,J,10,3)*R3-B(I,J,10,4)*R4
     2                           -B(I,J,10,5)*R5-B(I,J,10,6)*R6
     3                           -B(I,J,10,7)*R7-B(I,J,10,8)*R8
     4                           -B(I,J,10,9)*R9               )
     5                                                     /B(I,J,10,10)
            R11      = (R(I,J,11)-B(I,J,11,1)*R1-B(I,J,11,2)*R2
     1                           -B(I,J,11,3)*R3-B(I,J,11,4)*R4
     2                           -B(I,J,11,5)*R5-B(I,J,11,6)*R6
     3                           -B(I,J,11,7)*R7-B(I,J,11,8)*R8
     4                           -B(I,J,11,9)*R9-B(I,J,11,10)*R10)
     5                                                     /B(I,J,11,11)
            R(I,J,12)= (R(I,J,12)-B(I,J,12,1)*R1-B(I,J,12,2)*R2
     1                           -B(I,J,12,3)*R3-B(I,J,12,4)*R4
     2                           -B(I,J,12,5)*R5-B(I,J,12,6)*R6
     3                           -B(I,J,12,7)*R7-B(I,J,12,8)*R8
     4                           -B(I,J,12,9)*R9-B(I,J,12,10)*R10
     5                           -B(I,J,12,11)*R11)        /B(I,J,12,12)
            R(I,J,11)= R11-B(I,J,11,12)*R(I,J,12)
            R(I,J,10)= R10-B(I,J,10,12)*R(I,J,12)-B(I,J,10,11)*R(I,J,11)
            R(I,J,9) = R9 -B(I,J, 9,12)*R(I,J,12)-B(I,J, 9,11)*R(I,J,11)
     1                    -B(I,J, 9,10)*R(I,J,10)
            R(I,J,8) = R8 -B(I,J, 8,12)*R(I,J,12)-B(I,J, 8,11)*R(I,J,11)
     1                    -B(I,J, 8,10)*R(I,J,10)-B(I,J, 8, 9)*R(I,J, 9)
            R(I,J,7) = R7 -B(I,J, 7,12)*R(I,J,12)-B(I,J, 7,11)*R(I,J,11)
     1                    -B(I,J, 7,10)*R(I,J,10)-B(I,J, 7, 9)*R(I,J, 9)
     2                    -B(I,J, 7, 8)*R(I,J, 8)
            R(I,J,6) = R6 -B(I,J, 6,12)*R(I,J,12)-B(I,J, 6,11)*R(I,J,11)
     1                    -B(I,J, 6,10)*R(I,J,10)-B(I,J, 6, 9)*R(I,J, 9)
     2                    -B(I,J, 6, 8)*R(I,J, 8)-B(I,J, 6, 7)*R(I,J, 7)
            R(I,J,5) = R5 -B(I,J, 5,12)*R(I,J,12)-B(I,J, 5,11)*R(I,J,11)
     1                    -B(I,J, 5,10)*R(I,J,10)-B(I,J, 5, 9)*R(I,J, 9)
     2                    -B(I,J, 5, 8)*R(I,J, 8)-B(I,J, 5, 7)*R(I,J, 7)
     3                    -B(I,J, 5, 6)*R(I,J, 6)
            R(I,J,4) = R4 -B(I,J, 4,12)*R(I,J,12)-B(I,J, 4,11)*R(I,J,11)
     1                    -B(I,J, 4,10)*R(I,J,10)-B(I,J, 4, 9)*R(I,J, 9)
     2                    -B(I,J, 4, 8)*R(I,J, 8)-B(I,J, 4, 7)*R(I,J, 7)
     3                    -B(I,J, 4, 6)*R(I,J, 6)-B(I,J, 4, 5)*R(I,J, 5)
            R(I,J,3) = R3 -B(I,J, 3,12)*R(I,J,12)-B(I,J, 3,11)*R(I,J,11)
     1                    -B(I,J, 3,10)*R(I,J,10)-B(I,J, 3, 9)*R(I,J, 9)
     2                    -B(I,J, 3, 8)*R(I,J, 8)-B(I,J, 3, 7)*R(I,J, 7)
     3                    -B(I,J, 3, 6)*R(I,J, 6)-B(I,J, 3, 5)*R(I,J, 5)
     4                    -B(I,J, 3, 4)*R(I,J, 4)
            R(I,J,2) = R2 -B(I,J, 2,12)*R(I,J,12)-B(I,J, 2,11)*R(I,J,11)
     1                    -B(I,J, 2,10)*R(I,J,10)-B(I,J, 2, 9)*R(I,J, 9)
     2                    -B(I,J, 2, 8)*R(I,J, 8)-B(I,J, 2, 7)*R(I,J, 7)
     3                    -B(I,J, 2, 6)*R(I,J, 6)-B(I,J, 2, 5)*R(I,J, 5)
     4                    -B(I,J, 2, 4)*R(I,J, 4)-B(I,J, 2, 3)*R(I,J, 3)
            R(I,J,1) = R1 -B(I,J, 1,12)*R(I,J,12)-B(I,J, 1,11)*R(I,J,11)
     1                    -B(I,J, 1,10)*R(I,J,10)-B(I,J, 1, 9)*R(I,J, 9)
     2                    -B(I,J, 1, 8)*R(I,J, 8)-B(I,J, 1, 7)*R(I,J, 7)
     3                    -B(I,J, 1, 6)*R(I,J, 6)-B(I,J, 1, 5)*R(I,J, 5)
     4                    -B(I,J, 1, 4)*R(I,J, 4)-B(I,J, 1, 3)*R(I,J, 3)
     5                    -B(I,J, 1, 2)*R(I,J, 2)
  190    CONTINUE
  200 CONTINUE
C
C     Backward Substitution Sweep - Invert U
C
      DO 400 J = NPTS-1, 1, -1
         DO 390 L = 1, 12
            DO 380 I = 1, NSIM
               R(I,J,L) = R(I,J,L)
     1                  - C(I,J,L, 1)*R(I,J+1, 1)
     2                  - C(I,J,L, 2)*R(I,J+1, 2)
     3                  - C(I,J,L, 3)*R(I,J+1, 3)
     4                  - C(I,J,L, 4)*R(I,J+1, 4)
     5                  - C(I,J,L, 5)*R(I,J+1, 5)
     6                  - C(I,J,L, 6)*R(I,J+1, 6)
     7                  - C(I,J,L, 7)*R(I,J+1, 7)
     8                  - C(I,J,L, 8)*R(I,J+1, 8)
     9                  - C(I,J,L, 9)*R(I,J+1, 9)
     A                  - C(I,J,L,10)*R(I,J+1,10)
     B                  - C(I,J,L,11)*R(I,J+1,11)
     C                  - C(I,J,L,12)*R(I,J+1,12)
  380       CONTINUE
  390    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VFBTRS (NPTS, NSIM, A, B, C, R)
C
C     Routine to perform the Forward/Backward substitution sweeps on
C     a scalar tridiagonal system where A, B and C contain
C     the LU decomposition of the block tridiagonal system.
C
C     VLUTRS calculates the LU decomposition of the scalar tridiagonal system
C     VFBTRS performs the forward/backward sweeps to complete the inversion
C
C     NPTS:      The number of
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     A:         The supra-diagonal element of L
C     B:         The lu decomposition of the diagonal element of L
C     C:         The super-diagonal element of U
C     R:         The right hand side
C
C     A, B and C are unmodified by this routine
C     R contains the solution vector at return
C
C     The storage of the system is such that vectorization occurs over
C     the first index to provide a unit stride for maximum speed.
C
      DIMENSION A (NSIM,NPTS),
     1          B (NSIM,NPTS),
     2          C (NSIM,NPTS),
     3          R (NSIM,NPTS)
C
C     Forward Substitution Loop
C
C     J = 1
C     Calculate L[inverse](i,i) * R
C
      J = 1
      DO 10 I = 1, NSIM
         R(I,J) = R(I,J) / B(I,J)
   10 CONTINUE
C
C     Loop over the interior of the inversion - 2 to NPTS
C
      DO 200 J = 2, NPTS
C
C     R = (R - L(i,i-1)*R(j-1)) / L(i,i)
C
         DO 150 I = 1, NSIM
            R(I,J) = (R(I,J) - A(I,J)*R(I,J-1)) / B(I,J)
  150    CONTINUE
  200 CONTINUE
C
C     Backward Substitution Sweep - Invert U
C
      DO 400 J = NPTS-1, 1, -1
         DO 350 I = 1, NSIM
            R(I,J) = R(I,J) - C(I,J)*R(I,J+1)
  350    CONTINUE
  400 CONTINUE
C
C     Finished
      RETURN
      END
      SUBROUTINE VLUTR (NPTS, NSIM, IRANK, A, B, C)
C
C     Routine to do a vectorized LU decomposition of a
C     block tridiagonal system of equations.
C     The recursive nature of the LU decomposition leads
C     to a form which is not vectorizable.  Therefore, the
C     approach of this routine is to not attempt vectorization
C     of the LU, but to accomplish the vectorization through
C     simulataneously doing NSIM LU decompositions.
C     This form is with the identity on the diagonal of U.
C
C     NPTS:      The number of elements in the tridiagonal system
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     IRANK:     The rank of the system to invert
C     A:         The supra-diagonal block 7x7 term
C     B:         The       diagonal block 7x7 term
C     C:         The super-diagonal block 7x7 term
C
C     On Exit:
C     A:         L(j,j-1) The supra-diagonal term of L
C     B:         The non-pivoted lu decomposition of L(i,i)
C     C:         U(j,j+1) The super-diagonal term of U
C
      include 'common.inc'
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK)
C
      IF (IRANK .EQ. 5) THEN
         CALL VLUTR5 (NPTS, NSIM, A, B, C)
      ELSE IF (IRANK .EQ. 7) THEN
         CALL VLUTR7 (NPTS, NSIM, NRANK, A, B, C)
      ELSE IF (IRANK .EQ. 12) THEN
         CALL VLUT12 (NPTS, NSIM, NRANK, A, B, C)
      ELSE
         WRITE (IOUT,1000) IRANK, IRANK
         STOP
      ENDIF
C
C     Finished forming LU
      RETURN
 1000 FORMAT (' ','Block solver required for a ',I3,' x ',I3,' block.',
     1       /' ','This solver does not exist.  Run Aborting.')
      END
      SUBROUTINE VLUTR5 (NPTS, NSIM, A, B, C)
C
C     Routine to do a vectorized LU decomposition of a
C     5x5 block tridiagonal system of equations.
C     The recursive nature of the LU decomposition leads
C     to a form which is not vectorizable.  Therefore, the
C     approach of this routine is to not attempt vectorization
C     of the LU, but to accomplish the vectorization through
C     simulataneously doing NSIM LU decompositions.
C     This form is with the identity on the diagonal of U.
C
C     NPTS:      The number of elements in the tridiagonal system
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     A:         The supra-diagonal block 5x5 term
C     B:         The       diagonal block 5x5 term
C     C:         The super-diagonal block 5x5 term
C
C     On Exit:
C     A:         L(j,j-1) The supra-diagonal term of L
C     B:         The non-pivoted lu decomposition of L(i,i)
C                (this is needed both to form the LU and to invert the system)
C
C                One 5x5 block of B is of the form:
C
C                         l(1,1) u(1,2) u(1,3) u(1,4) u(1,5)
C                         l(2,1) l(2,2) u(2,3) u(2,4) u(2,5)
C                B[i,i] = l(3,1) l(3,2) l(3,3) u(3,4) u(3,5)
C                         l(4,1) l(4,2) l(4,3) l(4,4) u(4,5)
C                         l(5,1) l(5,2) l(5,3) l(5,4) l(5,5)
C
C     C:         U(j,j+1) The super-diagonal term of U
C
C     L(i,i-1) = A(i) therefore no operations need to be performed on A.
C     L(i,i)   = B(i) - L(i,i-1)*U(i-1,i)
C     U(i,i+1) = L[inverse](i,i)*C(i)
C
      DIMENSION A (NSIM,NPTS,5,5),
     1          B (NSIM,NPTS,5,5),
     2          C (NSIM,NPTS,5,5)
C
C     Form L(1,1) and U(1,2)
C
      J = 1
C
C     Form the lu decomposition of L(1,1)
C
      DO 100 I = 1, NSIM
C
C     Row 1
C
         B(I,J,1,2) = B(I,J,1,2) / B(I,J,1,1)
         B(I,J,1,3) = B(I,J,1,3) / B(I,J,1,1)
         B(I,J,1,4) = B(I,J,1,4) / B(I,J,1,1)
         B(I,J,1,5) = B(I,J,1,5) / B(I,J,1,1)
C
C     Row 2
C
         B(I,J,2,2) =  B(I,J,2,2) - B(I,J,2,1) * B(I,J,1,2)
         B(I,J,2,3) = (B(I,J,2,3) - B(I,J,2,1)*B(I,J,1,3)) / B(I,J,2,2)
         B(I,J,2,4) = (B(I,J,2,4) - B(I,J,2,1)*B(I,J,1,4)) / B(I,J,2,2)
         B(I,J,2,5) = (B(I,J,2,5) - B(I,J,2,1)*B(I,J,1,5)) / B(I,J,2,2)
C
C     Row 3
C
         B(I,J,3,2) =  B(I,J,3,2) - B(I,J,3,1) * B(I,J,1,2)
         B(I,J,3,3) =  B(I,J,3,3) - B(I,J,3,1) * B(I,J,1,3)
     1                            - B(I,J,3,2) * B(I,J,2,3)
         B(I,J,3,4) = (B(I,J,3,4) - B(I,J,3,1)*B(I,J,1,4)
     1                            - B(I,J,3,2)*B(I,J,2,4)) / B(I,J,3,3)
         B(I,J,3,5) = (B(I,J,3,5) - B(I,J,3,1)*B(I,J,1,5)
     1                            - B(I,J,3,2)*B(I,J,2,5)) / B(I,J,3,3)
C
C     Row 4
C
         B(I,J,4,2) =  B(I,J,4,2) - B(I,J,4,1) * B(I,J,1,2)
         B(I,J,4,3) =  B(I,J,4,3) - B(I,J,4,1) * B(I,J,1,3)
     1                            - B(I,J,4,2) * B(I,J,2,3)
         B(I,J,4,4) =  B(I,J,4,4) - B(I,J,4,1) * B(I,J,1,4)
     1                            - B(I,J,4,2) * B(I,J,2,4)
     2                            - B(I,J,4,3) * B(I,J,3,4)
         B(I,J,4,5) = (B(I,J,4,5) - B(I,J,4,1)*B(I,J,1,5)
     1                            - B(I,J,4,2)*B(I,J,2,5)
     2                            - B(I,J,4,3)*B(I,J,3,5)) / B(I,J,4,4)
C
C     Row 5
C
         B(I,J,5,2) =  B(I,J,5,2) - B(I,J,5,1) * B(I,J,1,2)
         B(I,J,5,3) =  B(I,J,5,3) - B(I,J,5,1) * B(I,J,1,3)
     1                            - B(I,J,5,2) * B(I,J,2,3)
         B(I,J,5,4) =  B(I,J,5,4) - B(I,J,5,1) * B(I,J,1,4)
     1                            - B(I,J,5,2) * B(I,J,2,4)
     2                            - B(I,J,5,3) * B(I,J,3,4)
         B(I,J,5,5) =  B(I,J,5,5) - B(I,J,5,1) * B(I,J,1,5)
     1                            - B(I,J,5,2) * B(I,J,2,5)
     2                            - B(I,J,5,3) * B(I,J,3,5)
     3                            - B(I,J,5,4) * B(I,J,4,5)
 100  CONTINUE
C
C     Form U(1,2) = L[inverse](1,1) * C(1)
C
      DO 200 L = 1, 5
         DO 180 I = 1, NSIM
C
C     Forward sweep of lu decomposition to form L[inverse]
C
            C(I,J,1,L) = C(I,J,1,L) / B(I,J,1,1)
            C(I,J,2,L) = ( C(I,J,2,L) - B(I,J,2,1)*C(I,J,1,L) )
     1                   / B(I,J,2,2)
            C(I,J,3,L) = ( C(I,J,3,L) - B(I,J,3,1)*C(I,J,1,L)
     1                                - B(I,J,3,2)*C(I,J,2,L) )
     2                   / B(I,J,3,3)
            C(I,J,4,L) = ( C(I,J,4,L) - B(I,J,4,1)*C(I,J,1,L)
     1                                - B(I,J,4,2)*C(I,J,2,L)
     2                                - B(I,J,4,3)*C(I,J,3,L) )
     3                   / B(I,J,4,4)
            C(I,J,5,L) = ( C(I,J,5,L) - B(I,J,5,1)*C(I,J,1,L)
     1                                - B(I,J,5,2)*C(I,J,2,L)
     2                                - B(I,J,5,3)*C(I,J,3,L)
     3                                - B(I,J,5,4)*C(I,J,4,L) )
     4                   / B(I,J,5,5)
C
C     Backward Sweep of lu
C
            C(I,J,4,L) = C(I,J,4,L) - B(I,J,4,5)*C(I,J,5,L)
            C(I,J,3,L) = C(I,J,3,L) - B(I,J,3,4)*C(I,J,4,L)
     1                              - B(I,J,3,5)*C(I,J,5,L)
            C(I,J,2,L) = C(I,J,2,L) - B(I,J,2,3)*C(I,J,3,L)
     1                              - B(I,J,2,4)*C(I,J,4,L)
     2                              - B(I,J,2,5)*C(I,J,5,L)
            C(I,J,1,L) = C(I,J,1,L) - B(I,J,1,2)*C(I,J,2,L)
     1                              - B(I,J,1,3)*C(I,J,3,L)
     2                              - B(I,J,1,4)*C(I,J,4,L)
     3                              - B(I,J,1,5)*C(I,J,5,L)
 180     CONTINUE
 200  CONTINUE
C
C     Loop over J = 2 to NPTS forming the LU terms
C
      DO 600 J = 2, NPTS
C
C     Form L(i,i) = B(i) - L(i,i-1)*U(i-1,i)
C
         DO 300 L = 1, 5
            DO 280 M = 1, 5
               DO 260 I = 1, NSIM
                  B(I,J,L,M) = B(I,J,L,M) - A(I,J,L,1)*C(I,J-1,1,M)
     1                                    - A(I,J,L,2)*C(I,J-1,2,M)
     2                                    - A(I,J,L,3)*C(I,J-1,3,M)
     3                                    - A(I,J,L,4)*C(I,J-1,4,M)
     4                                    - A(I,J,L,5)*C(I,J-1,5,M)
 260           CONTINUE
 280        CONTINUE
 300     CONTINUE
C
C     Form lu of L(i,i)
C
         DO 400 I = 1, NSIM
C
C     Row 1
C
            B(I,J,1,2) = B(I,J,1,2) / B(I,J,1,1)
            B(I,J,1,3) = B(I,J,1,3) / B(I,J,1,1)
            B(I,J,1,4) = B(I,J,1,4) / B(I,J,1,1)
            B(I,J,1,5) = B(I,J,1,5) / B(I,J,1,1)
C
C     Row 2
C
            B(I,J,2,2) =  B(I,J,2,2) - B(I,J,2,1) * B(I,J,1,2)
            B(I,J,2,3) = (B(I,J,2,3) - B(I,J,2,1)*B(I,J,1,3))/B(I,J,2,2)
            B(I,J,2,4) = (B(I,J,2,4) - B(I,J,2,1)*B(I,J,1,4))/B(I,J,2,2)
            B(I,J,2,5) = (B(I,J,2,5) - B(I,J,2,1)*B(I,J,1,5))/B(I,J,2,2)
C
C     Row 3
C
            B(I,J,3,2) =  B(I,J,3,2) - B(I,J,3,1) * B(I,J,1,2)
            B(I,J,3,3) =  B(I,J,3,3) - B(I,J,3,1) * B(I,J,1,3)
     1                               - B(I,J,3,2) * B(I,J,2,3)
            B(I,J,3,4) = (B(I,J,3,4) - B(I,J,3,1)*B(I,J,1,4)
     1                               - B(I,J,3,2)*B(I,J,2,4))/B(I,J,3,3)
            B(I,J,3,5) = (B(I,J,3,5) - B(I,J,3,1)*B(I,J,1,5)
     1                               - B(I,J,3,2)*B(I,J,2,5))/B(I,J,3,3)
C
C     Row 4
C
            B(I,J,4,2) =  B(I,J,4,2) - B(I,J,4,1) * B(I,J,1,2)
            B(I,J,4,3) =  B(I,J,4,3) - B(I,J,4,1) * B(I,J,1,3)
     1                               - B(I,J,4,2) * B(I,J,2,3)
            B(I,J,4,4) =  B(I,J,4,4) - B(I,J,4,1) * B(I,J,1,4)
     1                               - B(I,J,4,2) * B(I,J,2,4)
     2                               - B(I,J,4,3) * B(I,J,3,4)
            B(I,J,4,5) = (B(I,J,4,5) - B(I,J,4,1)*B(I,J,1,5)
     1                               - B(I,J,4,2)*B(I,J,2,5)
     2                               - B(I,J,4,3)*B(I,J,3,5))/B(I,J,4,4)
C
C     Row 5
C
            B(I,J,5,2) =  B(I,J,5,2) - B(I,J,5,1) * B(I,J,1,2)
            B(I,J,5,3) =  B(I,J,5,3) - B(I,J,5,1) * B(I,J,1,3)
     1                               - B(I,J,5,2) * B(I,J,2,3)
            B(I,J,5,4) =  B(I,J,5,4) - B(I,J,5,1) * B(I,J,1,4)
     1                               - B(I,J,5,2) * B(I,J,2,4)
     2                               - B(I,J,5,3) * B(I,J,3,4)
            B(I,J,5,5) =  B(I,J,5,5) - B(I,J,5,1) * B(I,J,1,5)
     1                               - B(I,J,5,2) * B(I,J,2,5)
     2                               - B(I,J,5,3) * B(I,J,3,5)
     3                               - B(I,J,5,4) * B(I,J,4,5)
 400     CONTINUE
C
C     Form U(i,i+1) = L[inverse](i,i) * C(i) for all except last term
C
         IF (J .NE. NPTS) THEN
            DO 500 L = 1, 5
               DO 480 I = 1, NSIM
C
C     Forward sweep of lu decomposition to form L[inverse]
C
                  C(I,J,1,L) = C(I,J,1,L) / B(I,J,1,1)
                  C(I,J,2,L) = ( C(I,J,2,L) - B(I,J,2,1)*C(I,J,1,L) )
     1                         / B(I,J,2,2)
                  C(I,J,3,L) = ( C(I,J,3,L) - B(I,J,3,1)*C(I,J,1,L)
     1                                      - B(I,J,3,2)*C(I,J,2,L) )
     2                         / B(I,J,3,3)
                  C(I,J,4,L) = ( C(I,J,4,L) - B(I,J,4,1)*C(I,J,1,L)
     1                                      - B(I,J,4,2)*C(I,J,2,L)
     2                                      - B(I,J,4,3)*C(I,J,3,L) )
     3                         / B(I,J,4,4)
                  C(I,J,5,L) = ( C(I,J,5,L) - B(I,J,5,1)*C(I,J,1,L)
     1                                      - B(I,J,5,2)*C(I,J,2,L)
     2                                      - B(I,J,5,3)*C(I,J,3,L)
     3                                      - B(I,J,5,4)*C(I,J,4,L) )
     4                         / B(I,J,5,5)
C
C     Backward Sweep of lu
C
                  C(I,J,4,L) = C(I,J,4,L) - B(I,J,4,5)*C(I,J,5,L)
                  C(I,J,3,L) = C(I,J,3,L) - B(I,J,3,4)*C(I,J,4,L)
     1                                    - B(I,J,3,5)*C(I,J,5,L)
                  C(I,J,2,L) = C(I,J,2,L) - B(I,J,2,3)*C(I,J,3,L)
     1                                    - B(I,J,2,4)*C(I,J,4,L)
     2                                    - B(I,J,2,5)*C(I,J,5,L)
                  C(I,J,1,L) = C(I,J,1,L) - B(I,J,1,2)*C(I,J,2,L)
     1                                    - B(I,J,1,3)*C(I,J,3,L)
     2                                    - B(I,J,1,4)*C(I,J,4,L)
     3                                    - B(I,J,1,5)*C(I,J,5,L)
 480           CONTINUE
 500        CONTINUE
         ENDIF
 600  CONTINUE
C
C     Finished forming LU
      RETURN
      END
      SUBROUTINE VLUTR7 (NPTS, NSIM, NRANK, A, B, C)
C
C     Routine to do a vectorized LU decomposition of a
C     7x7 block tridiagonal system of equations.
C     The recursive nature of the LU decomposition leads
C     to a form which is not vectorizable.  Therefore, the
C     approach of this routine is to not attempt vectorization
C     of the LU, but to accomplish the vectorization through
C     simulataneously doing NSIM LU decompositions.
C     This form is with the identity on the diagonal of U.
C
C     NPTS:      The number of elements in the tridiagonal system
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage of the tri-diagonal system
C     A:         The supra-diagonal block 7x7 term
C     B:         The       diagonal block 7x7 term
C     C:         The super-diagonal block 7x7 term
C
C     On Exit:
C     A:         L(j,j-1) The supra-diagonal term of L
C     B:         The non-pivoted lu decomposition of L(i,i)
C                (this is needed both to form the LU and to invert the system)
C
C                One 7x7 block of B is of the form:
C
C                         l(1,1) u(1,2) u(1,3) u(1,4) u(1,5) u(1,6) u(1,7)
C                         l(2,1) l(2,2) u(2,3) u(2,4) u(2,5) u(2,6) u(2,7)
C                         l(3,1) l(3,2) l(3,3) u(3,4) u(3,5) u(3,6) u(3,7)
C                B[i,i] = l(4,1) l(4,2) l(4,3) l(4,4) u(4,5) u(4,6) u(4,7)
C                         l(5,1) l(5,2) l(5,3) l(5,4) l(5,5) u(5,6) u(5,7)
C                         l(6,1) l(6,2) l(6,3) l(6,4) l(6,5) l(6,6) u(6,7)
C                         l(7,1) l(7,2) l(7,3) l(7,4) l(7,5) l(7,6) l(7,7)
C
C     C:         U(j,j+1) The super-diagonal term of U
C
C     L(i,i-1) = A(i) therefore no operations need to be performed on A.
C     L(i,i)   = B(i) - L(i,i-1)*U(i-1,i)
C     U(i,i+1) = L[inverse](i,i)*C(i)
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK)
C
C     Form L(1,1) and U(1,2)
C
      J = 1
C
C     Form the lu decomposition of L(1,1)
C
      DO 100 I = 1, NSIM
C
C     Row 1
C
         B(I,J,1,2) = B(I,J,1,2) / B(I,J,1,1)
         B(I,J,1,3) = B(I,J,1,3) / B(I,J,1,1)
         B(I,J,1,4) = B(I,J,1,4) / B(I,J,1,1)
         B(I,J,1,5) = B(I,J,1,5) / B(I,J,1,1)
         B(I,J,1,6) = B(I,J,1,6) / B(I,J,1,1)
         B(I,J,1,7) = B(I,J,1,7) / B(I,J,1,1)
C
C     Row 2
C
         B(I,J,2,2) =  B(I,J,2,2) - B(I,J,2,1) * B(I,J,1,2)
         B(I,J,2,3) = (B(I,J,2,3) - B(I,J,2,1)*B(I,J,1,3)) / B(I,J,2,2)
         B(I,J,2,4) = (B(I,J,2,4) - B(I,J,2,1)*B(I,J,1,4)) / B(I,J,2,2)
         B(I,J,2,5) = (B(I,J,2,5) - B(I,J,2,1)*B(I,J,1,5)) / B(I,J,2,2)
         B(I,J,2,6) = (B(I,J,2,6) - B(I,J,2,1)*B(I,J,1,6)) / B(I,J,2,2)
         B(I,J,2,7) = (B(I,J,2,7) - B(I,J,2,1)*B(I,J,1,7)) / B(I,J,2,2)
C
C     Row 3
C
         B(I,J,3,2) =  B(I,J,3,2) - B(I,J,3,1) * B(I,J,1,2)
         B(I,J,3,3) =  B(I,J,3,3) - B(I,J,3,1) * B(I,J,1,3)
     1                            - B(I,J,3,2) * B(I,J,2,3)
         B(I,J,3,4) = (B(I,J,3,4) - B(I,J,3,1)*B(I,J,1,4)
     1                            - B(I,J,3,2)*B(I,J,2,4)) / B(I,J,3,3)
         B(I,J,3,5) = (B(I,J,3,5) - B(I,J,3,1)*B(I,J,1,5)
     1                            - B(I,J,3,2)*B(I,J,2,5)) / B(I,J,3,3)
         B(I,J,3,6) = (B(I,J,3,6) - B(I,J,3,1)*B(I,J,1,6)
     1                            - B(I,J,3,2)*B(I,J,2,6)) / B(I,J,3,3)
         B(I,J,3,7) = (B(I,J,3,7) - B(I,J,3,1)*B(I,J,1,7)
     1                            - B(I,J,3,2)*B(I,J,2,7)) / B(I,J,3,3)
C
C     Row 4
C
         B(I,J,4,2) =  B(I,J,4,2) - B(I,J,4,1) * B(I,J,1,2)
         B(I,J,4,3) =  B(I,J,4,3) - B(I,J,4,1) * B(I,J,1,3)
     1                            - B(I,J,4,2) * B(I,J,2,3)
         B(I,J,4,4) =  B(I,J,4,4) - B(I,J,4,1) * B(I,J,1,4)
     1                            - B(I,J,4,2) * B(I,J,2,4)
     2                            - B(I,J,4,3) * B(I,J,3,4)
         B(I,J,4,5) = (B(I,J,4,5) - B(I,J,4,1)*B(I,J,1,5)
     1                            - B(I,J,4,2)*B(I,J,2,5)
     2                            - B(I,J,4,3)*B(I,J,3,5)) / B(I,J,4,4)
         B(I,J,4,6) = (B(I,J,4,6) - B(I,J,4,1)*B(I,J,1,6)
     1                            - B(I,J,4,2)*B(I,J,2,6)
     2                            - B(I,J,4,3)*B(I,J,3,6)) / B(I,J,4,4)
         B(I,J,4,7) = (B(I,J,4,7) - B(I,J,4,1)*B(I,J,1,7)
     1                            - B(I,J,4,2)*B(I,J,2,7)
     2                            - B(I,J,4,3)*B(I,J,3,7)) / B(I,J,4,4)
C
C     Row 5
C
         B(I,J,5,2) =  B(I,J,5,2) - B(I,J,5,1) * B(I,J,1,2)
         B(I,J,5,3) =  B(I,J,5,3) - B(I,J,5,1) * B(I,J,1,3)
     1                            - B(I,J,5,2) * B(I,J,2,3)
         B(I,J,5,4) =  B(I,J,5,4) - B(I,J,5,1) * B(I,J,1,4)
     1                            - B(I,J,5,2) * B(I,J,2,4)
     2                            - B(I,J,5,3) * B(I,J,3,4)
         B(I,J,5,5) =  B(I,J,5,5) - B(I,J,5,1) * B(I,J,1,5)
     1                            - B(I,J,5,2) * B(I,J,2,5)
     2                            - B(I,J,5,3) * B(I,J,3,5)
     3                            - B(I,J,5,4) * B(I,J,4,5)
         B(I,J,5,6) = (B(I,J,5,6) - B(I,J,5,1)*B(I,J,1,6)
     1                            - B(I,J,5,2)*B(I,J,2,6)
     2                            - B(I,J,5,3)*B(I,J,3,6)
     3                            - B(I,J,5,4)*B(I,J,4,6)) / B(I,J,5,5)
         B(I,J,5,7) = (B(I,J,5,7) - B(I,J,5,1)*B(I,J,1,7)
     1                            - B(I,J,5,2)*B(I,J,2,7)
     2                            - B(I,J,5,3)*B(I,J,3,7)
     3                            - B(I,J,5,4)*B(I,J,4,7)) / B(I,J,5,5)
C
C     Row 6
C
         B(I,J,6,2) =  B(I,J,6,2) - B(I,J,6,1) * B(I,J,1,2)
         B(I,J,6,3) =  B(I,J,6,3) - B(I,J,6,1) * B(I,J,1,3)
     1                            - B(I,J,6,2) * B(I,J,2,3)
         B(I,J,6,4) =  B(I,J,6,4) - B(I,J,6,1) * B(I,J,1,4)
     1                            - B(I,J,6,2) * B(I,J,2,4)
     2                            - B(I,J,6,3) * B(I,J,3,4)
         B(I,J,6,5) =  B(I,J,6,5) - B(I,J,6,1) * B(I,J,1,5)
     1                            - B(I,J,6,2) * B(I,J,2,5)
     2                            - B(I,J,6,3) * B(I,J,3,5)
     3                            - B(I,J,6,4) * B(I,J,4,5)
         B(I,J,6,6) =  B(I,J,6,6) - B(I,J,6,1) * B(I,J,1,6)
     1                            - B(I,J,6,2) * B(I,J,2,6)
     2                            - B(I,J,6,3) * B(I,J,3,6)
     3                            - B(I,J,6,4) * B(I,J,4,6)
     4                            - B(I,J,6,5) * B(I,J,5,6)
         B(I,J,6,7) = (B(I,J,6,7) - B(I,J,6,1)*B(I,J,1,7)
     1                            - B(I,J,6,2)*B(I,J,2,7)
     2                            - B(I,J,6,3)*B(I,J,3,7)
     3                            - B(I,J,6,4)*B(I,J,4,7)
     4                            - B(I,J,6,5)*B(I,J,5,7)) / B(I,J,6,6)
C
C     Row 7
C
         B(I,J,7,2) =  B(I,J,7,2) - B(I,J,7,1) * B(I,J,1,2)
         B(I,J,7,3) =  B(I,J,7,3) - B(I,J,7,1) * B(I,J,1,3)
     1                            - B(I,J,7,2) * B(I,J,2,3)
         B(I,J,7,4) =  B(I,J,7,4) - B(I,J,7,1) * B(I,J,1,4)
     1                            - B(I,J,7,2) * B(I,J,2,4)
     2                            - B(I,J,7,3) * B(I,J,3,4)
         B(I,J,7,5) =  B(I,J,7,5) - B(I,J,7,1) * B(I,J,1,5)
     1                            - B(I,J,7,2) * B(I,J,2,5)
     2                            - B(I,J,7,3) * B(I,J,3,5)
     3                            - B(I,J,7,4) * B(I,J,4,5)
         B(I,J,7,6) =  B(I,J,7,6) - B(I,J,7,1) * B(I,J,1,6)
     1                            - B(I,J,7,2) * B(I,J,2,6)
     2                            - B(I,J,7,3) * B(I,J,3,6)
     3                            - B(I,J,7,4) * B(I,J,4,6)
     4                            - B(I,J,7,5) * B(I,J,5,6)
         B(I,J,7,7) =  B(I,J,7,7) - B(I,J,7,1) * B(I,J,1,7)
     1                            - B(I,J,7,2) * B(I,J,2,7)
     2                            - B(I,J,7,3) * B(I,J,3,7)
     3                            - B(I,J,7,4) * B(I,J,4,7)
     4                            - B(I,J,7,5) * B(I,J,5,7)
     5                            - B(I,J,7,6) * B(I,J,6,7)
 100  CONTINUE
C
C     Form U(1,2) = L[inverse](1,1) * C(1)
C
      DO 200 L = 1, 7
         DO 180 I = 1, NSIM
C
C     Forward sweep of lu decomposition to form L[inverse]
C
            C(I,J,1,L) = C(I,J,1,L) / B(I,J,1,1)
            C(I,J,2,L) = ( C(I,J,2,L) - B(I,J,2,1)*C(I,J,1,L) )
     1                   / B(I,J,2,2)
            C(I,J,3,L) = ( C(I,J,3,L) - B(I,J,3,1)*C(I,J,1,L)
     1                                - B(I,J,3,2)*C(I,J,2,L) )
     2                   / B(I,J,3,3)
            C(I,J,4,L) = ( C(I,J,4,L) - B(I,J,4,1)*C(I,J,1,L)
     1                                - B(I,J,4,2)*C(I,J,2,L)
     2                                - B(I,J,4,3)*C(I,J,3,L) )
     3                   / B(I,J,4,4)
            C(I,J,5,L) = ( C(I,J,5,L) - B(I,J,5,1)*C(I,J,1,L)
     1                                - B(I,J,5,2)*C(I,J,2,L)
     2                                - B(I,J,5,3)*C(I,J,3,L)
     3                                - B(I,J,5,4)*C(I,J,4,L) )
     4                   / B(I,J,5,5)
            C(I,J,6,L) = ( C(I,J,6,L) - B(I,J,6,1)*C(I,J,1,L)
     1                                - B(I,J,6,2)*C(I,J,2,L)
     2                                - B(I,J,6,3)*C(I,J,3,L)
     3                                - B(I,J,6,4)*C(I,J,4,L)
     4                                - B(I,J,6,5)*C(I,J,5,L) )
     5                   / B(I,J,6,6)
            C(I,J,7,L) = ( C(I,J,7,L) - B(I,J,7,1)*C(I,J,1,L)
     1                                - B(I,J,7,2)*C(I,J,2,L)
     2                                - B(I,J,7,3)*C(I,J,3,L)
     3                                - B(I,J,7,4)*C(I,J,4,L)
     4                                - B(I,J,7,5)*C(I,J,5,L)
     5                                - B(I,J,7,6)*C(I,J,6,L) )
     6                   / B(I,J,7,7)
C
C     Backward Sweep of lu
C
            C(I,J,6,L) = C(I,J,6,L) - B(I,J,6,7)*C(I,J,7,L)
            C(I,J,5,L) = C(I,J,5,L) - B(I,J,5,6)*C(I,J,6,L)
     1                              - B(I,J,5,7)*C(I,J,7,L)
            C(I,J,4,L) = C(I,J,4,L) - B(I,J,4,5)*C(I,J,5,L)
     1                              - B(I,J,4,6)*C(I,J,6,L)
     2                              - B(I,J,4,7)*C(I,J,7,L)
            C(I,J,3,L) = C(I,J,3,L) - B(I,J,3,4)*C(I,J,4,L)
     1                              - B(I,J,3,5)*C(I,J,5,L)
     2                              - B(I,J,3,6)*C(I,J,6,L)
     3                              - B(I,J,3,7)*C(I,J,7,L)
            C(I,J,2,L) = C(I,J,2,L) - B(I,J,2,3)*C(I,J,3,L)
     1                              - B(I,J,2,4)*C(I,J,4,L)
     2                              - B(I,J,2,5)*C(I,J,5,L)
     3                              - B(I,J,2,6)*C(I,J,6,L)
     4                              - B(I,J,2,7)*C(I,J,7,L)
            C(I,J,1,L) = C(I,J,1,L) - B(I,J,1,2)*C(I,J,2,L)
     1                              - B(I,J,1,3)*C(I,J,3,L)
     2                              - B(I,J,1,4)*C(I,J,4,L)
     3                              - B(I,J,1,5)*C(I,J,5,L)
     4                              - B(I,J,1,6)*C(I,J,6,L)
     5                              - B(I,J,1,7)*C(I,J,7,L)
 180     CONTINUE
 200  CONTINUE
C
C     Loop over J = 2 to NPTS forming the LU terms
C
      DO 600 J = 2, NPTS
C
C     Form L(i,i) = B(i) - L(i,i-1)*U(i-1,i)
C
         DO 300 L = 1, 7
            DO 280 M = 1, 7
               DO 260 I = 1, NSIM
                  B(I,J,L,M) = B(I,J,L,M) - A(I,J,L,1)*C(I,J-1,1,M)
     1                                    - A(I,J,L,2)*C(I,J-1,2,M)
     2                                    - A(I,J,L,3)*C(I,J-1,3,M)
     3                                    - A(I,J,L,4)*C(I,J-1,4,M)
     4                                    - A(I,J,L,5)*C(I,J-1,5,M)
     5                                    - A(I,J,L,6)*C(I,J-1,6,M)
     6                                    - A(I,J,L,7)*C(I,J-1,7,M)
 260           CONTINUE
 280        CONTINUE
 300     CONTINUE
C
C     Form lu of L(i,i)
C
         DO 400 I = 1, NSIM
C
C     Row 1
C
            B(I,J,1,2) = B(I,J,1,2) / B(I,J,1,1)
            B(I,J,1,3) = B(I,J,1,3) / B(I,J,1,1)
            B(I,J,1,4) = B(I,J,1,4) / B(I,J,1,1)
            B(I,J,1,5) = B(I,J,1,5) / B(I,J,1,1)
            B(I,J,1,6) = B(I,J,1,6) / B(I,J,1,1)
            B(I,J,1,7) = B(I,J,1,7) / B(I,J,1,1)
C
C     Row 2
C
            B(I,J,2,2) =  B(I,J,2,2) - B(I,J,2,1) * B(I,J,1,2)
            B(I,J,2,3) = (B(I,J,2,3) - B(I,J,2,1)*B(I,J,1,3))/B(I,J,2,2)
            B(I,J,2,4) = (B(I,J,2,4) - B(I,J,2,1)*B(I,J,1,4))/B(I,J,2,2)
            B(I,J,2,5) = (B(I,J,2,5) - B(I,J,2,1)*B(I,J,1,5))/B(I,J,2,2)
            B(I,J,2,6) = (B(I,J,2,6) - B(I,J,2,1)*B(I,J,1,6))/B(I,J,2,2)
            B(I,J,2,7) = (B(I,J,2,7) - B(I,J,2,1)*B(I,J,1,7))/B(I,J,2,2)
C
C     Row 3
C
            B(I,J,3,2) =  B(I,J,3,2) - B(I,J,3,1) * B(I,J,1,2)
            B(I,J,3,3) =  B(I,J,3,3) - B(I,J,3,1) * B(I,J,1,3)
     1                               - B(I,J,3,2) * B(I,J,2,3)
            B(I,J,3,4) = (B(I,J,3,4) - B(I,J,3,1)*B(I,J,1,4)
     1                               - B(I,J,3,2)*B(I,J,2,4))/B(I,J,3,3)
            B(I,J,3,5) = (B(I,J,3,5) - B(I,J,3,1)*B(I,J,1,5)
     1                               - B(I,J,3,2)*B(I,J,2,5))/B(I,J,3,3)
            B(I,J,3,6) = (B(I,J,3,6) - B(I,J,3,1)*B(I,J,1,6)
     1                               - B(I,J,3,2)*B(I,J,2,6))/B(I,J,3,3)
            B(I,J,3,7) = (B(I,J,3,7) - B(I,J,3,1)*B(I,J,1,7)
     1                               - B(I,J,3,2)*B(I,J,2,7))/B(I,J,3,3)
C
C     Row 4
C
            B(I,J,4,2) =  B(I,J,4,2) - B(I,J,4,1) * B(I,J,1,2)
            B(I,J,4,3) =  B(I,J,4,3) - B(I,J,4,1) * B(I,J,1,3)
     1                               - B(I,J,4,2) * B(I,J,2,3)
            B(I,J,4,4) =  B(I,J,4,4) - B(I,J,4,1) * B(I,J,1,4)
     1                               - B(I,J,4,2) * B(I,J,2,4)
     2                               - B(I,J,4,3) * B(I,J,3,4)
            B(I,J,4,5) = (B(I,J,4,5) - B(I,J,4,1)*B(I,J,1,5)
     1                               - B(I,J,4,2)*B(I,J,2,5)
     2                               - B(I,J,4,3)*B(I,J,3,5))/B(I,J,4,4)
            B(I,J,4,6) = (B(I,J,4,6) - B(I,J,4,1)*B(I,J,1,6)
     1                               - B(I,J,4,2)*B(I,J,2,6)
     2                               - B(I,J,4,3)*B(I,J,3,6))/B(I,J,4,4)
            B(I,J,4,7) = (B(I,J,4,7) - B(I,J,4,1)*B(I,J,1,7)
     1                               - B(I,J,4,2)*B(I,J,2,7)
     2                               - B(I,J,4,3)*B(I,J,3,7))/B(I,J,4,4)
C
C     Row 5
C
            B(I,J,5,2) =  B(I,J,5,2) - B(I,J,5,1) * B(I,J,1,2)
            B(I,J,5,3) =  B(I,J,5,3) - B(I,J,5,1) * B(I,J,1,3)
     1                               - B(I,J,5,2) * B(I,J,2,3)
            B(I,J,5,4) =  B(I,J,5,4) - B(I,J,5,1) * B(I,J,1,4)
     1                               - B(I,J,5,2) * B(I,J,2,4)
     2                               - B(I,J,5,3) * B(I,J,3,4)
            B(I,J,5,5) =  B(I,J,5,5) - B(I,J,5,1) * B(I,J,1,5)
     1                               - B(I,J,5,2) * B(I,J,2,5)
     2                               - B(I,J,5,3) * B(I,J,3,5)
     3                               - B(I,J,5,4) * B(I,J,4,5)
            B(I,J,5,6) = (B(I,J,5,6) - B(I,J,5,1)*B(I,J,1,6)
     1                               - B(I,J,5,2)*B(I,J,2,6)
     2                               - B(I,J,5,3)*B(I,J,3,6)
     3                               - B(I,J,5,4)*B(I,J,4,6))/B(I,J,5,5)
            B(I,J,5,7) = (B(I,J,5,7) - B(I,J,5,1)*B(I,J,1,7)
     1                               - B(I,J,5,2)*B(I,J,2,7)
     2                               - B(I,J,5,3)*B(I,J,3,7)
     3                               - B(I,J,5,4)*B(I,J,4,7))/B(I,J,5,5)
C
C     Row 6
C
            B(I,J,6,2) =  B(I,J,6,2) - B(I,J,6,1) * B(I,J,1,2)
            B(I,J,6,3) =  B(I,J,6,3) - B(I,J,6,1) * B(I,J,1,3)
     1                               - B(I,J,6,2) * B(I,J,2,3)
            B(I,J,6,4) =  B(I,J,6,4) - B(I,J,6,1) * B(I,J,1,4)
     1                               - B(I,J,6,2) * B(I,J,2,4)
     2                               - B(I,J,6,3) * B(I,J,3,4)
            B(I,J,6,5) =  B(I,J,6,5) - B(I,J,6,1) * B(I,J,1,5)
     1                               - B(I,J,6,2) * B(I,J,2,5)
     2                               - B(I,J,6,3) * B(I,J,3,5)
     3                               - B(I,J,6,4) * B(I,J,4,5)
            B(I,J,6,6) =  B(I,J,6,6) - B(I,J,6,1) * B(I,J,1,6)
     1                               - B(I,J,6,2) * B(I,J,2,6)
     2                               - B(I,J,6,3) * B(I,J,3,6)
     3                               - B(I,J,6,4) * B(I,J,4,6)
     4                               - B(I,J,6,5) * B(I,J,5,6)
            B(I,J,6,7) = (B(I,J,6,7) - B(I,J,6,1)*B(I,J,1,7)
     1                               - B(I,J,6,2)*B(I,J,2,7)
     2                               - B(I,J,6,3)*B(I,J,3,7)
     3                               - B(I,J,6,4)*B(I,J,4,7)
     4                               - B(I,J,6,5)*B(I,J,5,7))/B(I,J,6,6)
C
C     Row 7
C
            B(I,J,7,2) =  B(I,J,7,2) - B(I,J,7,1) * B(I,J,1,2)
            B(I,J,7,3) =  B(I,J,7,3) - B(I,J,7,1) * B(I,J,1,3)
     1                               - B(I,J,7,2) * B(I,J,2,3)
            B(I,J,7,4) =  B(I,J,7,4) - B(I,J,7,1) * B(I,J,1,4)
     1                               - B(I,J,7,2) * B(I,J,2,4)
     2                               - B(I,J,7,3) * B(I,J,3,4)
            B(I,J,7,5) =  B(I,J,7,5) - B(I,J,7,1) * B(I,J,1,5)
     1                               - B(I,J,7,2) * B(I,J,2,5)
     2                               - B(I,J,7,3) * B(I,J,3,5)
     3                               - B(I,J,7,4) * B(I,J,4,5)
            B(I,J,7,6) =  B(I,J,7,6) - B(I,J,7,1) * B(I,J,1,6)
     1                               - B(I,J,7,2) * B(I,J,2,6)
     2                               - B(I,J,7,3) * B(I,J,3,6)
     3                               - B(I,J,7,4) * B(I,J,4,6)
     4                               - B(I,J,7,5) * B(I,J,5,6)
            B(I,J,7,7) =  B(I,J,7,7) - B(I,J,7,1) * B(I,J,1,7)
     1                               - B(I,J,7,2) * B(I,J,2,7)
     2                               - B(I,J,7,3) * B(I,J,3,7)
     3                               - B(I,J,7,4) * B(I,J,4,7)
     4                               - B(I,J,7,5) * B(I,J,5,7)
     5                               - B(I,J,7,6) * B(I,J,6,7)
 400     CONTINUE
C
C     Form U(i,i+1) = L[inverse](i,i) * C(i) for all except last term
C
         IF (J .NE. NPTS) THEN
            DO 500 L = 1, 7
               DO 480 I = 1, NSIM
C
C     Forward sweep of lu decomposition to form L[inverse]
C
                  C(I,J,1,L) = C(I,J,1,L) / B(I,J,1,1)
                  C(I,J,2,L) = ( C(I,J,2,L) - B(I,J,2,1)*C(I,J,1,L) )
     1                         / B(I,J,2,2)
                  C(I,J,3,L) = ( C(I,J,3,L) - B(I,J,3,1)*C(I,J,1,L)
     1                                      - B(I,J,3,2)*C(I,J,2,L) )
     2                         / B(I,J,3,3)
                  C(I,J,4,L) = ( C(I,J,4,L) - B(I,J,4,1)*C(I,J,1,L)
     1                                      - B(I,J,4,2)*C(I,J,2,L)
     2                                      - B(I,J,4,3)*C(I,J,3,L) )
     3                         / B(I,J,4,4)
                  C(I,J,5,L) = ( C(I,J,5,L) - B(I,J,5,1)*C(I,J,1,L)
     1                                      - B(I,J,5,2)*C(I,J,2,L)
     2                                      - B(I,J,5,3)*C(I,J,3,L)
     3                                      - B(I,J,5,4)*C(I,J,4,L) )
     4                         / B(I,J,5,5)
                  C(I,J,6,L) = ( C(I,J,6,L) - B(I,J,6,1)*C(I,J,1,L)
     1                                      - B(I,J,6,2)*C(I,J,2,L)
     2                                      - B(I,J,6,3)*C(I,J,3,L)
     3                                      - B(I,J,6,4)*C(I,J,4,L)
     4                                      - B(I,J,6,5)*C(I,J,5,L) )
     5                         / B(I,J,6,6)
                  C(I,J,7,L) = ( C(I,J,7,L) - B(I,J,7,1)*C(I,J,1,L)
     1                                      - B(I,J,7,2)*C(I,J,2,L)
     2                                      - B(I,J,7,3)*C(I,J,3,L)
     3                                      - B(I,J,7,4)*C(I,J,4,L)
     4                                      - B(I,J,7,5)*C(I,J,5,L)
     5                                      - B(I,J,7,6)*C(I,J,6,L) )
     6                         / B(I,J,7,7)
C
C     Backward Sweep of lu
C
                  C(I,J,6,L) = C(I,J,6,L) - B(I,J,6,7)*C(I,J,7,L)
                  C(I,J,5,L) = C(I,J,5,L) - B(I,J,5,6)*C(I,J,6,L)
     1                                    - B(I,J,5,7)*C(I,J,7,L)
                  C(I,J,4,L) = C(I,J,4,L) - B(I,J,4,5)*C(I,J,5,L)
     1                                    - B(I,J,4,6)*C(I,J,6,L)
     2                                    - B(I,J,4,7)*C(I,J,7,L)
                  C(I,J,3,L) = C(I,J,3,L) - B(I,J,3,4)*C(I,J,4,L)
     1                                    - B(I,J,3,5)*C(I,J,5,L)
     2                                    - B(I,J,3,6)*C(I,J,6,L)
     3                                    - B(I,J,3,7)*C(I,J,7,L)
                  C(I,J,2,L) = C(I,J,2,L) - B(I,J,2,3)*C(I,J,3,L)
     1                                    - B(I,J,2,4)*C(I,J,4,L)
     2                                    - B(I,J,2,5)*C(I,J,5,L)
     3                                    - B(I,J,2,6)*C(I,J,6,L)
     4                                    - B(I,J,2,7)*C(I,J,7,L)
                  C(I,J,1,L) = C(I,J,1,L) - B(I,J,1,2)*C(I,J,2,L)
     1                                    - B(I,J,1,3)*C(I,J,3,L)
     2                                    - B(I,J,1,4)*C(I,J,4,L)
     3                                    - B(I,J,1,5)*C(I,J,5,L)
     4                                    - B(I,J,1,6)*C(I,J,6,L)
     5                                    - B(I,J,1,7)*C(I,J,7,L)
 480           CONTINUE
 500        CONTINUE
         ENDIF
 600  CONTINUE
C
C     Finished forming LU
      RETURN
      END
      SUBROUTINE VLUT12 (NPTS, NSIM, NRANK, A, B, C)
C
C     Routine to do a vectorized LU decomposition of a
C     12x12 block tridiagonal system of equations.
C     The recursive nature of the LU decomposition leads
C     to a form which is not vectorizable.  Therefore, the
C     approach of this routine is to not attempt vectorization
C     of the LU, but to accomplish the vectorization through
C     simulataneously doing NSIM LU decompositions.
C     This form is with the identity on the diagonal of U.
C
C     NPTS:      The number of elements in the tridiagonal system
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     NRANK:     The actual dimension of the storage of the tri-diagonal system
C     A:         The supra-diagonal block 12x12 term
C     B:         The       diagonal block 12x12 term
C     C:         The super-diagonal block 12x12 term
C
C     On Exit:
C     A:         L(j,j-1) The supra-diagonal term of L
C     B:         The non-pivoted lu decomposition of L(i,i)
C                (this is needed both to form the LU and to invert the system)
C
C                One 12x12 block of B is of the form:
C
C                 l(1,1)  u(1,2)  u(1,3)  u(1,4)  u(1,5)  ... u(1,11)  u(1,12)
C                 l(2,1)  l(2,2)  u(2,3)  u(2,4)  u(2,5)  ... u(2,11)  u(2,12)
C                 l(3,1)  l(3,2)  l(3,3)  u(3,4)  u(3,5)  ... u(3,11)  u(3,12)
C        B[i,i] = l(4,1)  l(4,2)  l(4,3)  l(4,4)  u(4,5)  ... u(4,11)  u(4,12)
C                 l(5,1)  l(5,2)  l(5,3)  l(5,4)  l(5,5)  ... u(5,11)  u(5,12)
C                    .       .       .       .       .           .        .
C                    .       .       .       .       .           .        .
C                    .       .       .       .       .           .        .
C                 l(11,1) l(11,2) l(11,3) l(11,4) l(11,5) ... l(11,11) u(11,12)
C                 l(12,1) l(12,2) l(12,3) l(12,4) l(12,5) ... l(12,11) l(12,12)
C
C     C:         U(j,j+1) The super-diagonal term of U
C
C     L(i,i-1) = A(i) therefore no operations need to be performed on A.
C     L(i,i)   = B(i) - L(i,i-1)*U(i-1,i)
C     U(i,i+1) = L[inverse](i,i)*C(i)
C
      DIMENSION A (NSIM,NPTS,NRANK,NRANK),
     1          B (NSIM,NPTS,NRANK,NRANK),
     2          C (NSIM,NPTS,NRANK,NRANK)
C
C     Loop over J = 1 to NPTS forming the LU terms
C
      DO 600 J = 1, NPTS
C
C     Form L(i,i) = B(i) - L(i,i-1)*U(i-1,i) for all except the J = 1
C
         IF (J .NE. 1) THEN
            DO 130 L = 1, 12
               DO 120 M = 1, 12
                  DO 110 I = 1, NSIM
                     B(I,J,L,M) = B(I,J,L,M) - A(I,J,L, 1)*C(I,J-1, 1,M)
     1                                       - A(I,J,L, 2)*C(I,J-1, 2,M)
     2                                       - A(I,J,L, 3)*C(I,J-1, 3,M)
     3                                       - A(I,J,L, 4)*C(I,J-1, 4,M)
     4                                       - A(I,J,L, 5)*C(I,J-1, 5,M)
     5                                       - A(I,J,L, 6)*C(I,J-1, 6,M)
     6                                       - A(I,J,L, 7)*C(I,J-1, 7,M)
     7                                       - A(I,J,L, 8)*C(I,J-1, 8,M)
     8                                       - A(I,J,L, 9)*C(I,J-1, 9,M)
     9                                       - A(I,J,L,10)*C(I,J-1,10,M)
     A                                       - A(I,J,L,11)*C(I,J-1,11,M)
     B                                       - A(I,J,L,12)*C(I,J-1,12,M)
 110              CONTINUE
 120           CONTINUE
 130        CONTINUE
         ENDIF
C
C     Form the lu decomposition of L(i,i)
C
         DO 200 I = 1, NSIM
C
C     Row 1
C
            B(I,J,1, 2) = B(I,J,1, 2) / B(I,J,1,1)
            B(I,J,1, 3) = B(I,J,1, 3) / B(I,J,1,1)
            B(I,J,1, 4) = B(I,J,1, 4) / B(I,J,1,1)
            B(I,J,1, 5) = B(I,J,1, 5) / B(I,J,1,1)
            B(I,J,1, 6) = B(I,J,1, 6) / B(I,J,1,1)
            B(I,J,1, 7) = B(I,J,1, 7) / B(I,J,1,1)
            B(I,J,1, 8) = B(I,J,1, 8) / B(I,J,1,1)
            B(I,J,1, 9) = B(I,J,1, 9) / B(I,J,1,1)
            B(I,J,1,10) = B(I,J,1,10) / B(I,J,1,1)
            B(I,J,1,11) = B(I,J,1,11) / B(I,J,1,1)
            B(I,J,1,12) = B(I,J,1,12) / B(I,J,1,1)
C
C     Row 2
C
            B(I,J,2, 2) =  B(I,J,2, 2) - B(I,J,2,1)*B(I,J,1, 2)
            B(I,J,2, 3) = (B(I,J,2, 3) - B(I,J,2,1)*B(I,J,1, 3))
     1                    /B(I,J,2,2)
            B(I,J,2, 4) = (B(I,J,2, 4) - B(I,J,2,1)*B(I,J,1, 4))
     1                    /B(I,J,2,2)
            B(I,J,2, 5) = (B(I,J,2, 5) - B(I,J,2,1)*B(I,J,1, 5))
     1                    /B(I,J,2,2)
            B(I,J,2, 6) = (B(I,J,2, 6) - B(I,J,2,1)*B(I,J,1, 6))
     1                    /B(I,J,2,2)
            B(I,J,2, 7) = (B(I,J,2, 7) - B(I,J,2,1)*B(I,J,1, 7))
     1                    /B(I,J,2,2)
            B(I,J,2, 8) = (B(I,J,2, 8) - B(I,J,2,1)*B(I,J,1, 8))
     1                    /B(I,J,2,2)
            B(I,J,2, 9) = (B(I,J,2, 9) - B(I,J,2,1)*B(I,J,1, 9))
     1                    /B(I,J,2,2)
            B(I,J,2,10) = (B(I,J,2,10) - B(I,J,2,1)*B(I,J,1,10))
     1                    /B(I,J,2,2)
            B(I,J,2,11) = (B(I,J,2,11) - B(I,J,2,1)*B(I,J,1,11))
     1                    /B(I,J,2,2)
            B(I,J,2,12) = (B(I,J,2,12) - B(I,J,2,1)*B(I,J,1,12))
     1                    /B(I,J,2,2)
C
C     Row 3
C
            B(I,J,3, 2) =  B(I,J,3, 2) - B(I,J,3,1)*B(I,J,1, 2)
            B(I,J,3, 3) =  B(I,J,3, 3) - B(I,J,3,1)*B(I,J,1, 3)
     1                                 - B(I,J,3,2)*B(I,J,2, 3)
            B(I,J,3, 4) = (B(I,J,3, 4) - B(I,J,3,1)*B(I,J,1, 4)
     1                                 - B(I,J,3,2)*B(I,J,2, 4))
     2                    /B(I,J,3,3)
            B(I,J,3, 5) = (B(I,J,3, 5) - B(I,J,3,1)*B(I,J,1, 5)
     1                                 - B(I,J,3,2)*B(I,J,2, 5))
     2                    /B(I,J,3,3)
            B(I,J,3, 6) = (B(I,J,3, 6) - B(I,J,3,1)*B(I,J,1, 6)
     1                                 - B(I,J,3,2)*B(I,J,2, 6))
     2                    /B(I,J,3,3)
            B(I,J,3, 7) = (B(I,J,3, 7) - B(I,J,3,1)*B(I,J,1, 7)
     1                                 - B(I,J,3,2)*B(I,J,2, 7))
     2                    /B(I,J,3,3)
            B(I,J,3, 8) = (B(I,J,3, 8) - B(I,J,3,1)*B(I,J,1, 8)
     1                                 - B(I,J,3,2)*B(I,J,2, 8))
     2                    /B(I,J,3,3)
            B(I,J,3, 9) = (B(I,J,3, 9) - B(I,J,3,1)*B(I,J,1, 9)
     1                                 - B(I,J,3,2)*B(I,J,2, 9))
     2                    /B(I,J,3,3)
            B(I,J,3,10) = (B(I,J,3,10) - B(I,J,3,1)*B(I,J,1,10)
     1                                 - B(I,J,3,2)*B(I,J,2,10))
     2                    /B(I,J,3,3)
            B(I,J,3,11) = (B(I,J,3,11) - B(I,J,3,1)*B(I,J,1,11)
     1                                 - B(I,J,3,2)*B(I,J,2,11))
     2                    /B(I,J,3,3)
            B(I,J,3,12) = (B(I,J,3,12) - B(I,J,3,1)*B(I,J,1,12)
     1                                 - B(I,J,3,2)*B(I,J,2,12))
     2                    /B(I,J,3,3)
C
C     Row 4
C
            B(I,J,4, 2) =  B(I,J,4, 2) - B(I,J,4,1)*B(I,J,1, 2)
            B(I,J,4, 3) =  B(I,J,4, 3) - B(I,J,4,1)*B(I,J,1, 3)
     1                                 - B(I,J,4,2)*B(I,J,2, 3)
            B(I,J,4, 4) =  B(I,J,4, 4) - B(I,J,4,1)*B(I,J,1, 4)
     1                                 - B(I,J,4,2)*B(I,J,2, 4)
     2                                 - B(I,J,4,3)*B(I,J,3, 4)
            B(I,J,4, 5) = (B(I,J,4, 5) - B(I,J,4,1)*B(I,J,1, 5)
     1                                 - B(I,J,4,2)*B(I,J,2, 5)
     2                                 - B(I,J,4,3)*B(I,J,3, 5))
     3                    /B(I,J,4,4)
            B(I,J,4, 6) = (B(I,J,4, 6) - B(I,J,4,1)*B(I,J,1, 6)
     1                                 - B(I,J,4,2)*B(I,J,2, 6)
     2                                 - B(I,J,4,3)*B(I,J,3, 6))
     3                    /B(I,J,4,4)
            B(I,J,4, 7) = (B(I,J,4, 7) - B(I,J,4,1)*B(I,J,1, 7)
     1                                 - B(I,J,4,2)*B(I,J,2, 7)
     2                                 - B(I,J,4,3)*B(I,J,3, 7))
     3                    /B(I,J,4,4)
            B(I,J,4, 8) = (B(I,J,4, 8) - B(I,J,4,1)*B(I,J,1, 8)
     1                                 - B(I,J,4,2)*B(I,J,2, 8)
     2                                 - B(I,J,4,3)*B(I,J,3, 8))
     3                    /B(I,J,4,4)
            B(I,J,4, 9) = (B(I,J,4, 9) - B(I,J,4,1)*B(I,J,1, 9)
     1                                 - B(I,J,4,2)*B(I,J,2, 9)
     2                                 - B(I,J,4,3)*B(I,J,3, 9))
     3                    /B(I,J,4,4)
            B(I,J,4,10) = (B(I,J,4,10) - B(I,J,4,1)*B(I,J,1,10)
     1                                 - B(I,J,4,2)*B(I,J,2,10)
     2                                 - B(I,J,4,3)*B(I,J,3,10))
     3                    /B(I,J,4,4)
            B(I,J,4,11) = (B(I,J,4,11) - B(I,J,4,1)*B(I,J,1,11)
     1                                 - B(I,J,4,2)*B(I,J,2,11)
     2                                 - B(I,J,4,3)*B(I,J,3,11))
     3                    /B(I,J,4,4)
            B(I,J,4,12) = (B(I,J,4,12) - B(I,J,4,1)*B(I,J,1,12)
     1                                 - B(I,J,4,2)*B(I,J,2,12)
     2                                 - B(I,J,4,3)*B(I,J,3,12))
     3                    /B(I,J,4,4)
C
C     Row 5
C
            B(I,J,5, 2) =  B(I,J,5, 2) - B(I,J,5,1)*B(I,J,1, 2)
            B(I,J,5, 3) =  B(I,J,5, 3) - B(I,J,5,1)*B(I,J,1, 3)
     1                                 - B(I,J,5,2)*B(I,J,2, 3)
            B(I,J,5, 4) =  B(I,J,5, 4) - B(I,J,5,1)*B(I,J,1, 4)
     1                                 - B(I,J,5,2)*B(I,J,2, 4)
     2                                 - B(I,J,5,3)*B(I,J,3, 4)
            B(I,J,5, 5) =  B(I,J,5, 5) - B(I,J,5,1)*B(I,J,1, 5)
     1                                 - B(I,J,5,2)*B(I,J,2, 5)
     2                                 - B(I,J,5,3)*B(I,J,3, 5)
     3                                 - B(I,J,5,4)*B(I,J,4, 5)
            B(I,J,5, 6) = (B(I,J,5, 6) - B(I,J,5,1)*B(I,J,1, 6)
     1                                 - B(I,J,5,2)*B(I,J,2, 6)
     2                                 - B(I,J,5,3)*B(I,J,3, 6)
     3                                 - B(I,J,5,4)*B(I,J,4, 6))
     4                    /B(I,J,5,5)
            B(I,J,5, 7) = (B(I,J,5, 7) - B(I,J,5,1)*B(I,J,1, 7)
     1                                 - B(I,J,5,2)*B(I,J,2, 7)
     2                                 - B(I,J,5,3)*B(I,J,3, 7)
     3                                 - B(I,J,5,4)*B(I,J,4, 7))
     4                    /B(I,J,5,5)
            B(I,J,5, 8) = (B(I,J,5, 8) - B(I,J,5,1)*B(I,J,1, 8)
     1                                 - B(I,J,5,2)*B(I,J,2, 8)
     2                                 - B(I,J,5,3)*B(I,J,3, 8)
     3                                 - B(I,J,5,4)*B(I,J,4, 8))
     4                    /B(I,J,5,5)
            B(I,J,5, 9) = (B(I,J,5, 9) - B(I,J,5,1)*B(I,J,1, 9)
     1                                 - B(I,J,5,2)*B(I,J,2, 9)
     2                                 - B(I,J,5,3)*B(I,J,3, 9)
     3                                 - B(I,J,5,4)*B(I,J,4, 9))
     4                    /B(I,J,5,5)
            B(I,J,5,10) = (B(I,J,5,10) - B(I,J,5,1)*B(I,J,1,10)
     1                                 - B(I,J,5,2)*B(I,J,2,10)
     2                                 - B(I,J,5,3)*B(I,J,3,10)
     3                                 - B(I,J,5,4)*B(I,J,4,10))
     4                    /B(I,J,5,5)
            B(I,J,5,11) = (B(I,J,5,11) - B(I,J,5,1)*B(I,J,1,11)
     1                                 - B(I,J,5,2)*B(I,J,2,11)
     2                                 - B(I,J,5,3)*B(I,J,3,11)
     3                                 - B(I,J,5,4)*B(I,J,4,11))
     4                    /B(I,J,5,5)
            B(I,J,5,12) = (B(I,J,5,12) - B(I,J,5,1)*B(I,J,1,12)
     1                                 - B(I,J,5,2)*B(I,J,2,12)
     2                                 - B(I,J,5,3)*B(I,J,3,12)
     3                                 - B(I,J,5,4)*B(I,J,4,12))
     4                    /B(I,J,5,5)
C
C     Row 6
C
            B(I,J,6, 2) =  B(I,J,6, 2) - B(I,J,6,1)*B(I,J,1, 2)
            B(I,J,6, 3) =  B(I,J,6, 3) - B(I,J,6,1)*B(I,J,1, 3)
     1                                 - B(I,J,6,2)*B(I,J,2, 3)
            B(I,J,6, 4) =  B(I,J,6, 4) - B(I,J,6,1)*B(I,J,1, 4)
     1                                 - B(I,J,6,2)*B(I,J,2, 4)
     2                                 - B(I,J,6,3)*B(I,J,3, 4)
            B(I,J,6, 5) =  B(I,J,6, 5) - B(I,J,6,1)*B(I,J,1, 5)
     1                                 - B(I,J,6,2)*B(I,J,2, 5)
     2                                 - B(I,J,6,3)*B(I,J,3, 5)
     3                                 - B(I,J,6,4)*B(I,J,4, 5)
            B(I,J,6, 6) =  B(I,J,6, 6) - B(I,J,6,1)*B(I,J,1, 6)
     1                                 - B(I,J,6,2)*B(I,J,2, 6)
     2                                 - B(I,J,6,3)*B(I,J,3, 6)
     3                                 - B(I,J,6,4)*B(I,J,4, 6)
     4                                 - B(I,J,6,5)*B(I,J,5, 6)
            B(I,J,6, 7) = (B(I,J,6, 7) - B(I,J,6,1)*B(I,J,1, 7)
     1                                 - B(I,J,6,2)*B(I,J,2, 7)
     2                                 - B(I,J,6,3)*B(I,J,3, 7)
     3                                 - B(I,J,6,4)*B(I,J,4, 7)
     4                                 - B(I,J,6,5)*B(I,J,5, 7))
     5                    /B(I,J,6,6)
            B(I,J,6, 8) = (B(I,J,6, 8) - B(I,J,6,1)*B(I,J,1, 8)
     1                                 - B(I,J,6,2)*B(I,J,2, 8)
     2                                 - B(I,J,6,3)*B(I,J,3, 8)
     3                                 - B(I,J,6,4)*B(I,J,4, 8)
     4                                 - B(I,J,6,5)*B(I,J,5, 8))
     5                    /B(I,J,6,6)
            B(I,J,6, 9) = (B(I,J,6, 9) - B(I,J,6,1)*B(I,J,1, 9)
     1                                 - B(I,J,6,2)*B(I,J,2, 9)
     2                                 - B(I,J,6,3)*B(I,J,3, 9)
     3                                 - B(I,J,6,4)*B(I,J,4, 9)
     4                                 - B(I,J,6,5)*B(I,J,5, 9))
     5                    /B(I,J,6,6)
            B(I,J,6,10) = (B(I,J,6,10) - B(I,J,6,1)*B(I,J,1,10)
     1                                 - B(I,J,6,2)*B(I,J,2,10)
     2                                 - B(I,J,6,3)*B(I,J,3,10)
     3                                 - B(I,J,6,4)*B(I,J,4,10)
     4                                 - B(I,J,6,5)*B(I,J,5,10))
     5                    /B(I,J,6,6)
            B(I,J,6,11) = (B(I,J,6,11) - B(I,J,6,1)*B(I,J,1,11)
     1                                 - B(I,J,6,2)*B(I,J,2,11)
     2                                 - B(I,J,6,3)*B(I,J,3,11)
     3                                 - B(I,J,6,4)*B(I,J,4,11)
     4                                 - B(I,J,6,5)*B(I,J,5,11))
     5                    /B(I,J,6,6)
            B(I,J,6,12) = (B(I,J,6,12) - B(I,J,6,1)*B(I,J,1,12)
     1                                 - B(I,J,6,2)*B(I,J,2,12)
     2                                 - B(I,J,6,3)*B(I,J,3,12)
     3                                 - B(I,J,6,4)*B(I,J,4,12)
     4                                 - B(I,J,6,5)*B(I,J,5,12))
     5                    /B(I,J,6,6)
C
C     Row 7
C
            B(I,J,7, 2) =  B(I,J,7, 2) - B(I,J,7,1)*B(I,J,1, 2)
            B(I,J,7, 3) =  B(I,J,7, 3) - B(I,J,7,1)*B(I,J,1, 3)
     1                                 - B(I,J,7,2)*B(I,J,2, 3)
            B(I,J,7, 4) =  B(I,J,7, 4) - B(I,J,7,1)*B(I,J,1, 4)
     1                                 - B(I,J,7,2)*B(I,J,2, 4)
     2                                 - B(I,J,7,3)*B(I,J,3, 4)
            B(I,J,7, 5) =  B(I,J,7, 5) - B(I,J,7,1)*B(I,J,1, 5)
     1                                 - B(I,J,7,2)*B(I,J,2, 5)
     2                                 - B(I,J,7,3)*B(I,J,3, 5)
     3                                 - B(I,J,7,4)*B(I,J,4, 5)
            B(I,J,7, 6) =  B(I,J,7, 6) - B(I,J,7,1)*B(I,J,1, 6)
     1                                 - B(I,J,7,2)*B(I,J,2, 6)
     2                                 - B(I,J,7,3)*B(I,J,3, 6)
     3                                 - B(I,J,7,4)*B(I,J,4, 6)
     4                                 - B(I,J,7,5)*B(I,J,5, 6)
            B(I,J,7, 7) =  B(I,J,7, 7) - B(I,J,7,1)*B(I,J,1, 7)
     1                                 - B(I,J,7,2)*B(I,J,2, 7)
     2                                 - B(I,J,7,3)*B(I,J,3, 7)
     3                                 - B(I,J,7,4)*B(I,J,4, 7)
     4                                 - B(I,J,7,5)*B(I,J,5, 7)
     5                                 - B(I,J,7,6)*B(I,J,6, 7)
            B(I,J,7, 8) = (B(I,J,7, 8) - B(I,J,7,1)*B(I,J,1, 8)
     1                                 - B(I,J,7,2)*B(I,J,2, 8)
     2                                 - B(I,J,7,3)*B(I,J,3, 8)
     3                                 - B(I,J,7,4)*B(I,J,4, 8)
     4                                 - B(I,J,7,5)*B(I,J,5, 8)
     5                                 - B(I,J,7,6)*B(I,J,6, 8))
     6                    /B(I,J,7,7)
            B(I,J,7, 9) = (B(I,J,7, 9) - B(I,J,7,1)*B(I,J,1, 9)
     1                                 - B(I,J,7,2)*B(I,J,2, 9)
     2                                 - B(I,J,7,3)*B(I,J,3, 9)
     3                                 - B(I,J,7,4)*B(I,J,4, 9)
     4                                 - B(I,J,7,5)*B(I,J,5, 9)
     5                                 - B(I,J,7,6)*B(I,J,6, 9))
     6                    /B(I,J,7,7)
            B(I,J,7,10) = (B(I,J,7,10) - B(I,J,7,1)*B(I,J,1,10)
     1                                 - B(I,J,7,2)*B(I,J,2,10)
     2                                 - B(I,J,7,3)*B(I,J,3,10)
     3                                 - B(I,J,7,4)*B(I,J,4,10)
     4                                 - B(I,J,7,5)*B(I,J,5,10)
     5                                 - B(I,J,7,6)*B(I,J,6,10))
     6                    /B(I,J,7,7)
            B(I,J,7,11) = (B(I,J,7,11) - B(I,J,7,1)*B(I,J,1,11)
     1                                 - B(I,J,7,2)*B(I,J,2,11)
     2                                 - B(I,J,7,3)*B(I,J,3,11)
     3                                 - B(I,J,7,4)*B(I,J,4,11)
     4                                 - B(I,J,7,5)*B(I,J,5,11)
     5                                 - B(I,J,7,6)*B(I,J,6,11))
     6                    /B(I,J,7,7)
            B(I,J,7,12) = (B(I,J,7,12) - B(I,J,7,1)*B(I,J,1,12)
     1                                 - B(I,J,7,2)*B(I,J,2,12)
     2                                 - B(I,J,7,3)*B(I,J,3,12)
     3                                 - B(I,J,7,4)*B(I,J,4,12)
     4                                 - B(I,J,7,5)*B(I,J,5,12)
     5                                 - B(I,J,7,6)*B(I,J,6,12))
     6                    /B(I,J,7,7)
C
C     Row 8
C
            B(I,J,8, 2) =  B(I,J,8, 2) - B(I,J,8,1)*B(I,J,1, 2)
            B(I,J,8, 3) =  B(I,J,8, 3) - B(I,J,8,1)*B(I,J,1, 3)
     1                                 - B(I,J,8,2)*B(I,J,2, 3)
            B(I,J,8, 4) =  B(I,J,8, 4) - B(I,J,8,1)*B(I,J,1, 4)
     1                                 - B(I,J,8,2)*B(I,J,2, 4)
     2                                 - B(I,J,8,3)*B(I,J,3, 4)
            B(I,J,8, 5) =  B(I,J,8, 5) - B(I,J,8,1)*B(I,J,1, 5)
     1                                 - B(I,J,8,2)*B(I,J,2, 5)
     2                                 - B(I,J,8,3)*B(I,J,3, 5)
     3                                 - B(I,J,8,4)*B(I,J,4, 5)
            B(I,J,8, 6) =  B(I,J,8, 6) - B(I,J,8,1)*B(I,J,1, 6)
     1                                 - B(I,J,8,2)*B(I,J,2, 6)
     2                                 - B(I,J,8,3)*B(I,J,3, 6)
     3                                 - B(I,J,8,4)*B(I,J,4, 6)
     4                                 - B(I,J,8,5)*B(I,J,5, 6)
            B(I,J,8, 7) =  B(I,J,8, 7) - B(I,J,8,1)*B(I,J,1, 7)
     1                                 - B(I,J,8,2)*B(I,J,2, 7)
     2                                 - B(I,J,8,3)*B(I,J,3, 7)
     3                                 - B(I,J,8,4)*B(I,J,4, 7)
     4                                 - B(I,J,8,5)*B(I,J,5, 7)
     5                                 - B(I,J,8,6)*B(I,J,6, 7)
            B(I,J,8, 8) =  B(I,J,8, 8) - B(I,J,8,1)*B(I,J,1, 8)
     1                                 - B(I,J,8,2)*B(I,J,2, 8)
     2                                 - B(I,J,8,3)*B(I,J,3, 8)
     3                                 - B(I,J,8,4)*B(I,J,4, 8)
     4                                 - B(I,J,8,5)*B(I,J,5, 8)
     5                                 - B(I,J,8,6)*B(I,J,6, 8)
     6                                 - B(I,J,8,7)*B(I,J,7, 8)
            B(I,J,8, 9) = (B(I,J,8, 9) - B(I,J,8,1)*B(I,J,1, 9)
     1                                 - B(I,J,8,2)*B(I,J,2, 9)
     2                                 - B(I,J,8,3)*B(I,J,3, 9)
     3                                 - B(I,J,8,4)*B(I,J,4, 9)
     4                                 - B(I,J,8,5)*B(I,J,5, 9)
     5                                 - B(I,J,8,6)*B(I,J,6, 9)
     6                                 - B(I,J,8,7)*B(I,J,7, 9))
     7                    /B(I,J,8,8)
            B(I,J,8,10) = (B(I,J,8,10) - B(I,J,8,1)*B(I,J,1,10)
     1                                 - B(I,J,8,2)*B(I,J,2,10)
     2                                 - B(I,J,8,3)*B(I,J,3,10)
     3                                 - B(I,J,8,4)*B(I,J,4,10)
     4                                 - B(I,J,8,5)*B(I,J,5,10)
     5                                 - B(I,J,8,6)*B(I,J,6,10)
     6                                 - B(I,J,8,7)*B(I,J,7,10))
     7                    /B(I,J,8,8)
            B(I,J,8,11) = (B(I,J,8,11) - B(I,J,8,1)*B(I,J,1,11)
     1                                 - B(I,J,8,2)*B(I,J,2,11)
     2                                 - B(I,J,8,3)*B(I,J,3,11)
     3                                 - B(I,J,8,4)*B(I,J,4,11)
     4                                 - B(I,J,8,5)*B(I,J,5,11)
     5                                 - B(I,J,8,6)*B(I,J,6,11)
     6                                 - B(I,J,8,7)*B(I,J,7,11))
     7                    /B(I,J,8,8)
            B(I,J,8,12) = (B(I,J,8,12) - B(I,J,8,1)*B(I,J,1,12)
     1                                 - B(I,J,8,2)*B(I,J,2,12)
     2                                 - B(I,J,8,3)*B(I,J,3,12)
     3                                 - B(I,J,8,4)*B(I,J,4,12)
     4                                 - B(I,J,8,5)*B(I,J,5,12)
     5                                 - B(I,J,8,6)*B(I,J,6,12)
     6                                 - B(I,J,8,7)*B(I,J,7,12))
     7                    /B(I,J,8,8)
C
C     Row 9
C
            B(I,J,9, 2) =  B(I,J,9, 2) - B(I,J,9,1)*B(I,J,1, 2)
            B(I,J,9, 3) =  B(I,J,9, 3) - B(I,J,9,1)*B(I,J,1, 3)
     1                                 - B(I,J,9,2)*B(I,J,2, 3)
            B(I,J,9, 4) =  B(I,J,9, 4) - B(I,J,9,1)*B(I,J,1, 4)
     1                                 - B(I,J,9,2)*B(I,J,2, 4)
     2                                 - B(I,J,9,3)*B(I,J,3, 4)
            B(I,J,9, 5) =  B(I,J,9, 5) - B(I,J,9,1)*B(I,J,1, 5)
     1                                 - B(I,J,9,2)*B(I,J,2, 5)
     2                                 - B(I,J,9,3)*B(I,J,3, 5)
     3                                 - B(I,J,9,4)*B(I,J,4, 5)
            B(I,J,9, 6) =  B(I,J,9, 6) - B(I,J,9,1)*B(I,J,1, 6)
     1                                 - B(I,J,9,2)*B(I,J,2, 6)
     2                                 - B(I,J,9,3)*B(I,J,3, 6)
     3                                 - B(I,J,9,4)*B(I,J,4, 6)
     4                                 - B(I,J,9,5)*B(I,J,5, 6)
            B(I,J,9, 7) =  B(I,J,9, 7) - B(I,J,9,1)*B(I,J,1, 7)
     1                                 - B(I,J,9,2)*B(I,J,2, 7)
     2                                 - B(I,J,9,3)*B(I,J,3, 7)
     3                                 - B(I,J,9,4)*B(I,J,4, 7)
     4                                 - B(I,J,9,5)*B(I,J,5, 7)
     5                                 - B(I,J,9,6)*B(I,J,6, 7)
            B(I,J,9, 8) =  B(I,J,9, 8) - B(I,J,9,1)*B(I,J,1, 8)
     1                                 - B(I,J,9,2)*B(I,J,2, 8)
     2                                 - B(I,J,9,3)*B(I,J,3, 8)
     3                                 - B(I,J,9,4)*B(I,J,4, 8)
     4                                 - B(I,J,9,5)*B(I,J,5, 8)
     5                                 - B(I,J,9,6)*B(I,J,6, 8)
     6                                 - B(I,J,9,7)*B(I,J,7, 8)
            B(I,J,9, 9) =  B(I,J,9, 9) - B(I,J,9,1)*B(I,J,1, 9)
     1                                 - B(I,J,9,2)*B(I,J,2, 9)
     2                                 - B(I,J,9,3)*B(I,J,3, 9)
     3                                 - B(I,J,9,4)*B(I,J,4, 9)
     4                                 - B(I,J,9,5)*B(I,J,5, 9)
     5                                 - B(I,J,9,6)*B(I,J,6, 9)
     6                                 - B(I,J,9,7)*B(I,J,7, 9)
     7                                 - B(I,J,9,8)*B(I,J,8, 9)
            B(I,J,9,10) = (B(I,J,9,10) - B(I,J,9,1)*B(I,J,1,10)
     1                                 - B(I,J,9,2)*B(I,J,2,10)
     2                                 - B(I,J,9,3)*B(I,J,3,10)
     3                                 - B(I,J,9,4)*B(I,J,4,10)
     4                                 - B(I,J,9,5)*B(I,J,5,10)
     5                                 - B(I,J,9,6)*B(I,J,6,10)
     6                                 - B(I,J,9,7)*B(I,J,7,10)
     7                                 - B(I,J,9,8)*B(I,J,8,10))
     8                    /B(I,J,9,9)
            B(I,J,9,11) = (B(I,J,9,11) - B(I,J,9,1)*B(I,J,1,11)
     1                                 - B(I,J,9,2)*B(I,J,2,11)
     2                                 - B(I,J,9,3)*B(I,J,3,11)
     3                                 - B(I,J,9,4)*B(I,J,4,11)
     4                                 - B(I,J,9,5)*B(I,J,5,11)
     5                                 - B(I,J,9,6)*B(I,J,6,11)
     6                                 - B(I,J,9,7)*B(I,J,7,11)
     7                                 - B(I,J,9,8)*B(I,J,8,11))
     8                    /B(I,J,9,9)
            B(I,J,9,12) = (B(I,J,9,12) - B(I,J,9,1)*B(I,J,1,12)
     1                                 - B(I,J,9,2)*B(I,J,2,12)
     2                                 - B(I,J,9,3)*B(I,J,3,12)
     3                                 - B(I,J,9,4)*B(I,J,4,12)
     4                                 - B(I,J,9,5)*B(I,J,5,12)
     5                                 - B(I,J,9,6)*B(I,J,6,12)
     6                                 - B(I,J,9,7)*B(I,J,7,12)
     7                                 - B(I,J,9,8)*B(I,J,8,12))
     8                    /B(I,J,9,9)
C
C     Row 10
C
            B(I,J,10, 2)= B(I,J,10, 2) - B(I,J,10,1)*B(I,J,1, 2)
            B(I,J,10, 3)= B(I,J,10, 3) - B(I,J,10,1)*B(I,J,1, 3)
     1                                 - B(I,J,10,2)*B(I,J,2, 3)
            B(I,J,10, 4)= B(I,J,10, 4) - B(I,J,10,1)*B(I,J,1, 4)
     1                                 - B(I,J,10,2)*B(I,J,2, 4)
     2                                 - B(I,J,10,3)*B(I,J,3, 4)
            B(I,J,10, 5)= B(I,J,10, 5) - B(I,J,10,1)*B(I,J,1, 5)
     1                                 - B(I,J,10,2)*B(I,J,2, 5)
     2                                 - B(I,J,10,3)*B(I,J,3, 5)
     3                                 - B(I,J,10,4)*B(I,J,4, 5)
            B(I,J,10, 6)= B(I,J,10, 6) - B(I,J,10,1)*B(I,J,1, 6)
     1                                 - B(I,J,10,2)*B(I,J,2, 6)
     2                                 - B(I,J,10,3)*B(I,J,3, 6)
     3                                 - B(I,J,10,4)*B(I,J,4, 6)
     4                                 - B(I,J,10,5)*B(I,J,5, 6)
            B(I,J,10, 7)= B(I,J,10, 7) - B(I,J,10,1)*B(I,J,1, 7)
     1                                 - B(I,J,10,2)*B(I,J,2, 7)
     2                                 - B(I,J,10,3)*B(I,J,3, 7)
     3                                 - B(I,J,10,4)*B(I,J,4, 7)
     4                                 - B(I,J,10,5)*B(I,J,5, 7)
     5                                 - B(I,J,10,6)*B(I,J,6, 7)
            B(I,J,10, 8)= B(I,J,10, 8) - B(I,J,10,1)*B(I,J,1, 8)
     1                                 - B(I,J,10,2)*B(I,J,2, 8)
     2                                 - B(I,J,10,3)*B(I,J,3, 8)
     3                                 - B(I,J,10,4)*B(I,J,4, 8)
     4                                 - B(I,J,10,5)*B(I,J,5, 8)
     5                                 - B(I,J,10,6)*B(I,J,6, 8)
     6                                 - B(I,J,10,7)*B(I,J,7, 8)
            B(I,J,10, 9)= B(I,J,10, 9) - B(I,J,10,1)*B(I,J,1, 9)
     1                                 - B(I,J,10,2)*B(I,J,2, 9)
     2                                 - B(I,J,10,3)*B(I,J,3, 9)
     3                                 - B(I,J,10,4)*B(I,J,4, 9)
     4                                 - B(I,J,10,5)*B(I,J,5, 9)
     5                                 - B(I,J,10,6)*B(I,J,6, 9)
     6                                 - B(I,J,10,7)*B(I,J,7, 9)
     7                                 - B(I,J,10,8)*B(I,J,8, 9)
            B(I,J,10,10)= B(I,J,10,10) - B(I,J,10,1)*B(I,J,1,10)
     1                                 - B(I,J,10,2)*B(I,J,2,10)
     2                                 - B(I,J,10,3)*B(I,J,3,10)
     3                                 - B(I,J,10,4)*B(I,J,4,10)
     4                                 - B(I,J,10,5)*B(I,J,5,10)
     5                                 - B(I,J,10,6)*B(I,J,6,10)
     6                                 - B(I,J,10,7)*B(I,J,7,10)
     7                                 - B(I,J,10,8)*B(I,J,8,10)
     8                                 - B(I,J,10,9)*B(I,J,9,10)
            B(I,J,10,11)=(B(I,J,10,11) - B(I,J,10,1)*B(I,J,1,11)
     1                                 - B(I,J,10,2)*B(I,J,2,11)
     2                                 - B(I,J,10,3)*B(I,J,3,11)
     3                                 - B(I,J,10,4)*B(I,J,4,11)
     4                                 - B(I,J,10,5)*B(I,J,5,11)
     5                                 - B(I,J,10,6)*B(I,J,6,11)
     6                                 - B(I,J,10,7)*B(I,J,7,11)
     7                                 - B(I,J,10,8)*B(I,J,8,11)
     8                                 - B(I,J,10,9)*B(I,J,9,11))
     9                   /B(I,J,10,10)
            B(I,J,10,12)=(B(I,J,10,12) - B(I,J,10,1)*B(I,J,1,12)
     1                                 - B(I,J,10,2)*B(I,J,2,12)
     2                                 - B(I,J,10,3)*B(I,J,3,12)
     3                                 - B(I,J,10,4)*B(I,J,4,12)
     4                                 - B(I,J,10,5)*B(I,J,5,12)
     5                                 - B(I,J,10,6)*B(I,J,6,12)
     6                                 - B(I,J,10,7)*B(I,J,7,12)
     7                                 - B(I,J,10,8)*B(I,J,8,12)
     8                                 - B(I,J,10,9)*B(I,J,9,12))
     9                   /B(I,J,10,10)
C
C     Row 11
C
            B(I,J,11, 2)= B(I,J,11, 2) - B(I,J,11,1)*B(I,J,1, 2)
            B(I,J,11, 3)= B(I,J,11, 3) - B(I,J,11,1)*B(I,J,1, 3)
     1                                 - B(I,J,11,2)*B(I,J,2, 3)
            B(I,J,11, 4)= B(I,J,11, 4) - B(I,J,11,1)*B(I,J,1, 4)
     1                                 - B(I,J,11,2)*B(I,J,2, 4)
     2                                 - B(I,J,11,3)*B(I,J,3, 4)
            B(I,J,11, 5)= B(I,J,11, 5) - B(I,J,11,1)*B(I,J,1, 5)
     1                                 - B(I,J,11,2)*B(I,J,2, 5)
     2                                 - B(I,J,11,3)*B(I,J,3, 5)
     3                                 - B(I,J,11,4)*B(I,J,4, 5)
            B(I,J,11, 6)= B(I,J,11, 6) - B(I,J,11,1)*B(I,J,1, 6)
     1                                 - B(I,J,11,2)*B(I,J,2, 6)
     2                                 - B(I,J,11,3)*B(I,J,3, 6)
     3                                 - B(I,J,11,4)*B(I,J,4, 6)
     4                                 - B(I,J,11,5)*B(I,J,5, 6)
            B(I,J,11, 7)= B(I,J,11, 7) - B(I,J,11,1)*B(I,J,1, 7)
     1                                 - B(I,J,11,2)*B(I,J,2, 7)
     2                                 - B(I,J,11,3)*B(I,J,3, 7)
     3                                 - B(I,J,11,4)*B(I,J,4, 7)
     4                                 - B(I,J,11,5)*B(I,J,5, 7)
     5                                 - B(I,J,11,6)*B(I,J,6, 7)
            B(I,J,11, 8)= B(I,J,11, 8) - B(I,J,11,1)*B(I,J,1, 8)
     1                                 - B(I,J,11,2)*B(I,J,2, 8)
     2                                 - B(I,J,11,3)*B(I,J,3, 8)
     3                                 - B(I,J,11,4)*B(I,J,4, 8)
     4                                 - B(I,J,11,5)*B(I,J,5, 8)
     5                                 - B(I,J,11,6)*B(I,J,6, 8)
     6                                 - B(I,J,11,7)*B(I,J,7, 8)
            B(I,J,11, 9)= B(I,J,11, 9) - B(I,J,11,1)*B(I,J,1, 9)
     1                                 - B(I,J,11,2)*B(I,J,2, 9)
     2                                 - B(I,J,11,3)*B(I,J,3, 9)
     3                                 - B(I,J,11,4)*B(I,J,4, 9)
     4                                 - B(I,J,11,5)*B(I,J,5, 9)
     5                                 - B(I,J,11,6)*B(I,J,6, 9)
     6                                 - B(I,J,11,7)*B(I,J,7, 9)
     7                                 - B(I,J,11,8)*B(I,J,8, 9)
            B(I,J,11,10)= B(I,J,11,10) - B(I,J,11,1)*B(I,J,1,10)
     1                                 - B(I,J,11,2)*B(I,J,2,10)
     2                                 - B(I,J,11,3)*B(I,J,3,10)
     3                                 - B(I,J,11,4)*B(I,J,4,10)
     4                                 - B(I,J,11,5)*B(I,J,5,10)
     5                                 - B(I,J,11,6)*B(I,J,6,10)
     6                                 - B(I,J,11,7)*B(I,J,7,10)
     7                                 - B(I,J,11,8)*B(I,J,8,10)
     8                                 - B(I,J,11,9)*B(I,J,9,10)
            B(I,J,11,11)= B(I,J,11,11) - B(I,J,11,1)*B(I,J,1,11)
     1                                 - B(I,J,11,2)*B(I,J,2,11)
     2                                 - B(I,J,11,3)*B(I,J,3,11)
     3                                 - B(I,J,11,4)*B(I,J,4,11)
     4                                 - B(I,J,11,5)*B(I,J,5,11)
     5                                 - B(I,J,11,6)*B(I,J,6,11)
     6                                 - B(I,J,11,7)*B(I,J,7,11)
     7                                 - B(I,J,11,8)*B(I,J,8,11)
     8                                 - B(I,J,11,9)*B(I,J,9,11)
     9                                 - B(I,J,11,10)*B(I,J,10,11)
            B(I,J,11,12)=(B(I,J,11,12) - B(I,J,11,1)*B(I,J,1,12)
     1                                 - B(I,J,11,2)*B(I,J,2,12)
     2                                 - B(I,J,11,3)*B(I,J,3,12)
     3                                 - B(I,J,11,4)*B(I,J,4,12)
     4                                 - B(I,J,11,5)*B(I,J,5,12)
     5                                 - B(I,J,11,6)*B(I,J,6,12)
     6                                 - B(I,J,11,7)*B(I,J,7,12)
     7                                 - B(I,J,11,8)*B(I,J,8,12)
     8                                 - B(I,J,11,9)*B(I,J,9,12)
     9                                 - B(I,J,11,10)*B(I,J,10,12))
     A                   /B(I,J,11,11)
C
C     Row 12
C
            B(I,J,12, 2)= B(I,J,12, 2) - B(I,J,12,1)*B(I,J,1, 2)
            B(I,J,12, 3)= B(I,J,12, 3) - B(I,J,12,1)*B(I,J,1, 3)
     1                                 - B(I,J,12,2)*B(I,J,2, 3)
            B(I,J,12, 4)= B(I,J,12, 4) - B(I,J,12,1)*B(I,J,1, 4)
     1                                 - B(I,J,12,2)*B(I,J,2, 4)
     2                                 - B(I,J,12,3)*B(I,J,3, 4)
            B(I,J,12, 5)= B(I,J,12, 5) - B(I,J,12,1)*B(I,J,1, 5)
     1                                 - B(I,J,12,2)*B(I,J,2, 5)
     2                                 - B(I,J,12,3)*B(I,J,3, 5)
     3                                 - B(I,J,12,4)*B(I,J,4, 5)
            B(I,J,12, 6)= B(I,J,12, 6) - B(I,J,12,1)*B(I,J,1, 6)
     1                                 - B(I,J,12,2)*B(I,J,2, 6)
     2                                 - B(I,J,12,3)*B(I,J,3, 6)
     3                                 - B(I,J,12,4)*B(I,J,4, 6)
     4                                 - B(I,J,12,5)*B(I,J,5, 6)
            B(I,J,12, 7)= B(I,J,12, 7) - B(I,J,12,1)*B(I,J,1, 7)
     1                                 - B(I,J,12,2)*B(I,J,2, 7)
     2                                 - B(I,J,12,3)*B(I,J,3, 7)
     3                                 - B(I,J,12,4)*B(I,J,4, 7)
     4                                 - B(I,J,12,5)*B(I,J,5, 7)
     5                                 - B(I,J,12,6)*B(I,J,6, 7)
            B(I,J,12, 8)= B(I,J,12, 8) - B(I,J,12,1)*B(I,J,1, 8)
     1                                 - B(I,J,12,2)*B(I,J,2, 8)
     2                                 - B(I,J,12,3)*B(I,J,3, 8)
     3                                 - B(I,J,12,4)*B(I,J,4, 8)
     4                                 - B(I,J,12,5)*B(I,J,5, 8)
     5                                 - B(I,J,12,6)*B(I,J,6, 8)
     6                                 - B(I,J,12,7)*B(I,J,7, 8)
            B(I,J,12, 9)= B(I,J,12, 9) - B(I,J,12,1)*B(I,J,1, 9)
     1                                 - B(I,J,12,2)*B(I,J,2, 9)
     2                                 - B(I,J,12,3)*B(I,J,3, 9)
     3                                 - B(I,J,12,4)*B(I,J,4, 9)
     4                                 - B(I,J,12,5)*B(I,J,5, 9)
     5                                 - B(I,J,12,6)*B(I,J,6, 9)
     6                                 - B(I,J,12,7)*B(I,J,7, 9)
     7                                 - B(I,J,12,8)*B(I,J,8, 9)
            B(I,J,12,10)= B(I,J,12,10) - B(I,J,12,1)*B(I,J,1,10)
     1                                 - B(I,J,12,2)*B(I,J,2,10)
     2                                 - B(I,J,12,3)*B(I,J,3,10)
     3                                 - B(I,J,12,4)*B(I,J,4,10)
     4                                 - B(I,J,12,5)*B(I,J,5,10)
     5                                 - B(I,J,12,6)*B(I,J,6,10)
     6                                 - B(I,J,12,7)*B(I,J,7,10)
     7                                 - B(I,J,12,8)*B(I,J,8,10)
     8                                 - B(I,J,12,9)*B(I,J,9,10)
            B(I,J,12,11)= B(I,J,12,11) - B(I,J,12,1)*B(I,J,1,11)
     1                                 - B(I,J,12,2)*B(I,J,2,11)
     2                                 - B(I,J,12,3)*B(I,J,3,11)
     3                                 - B(I,J,12,4)*B(I,J,4,11)
     4                                 - B(I,J,12,5)*B(I,J,5,11)
     5                                 - B(I,J,12,6)*B(I,J,6,11)
     6                                 - B(I,J,12,7)*B(I,J,7,11)
     7                                 - B(I,J,12,8)*B(I,J,8,11)
     8                                 - B(I,J,12,9)*B(I,J,9,11)
     9                                 - B(I,J,12,10)*B(I,J,10,11)
            B(I,J,12,12)= B(I,J,12,12) - B(I,J,12,1)*B(I,J,1,12)
     1                                 - B(I,J,12,2)*B(I,J,2,12)
     2                                 - B(I,J,12,3)*B(I,J,3,12)
     3                                 - B(I,J,12,4)*B(I,J,4,12)
     4                                 - B(I,J,12,5)*B(I,J,5,12)
     5                                 - B(I,J,12,6)*B(I,J,6,12)
     6                                 - B(I,J,12,7)*B(I,J,7,12)
     7                                 - B(I,J,12,8)*B(I,J,8,12)
     8                                 - B(I,J,12,9)*B(I,J,9,12)
     9                                 - B(I,J,12,10)*B(I,J,10,12)
     A                                 - B(I,J,12,11)*B(I,J,11,12)
 200     CONTINUE
C
C     Form U(i,i+1) = L[inverse](i,i) * C(i) for all except last term
C
         IF (J .NE. NPTS) THEN
            DO 500 L = 1, 12
               DO 480 I = 1, NSIM
C
C     Forward sweep of lu decomposition to form L[inverse]
C
                  C(I,J,1,L) = C(I,J,1,L) / B(I,J,1,1)
                  C(I,J,2,L) = ( C(I,J,2,L) - B(I,J,2,1)*C(I,J,1,L) )
     1                         / B(I,J,2,2)
                  C(I,J,3,L) = ( C(I,J,3,L) - B(I,J,3,1)*C(I,J,1,L)
     1                                      - B(I,J,3,2)*C(I,J,2,L) )
     2                         / B(I,J,3,3)
                  C(I,J,4,L) = ( C(I,J,4,L) - B(I,J,4,1)*C(I,J,1,L)
     1                                      - B(I,J,4,2)*C(I,J,2,L)
     2                                      - B(I,J,4,3)*C(I,J,3,L) )
     3                         / B(I,J,4,4)
                  C(I,J,5,L) = ( C(I,J,5,L) - B(I,J,5,1)*C(I,J,1,L)
     1                                      - B(I,J,5,2)*C(I,J,2,L)
     2                                      - B(I,J,5,3)*C(I,J,3,L)
     3                                      - B(I,J,5,4)*C(I,J,4,L) )
     4                         / B(I,J,5,5)
                  C(I,J,6,L) = ( C(I,J,6,L) - B(I,J,6,1)*C(I,J,1,L)
     1                                      - B(I,J,6,2)*C(I,J,2,L)
     2                                      - B(I,J,6,3)*C(I,J,3,L)
     3                                      - B(I,J,6,4)*C(I,J,4,L)
     4                                      - B(I,J,6,5)*C(I,J,5,L) )
     5                         / B(I,J,6,6)
                  C(I,J,7,L) = ( C(I,J,7,L) - B(I,J,7,1)*C(I,J,1,L)
     1                                      - B(I,J,7,2)*C(I,J,2,L)
     2                                      - B(I,J,7,3)*C(I,J,3,L)
     3                                      - B(I,J,7,4)*C(I,J,4,L)
     4                                      - B(I,J,7,5)*C(I,J,5,L)
     5                                      - B(I,J,7,6)*C(I,J,6,L) )
     6                         / B(I,J,7,7)
                  C(I,J,8,L) = ( C(I,J,8,L) - B(I,J,8,1)*C(I,J,1,L)
     1                                      - B(I,J,8,2)*C(I,J,2,L)
     2                                      - B(I,J,8,3)*C(I,J,3,L)
     3                                      - B(I,J,8,4)*C(I,J,4,L)
     4                                      - B(I,J,8,5)*C(I,J,5,L)
     5                                      - B(I,J,8,6)*C(I,J,6,L)
     6                                      - B(I,J,8,7)*C(I,J,7,L) )
     7                         / B(I,J,8,8)
                  C(I,J,9,L) = ( C(I,J,9,L) - B(I,J,9,1)*C(I,J,1,L)
     1                                      - B(I,J,9,2)*C(I,J,2,L)
     2                                      - B(I,J,9,3)*C(I,J,3,L)
     3                                      - B(I,J,9,4)*C(I,J,4,L)
     4                                      - B(I,J,9,5)*C(I,J,5,L)
     5                                      - B(I,J,9,6)*C(I,J,6,L)
     6                                      - B(I,J,9,7)*C(I,J,7,L)
     7                                      - B(I,J,9,8)*C(I,J,8,L) )
     8                         / B(I,J,9,9)
                  C(I,J,10,L)=( C(I,J,10,L) - B(I,J,10,1)*C(I,J,1,L)
     1                                      - B(I,J,10,2)*C(I,J,2,L)
     2                                      - B(I,J,10,3)*C(I,J,3,L)
     3                                      - B(I,J,10,4)*C(I,J,4,L)
     4                                      - B(I,J,10,5)*C(I,J,5,L)
     5                                      - B(I,J,10,6)*C(I,J,6,L)
     6                                      - B(I,J,10,7)*C(I,J,7,L)
     7                                      - B(I,J,10,8)*C(I,J,8,L)
     8                                      - B(I,J,10,9)*C(I,J,9,L) )
     9                         / B(I,J,10,10)
                  C(I,J,11,L)=( C(I,J,11,L) - B(I,J,11,1)*C(I,J,1,L)
     1                                      - B(I,J,11,2)*C(I,J,2,L)
     2                                      - B(I,J,11,3)*C(I,J,3,L)
     3                                      - B(I,J,11,4)*C(I,J,4,L)
     4                                      - B(I,J,11,5)*C(I,J,5,L)
     5                                      - B(I,J,11,6)*C(I,J,6,L)
     6                                      - B(I,J,11,7)*C(I,J,7,L)
     7                                      - B(I,J,11,8)*C(I,J,8,L)
     8                                      - B(I,J,11,9)*C(I,J,9,L)
     9                                      - B(I,J,11,10)*C(I,J,10,L) )
     A                         / B(I,J,11,11)
                  C(I,J,12,L)=( C(I,J,12,L) - B(I,J,12,1)*C(I,J,1,L)
     1                                      - B(I,J,12,2)*C(I,J,2,L)
     2                                      - B(I,J,12,3)*C(I,J,3,L)
     3                                      - B(I,J,12,4)*C(I,J,4,L)
     4                                      - B(I,J,12,5)*C(I,J,5,L)
     5                                      - B(I,J,12,6)*C(I,J,6,L)
     6                                      - B(I,J,12,7)*C(I,J,7,L)
     7                                      - B(I,J,12,8)*C(I,J,8,L)
     8                                      - B(I,J,12,9)*C(I,J,9,L)
     9                                      - B(I,J,12,10)*C(I,J,10,L)
     A                                      - B(I,J,12,11)*C(I,J,11,L) )
     B                         / B(I,J,12,12)
C
C     Backward Sweep of lu
C
                  C(I,J,11,L) = C(I,J,11,L) - B(I,J,11,12)*C(I,J,12,L)
                  C(I,J,10,L) = C(I,J,10,L) - B(I,J,10,11)*C(I,J,11,L)
     1                                      - B(I,J,10,12)*C(I,J,12,L)
                  C(I,J, 9,L) = C(I,J, 9,L) - B(I,J, 9,10)*C(I,J,10,L)
     1                                      - B(I,J, 9,11)*C(I,J,11,L)
     2                                      - B(I,J, 9,12)*C(I,J,12,L)
                  C(I,J, 8,L) = C(I,J, 8,L) - B(I,J, 8, 9)*C(I,J, 9,L)
     1                                      - B(I,J, 8,10)*C(I,J,10,L)
     2                                      - B(I,J, 8,11)*C(I,J,11,L)
     3                                      - B(I,J, 8,12)*C(I,J,12,L)
                  C(I,J, 7,L) = C(I,J, 7,L) - B(I,J, 7, 8)*C(I,J, 8,L)
     1                                      - B(I,J, 7, 9)*C(I,J, 9,L)
     2                                      - B(I,J, 7,10)*C(I,J,10,L)
     3                                      - B(I,J, 7,11)*C(I,J,11,L)
     4                                      - B(I,J, 7,12)*C(I,J,12,L)
                  C(I,J, 6,L) = C(I,J, 6,L) - B(I,J, 6, 7)*C(I,J, 7,L)
     1                                      - B(I,J, 6, 8)*C(I,J, 8,L)
     2                                      - B(I,J, 6, 9)*C(I,J, 9,L)
     3                                      - B(I,J, 6,10)*C(I,J,10,L)
     4                                      - B(I,J, 6,11)*C(I,J,11,L)
     5                                      - B(I,J, 6,12)*C(I,J,12,L)
                  C(I,J, 5,L) = C(I,J, 5,L) - B(I,J, 5, 6)*C(I,J, 6,L)
     1                                      - B(I,J, 5, 7)*C(I,J, 7,L)
     2                                      - B(I,J, 5, 8)*C(I,J, 8,L)
     3                                      - B(I,J, 5, 9)*C(I,J, 9,L)
     4                                      - B(I,J, 5,10)*C(I,J,10,L)
     5                                      - B(I,J, 5,11)*C(I,J,11,L)
     6                                      - B(I,J, 5,12)*C(I,J,12,L)
                  C(I,J, 4,L) = C(I,J, 4,L) - B(I,J, 4, 5)*C(I,J, 5,L)
     1                                      - B(I,J, 4, 6)*C(I,J, 6,L)
     2                                      - B(I,J, 4, 7)*C(I,J, 7,L)
     3                                      - B(I,J, 4, 8)*C(I,J, 8,L)
     4                                      - B(I,J, 4, 9)*C(I,J, 9,L)
     5                                      - B(I,J, 4,10)*C(I,J,10,L)
     6                                      - B(I,J, 4,11)*C(I,J,11,L)
     7                                      - B(I,J, 4,12)*C(I,J,12,L)
                  C(I,J, 3,L) = C(I,J, 3,L) - B(I,J, 3, 4)*C(I,J, 4,L)
     1                                      - B(I,J, 3, 5)*C(I,J, 5,L)
     2                                      - B(I,J, 3, 6)*C(I,J, 6,L)
     3                                      - B(I,J, 3, 7)*C(I,J, 7,L)
     4                                      - B(I,J, 3, 8)*C(I,J, 8,L)
     5                                      - B(I,J, 3, 9)*C(I,J, 9,L)
     6                                      - B(I,J, 3,10)*C(I,J,10,L)
     7                                      - B(I,J, 3,11)*C(I,J,11,L)
     8                                      - B(I,J, 3,12)*C(I,J,12,L)
                  C(I,J, 2,L) = C(I,J, 2,L) - B(I,J, 2, 3)*C(I,J, 3,L)
     1                                      - B(I,J, 2, 4)*C(I,J, 4,L)
     2                                      - B(I,J, 2, 5)*C(I,J, 5,L)
     3                                      - B(I,J, 2, 6)*C(I,J, 6,L)
     4                                      - B(I,J, 2, 7)*C(I,J, 7,L)
     5                                      - B(I,J, 2, 8)*C(I,J, 8,L)
     6                                      - B(I,J, 2, 9)*C(I,J, 9,L)
     7                                      - B(I,J, 2,10)*C(I,J,10,L)
     8                                      - B(I,J, 2,11)*C(I,J,11,L)
     9                                      - B(I,J, 2,12)*C(I,J,12,L)
                  C(I,J, 1,L) = C(I,J, 1,L) - B(I,J, 1, 2)*C(I,J, 2,L)
     1                                      - B(I,J, 1, 3)*C(I,J, 3,L)
     2                                      - B(I,J, 1, 4)*C(I,J, 4,L)
     3                                      - B(I,J, 1, 5)*C(I,J, 5,L)
     4                                      - B(I,J, 1, 6)*C(I,J, 6,L)
     5                                      - B(I,J, 1, 7)*C(I,J, 7,L)
     6                                      - B(I,J, 1, 8)*C(I,J, 8,L)
     7                                      - B(I,J, 1, 9)*C(I,J, 9,L)
     8                                      - B(I,J, 1,10)*C(I,J,10,L)
     9                                      - B(I,J, 1,11)*C(I,J,11,L)
     A                                      - B(I,J, 1,12)*C(I,J,12,L)
 480           CONTINUE
 500        CONTINUE
         ENDIF
 600  CONTINUE
C
C     Finished forming LU
      RETURN
      END
      SUBROUTINE VLUTRS (NPTS, NSIM, A, B, C)
C
C     Routine to do a vectorized LU decomposition of a
C     scalar tridiagonal system of equations.
C     The recursive nature of the LU decomposition leads
C     to a form which is not vectorizable.  Therefore, the
C     approach of this routine is to not attempt vectorization
C     of the LU, but to accomplish the vectorization through
C     simultaneously doing NSIM LU decompositions.
C     This form is with the identity on the diagonal of U.
C
C     NPTS:      The number of elements in the tridiagonal system
C     NSIM:      The number of tridiagonal systems to simultaneously invert
C     A:         The supra-diagonal scalar term
C     B:         The       diagonal scalar term
C     C:         The super-diagonal scalar term
C
C     On Exit:
C     A:         L(j,j-1) The supra-diagonal term of L
C     B:         L(j,j)[-1]
C     C:         U(j,j+1) The super-diagonal term of U
C
C     L(i,i-1) = A(i) therefore no operations need to be performed on A.
C     L(i,i)   = B(i) - L(i,i-1)*U(i-1,i)
C     U(i,i+1) = L[inverse](i,i)*C(i)
C
      DIMENSION A (NSIM,NPTS),
     1          B (NSIM,NPTS),
     2          C (NSIM,NPTS)
C
C     Form L(1,1) and U(1,2)
C
      J = 1
C
C     L(1,1) = B(1) => Leave B(1) unchanged
C     Form U(1,2) = L[inverse](1,1) * C(1)
C
      DO 200 I = 1, NSIM
         C(I,J) = C(I,J) / B(I,J)
  200 CONTINUE
C
C     Loop over J = 2 to NPTS-1 forming the LU terms
C
      DO 400 J = 2, NPTS-1
C
C     Form L(i,i) = B(i) - L(i,i-1)*U(i-1,i)
C     Form U(i,i+1) = L[inverse](i,i) * C(i)
C
         DO 300 I = 1, NSIM
            B(I,J) = B(I,J) - A(I,J)*C(I,J-1)
            C(I,J) = C(I,J) / B(I,J)
  300    CONTINUE
  400 CONTINUE
C
C     Form L(N,N) = B(N) - L(N,N-1)*U(N-1,N)
C
      J = NPTS
      DO 500 I = 1, NSIM
         B(I,J) = B(I,J) - A(I,J)*C(I,J-1)
  500 CONTINUE
C
C     Finished forming LU
      RETURN
      END
      SUBROUTINE BLDLMX (JDIM, RHOW, TAUW, RMUW, UMAX, UMIN, Y, RHO,
     1                   VORT, F, RMUT)
C
C     Routine to calculate the turbulent eddy viscosity using
C     the two-layer algebraic Baldwin-Lomax model of AIAA 78-257.
C
C     JDIM     : Dimension
C     RHOW     : Density at the wall
C     TAUW     : Wall shear stress
C     RMUW     : Molecular viscosity at the wall
C     UMAX     : The maximum value of the velocity magnitude in the profile
C     UMIN     : The minimum value of the velocity magnitude in the profile
C     Y        : Distance from the wall
C     RHO      : Density
C     VORT     : Vorticity magnitude
C     F        : Function for the outer layer
C     RMUT     : The turbulent eddy viscosity calculated by this routine
C
C     The above variables are in non-dimensional form as follows:
C        density   non-dimensionalized by freestream density
C        velocity  non-dimensionalized by freestream speed of sound
C        viscosity non-dimensionalized by freestream molecular viscosity
C        distance  non-dimensionalized by characteristic length L
C
      include 'common.inc'
C
      DIMENSION Y     (JDIM),
     1          RHO   (JDIM),
     2          VORT  (JDIM),
     3          F     (JDIM),
     4          RMUT  (JDIM)
C
C     Baldwin-Lomax constants
C
      RK     = 0.4E0
      APLUS  = 26.E0
      CLAUSR = 0.0168E0
      CCP    = 1.6E0
      CWK    = 0.25E0
      CKLEB  = 0.3E0
C
      YPWALL = SQRT(RE/FSMACH*RHOW*TAUW) / RMUW
C
C     Loop over J defining the inner turbulent viscosity and
C     determining the function F(y).
C     In the definition of F(y), the exponential term should be
C     set to zero for a wake.  This is not presently done.
C
      DO 100 J = 1, JDIM
         YPLUS   = YPWALL * Y(J)
         ETERM   = Y(J) * (1.E0 - EXP(-YPLUS/APLUS))
         RLNGTH  = RK * ETERM
         F(J)    = ETERM * VORT(J)
         RMUT(J) = RE / FSMACH * RHO(J) * RLNGTH * RLNGTH * VORT(J)
  100 CONTINUE
C
C     Determine the maximum of the function F(y) and the associated y
C
      JSTRT = 1
      JEND  = JDIM
      FMAX  = 0.E0
      DO 200 J = JSTRT, JEND
         IF (F(J) .GT. FMAX) THEN
            FMAX = F(J)
            YMAX = Y(J)
         ENDIF
  200 CONTINUE
C
C     Form the outer layer eddy viscosity values and store them in
C     the F array.
C
      UDIFF = UMAX - UMIN
      FWAKE = MIN( (YMAX*FMAX), (CWK*YMAX*UDIFF*UDIFF/FMAX) )
      DO 300 J = 1, JDIM
         FKLEB = 1.E0 / (1.E0 + 5.5E0*(CKLEB*Y(J)/YMAX)**6)
         F(J) = RE / FSMACH * CLAUSR * CCP * RHO(J) * FWAKE * FKLEB
  300 CONTINUE
C
C     Determine where the switch from the inner to the outer model occurs
C
      JSWITCH = JDIM
      DO 400 J = 1, JDIM
         IF (RMUT(J) .GE. F(J)) THEN
            JSWITCH = J
            GO TO 410
         ENDIF
  400 CONTINUE
  410 CONTINUE
C
C     Store the outer model value of eddy viscosity into the eddy
C     viscosity array for J >= JSWITCH (the crossover point)
C
      DO 500 J = JSWITCH, JDIM
         RMUT(J) = F(J)
  500 CONTINUE
C
C     Finished calculating the algebraic eddy viscosity
      RETURN
      END
      SUBROUTINE TURB (IDIM, JDIM, KDIM, MAXDIM, I, ITURB,
     1                 Q, RMUT, S, VOL, IBCDAT, NBCS,
     2                 VORT, TVIS, DIST,
     3                 RHO, VORTJ, RMUTJ, Y, FUN)
C
C     Routine to calculate the eddy viscosity coefficient.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     MAXDIM         : Maximum dimension of the J-K plane
C     I              : Current I Plane
C     ITURB          : Turbulence model
C     Q              : Primitive variables at cell centers
C     RMUT           : Eddy Viscosity at cell centers
C     S              : Metrics
C     VOL            : Cell volumes
C     IBCDAT         : Data controlling boundary conditions
C     NBCS           : Number of boundary conditions for current block
C     VORT           : Temporary storage of the magnitude of the vorticity
C     TVIS           : Storage for the turbulent eddy viscosity in J-K plane.
C                      This will store the viscosity for up to 4 walls.
C     DIST           : Storage for the normal distance to wall in J-K plane.
C                      This will store the distance for up to 4 walls.
C     RHO            : Density in the profile
C     VORTJ          : Vorticity in the profile
C     RMUTJ          : Turbulent eddy viscosity in the profile
C     Y              : Normal distance from wall in the profile
C     FUN            : Used in BLDLMX to calculate F(y) and store mu(outer)
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2),
     2          S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     3          VOL   (0:JDIM+1,0:KDIM+1,0:IDIM+1)
C
      DIMENSION VORT  (0:JDIM+1,0:KDIM+1),
     1          TVIS  (0:JDIM+1,0:KDIM+1,4),
     2          DIST  (0:JDIM+1,0:KDIM+1,4)
C
C     Profile variables
C
      DIMENSION RHO   (MAXDIM+1),
     1          VORTJ (MAXDIM+1),
     2          RMUTJ (MAXDIM+1),
     3          Y     (MAXDIM+1),
     4          FUN   (MAXDIM+1)
C
      DIMENSION IBCDAT(10,NBCS)
C
C     Function for Sutherlands Law
C
      VIS(TT,VNUM,VTINF) = TT * SQRT( TT ) * VNUM / ( TT + VTINF )
C
C     Constants for Sutherlands Law
C
      SREF  = 198.6E0
      IF ( SIUNIT ) SREF = SREF / 1.8E0
      STINF = SREF / TINF
      SNUM  = 1.E0 + STINF
C
C     Initialize J1W, JDIMW, K1W, KDIMW
C     These variables tell if there is a wall on the J = 1, J = JDIM
C     K = 1 or K = KDIM boundaries.  This data tells the turbulent
C     scheme to calculate turbulence eddy viscosities based on all walls
C     present but must calculate the viscosity over the entire plane
C     rather than just of the wall.
C
      J1W   = 0
      JDIMW = 0
      K1W   = 0
      KDIMW = 0
C
C     Calculate the vorticity at the cell centers
C
C     The vorticity calculated at the wall will not be fixed to be exactly
C     correct.  This is not an issue as the wall value of eddy viscosity
C     is identically zero.
C
C     Store the values of U, V, W used to build up the derivative terms
C     in the DIST array as it is not used until after VORT is defined.
C     Store the derivative terms used to build up the vorticity in the
C     TVIS array as it is not used until after VORT is defined.
C
C     Form the I contribution to the magnitude of vorticity
C
      DO 120 K = 1, KDIM + 1
         DO 110 J = 1, JDIM + 1
C
C     Calculate first derivative terms using Divergence Theorem
C**** These terms will have errors in the I + I+1 terms for the
C**** MARCHing algorithm
C
            DUDY    = 0.5E0*(Q(J,K,I+1,2)+Q(J,K,I,2)) * S(J,K,I,2,1)
     1                                                * S(J,K,I,4,1)
     2              - 0.5E0*(Q(J,K,I,2)+Q(J,K,I-1,2)) * S(J,K,I-1,2,1)
     3                                                * S(J,K,I-1,4,1)
            DUDZ    = 0.5E0*(Q(J,K,I+1,2)+Q(J,K,I,2)) * S(J,K,I,3,1)
     1                                                * S(J,K,I,4,1)
     2              - 0.5E0*(Q(J,K,I,2)+Q(J,K,I-1,2)) * S(J,K,I-1,3,1)
     3                                                * S(J,K,I-1,4,1)
            DVDX    = 0.5E0*(Q(J,K,I+1,3)+Q(J,K,I,3)) * S(J,K,I,1,1)
     1                                                * S(J,K,I,4,1)
     2              - 0.5E0*(Q(J,K,I,3)+Q(J,K,I-1,3)) * S(J,K,I-1,1,1)
     3                                                * S(J,K,I-1,4,1)
            DVDZ    = 0.5E0*(Q(J,K,I+1,3)+Q(J,K,I,3)) * S(J,K,I,3,1)
     1                                                * S(J,K,I,4,1)
     2              - 0.5E0*(Q(J,K,I,3)+Q(J,K,I-1,3)) * S(J,K,I-1,3,1)
     3                                                * S(J,K,I-1,4,1)
            DWDX    = 0.5E0*(Q(J,K,I+1,4)+Q(J,K,I,4)) * S(J,K,I,1,1)
     1                                                * S(J,K,I,4,1)
     2              - 0.5E0*(Q(J,K,I,4)+Q(J,K,I-1,4)) * S(J,K,I-1,1,1)
     3                                                * S(J,K,I-1,4,1)
            DWDY    = 0.5E0*(Q(J,K,I+1,4)+Q(J,K,I,4)) * S(J,K,I,2,1)
     1                                                * S(J,K,I,4,1)
     2              - 0.5E0*(Q(J,K,I,4)+Q(J,K,I-1,4)) * S(J,K,I-1,2,1)
     3                                                * S(J,K,I-1,4,1)
            TVIS(J,K,1) = DUDY - DVDX
            TVIS(J,K,2) = DVDZ - DWDY
            TVIS(J,K,3) = DWDX - DUDZ
  110    CONTINUE
  120 CONTINUE
C
C     Form the J contribution to the magnitude of vorticity
C
C     Calculate U,V,W at cell interfaces as averages of cell centers
C     Store U in DIST(1), V in DIST(2) and W in DIST(3)
C
      DO 220 K = 2, KDIM
         DO 210 J = 0, JDIM + 1
            DIST(J,K,1) = 0.5E0 * ( Q(J,K,I,2) + Q(J+1,K,I,2) )
            DIST(J,K,2) = 0.5E0 * ( Q(J,K,I,3) + Q(J+1,K,I,3) )
            DIST(J,K,3) = 0.5E0 * ( Q(J,K,I,4) + Q(J+1,K,I,4) )
  210    CONTINUE
  220 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 250 IBC = 1, NBCS
         IF (IBCDAT(1,IBC) .EQ. IWALL .AND.
     1       IBCDAT(2,IBC) .EQ. 2) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            KSTRT  = IBCDAT(8,IBC)
            KEND   = IBCDAT(9,IBC)
            IF (INROUT .EQ. 1) THEN
               JBCPT = 1
               JNTR  = 1
               J1W   = 1
            ELSE
               JBCPT = JDIM + 1
               JNTR  = JDIM
               JDIMW = 1
            ENDIF
            IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
               DO 230 K = KSTRT, KEND
                  DIST(JNTR,K,1) = 0.E0
                  DIST(JNTR,K,2) = 0.E0
                  DIST(JNTR,K,3) = 0.E0
  230          CONTINUE
            ENDIF
         ENDIF
  250 CONTINUE
C
C     Loop over K forming the contribution along the J direction
C     to the vorticity
C
      DO 270 K = 2, KDIM
         DO 260 J = 1, JDIM
C
C     Calculate first derivative terms using Divergence Theorem
C
            DUDY = DIST(J,K,1)   * S(J,K,I,2,2)   * S(J,K,I,4,2) -
     1             DIST(J-1,K,1) * S(J-1,K,I,2,2) * S(J-1,K,I,4,2)
            DUDZ = DIST(J,K,1)   * S(J,K,I,3,2)   * S(J,K,I,4,2) -
     1             DIST(J-1,K,1) * S(J-1,K,I,3,2) * S(J-1,K,I,4,2)
            DVDX = DIST(J,K,2)   * S(J,K,I,1,2)   * S(J,K,I,4,2) -
     1             DIST(J-1,K,2) * S(J-1,K,I,1,2) * S(J-1,K,I,4,2)
            DVDZ = DIST(J,K,2)   * S(J,K,I,3,2)   * S(J,K,I,4,2) -
     1             DIST(J-1,K,2) * S(J-1,K,I,3,2) * S(J-1,K,I,4,2)
            DWDX = DIST(J,K,3)   * S(J,K,I,1,2)   * S(J,K,I,4,2) -
     1             DIST(J-1,K,3) * S(J-1,K,I,1,2) * S(J-1,K,I,4,2)
            DWDY = DIST(J,K,3)   * S(J,K,I,2,2)   * S(J,K,I,4,2) -
     1             DIST(J-1,K,3) * S(J-1,K,I,2,2) * S(J-1,K,I,4,2)
            TVIS(J,K,1) = TVIS(J,K,1) + DUDY - DVDX
            TVIS(J,K,2) = TVIS(J,K,2) + DVDZ - DWDY
            TVIS(J,K,3) = TVIS(J,K,3) + DWDX - DUDZ
  260    CONTINUE
  270 CONTINUE
C
C     Calculate U,V,W at cell interfaces as averages of cell centers
C     Store U in DIST(1), V in DIST(2) and W in DIST(3)
C
      DO 320 J = 2, JDIM
         DO 310 K = 0, KDIM + 1
            DIST(J,K,1) = 0.5E0 * ( Q(J,K,I,2) + Q(J,K+1,I,2) )
            DIST(J,K,2) = 0.5E0 * ( Q(J,K,I,3) + Q(J,K+1,I,3) )
            DIST(J,K,3) = 0.5E0 * ( Q(J,K,I,4) + Q(J,K+1,I,4) )
  310    CONTINUE
  320 CONTINUE
C
C     Loop over boundary conditions and fix the wall data
C
      DO 350 IBC = 1, NBCS
         IF (IBCDAT(1,IBC) .EQ. IWALL .AND.
     1       IBCDAT(2,IBC) .EQ. 3) THEN
            INROUT = IBCDAT(3,IBC)
            ISTRT  = IBCDAT(4,IBC)
            IEND   = IBCDAT(5,IBC)
            JSTRT  = IBCDAT(6,IBC)
            JEND   = IBCDAT(7,IBC)
            IF (INROUT .EQ. 1) THEN
               KBCPT = 1
               KNTR  = 1
               K1W   = 1
            ELSE
               KBCPT = KDIM + 1
               KNTR  = KDIM
               KDIMW = 1
            ENDIF
            IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
               DO 330 J = JSTRT, JEND
                  DIST(J,KNTR,1)   = 0.E0
                  DIST(J,KNTR,2)   = 0.E0
                  DIST(J,KNTR,3)   = 0.E0
  330          CONTINUE
            ENDIF
         ENDIF
  350 CONTINUE
C
C     Loop over J forming the contribution along the K direction
C     to the vorticity
C
      DO 370 J = 2, JDIM
         DO 360 K = 1, KDIM
C
C     Calculate first derivative terms using Divergence Theorem
C
            DUDY = DIST(J,K,1)   * S(J,K,I,2,3)   * S(J,K,I,4,3) -
     1             DIST(J,K-1,1) * S(J,K-1,I,2,3) * S(J,K-1,I,4,3)
            DUDZ = DIST(J,K,1)   * S(J,K,I,3,3)   * S(J,K,I,4,3) -
     1             DIST(J,K-1,1) * S(J,K-1,I,3,3) * S(J,K-1,I,4,3)
            DVDX = DIST(J,K,2)   * S(J,K,I,1,3)   * S(J,K,I,4,3) -
     1             DIST(J,K-1,2) * S(J,K-1,I,1,3) * S(J,K-1,I,4,3)
            DVDZ = DIST(J,K,2)   * S(J,K,I,3,3)   * S(J,K,I,4,3) -
     1             DIST(J,K-1,2) * S(J,K-1,I,3,3) * S(J,K-1,I,4,3)
            DWDX = DIST(J,K,3)   * S(J,K,I,1,3)   * S(J,K,I,4,3) -
     1             DIST(J,K-1,3) * S(J,K-1,I,1,3) * S(J,K-1,I,4,3)
            DWDY = DIST(J,K,3)   * S(J,K,I,2,3)   * S(J,K,I,4,3) -
     1             DIST(J,K-1,3) * S(J,K-1,I,2,3) * S(J,K-1,I,4,3)
            TVIS(J,K,1) = TVIS(J,K,1) + DUDY - DVDX
            TVIS(J,K,2) = TVIS(J,K,2) + DVDZ - DWDY
            TVIS(J,K,3) = TVIS(J,K,3) + DWDX - DUDZ
  360    CONTINUE
  370 CONTINUE
C
C     Divide by the Volume and form the magnitude of vorticity
C
C***This may cause problems when VOL = 0 (only for j,k = 1 and j or k = dim + 1
      DO 390 K = 1, KDIM + 1
         DO 380 J = 1, JDIM + 1
            VOLI = 1.E0 / (VOL(J,K,I) + RSMASQ)
            VORT(J,K) = SQRT ( TVIS(J,K,1) * TVIS(J,K,1)
     1                       + TVIS(J,K,2) * TVIS(J,K,2)
     2                       + TVIS(J,K,3) * TVIS(J,K,3) ) * VOLI
  380    CONTINUE
  390 CONTINUE
C
C     Calculate the turbulent eddy viscosity normal to each wall
C
      NBRWLS = 0
C
C     Calculate the turbulent eddy viscosity in the J direction
C
C     J = 1 wall
C
      IF (J1W .EQ. 1) THEN
         NBRWLS = NBRWLS + 1
         JBC    = 1
         JN     = 2
         JM     = 1
         JMP1   = 2
C
C     Calculate the directed distance 'normal' to the wall
C
         DO 405 K = 2, KDIM
            DIST(1,K,NBRWLS) = 0.E0
            DIST(2,K,NBRWLS) = 0.E0
  405    CONTINUE
         DO 420 J = 2, JDIM
            DO 410 K = 2, KDIM
               DY = VOL(J,K,I) / (0.5E0*(S(J,K,I,4,2)+S(J-1,K,I,4,2)))
               DIST(J,K,NBRWLS)   = DIST(J,K,NBRWLS) + 0.5E0 * DY
               DIST(J+1,K,NBRWLS) = DIST(J,K,NBRWLS) + 0.5E0 * DY
  410       CONTINUE
  420    CONTINUE
C
C     Loop over each profile and calculate the turbulent eddy viscosity
C     in that profile.
C
         DO 450 K = 2, KDIM
C
C     Find the maximum and minimum of the velocity magnitude (Umax, Umin)
C     in the profile and get the density and vorticity in an array for
C     the appropriate algebraic eddy viscosity model.
C
            UMAX = - 999999.E0
            UMIN =   999999.E0
            DO 430 J = 1, JDIM + 1
               UMAGN    = SQRT ( Q(J,K,I,2)*Q(J,K,I,2)
     1                         + Q(J,K,I,3)*Q(J,K,I,3)
     2                         + Q(J,K,I,4)*Q(J,K,I,4) )
               UMAX     = MAX ( UMAX, UMAGN )
               UMIN     = MIN ( UMIN, UMAGN )
               RHO(J)   = Q(J,K,I,1)
               VORTJ(J) = VORT(J,K)
               Y(J)     = DIST(J,K,NBRWLS)
  430       CONTINUE
C
C     Calculate 'wall' values of density, viscosity and shear stress
C
            RHOW  = Q(JBC,K,I,1)
            TW    = GAMMA * Q(JBC,K,I,5) / Q(JBC,K,I,1)
            RMUW  = VIS (TW, SNUM, STINF)
C
            UBARN = S(JM,K,I,1,2) * Q(JN,K,I,2)
     1            + S(JM,K,I,2,2) * Q(JN,K,I,3)
     2            + S(JM,K,I,3,2) * Q(JN,K,I,4)
            VELN  = SQRT ( (Q(JN,K,I,2) - UBARN*S(JM,K,I,1,2))**2
     1                   + (Q(JN,K,I,3) - UBARN*S(JM,K,I,2,2))**2
     2                   + (Q(JN,K,I,4) - UBARN*S(JM,K,I,3,2))**2 )
C
C     Average metrics and cell volume
C
            VOLAUX = 0.5E0 * VOL(JMP1,K,I)
            SPJ1   = 0.5E0 * ( S(JMP1,K,I,1,2)*S(JMP1,K,I,4,2)
     1                       + S(JM,K,I,1,2)*S(JM,K,I,4,2) )
            SPJ2   = 0.5E0 * ( S(JMP1,K,I,2,2)*S(JMP1,K,I,4,2)
     1                       + S(JM,K,I,2,2)*S(JM,K,I,4,2) )
            SPJ3   = 0.5E0 * ( S(JMP1,K,I,3,2)*S(JMP1,K,I,4,2)
     1                       + S(JM,K,I,3,2)*S(JM,K,I,4,2) )
            SMJ1   = S(JM,K,I,1,2)*S(JM,K,I,4,2)
            SMJ2   = S(JM,K,I,2,2)*S(JM,K,I,4,2)
            SMJ3   = S(JM,K,I,3,2)*S(JM,K,I,4,2)
C
C     Calculate first derivative terms using Divergence Theorem
C
            DVELDX = VELN*SPJ1 / VOLAUX
            DVELDY = VELN*SPJ2 / VOLAUX
            DVELDZ = VELN*SPJ3 / VOLAUX
C
C     Tau(wall)
C
            DVELDN = DVELDX * S(JM,K,I,1,2) + DVELDY * S(JM,K,I,2,2)
     1             + DVELDZ * S(JM,K,I,3,2)
            TAUW   = RMUW * DVELDN
C
C     Calculate the eddy viscosity using the algebraic method of
C     Baldwin and Lomax (AIAA 78-257)
C
            JDIMP1 = JDIM + 1
            CALL BLDLMX (JDIMP1, RHOW, TAUW, RMUW, UMAX, UMIN, Y, RHO,
     1                   VORTJ, FUN, RMUTJ)
C
C     Store these values of eddy viscosity into arrays used to build
C     the total eddy viscosity.
C
            DO 440 J = 1, JDIM + 1
               TVIS(J,K,NBRWLS) = RMUTJ(J)
  440       CONTINUE
  450    CONTINUE
      ENDIF
C
C     Build up the total turbulent eddy viscosity from the contribution
C     from each wall.
C
      DO 920 K = 1, KDIM
         DO 910 J = 1, JDIM + 1
            RMUT(J,K,I) = TVIS(J,K,1)
  910    CONTINUE
  920 CONTINUE
C
C     Finished calculating the turbulent eddy viscosity
      RETURN
 1000 FORMAT (' ','RUN ABORTING. Invalid Turbulence Model specified.')
      END
      SUBROUTINE DAMPMU (IMODEL, NPTS, Q, PROPS, TKE, FMU)
C
C Routine to calculate damping functions for turbulence models
C
C This routine is organized as follows:
C     1. Calculate FMU from appropriate damping function
C        a. High Re No.   (FMU = 1)
C        b. Speziale, Abid, Anderson
C        c. Zhang, So, Gatski, Speziale
C     2. For Algebraic Stress Model, modify FMU = FMU * CMUSTR / CMU
C        to account for variable CMUSTR in eddy-viscosity
C
C IMODEL         : Turbulence model control array
C NPTS           : Number of points to calculate damping terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C TKE            : Turbulent kinetic energy
C FMU            :
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP),
     2          TKE   (NPTS),
     3          FMU   (NPTS)
C
C Constant to prevent division by zero
C
      DATA SMALL / 1.0E-10 /
C
      ITURB = IMODEL( 1)
      IDAMP = IMODEL( 3)
      IASM  = IMODEL(10)
C
C 1. Calculate FMU
C
C 1-a. High Reynolds Number form => FDAMP = 1
C
      IF (IDAMP .EQ. IFMHR) THEN
         DO 100 I = 1, NPTS
            FMU(I) = 1.E0
  100    CONTINUE
C
C 1-b. Speziale et al. (AIAA 90-1481)
C      RET is the turbulent Reynolds number (appropriately non-dimensional)
C
      ELSE IF (IDAMP .EQ. IFMSAA) THEN
         DO 200 I = 1, NPTS
            RHO    = Q    (I,1)
            EPSLN  = Q    (I,IEPSLN)
            RMU    = PROPS(I,1)
            YPLUS  = PROPS(I,3)
C
C Turbulent Reynolds number.
C Check for positivity.
C
            RET    = RHO * TKE(I) * TKE(I) / (EPSLN * RMU + RSMALL) *
     1               RE / FSMACH
            RET    = MAX (RET, SMALL)
C
C Damping function = O(1/y) near wall.  Fmu -> 1 far from wall.
C The form of Fmu in Speziale et al. needs to be limited to 1 as get
C away from wall as RET approaches a small value outside of bl (Abid)
C
            FMU(I) = (1.E0 + 3.45E0 / SQRT(RET)) * TANH( YPLUS / 70.E0 )
            FMU(I) = MIN (FMU(I), 1.E0)
  200    CONTINUE
C
C 1-c. Zhang, So, Gatski, Speziale (Near-Wall Turbulent Flows)
C      RET is the turbulent Reynolds number (appropriately non-dimensional)
C
      ELSE IF (IDAMP .EQ. IFMZSG) THEN
         DO 300 I = 1, NPTS
            RHO    = Q    (I,1)
            EPSLN  = Q    (I,IEPSLN)
            RMU    = PROPS(I,1)
            YPLUS  = PROPS(I,3)
C
C Turbulent Reynolds number.
C Check for positivity.
C
            RET    = RHO * TKE(I) * TKE(I) / (EPSLN*RMU + RSMALL) *
     1               RE / FSMACH
            RET    = MAX (RET, SMALL)
C
C Damping function = O(1/y) near wall.  Fmu -> 1 far from wall.
C The form of Fmu in Speziale et al. needs to be limited to 1 as get
C away from wall as RET approaches a small value outside of bl (Abid)
C
            FMU(I) = (1.E0 + 3.45E0 / SQRT(RET)) * TANH(YPLUS / 115.E0)
            FMU(I) = MIN (FMU(I), 1.E0)
  300    CONTINUE
      ELSE
         WRITE (IOUT,1010) IDAMP
         STOP
      ENDIF
C
C 2. Algebraic Stress Model
C    Set FMU = FMU * CMUSTR / CMU to account for variable CMUSTR
C
C-N.B. Currently not including cmu* in heat transfer and diffusion for ASM
C-    IF (IASM .EQ. IASMGS) THEN
C-       DO 900 I = 1, NPTS
C-          CMUSTR = PROPS(I,ICMUST)
C-          FMU(I) = FMU(I) * CMUSTR / CMU
C-900    CONTINUE
C-    ENDIF
C
C Finished with damping functions
      RETURN
 1000 FORMAT (' ','DAMPMU  : Invalid turbulence model specified ',
     1            'ITURB = ',I5,
     2       /' ','Run Aborting.')
 1010 FORMAT (' ','DAMPMU  : Invalid damping functions specified ',
     1            'IDAMP = ',I5,
     2       /' ','Run Aborting.')
      END
      SUBROUTINE DAMPEE (IMODEL, NPTS, Q, PROPS, DEL2K, TKE,
     1                   TAU, DQDX, DQDY, DQDZ, ETILDE, XSIW, FDAMP)
C
C Routine to calculate the damping functions F1, F2 and epsilon^tilde for
C the source terms for the k-epsilon turbulence model.
C This routine also implements the Anisotropic Dissipation Rate Model.
C This routine is organized as:
C      I. Calculate damping functions
C         a. High Reynolds number form
C         b. Speziale-Abid-Anderson model
C         c. Zhang-So-Gatski-Speziale model
C         d. Zhang-So-Speziale-Lai model
C         e. RNG (Yakhot-Orszag-Thangam-Gatski-Speziale) model
C         f. So et al. 1995 model
C         g. Abid's algebraic stress(Abid,Morrison,Gatski,Speziale AIAA 96-0565)
C      II. Anisotropic dissipation rate model
C
C IMODEL         : Turbulence model control array
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DEL2K          :
C TKE            : Turbulent kinetic energy
C ETILDE         :
C XSIW           :
C FDAMP          :
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DEL2K (NPTS),
     1          TKE   (NPTS),
     2          TAU   (NPTS,6),
     3          DQDX  (NPTS,NQ),
     4          DQDY  (NPTS,NQ),
     5          DQDZ  (NPTS,NQ),
     6          ETILDE(NPTS),
     7          XSIW  (NPTS),
     8          FDAMP (NPTS,2)
C
      T23    = 2.E0 / 3.E0
C
      ITURB  = IMODEL(1)
      IEPSEQ = IMODEL(2)
      IADRM  = IMODEL(4)
C
C I. Form the damping functions for the source terms epsilon equation
C
C I-a. High Reynolds number form
C
      IF (IEPSEQ .EQ. IEEHR) THEN
         DO 100 I = 1, NPTS
            EPSLN      = Q(I,IEPSLN)
            FDAMP(I,1) = 1.E0
            FDAMP(I,2) = 1.E0
            ETILDE(I)  = EPSLN
            XSIW(I)    = 0.E0
  100    CONTINUE
C
C I-b. Speziale-Abid-Anderson. AIAA 90-1481 for wall bounded flows
C
      ELSE IF (IEPSEQ .EQ. IEESAA) THEN
         DO 200 I = 1, NPTS
C
            RHO   = Q(I,1)
            P     = Q(I,5)
            EPSLN = Q(I,IEPSLN)
C
            RMU   = PROPS(I,1)
            RMUT  = PROPS(I,2)
            YPLUS = PROPS(I,3)
C
C RET = turbulent Reynolds number
C F1  = 1
C F2  = [(1 - exp(-Y+/A2))**2] * (1 - 2/9 exp(-(RET/6)**2) )
C
            FDAMP(I,1) = 1.E0
            RET        = RHO * TKE(I) * TKE(I) / (EPSLN * RMU)*RE/FSMACH
            F2         = ( 1.E0 - EXP(-YPLUS / A2KE) )**2
            CE2        = ( 1.E0 - 2.E0/9.E0 * EXP(-RET*RET/36.E0) )
            IF (YPLUS .GT. 500.E0) CE2 = 1.E0
            FDAMP(I,2) = CE2 * F2
            ETILDE(I)  = EPSLN
            XSIW(I)    = 0.E0
  200    CONTINUE
C
C I-c. Zhang-So-Gatski-Speziale. Near-Wall Turbulent Flows
C
      ELSE IF (IEPSEQ .EQ. IEEZSG) THEN
         DO 300 I = 1, NPTS
C
            RHO    = Q(I,1)
            EPSLN  = Q(I,IEPSLN)
C
            RMU    = PROPS(I,1)
            RMUT   = PROPS(I,2)
            YPLUS  = PROPS(I,3)
            YNORML = ABS (PROPS(I,4))
C
C RET = turbulent Reynolds number
C
            RET        = RHO * TKE(I) * TKE(I) / (EPSLN * RMU)*RE/FSMACH
            FW2        = EXP( -(RET /  40.E0)**2 )
            IF (YPLUS .GT. 250.E0) FW2 = 0.E0
            FDAMP(I,1) = 1.E0
            FDAMP(I,2) = 1.E0
            ETILDE(I)  = EPSLN - RMU/RHO*DEL2K(I)*FSMACH/RE
            ETILDE(I)  = MAX (ETILDE(I), 0.E0)
C
            ESTAR      = EPSLN - 2.E0*RMU/RHO*TKE(I)/(YNORML*YNORML)
     1                               *FSMACH/RE
            ESTAR      = MAX (ESTAR,  0.E0)
C
C Production term: (TAUij = - rho tau_ij)
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
            PROD       =   TAU(I,1) * DQDX(I,2)
     1                   + TAU(I,2) * DQDY(I,3)
     2                   + TAU(I,3) * DQDZ(I,4)
     3                   + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4                   + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5                   + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
            IF (POSPRD) PROD = ABS (PROD)
C
            PRODUL     = PROD
C
C Limit production term for robustness:
C
            TSTDIS     = PRDLIM * RHO * EPSLN
            PROD       = MIN (PROD, TSTDIS)
C
            PRODE      = PRDE * PROD + PRDEM1 * PRODUL
C
            XSIW(I)    = FW2 * ( -2.E0 * RHO * EPSLN * ETILDE(I)
     1                         + 1.5E0 * RHO * ESTAR * ESTAR
     2                         - 1.5E0 * CEPS1 * EPSLN * PRODE) / TKE(I)
  300    CONTINUE
C
C I-d. Zhang-So-Speziale-Lai. (AIAA J. Vol. 31, No. 1, Jan. 1993)
C
      ELSE IF (IEPSEQ .EQ. IEEZSL) THEN
         DO 400 I = 1, NPTS
C
            RHO    = Q(I,1)
            EPSLN  = Q(I,IEPSLN)
C
            RMU    = PROPS(I,1)
            RMUT   = PROPS(I,2)
            YPLUS  = PROPS(I,3)
            YNORML = ABS (PROPS(I,4))
C
C RET = turbulent Reynolds number
C
            RET        = RHO * TKE(I) * TKE(I) / (EPSLN * RMU)*RE/FSMACH
            FW2        = EXP( -(RET /  64.E0)**2 )
            IF (YPLUS .GT. 250.E0) FW2 = 0.E0
            FDAMP(I,1) = 1.E0
            FDAMP(I,2) = 1.E0
            ETILDE(I)  = EPSLN - RMU/RHO*DEL2K(I)*FSMACH/RE
            ETILDE(I)  = MAX (ETILDE(I), 0.E0)
C
            ESTAR      = EPSLN - 2.E0*RMU/RHO*TKE(I)/(YNORML*YNORML)
     1                               *FSMACH/RE
            ESTAR      = MAX (ESTAR,  0.E0)
C
            XSIW(I)    = FW2 * ( -2.E0 * RHO * EPSLN * ETILDE(I)
     1                         + 1.5E0 * RHO * ESTAR * ESTAR  ) / TKE(I)
  400    CONTINUE
C
C I-e. RNG Yakhot-Orszag-Thangam-Gatski-Speziale Phys. Fluids A Vol. 4
C      No. 7, July 1992
C      Coding based on original code of Prof. J. M. Cimbala.
C
C     eta_0 = sqrt [(C_eps2 - 1) / (C_mu * (C_eps1 - 1) )]
C
      ELSE IF (IEPSEQ .EQ. IEERNG) THEN
         ETA0   = 4.38E0
         BETRNG = 0.012E0
         DO 500 I = 1, NPTS
C
            RHO    = Q(I,1)
            EPSLN  = Q(I,IEPSLN)
C
            RMU    = PROPS(I,1)
            RMUT   = PROPS(I,2)
C
C Production term: (TAUij = - rho tau_ij)
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
            PROD       =   TAU(I,1) * DQDX(I,2)
     1                   + TAU(I,2) * DQDY(I,3)
     2                   + TAU(I,3) * DQDZ(I,4)
     3                   + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4                   + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5                   + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
            IF (POSPRD) PROD = ABS (PROD)
C
            PRODUL     = PROD
C
C Limit production term for robustness:
C
            TSTDIS     = PRDLIM * RHO * EPSLN
            PROD       = MIN (PROD, TSTDIS)
C
            PRODE      = PRDE * PROD + PRDEM1 * PRODUL
C
C S_ij
C
            SSXX       = DQDX(I,2)
            SSYY       = DQDY(I,3)
            SSZZ       = DQDZ(I,4)
            SSXY       = 0.5E0 * (DQDY(I,2) + DQDX(I,3))
            SSXZ       = 0.5E0 * (DQDZ(I,2) + DQDX(I,4))
            SSYZ       = 0.5E0 * (DQDZ(I,3) + DQDY(I,4))
C
            SIJSIJ     =     ( SSXX*SSXX + SSYY*SSYY + SSZZ*SSZZ
     1                 + 2.E0*(SSXY*SSXY + SSXZ*SSXZ + SSYZ*SSYZ) )
C
            ETA        = SQRT (2.E0 * SIJSIJ) * TKE(I) / EPSLN
C
C Polynomial in eta for RNG
C
            FACT       = ETA * (1.E0 - ETA / ETA0)
     1                   / (1.E0 + BETRNG * ETA * ETA * ETA)
C
C XSIW = - R
C
            FDAMP(I,1) = 1.E0
            FDAMP(I,2) = 1.E0
            ETILDE(I)  = EPSLN
            XSIW(I)    = - FACT * PRODE * EPSLN / TKE(I)
  500    CONTINUE
C
C I-f. So et al. 1995
C
      ELSE IF (IEPSEQ .EQ. IEES95) THEN
         DO 600 I = 1, NPTS
C
            RHO    = Q(I,1)
            EPSLN  = Q(I,IEPSLN)
C
            RMU    = PROPS(I,1)
            RMUT   = PROPS(I,2)
            YPLUS  = PROPS(I,3)
            YNORML = ABS (PROPS(I,4))
C
C RET = turbulent Reynolds number
C
            RET         = RHO * TKE(I) * TKE(I) / (EPSLN*RMU)*RE/FSMACH
            FW2         = EXP( -(RET /  40.E0)**2 )
            FDAMP (I,1) = 1.E0
            FDAMP (I,2) = 1.E0 - 2.E0/9.E0 * EXP( -(RET / 6.E0)**2 )
            ETILDE(I)   = EPSLN
C
C Production term: (TAUij = - rho tau_ij)
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
            PROD        =   TAU(I,1) * DQDX(I,2)
     1                    + TAU(I,2) * DQDY(I,3)
     2                    + TAU(I,3) * DQDZ(I,4)
     3                    + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4                    + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5                    + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
            IF (POSPRD) PROD = ABS (PROD)
C
            PRODUL      = PROD
C
C Limit production term for robustness:
C
            TSTDIS      = PRDLIM * RHO * EPSLN
            PROD        = MIN (PROD, TSTDIS)
C
            PRODE       = PRDE * PROD + PRDEM1 * PRODUL
C
C N.B. DEL2K = 2 {|del[sqrt(k)]|}^2  so that a 1/2 is needed on the ceps4 term
C
            XSIW  (I)   = EPSLN / TKE(I) *
     1                  ( CEPS3 * SQRT(RET) * RHO * EPSLN
     2                  + CEPS4 * 0.5E0 * DEL2K(I) * RMU * FSMACH / RE
     3                  + CEPS5 * FW2 * PRODE )
  600    CONTINUE
C
C I-g. Abid's algebraic stress (Abid,Morrison,Gatski,Speziale AIAA 96-0565)
C
      ELSE IF (IEPSEQ .EQ. IEEABD) THEN
         DO 700 I = 1, NPTS
C
            RHO    = Q(I,1)
            EPSLN  = Q(I,IEPSLN)
C
            RMU    = PROPS(I,1)
            YPLUS  = PROPS(I,3)
            YNORML = ABS (PROPS(I,4))
C
C F1  = 1
C F2  = [(1 - exp(-Y+/5.5))**2]
C
            FDAMP(I,1) = 1.E0
            FDAMP(I,2) = ( 1.E0 - EXP(-YPLUS / 5.5E0) )**2
C-----      REY        = RHO * SQRT(TKE(I)) * YNORML / RMU * RE / FSMACH
C-----      FDAMP(I,2) = ( 1.E0 - EXP(-REY / 12.E0) )
            ETILDE(I)  = EPSLN
            XSIW(I)    = 0.E0
  700    CONTINUE
C
C Error
C
      ELSE
         WRITE (IOUT,1000) IEPSEQ
         STOP
      ENDIF
C
C II. Anisotropic Dissipation Rate Model (ADRM)
C
       IF (IADRM .EQ. IADRGS) THEN
C
C     Constants based on SSG pressure-strain
C
C----       C1     = 6.80E0
            C2     = 0.36E0
            C3     = 1.25E0
            C4     = 0.40E0
C
            CE5    = 5.80E0
            BET3   = 0.60E0
C
            BET    = 0.75E0 * (14.E0*BET3/11.E0 - 16.E0/33.E0)
C
            TBP1   = 2.E0 / 15.E0 * (1.E0 + BET)
C
            DO 900 I = 1, NPTS
               RHO        = Q(I,1)
               EPSLN      = Q(I,IEPSLN)
C
               TIMSCL     = TKE(I) / EPSLN
C
C Production term: (TAUij = - rho tau_ij)
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
               PROD       =   TAU(I,1) * DQDX(I,2)
     1                      + TAU(I,2) * DQDY(I,3)
     2                      + TAU(I,3) * DQDZ(I,4)
     3                      + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4                      + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5                      + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
               IF (POSPRD) PROD = ABS (PROD)
C
C Limit production term for robustness:
C
               TSTDIS     = PRDLIM * RHO * EPSLN
               PROD       = MIN (PROD, TSTDIS)
C
C     Constants based on SSG pressure-strain
C
               POVERE     = PROD / (RHO*EPSLN)
C
               C1         = 3.40E0 + 1.8E0 * POVERE
               CGEPS      = POVERE
               CG         = POVERE
C
               GSMALL     = 1.E0 / (0.5E0 * C1 + CG - 1.E0)
C
               AL1        = 0.5E0 * (4.E0 / 3.E0 - C2) * GSMALL
               AL2        = 0.5E0 * (2.E0        - C4) * GSMALL
               AL3        = 0.5E0 * (2.E0        - C3) * GSMALL
C
               GEPS       = 1.E0 / (CE5 + CGEPS - 1.E0)
C
               BET1       = ( 7.E0 * BET3 + 1.E0) / 11.E0 * GEPS
               BET2       = (15.E0 * BET3 - 1.E0) / 11.E0 * GEPS
C
               TB2A3      = 2.E0 / 3.E0  * (BET2 / AL3)**2
               TB1A2      = 2.E0         * (BET1 / AL2)**2
C
C     S_ij
C
               SXX        = DQDX(I,2)
               SYY        = DQDY(I,3)
               SZZ        = DQDZ(I,4)
               SXY        = 0.5E0 * (DQDY(I,2) + DQDX(I,3))
               SXZ        = 0.5E0 * (DQDZ(I,2) + DQDX(I,4))
               SYZ        = 0.5E0 * (DQDZ(I,3) + DQDY(I,4))
C
C     W_ij
C
               WYX        = 0.5E0 * (DQDX(I,3) - DQDY(I,2))
               WZX        = 0.5E0 * (DQDX(I,4) - DQDZ(I,2))
               WZY        = 0.5E0 * (DQDY(I,4) - DQDZ(I,3))
               WXY        = 0.5E0 * (DQDY(I,2) - DQDX(I,3))
               WXZ        = 0.5E0 * (DQDZ(I,2) - DQDX(I,4))
               WYZ        = 0.5E0 * (DQDZ(I,3) - DQDY(I,4))
C
               ETASQ      =      AL3 * AL3 * TIMSCL * TIMSCL *
     1                          ( SXX*SXX + SYY*SYY + SZZ*SZZ
     2                    + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ) )
               ZETSQ      =      AL2 * AL2 * TIMSCL * TIMSCL *
     1                      2.E0*(WXY*WXY + WXZ*WXZ + WYZ*WYZ)
C
               CMUSTR     = 1.E0 / (1.E0 - TB2A3*ETASQ + TB1A2*ZETSQ)
               CEPSTR     = CEPS1 + TBP1 * GEPS * CMUSTR / CMU
C
               FDAMP(I,1) = FDAMP(I,1) * CEPSTR / CEPS1
  900      CONTINUE
        ENDIF
C
C Finished with k-epsilon damping terms
      RETURN
 1000 FORMAT (' ','DAMPEE: Invalid epsilon model specified = ',I5,
     1       /' ','Run Aborting.')
      END
      SUBROUTINE EPSCMP (IMODEL, NPTS, Q, PROPS, TKE, SIJ, WIJ, EPSC)
C
C Routine to calculate compressible dissipation rate where the dissipation
C rate has been decomposed into a solenoidal and compressible portion as
C      eps = eps_s + eps_c
C where eps_s is the solenoidal (incompressible) portion and eps_c is the
C dilatational (compressible) portion.  This routine returns eps_c.
C This routine is used for two-equation (k-epsilon) and Reynolds stress models.
C
C This routine is organized as follows:
C     1. Calculate EPSC from appropriate model
C        a. No compressibility correction => epsc = 0
C        b. Sarkar's correction           => epsc = const * M_T^2 * eps
C        c. Ristorcelli's correction
C
C IMODEL         : Turbulence model control array
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C TKE            : Turbulent Kinetic Energy
C SIJ            :
C WIJ            :
C EPSC           : Compressible dissipation rate
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP),
     2          TKE   (NPTS),
     3          SIJ   (NPTS,6),
     4          WIJ   (NPTS,6),
     5          EPSC  (NPTS)
C
      IEPSC = IMODEL(11)
C
C 1. Calculate EPSC
C
C 1-a. No compressibility correction
C
      IF (IEPSC .EQ. IECNO) THEN
         DO 100 I = 1, NPTS
            EPSC(I) = 0.E0
  100    CONTINUE
C
C 1-b. Sarkar's compressible dissipation
C
      ELSE IF (IEPSC .EQ. IECSAR) THEN
         DO 200 I = 1, NPTS
            RHO     = Q    (I,1)
            P       = Q    (I,5)
            EPSLN   = Q    (I,IEPSLN)
C
C Turbulent Mach Number (from Sarkar et al.)
C
            ASQ     = GAMMA * P / RHO
            RMTSQ   = 2.E0 * TKE(I) / ASQ
C
            EPSC(I) = ALF1 * RMTSQ * EPSLN
  200    CONTINUE
C
C 1-c. Ristorcelli's compressible dissipation
C
      ELSE IF (IEPSC .EQ. IECRIS) THEN
         T13   = 1.E0 / 3.E0
         T23   = 2.E0 / 3.E0
         T49   = 4.E0 / 9.E0
C
C Ristorcelli's integral constants - from experimental data
C     Slow Integral 1,2,3
C     Rapid Integral 1,2,3
C
         SI1   =  0.300E0
         SI2   = 13.768E0
         SI3   =  2.623E0
C
         RI1   =  1.392E0
         RI2   =  0.E0
         RI3   =  3.E0
C
         RALFA = 1.E0
C
         RCON1 = 16.E0 / (3.E0 * RALFA)
         RCON2 = T23 ** 5
         RCON3 = (1.E0 / 15.E0) ** 2
C
         DO 300 I = 1, NPTS
            RHO     = Q    (I,1)
            P       = Q    (I,5)
            EPSLN   = Q    (I,IEPSLN)
            RMU     = PROPS(I,1)
C
C Turbulent Mach Number, Reynolds Number (from Ristorcelli's definition)
C
            ASQ     = GAMMA * P / RHO
            RMTSQ   = T23 * TKE(I) / ASQ
            RMT4    = RMTSQ * RMTSQ
            RET     = T49 * RHO * TKE(I) * TKE(I) / (EPSLN * RMU) *
     1                RE / FSMACH
C
            SXX     = SIJ(I,1)
            SYY     = SIJ(I,2)
            SZZ     = SIJ(I,3)
            SXY     = SIJ(I,4)
            SXZ     = SIJ(I,5)
            SYZ     = SIJ(I,6)
C
            WYX     = WIJ(I,1)
            WZX     = WIJ(I,2)
            WZY     = WIJ(I,3)
            WXY     = WIJ(I,4)
            WXZ     = WIJ(I,5)
            WYZ     = WIJ(I,6)
C
C S_ij * S_ij (symmetric tensor), W_ij * W_ij (anti-symmetric tensor)
C Note: Ristorcelli's notes define S_ij = .5 (U_i,j + U_j,i - 1/3 U_k,k)
C       the S_ij used here do NOT subtract off the trace.  The additional
C       term 1/3 trace^2 subtracted off of SIJSIJ accounts for this difference.
C
            TRACES  = SXX + SYY + SZZ
            SIJSIJ  =         SXX*SXX + SYY*SYY + SZZ*SZZ
     1                + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ)
     2                - T13 * TRACES * TRACES
            WIJWIJ  = - 2.E0*(WXY*WYX + WXZ*WZX + WYZ*WZY)
C
            SHATSQ  = TKE(I) * TKE(I) / (EPSLN * EPSLN) * SIJSIJ
            WHATSQ  = TKE(I) * TKE(I) / (EPSLN * EPSLN) * WIJWIJ
C
            EPSC(I) = EPSLN *
     1            ( RCON1 * RMT4 / RET * (SI2 + 6.E0 * SI1 * SI3)
     2            + RCON2 * RMT4 / RET * (3.E0*SHATSQ+5.E0*WHATSQ)
     3              * (0.6E0*RI3 + RCON3*(13.E0*SHATSQ+15.E0*WHATSQ)
     4                                  *RALFA*RI1) )
  300    CONTINUE
C
C Error
C
      ELSE
         WRITE (IOUT,1000) IEPSC
         STOP
      ENDIF
C
C Finished with compressible dissipation
      RETURN
 1000 FORMAT (' ','EPSCMP  : Invalid compressible dissipation model ',
     1            'specified IEPSC = ',I5,
     2       /' ','Run Aborting.')
      END
      SUBROUTINE PRDIL  (IMODEL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU,
     1                   TKE, SIJ, WIJ, EPSC, PDIL)
C
C Routine to calculate pressure-dilatation model.  This routine returns p_dil.
C This routine is used for two-equation (k-epsilon) and Reynolds stress models.
C
C This routine is organized as follows:
C     1. Calculate PDIL from appropriate model
C        a. No pressure-dilatation            => pdil = 0
C        b. Sarkar's pressure-dilatation      => pdil = const * M_T^2 * eps
C        c. Ristorcelli's pressure-dilatation => pdil = chi   * M_T^2 * (P-e)
C
C IMODEL         : Turbulence model control array
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C TAU            : Reynolds stresses
C TKE            : Turbulent Kinetic Energy
C SIJ            :
C WIJ            :
C EPSC           : Compressible dissipation rate
C PDIL           : Pressure-Dilatation
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          TAU   (NPTS,6),
     4          TKE   (NPTS),
     5          SIJ   (NPTS,6),
     6          WIJ   (NPTS,6),
     7          EPSC  (NPTS),
     8          PDIL  (NPTS)
C
      IPDIL = IMODEL(12)
C
C 1. Calculate PDIL
C
C 1-a. No Pressure-Dilatation
C
      IF (IPDIL .EQ. IPDNO) THEN
         DO 100 I = 1, NPTS
            PDIL(I) = 0.E0
  100    CONTINUE
C
C 1-b. Sarkar's Pressure-Dilatation
C
      ELSE IF (IPDIL .EQ. IPDSAR) THEN
         DO 200 I = 1, NPTS
            RHO     = Q    (I,1)
            P       = Q    (I,5)
            EPSLN   = Q    (I,IEPSLN)
C
C Production term:
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
            PROD    =   TAU(I,1) * DQDX(I,2)
     1                + TAU(I,2) * DQDY(I,3)
     2                + TAU(I,3) * DQDZ(I,4)
     3                + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4                + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5                + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
            IF (POSPRD) PROD = ABS (PROD)
C
C Limit production term for robustness:
C
            TSTDIS  = PRDLIM * RHO * EPSLN
            PROD    = MIN (PROD, TSTDIS)
C
C Turbulent Mach Number (from Sarkar et al.)
C
            ASQ     = GAMMA * P / RHO
            RMTSQ   = 2.E0 * TKE(I) / ASQ
            RMT     = SQRT (RMTSQ)
C
C Pressure-Dilatation
C This form is from Sarkar, ICASE 91-42
C
            PDIL(I) = - ALF2 * PROD * RMTSQ + ALF3 * RHO * EPSLN * RMTSQ
C
  200    CONTINUE
C
C 1-c. Ristorcelli's Pressure-Dilatation
C
      ELSE IF (IPDIL .EQ. IPDRIS) THEN
         T13   = 1.E0 / 3.E0
         T23   = 2.E0 / 3.E0
         T49   = 4.E0 / 9.E0
C
C Ristorcelli's integral constants - from experimental data
C     Slow Integral 1,2,3
C     Rapid Integral 1,2,3
C
         SI1   =  0.300E0
         SI2   = 13.768E0
         SI3   =  2.623E0
C
         RI1   =  1.392E0
         RI2   =  0.E0
         RI3   =  3.E0
C
         RALFA = 1.E0
C
         DO 300 I = 1, NPTS
            RHO     = Q    (I,1)
            P       = Q    (I,5)
            EPSLN   = Q    (I,IEPSLN)
            RMU     = PROPS(I,1)
C
C Production term:
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
            PROD    =   TAU(I,1) * DQDX(I,2)
     1                + TAU(I,2) * DQDY(I,3)
     2                + TAU(I,3) * DQDZ(I,4)
     3                + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4                + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5                + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
            IF (POSPRD) PROD = ABS (PROD)
C
C Limit production term for robustness:
C
            TSTDIS  = PRDLIM * RHO * EPSLN
            PROD    = MIN (PROD, TSTDIS)
C
C Turbulent Mach Number, Reynolds Number (from Ristorcelli's definition)
C
            ASQ     = GAMMA * P / RHO
            RMTSQ   = T23 * TKE(I) / ASQ
            RMT4    = RMTSQ * RMTSQ
C
            SXX     = SIJ(I,1)
            SYY     = SIJ(I,2)
            SZZ     = SIJ(I,3)
            SXY     = SIJ(I,4)
            SXZ     = SIJ(I,5)
            SYZ     = SIJ(I,6)
C
            WYX     = WIJ(I,1)
            WZX     = WIJ(I,2)
            WZY     = WIJ(I,3)
            WXY     = WIJ(I,4)
            WXZ     = WIJ(I,5)
            WYZ     = WIJ(I,6)
C
C S_ij * S_ij (symmetric tensor), W_ij * W_ij (anti-symmetric tensor)
C Note: Ristorcelli's notes define S_ij = .5 (U_i,j + U_j,i - 1/3 U_k,k)
C       the S_ij used here do NOT subtract off the trace.  The additional
C       term 1/3 trace^2 subtracted off of SIJSIJ accounts for this difference.
C
            TRACES  = SXX + SYY + SZZ
            SIJSIJ  =         SXX*SXX + SYY*SYY + SZZ*SZZ
     1                + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ)
     2                - T13 * TRACES * TRACES
            WIJWIJ  = - 2.E0*(WXY*WYX + WXZ*WZX + WYZ*WZY)
C
            SHATSQ  = TKE(I) * TKE(I) / (EPSLN * EPSLN) * SIJSIJ
            WHATSQ  = TKE(I) * TKE(I) / (EPSLN * EPSLN) * WIJWIJ
C
            PDIR    = T23 * T23 * T23 / 30.E0 * RALFA * RALFA * RI1
            PDI     = T23 * SI1 + PDIR * (3.E0*SHATSQ+5.E0*WHATSQ)
            CHIPD   = 2.E0 * PDI /
     1                (1.E0+2.E0*PDI*RMTSQ+1.5E0*PDIR*RMT4*GAMMA*GAMM1)
C
C Pressure-Dilatation
C
            PDIL(I) = - CHIPD * RMTSQ * (PROD - RHO * (EPSLN + EPSC(I)))
  300    CONTINUE
C
C Error
C
      ELSE
         WRITE (IOUT,1000) IPDIL
         STOP
      ENDIF
C
C Finished with pressure-dilatation
      RETURN
 1000 FORMAT (' ','PRDIL   : Invalid Pressure-Dilatation model ',
     1            'specified IPDIL = ',I5,
     2       /' ','Run Aborting.')
      END
      SUBROUTINE RMUTKE (IMODEL, NPTS, Q, PROPS, TKE, FMU)
C
C     Routine to calculate the turbulent eddy viscosity  for the k-epsilon
C     turbulence model.
C
C     IMODEL         : Tur
C     NPTS           : Number of points
C     Q              : Primitive variables at cell centers
C     PROPS          : Properties at cell centers
C     TKE            : Turbulent kinetic energy
C     NDAMP          :
C     FMU            : Damping functions for mut
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP),
     2          TKE   (NPTS),
     3          FMU   (NPTS)
C
C     Constant to prevent division by zero
C
      DATA SMALL / 1.0E-10 /
C
      ITURB = IMODEL(1)
C
C     Calculate damping functions
C
      CALL DAMPMU (IMODEL, NPTS, Q, PROPS, TKE, FMU)
C
C     Calculate the turbulent eddy viscosity at cell centers from values
C     of turbulent kinetic energy (k) and dissipation (epsilon).
C
      DO 100 I = 1, NPTS
         RHO        = Q(I,1)
         EPSLN      = Q(I,IEPSLN)
C
         PROPS(I,2) = CMU * FMU(I) * RHO * TKE(I) * TKE(I) /
     1                (EPSLN + RSMALL) * RE / FSMACH
  100 CONTINUE
C
C     Finished calculating RMUT from k and epsilon
      RETURN
 1000 FORMAT (' ','RMUTKE: Invalid turbulence model specified ',
     1            'ITURB = ',I5,
     2       /' ','Run Aborting.')
      END
      SUBROUTINE SRCKE (IMODEL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU,
     1                  DEL2K, TKE, ETILDE, XSIW, FDAMP,
     2                  EPSC, PDIL, SIJ, WIJ, SRC, NPRLIM, NPRNEG)
C
C Routine to calculate the source terms for the k-epsilon turbulence model.
C
C This routine is organized as follows:
C      1. Calculate damping functions and epsilon^tilde
C      2. Calculate compressible dissipation
C      3. Calculate pressure-dilatation
C      4. Form the source terms for the k-epsilon model
C
C IMODEL         : Turbulence model control array
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C TAU            : Reynolds stresses
C DEL2K          :
C TKE            :
C ETILDE         :
C XSIW           :
C FDAMP          :
C EPSC           :
C PDIL           :
C SIJ            :
C WIJ            :
C SRC            : Source terms for the k-omega model at the cell centers
C                  of the I-plane
C NPRLIM         : Number of limitations to the production term
C NPRNEG         : Number of times invoke positivity preservation for production
C
      include 'common.inc'
C
      DIMENSION IMODEL(NMDL)
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          TAU   (NPTS,6),
     4          DEL2K (NPTS),
     5          TKE   (NPTS),
     6          ETILDE(NPTS),
     7          XSIW  (NPTS),
     8          FDAMP (NPTS,2),
     9          EPSC  (NPTS),
     A          PDIL  (NPTS),
     B          SIJ   (NPTS,6),
     C          WIJ   (NPTS,6),
     D          SRC   (NPTS,NF)
C
C 1.  Calculate damping functions and epsilon^tilde
C
      CALL DAMPEE (IMODEL, NPTS, Q, PROPS, DEL2K, TKE,
     1             TAU, DQDX, DQDY, DQDZ, ETILDE, XSIW, FDAMP)
C
C 2.  Calculate compressible dissipation
C
      CALL EPSCMP (IMODEL, NPTS, Q, PROPS, TKE, SIJ, WIJ, EPSC)
C
C 3.  Calculate pressure-dilatation
C
      CALL PRDIL  (IMODEL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU,
     1             TKE, SIJ, WIJ, EPSC, PDIL)
C
C 4.  Form the source terms for the k-epsilon model
C
      DO 100 I = 1, NPTS
C
         RHO    = Q(I,1)
         P      = Q(I,5)
         EPSLN  = Q(I,7)
C
         RMU    = PROPS(I,1)
         RMUT   = PROPS(I,2)
         YPLUS  = PROPS(I,3)
C
C DU_k/DX_k = (DU/DX + DV/DY + DW/DZ) / 3
C
         DUKDXK = (DQDX(I,2) + DQDY(I,3) + DQDZ(I,4)) / 3.E0
C
C Production term:
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
         PROD   =   TAU(I,1) * DQDX(I,2)
     1            + TAU(I,2) * DQDY(I,3)
     2            + TAU(I,3) * DQDZ(I,4)
     3            + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4            + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5            + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
C Transition specification
C
         IF (PROPS(I,4) .LT. 0.E0) PROD = 0.E0
C
C Positivity preservation for production
C
         IF (POSPRD) THEN
            IF (PROD .LT. 0.E0) THEN
               NPRNEG = NPRNEG + 1
               PROD   = ABS (PROD)
            ENDIF
         ENDIF
C
         PRODUL = PROD
C
C Limit production term for robustness:
C
         TSTDIS = PRDLIM * RHO * EPSLN
         IF (PROD .GT. TSTDIS) THEN
            NPRLIM = NPRLIM + 1
            PROD   = TSTDIS
         ENDIF
C
C Production term for epsilon: use either limited or unlimited form
C->  PRODE = - CEPS1*epsilon/k*rho*tau_ij*(Du_i/Dx_j-Du_k/Dx_k*delta_ij/3)
C->          - 4/3*rho*epsilon*Du_k/Dx_k
C->  from: Speziale and Sarkar, ICASE 91-9
C
         PRODE = CEPS1 * FDAMP(I,1) * EPSLN / TKE(I)
     1           * (PRDE * PROD + PRDEM1 * PRODUL)
C
C->  1           ( TAU(I,1) * (DQDX(I,2) - DUKDXK)
C->  2           + TAU(I,2) * (DQDY(I,3) - DUKDXK)
C->  3           + TAU(I,3) * (DQDZ(I,4) - DUKDXK)
C->  4           + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
C->  5           + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
C->  6           + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4)) )
C->  7         - 4.E0 * RHO * EPSLN * DUKDXK
C
C Dissipation
C
         DISSK = RHO * (EPSLN + EPSC(I))
C
         DISSE = CEPS2 * FDAMP(I,2) * RHO * EPSLN * ETILDE(I) / TKE(I)
C
C Calculate the Pressure-Velocity correlation term:
C    PVEL  = CPVELK * mu_T * sigma_rho / rho^2 * (DrhoDx_i DPDx_i)
C
         PVEL  = CPVELK * RMUT * SIGRHO / (RHO * RHO) * FSMACH / RE *
     1           ( DQDX(I,1) * DQDX(I,5) + DQDY(I,1) * DQDY(I,5)
     2           + DQDZ(I,1) * DQDZ(I,5) )
C
C Calculate Source Term
C
         SRC(I,1) = 0.E0
         SRC(I,2) = 0.E0
         SRC(I,3) = 0.E0
         SRC(I,4) = 0.E0
         SRC(I,5) = 0.E0
         SRC(I,6) = PROD  - DISSK - PVEL + PDIL(I)
         SRC(I,7) = PRODE - DISSE + XSIW(I)
  100 CONTINUE
C
C Finished with k-epsilon source terms
      RETURN
      END
      SUBROUTINE RMUTKW (IDIM, JDIM, KDIM, I, Q, RMUT)
C
C     Routine to calculate the turbulent eddy viscosity  for the k-omega
C     turbulence model.
C
C     IDIM,JDIM,KDIM : Dimensions of current block
C     I              : Plane to do calculation at
C     Q              : Primitive variables at cell centers
C     RMUT           : Turbulent eddy viscosity at cell centers
C                      of the I-plane
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ),
     1          RMUT  (0:JDIM+2,0:KDIM+2,0:IDIM+2)
C
C     Calculate the turbulent eddy viscosity at cell centers from values
C     of turbulent kinetic energy (k) and specific dissipation rate (omega)
C
      DO 120 K = 0, KDIM + 2
         DO 110 J = 0, JDIM + 2
            RHO         = Q(J,K,I,1)
            TKE         = Q(J,K,I,6)
            OMEGA       = Q(J,K,I,7)
            RMUT(J,K,I) = CMU * RHO * TKE / (OMEGA + RSMALL) *
     1                    RE / FSMACH
  110    CONTINUE
  120 CONTINUE
C
C     Finished calculating RMUT from k and omega
      RETURN
      END
      SUBROUTINE SRCKW (NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU, SRC,
     1                  NPRLIM, NPRNEG)
C
C Routine to calculate the source terms for the k-omega turbulence model.
C
C This routine is organized as follows:
C      1. Form the source terms for the k-epsilon model
C
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C TAU            : Reynolds stresses
C SRC            : Source terms for the k-omega model at the cell centers
C                  of the I-plane
C NPRLIM         : Counter for number of times production limited
C NPRNEG         : Number of times invoke positivity preservation for production
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          TAU   (NPTS,6),
     4          SRC   (NPTS,NF)
C
C 1.  Form the source terms for the k-omega model
C
      DO 100 I = 1, NPTS
C
         RHO    = Q(I,1)
         TKE    = Q(I,6)
         OMEGA  = Q(I,7)
C
C Production term:
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C
         PROD   =   TAU(I,1) * DQDX(I,2)
     1            + TAU(I,2) * DQDY(I,3)
     2            + TAU(I,3) * DQDZ(I,4)
     3            + TAU(I,4) * (DQDY(I,2) + DQDX(I,3))
     4            + TAU(I,5) * (DQDZ(I,2) + DQDX(I,4))
     5            + TAU(I,6) * (DQDZ(I,3) + DQDY(I,4))
C
C Alternate Form of Production Term: PROD = mu_t * Vorticity^2
C
C        WXY     = 0.5E0 * (DQDY(I,2) - DQDX(I,3))
C        WXZ     = 0.5E0 * (DQDZ(I,2) - DQDX(I,4))
C        WYZ     = 0.5E0 * (DQDZ(I,3) - DQDY(I,4))
C        WVORT   = 4.E0 * (WXY*WXY + WXZ*WXZ + WYZ*WYZ)
C        RMUT    = PROPS(I,2)
C        PROD    = RMUT * WVORT * FSMACH / RE
C
C Transition specification
C
         IF (PROPS(I,4) .LT. 0.E0) PROD = 0.E0
C
C Positivity preservation for production
C
         IF (POSPRD) THEN
            IF (PROD .LT. 0.E0) THEN
               NPRNEG = NPRNEG + 1
               PROD   = ABS (PROD)
            ENDIF
         ENDIF
C
         PRODUL = PROD
C
C Limit production term for robustness:
C
         TSTDIS = PRDLIM * BSTRKW * RHO * TKE * OMEGA
         IF (PROD .GT. TSTDIS) THEN
            NPRLIM = NPRLIM + 1
            PROD   = TSTDIS
         ENDIF
C
C Production for omega equation: use either limited or unlimited form
C
         PRODW  = PRDE * PROD + PRDEM1 * PRODUL
C
C Calculate Source Term
C
         SRC(I,1) = 0.E0
         SRC(I,2) = 0.E0
         SRC(I,3) = 0.E0
         SRC(I,4) = 0.E0
         SRC(I,5) = 0.E0
         SRC(I,6) = PROD - BSTRKW * RHO * TKE * OMEGA
         SRC(I,7) = GKW * OMEGA / TKE * PRODW - BKW * RHO * OMEGA*OMEGA
  100 CONTINUE
C
C Finished with k-omega source terms
      RETURN
      END
      SUBROUTINE DMPSGS (IMODEL, NPTS, Q, PROPS, FMU, IERROR)
      RETURN
      END
      SUBROUTINE GETSF2 (IMODEL, IDIM, JDIM, KDIM, I,
     1                   Q, PROPS, S, VOL, IBCDAT, NBCS, SF2, IERROR)
      RETURN
      END
      SUBROUTINE RMUSGS (IMODEL, NPTS, Q, PROPS, VOL, DQDX, DQDY, DQDZ,
     1                   SF2, FMU, IERROR)
      RETURN
      END
      SUBROUTINE GETBIJ (NPTS, Q, BIJ)
C
C Routine to calculate the anisotropy tensor for Reynolds stresses.
C
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C BIJ            : Anisotropy tensor
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ)
C
C     +---------------+
C     +      BIJ      +
C     +  (i,j)   sub  +
C     +---------------+
C     +   x,x     1   +
C     +   y,y     2   +
C     +   z,z     3   +
C     +   x,y     4   +
C     +   x,z     5   +
C     +   y,z     6   +
C     +---------------+
C
      DIMENSION BIJ   (NPTS,6)
C
C T13
C
      T13 = 1.E0 / 3.E0
C
C Calculate the Anisotropy tensor b_ij
C
      DO 100 I = 1, NPTS
C
         TAUXX = Q(I,6)
         TAUYY = Q(I,7)
         TAUZZ = Q(I,8)
         TAUXY = Q(I,9)
         TAUXZ = Q(I,10)
         TAUYZ = Q(I,11)
C
         TKE   = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
C b_ij, Anisotropy tensor
C
         BIJ(I,1) = 0.5E0 * TAUXX / TKE - T13
         BIJ(I,2) = 0.5E0 * TAUYY / TKE - T13
         BIJ(I,3) = 0.5E0 * TAUZZ / TKE - T13
         BIJ(I,4) = 0.5E0 * TAUXY / TKE
         BIJ(I,5) = 0.5E0 * TAUXZ / TKE
         BIJ(I,6) = 0.5E0 * TAUYZ / TKE
  100 CONTINUE
C
C Finished calculating anisotropy tensor
      RETURN
      END
      SUBROUTINE GETSW  (NPTS, Q, DQDX, DQDY, DQDZ, SIJ, WIJ)
C
C Routine to calculate the symmetric and anti-symmetric tensors S_ij, W_ij
C from the mean velocity gradient.
C
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C SIJ            : Symmetric tensor      (du_i/dx_j + du_j/dx_i)/2
C WIJ            : Anit-Symmetric tensor (du_i/dx_j - du_j/dx_i)/2
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          DQDX  (NPTS,NQ),
     2          DQDY  (NPTS,NQ),
     3          DQDZ  (NPTS,NQ)
C
C     +-------------+---------------+
C     +     SIJ     +       WIJ     +
C     + (i,j)  sub  +  (i,j)   sub  +
C     +-------------+---------------+
C     +  x,x    1   +   y,x     1   +
C     +  y,y    2   +   z,x     2   +
C     +  z,z    3   +   z,y     3   +
C     +  x,y    4   +   x,y     4   +
C     +  x,z    5   +   x,z     5   +
C     +  y,z    6   +   y,z     6   +
C     +-------------+---------------+
C
      DIMENSION SIJ   (NPTS,6),
     1          WIJ   (NPTS,6)
C
C Calculate the symmetric tensor S_ij and anti-symmetric tensor W_ij
C
      DO 100 I = 1, NPTS
C
C S_ij, Symmetric tensor
C
         SIJ(I,1) = DQDX(I,2)
         SIJ(I,2) = DQDY(I,3)
         SIJ(I,3) = DQDZ(I,4)
         SIJ(I,4) = 0.5E0 * (DQDY(I,2) + DQDX(I,3))
         SIJ(I,5) = 0.5E0 * (DQDZ(I,2) + DQDX(I,4))
         SIJ(I,6) = 0.5E0 * (DQDZ(I,3) + DQDY(I,4))
C
C W_ij, Anti-Symmetric tensor
C
         WIJ(I,1) = 0.5E0 * (DQDX(I,3) - DQDY(I,2))
         WIJ(I,2) = 0.5E0 * (DQDX(I,4) - DQDZ(I,2))
         WIJ(I,3) = 0.5E0 * (DQDY(I,4) - DQDZ(I,3))
         WIJ(I,4) = 0.5E0 * (DQDY(I,2) - DQDX(I,3))
         WIJ(I,5) = 0.5E0 * (DQDZ(I,2) - DQDX(I,4))
         WIJ(I,6) = 0.5E0 * (DQDZ(I,3) - DQDY(I,4))
  100 CONTINUE
C
C     Finished calculating tensors
      RETURN
      END
      SUBROUTINE SRCRS (IMODEL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ,
     1                  PIIJ, DEL2K, TKE, ETILDE, XSIW, FDAMP,
     2                  EPSC, PDIL, SIJ, WIJ, SRC, NPRLIM, NPRNEG)
C
C Routine to calculate the source terms for the Reynolds stress
C turbulence model.
C
C This routine is organized into the following sections:
C      1. Calculate damping functions for epsilon equation
C      2. Calculate b_ij
C      3. Calculate compressible dissipation
C      4. Calculate the pressure-strain rate correlation from b, S, W
C      5. Calculate the source terms for the tau and epsilon equations
C      6. Add the epsilon_ij terms
C
C IMODEL         : Turbulence model array
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C PIIJ           : Pressure Strain Correlation
C                  This array contains TAU=-rho tau_ij on entrance to routine
C DEL2K          : Laplacian of turbulent kinetic energy
C TKE            :
C ETILDE         :
C XSIW           :
C FDAMP          :
C EPSC           :
C PDIL           :
C SIJ            :
C WIJ            :
C SRC            : Source terms for the k-omega model at the cell centers
C                      of the I-plane
C NPRLIM         : Number of limitations to the production term
C NPRNEG         : Number of times invoke positivity preservation for production
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          PIIJ  (NPTS,6),
     4          DEL2K (NPTS),
     5          TKE   (NPTS),
     6          ETILDE(NPTS),
     7          XSIW  (NPTS),
     8          FDAMP (NPTS,2),
     9          EPSC  (NPTS),
     A          PDIL  (NPTS),
     B          SIJ   (NPTS,6),
     C          WIJ   (NPTS,6),
     D          SRC   (NPTS,NF)
C
      DIMENSION IMODEL(NMDL)
C
C Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
      ITURB  = IMODEL(1)
      IPSMDL = IMODEL(6)
      IEPSIJ = IMODEL(7)
C
C 1. Calculate the damping functions for the epsilon equation
C    PIIJ contains TAU = - rho tau_ij at this point
C
      CALL DAMPEE (IMODEL, NPTS, Q, PROPS, DEL2K, TKE,
     1             PIIJ, DQDX, DQDY, DQDZ, ETILDE, XSIW, FDAMP)
C
C 2. Call routine to calculate b_ij
C    Temporary space:
C       b_ij: PIIJ
C       NOTE: use b_ij: SRC(1,1) in the future
C    this assumes that SRC is at least 12 long and has not been used yet
C
      CALL GETBIJ (NPTS, Q, PIIJ)
C
C 3. Calculate compressible dissipation
C
      CALL EPSCMP (IMODEL, NPTS, Q, PROPS, TKE, SIJ, WIJ, EPSC)
C
C 4. Calculate pressure-dilatation
C***********
C***This won't work as I currently don't have TAU
C***********
C
      CALL PRDIL  (IMODEL, NPTS, Q, PROPS, DQDX, DQDY, DQDZ, TAU,
     1             TKE, SIJ, WIJ, EPSC, PDIL)
C
C 5. Call routine to calculate Pressure-Strain Correlation
C    b_ij is passed in in PIIJ.  The pressure-strain is returned in PIIJ.
C
      CALL PSTRAN (IPSMDL, NPTS, Q, PROPS, SIJ, WIJ, PIIJ)
C
C 6. Form the source terms for the Reynolds stress model
C
      DO 100 I = 1, NPTS
C
         RHO    = Q(I,1)
         P      = Q(I,5)
         TAUXX  = Q(I,6)
         TAUYY  = Q(I,7)
         TAUZZ  = Q(I,8)
         TAUXY  = Q(I,9)
         TAUXZ  = Q(I,10)
         TAUYZ  = Q(I,11)
         EPSLN  = Q(I,12)
C
         RMU    = PROPS(I,1)
         RMUT   = PROPS(I,2)
         YPLUS  = PROPS(I,3)
         YNORML = ABS (PROPS(I,4))
C
C Transition specification
C
         TRANS = 1.E0
         IF (PROPS(I,4) .LT. 0.E0) TRANS = 0.E0
C
C DUKDXK = DU_k/DX_k / 3 = (DU/DX + DV/DY + DW/DZ) / 3
C
         DUKDXK = (DQDX(I,2) + DQDY(I,3) + DQDZ(I,4)) / 3.E0
C
C Production terms P_ij:
C    P_ij = - rho Tau_ik du_j/dx_k - rho Tau_jk du_i/dx_k
C
         PXX   = - 2.E0 * RHO * ( TAUXX * DQDX(I,2) +
     1                            TAUXY * DQDY(I,2) +
     2                            TAUXZ * DQDZ(I,2) ) * TRANS
         PYY   = - 2.E0 * RHO * ( TAUXY * DQDX(I,3) +
     1                            TAUYY * DQDY(I,3) +
     2                            TAUYZ * DQDZ(I,3) ) * TRANS
         PZZ   = - 2.E0 * RHO * ( TAUXZ * DQDX(I,4) +
     1                            TAUYZ * DQDY(I,4) +
     2                            TAUZZ * DQDZ(I,4) ) * TRANS
         PXY   = - RHO * ( TAUXX * DQDX(I,3) +
     1                     TAUXY * DQDY(I,3) +
     2                     TAUXZ * DQDZ(I,3) +
     3                     TAUXY * DQDX(I,2) +
     4                     TAUYY * DQDY(I,2) +
     5                     TAUYZ * DQDZ(I,2) ) * TRANS
         PXZ   = - RHO * ( TAUXX * DQDX(I,4) +
     1                     TAUXY * DQDY(I,4) +
     2                     TAUXZ * DQDZ(I,4) +
     3                     TAUXZ * DQDX(I,2) +
     4                     TAUYZ * DQDY(I,2) +
     5                     TAUZZ * DQDZ(I,2) ) * TRANS
         PYZ   = - RHO * ( TAUXY * DQDX(I,4) +
     1                     TAUYY * DQDY(I,4) +
     2                     TAUYZ * DQDZ(I,4) +
     3                     TAUXZ * DQDX(I,3) +
     4                     TAUYZ * DQDY(I,3) +
     5                     TAUZZ * DQDZ(I,3) ) * TRANS
C
         PROD  = 0.5E0 * (PXX + PYY + PZZ)
C
C Positivity preservation for production
C
         IF (POSPRD) THEN
            IF (PROD .LT. 0.E0) THEN
               NPRNEG = NPRNEG + 1
               PROD   = ABS (PROD)
            ENDIF
         ENDIF
C
         PRODUL = PROD
C
C Limit production term for robustness:
C
         TSTDIS = PRDLIM * RHO * EPSLN
         IF (PROD .GT. TSTDIS) THEN
            NPRLIM = NPRLIM + 1
            PROD   = TSTDIS
         ENDIF
C
C Production term for epsilon:
C->  PRODE = - CEPS1*epsilon/k*rho*tau_ij*(Du_i/Dx_j-Du_k/Dx_k*delta_ij/3)
C->          - 4/3*rho*epsilon*Du_k/Dx_k
C->  from: Speziale and Sarkar, ICASE 91-9
C
         PRODE  = CEPS1 * FDAMP(I,1) * EPSLN / TKE(I)
     1            * (PRDE * PROD + PRDEM1 * PRODUL)
C
C->      PRODE  = - CEPS1 * FDAMP(I,1) * RHO * EPSLN / TKE(I) *
C->  1               ( TAUXX * (DQDX(I,2) - DUKDXK)
C->  2               + TAUYY * (DQDY(I,3) - DUKDXK)
C->  3               + TAUZZ * (DQDZ(I,4) - DUKDXK)
C->  4               + TAUXY * (DQDY(I,2) + DQDX(I,3))
C->  5               + TAUXZ * (DQDZ(I,2) + DQDX(I,4))
C->  6               + TAUYZ * (DQDZ(I,3) + DQDY(I,4)) )
C
C Additional term from Speziale - factor of 3 is required because of
C definition DUKDXK
C
         DNUDT  = (1.E0 - 0.7E0 * GAMM1) * DUKDXK * 3.E0
C
C Dissipation
C
         DISSE  = CEPS2 * FDAMP(I,2) * RHO * EPSLN * ETILDE(I) / TKE(I)
C
C Calculate the Pressure-Velocity correlation term:
C    PVEL  = CPVELK * mu_T * sigma_rho / rho^2 * (DrhoDx_i DPDx_i)
C
         PVEL  = CPVELK * RMUT * SIGRHO / (RHO * RHO) * FSMACH / RE *
     1           ( DQDX(I,1) * DQDX(I,5) + DQDY(I,1) * DQDY(I,5)
     2           + DQDZ(I,1) * DQDZ(I,5) )
         PVELXX = 0.e0
         PVELYY = 0.e0
         PVELZZ = 0.e0
         PVELXY = 0.e0
         PVELXZ = 0.e0
         PVELYZ = 0.e0
C
C Calculate Source Term
C
         SRC(I,1)  = 0.E0
         SRC(I,2)  = 0.E0
         SRC(I,3)  = 0.E0
         SRC(I,4)  = 0.E0
         SRC(I,5)  = 0.E0
         SRC(I,6)  = PXX + PIIJ(I,1) - PVELXX + PDIL(I)
         SRC(I,7)  = PYY + PIIJ(I,2) - PVELYY + PDIL(I)
         SRC(I,8)  = PZZ + PIIJ(I,3) - PVELZZ + PDIL(I)
         SRC(I,9)  = PXY + PIIJ(I,4) - PVELXY
         SRC(I,10) = PXZ + PIIJ(I,5) - PVELXZ
         SRC(I,11) = PYZ + PIIJ(I,6) - PVELYZ
         SRC(I,12) = PRODE - DISSE + XSIW(I)
C->  1               + (DNUDT - 4.E0 * DUKDXK) * RHO * EPSLN
  100 CONTINUE
C
C 6. Add source terms due to dissipation
C
      CALL SRCEIJ (IEPSIJ, NPTS, Q, PROPS, DQDX, DQDY, DQDZ,
     1             EPSC, DEL2K, SRC)
C
C Finished with Reynolds Stress source terms
      RETURN
      END
      SUBROUTINE SRCRSW (IMODEL, Q, PROPS, SN, DQDX, DQDY, DQDZ,
     1                   TKE, EPSC, SRC, SRCW,
     2                   IDIM, JDIM, KDIM, I, NBCS, IBCDAT,
     3                   S, RC, YNI, YNITOT)
C
C Routine to calculate the wall normal dependent source terms for the
C Reynolds stress turbulence model.
C
C Assumptions:
C    I.   The contributions due to walls are restricted to walls on the
C         current block
C    II.  The total contribution due to all walls is calculated as weighted
C         sum of each wall as:
C             a_ij_walls = Sum (a_ij_l / yn_l)   / Sum (1 / yn_l)
C                           l=1,walls               l=1,walls
C    III. The distance to any given wall is sufficiently approximated as the
C         distance from the cell center to the wall point = dist (R - R_wall)
C
C This routine is organized into the following sections:
C      1. Initialize total inverse distance to zero
C      2. Loop over all boundary conditions
C         a. If WALL boundary then
C            i.   Initialize SN, YNI to zero on current plane
C            ii.  Calculate SN, inverse distance to wall along normal coordinate
C                 1. I direction )
C                 2. J direction } For each wall point, calculate SN, YNI
C                 3. K direction )
C                 4. Error
C            iii. Sum inverse distance to total inverse distance
C            iv.  Add weighted pressure-strain to additional source terms
C            v.   Add weighted epsilon_ij to additional source terms
C      3. Weight additional source terms by total inverse distance and add
C         to residual
C
C IMODEL         : Turbulence model array
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C SN             : Wall normals
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C TKE            :
C EPSC           :
C SRC            : Source terms at the cell centers of the I-plane
C SRCW           : Wall normal dependent Reynolds stress source terms
C IDIM,JDIM,KDIM : Dimensions of current block
C I              : I plane to calculate additional source terms at
C NBCS           : Number of boundary conditions for current block
C IBCDAT         : Data controlling boundary conditions:
C                  IBCDAT(1,ibc) = Boundary Condition Type
C                         2      = Direction (1=i, 2=j, 3=k)
C                         3      = i(1 or idim)
C                         4      = istrt
C                         5      = iend
C                         6      = jstrt
C                         7      = jend
C                         8      = kstrt
C                         9      = kend
C                         10     = profile identifier
C S              : Metrics
C RC             : Grid position vector to cell center
C YNI            : Storage for inverse normal distance to wall
C YNITOT         : Storage for total inverse normal distance to wall for
C                  all walls
C
      include 'common.inc'
C
      DIMENSION Q     (2:JDIM,2:KDIM,NQ),
     1          PROPS (2:JDIM,2:KDIM,NP),
     2          SN    (2:JDIM,2:KDIM,3)
C
      DIMENSION DQDX  (2:JDIM,2:KDIM,NQ),
     1          DQDY  (2:JDIM,2:KDIM,NQ),
     2          DQDZ  (2:JDIM,2:KDIM,NQ),
     3          TKE   (2:JDIM,2:KDIM),
     4          EPSC  (2:JDIM,2:KDIM),
     5          SRC   (2:JDIM,2:KDIM,NF),
     6          SRCW  (2:JDIM,2:KDIM,6)
C
      DIMENSION IBCDAT(10,NBCS)
C
      DIMENSION S     (0:JDIM+1,0:KDIM+1,0:IDIM+1,4,3),
     1          RC    (  JDIM+1,  KDIM+1,  IDIM+1,3)
C
      DIMENSION YNI   (2:JDIM,2:KDIM),
     1          YNITOT(2:JDIM,2:KDIM)
C
      DIMENSION IMODEL(NMDL)
C
      LOGICAL   DOPLAN,
     1          DOWALL
C
C Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
      ITURB  = IMODEL(1)
      IPSMDL = IMODEL(6)
      IEPSIJ = IMODEL(7)
C
C     Number of points in a cross-section to calculate source terms at
C
      NPTS   = (JDIM - 1) * (KDIM - 1)
C
C 1.  Initialize total inverse distance and wall source terms to zero
C
      DO 120 K = 2, KDIM
         DO 110 J = 2, JDIM
            YNITOT(J,K)   = 0.E0
            SRCW  (J,K,1) = 0.E0
            SRCW  (J,K,2) = 0.E0
            SRCW  (J,K,3) = 0.E0
            SRCW  (J,K,4) = 0.E0
            SRCW  (J,K,5) = 0.E0
            SRCW  (J,K,6) = 0.E0
  110    CONTINUE
  120 CONTINUE
C
C     Initialize DOPLAN to false so that the source terms are updated
C     only if walls affect the current plane
C
      DOPLAN = .FALSE.
C
C 2.  Loop over all boundary conditions
C
      DO 290 IBC = 1, NBCS
C
C     Initialize DOWALL to false so that the additional source terms
C     are calculated only if the current wall affects this plane
C
         DOWALL   = .FALSE.
         IBCTYP   = IBCDAT(1,IBC)
C
C 2.a. If WALL boundary then
C Store boundary condition data in mnemonic names
C
         IF (IBCTYP .EQ. IWALL) THEN
            IDIR     = IBCDAT(2,IBC)
            INROUT   = IBCDAT(3,IBC)
            ISTRT    = IBCDAT(4,IBC)
            IEND     = IBCDAT(5,IBC)
            JSTRT    = IBCDAT(6,IBC)
            JEND     = IBCDAT(7,IBC)
            KSTRT    = IBCDAT(8,IBC)
            KEND     = IBCDAT(9,IBC)
C
C 2.a.i.    Initialize SN, YNI to zero
C
            DO 210 K = 2, KDIM
               DO 205 J = 2, JDIM
                  SN (J,K,1) = 0.E0
                  SN (J,K,2) = 0.E0
                  SN (J,K,3) = 0.E0
                  YNI(J,K)   = 0.E0
  205          CONTINUE
  210       CONTINUE
C
C 2.a.ii.   Calculate SN, inverse distance to wall along normal coordinate
C
C 2.a.ii-1. I direction
C
            IF (IDIR .EQ. 1) THEN
C**            write (iout,'(a)') ' Stopping in SRCRSw'
C**            stop
               DOWALL = .TRUE.
C
               IF (INROUT .EQ. 1) THEN
                  IBCW = 1
               ELSE
                  IBCW = IDIM + 1
               ENDIF
                  DO 230 K = KSTRT, KEND
                     DO 220 J = JSTRT, JEND
                        SN (J,K,1) = S (J,K,IBCW,1,IDIR)
                        SN (J,K,2) = S (J,K,IBCW,2,IDIR)
                        SN (J,K,3) = S (J,K,IBCW,3,IDIR)
                        DX         = RC(J,K,I,1) - RC(J,K,IBCW,1)
                        DY         = RC(J,K,I,2) - RC(J,K,IBCW,2)
                        DZ         = RC(J,K,I,3) - RC(J,K,IBCW,3)
                        YNI(J,K)   = SQRT (DX*DX + DY*DY + DZ*DZ)
  220                CONTINUE
  230             CONTINUE
C
C 2.a.ii-2. J direction
C
            ELSE IF (IDIR .EQ. 2) THEN
               DOWALL = .TRUE.
               IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                  IF (INROUT .EQ. 1) THEN
                     JBCW = 1
                  ELSE
                     JBCW = JDIM + 1
                  ENDIF
                  DO 250 K = KSTRT, KEND
                     DO 240 J = 2, JDIM
                        SN (J,K,1) = S(JBCW,K,I,1,IDIR)
                        SN (J,K,2) = S(JBCW,K,I,2,IDIR)
                        SN (J,K,3) = S(JBCW,K,I,3,IDIR)
                        DX         = RC(J,K,I,1) - RC(JBCW,K,I,1)
                        DY         = RC(J,K,I,2) - RC(JBCW,K,I,2)
                        DZ         = RC(J,K,I,3) - RC(JBCW,K,I,3)
                        YNI(J,K)   = SQRT (DX*DX + DY*DY + DZ*DZ)
  240                CONTINUE
  250             CONTINUE
               ENDIF
C
C 2.a.ii-3. K direction
C
            ELSE IF (IDIR .EQ. 3) THEN
C**            write (iout,'(a)') ' Stopping in SRCRSw'
C**            stop
               DOWALL = .TRUE.
               IF (I .GE. ISTRT .AND. I .LE. IEND) THEN
                  IF (INROUT .EQ. 1) THEN
                     KBCW = 1
                  ELSE
                     KBCW = KDIM + 1
                  ENDIF
                  DO 270 K = 2, KDIM
                     DO 260 J = JSTRT, JEND
                        SN (J,K,1) = S(J,KBCW,I,1,IDIR)
                        SN (J,K,2) = S(J,KBCW,I,2,IDIR)
                        SN (J,K,3) = S(J,KBCW,I,3,IDIR)
                        DX         = RC(J,K,I,1) - RC(J,KBCW,I,1)
                        DY         = RC(J,K,I,2) - RC(J,KBCW,I,2)
                        DZ         = RC(J,K,I,3) - RC(J,KBCW,I,3)
                        YNI(J,K)   = SQRT (DX*DX + DY*DY + DZ*DZ)
  260                CONTINUE
  270             CONTINUE
               ENDIF
C
C 2.a.ii-4. Error
C
            ELSE
               WRITE (IOUT,1000) IDIR
               STOP
            ENDIF
C---------
C     do k = 2, kdim
C        do j = 2, jdim
C           write (iout,'(a,3i3,4e14.6)') ' i,j,k,s,y ',
C    1             i, j, k, sn(j,k,1), sn(j,k,2), sn(j,k,3), yni(j,k)
C        end do
C     end do
C---------
C
C           Only call the additional source terms if a wall actually affects
C           the current plane
C
            IF (DOWALL) THEN
C
C           Set DOPLAN so that the source terms are updated
C
               DOPLAN = .TRUE.
C
C 2.a.iii.  Sum inverse distance to total inverse distance
C
               DO 285 K = 2, KDIM
                  DO 280 J = 2, JDIM
                     YNITOT(J,K) = YNITOT(J,K) + YNI(J,K)
  280             CONTINUE
  285          CONTINUE
C
C 2.a.iv.  Add weighted pressure-strain to additional source terms
C
               CALL PSTRANW (IPSMDL, NPTS, Q, PROPS, SN, YNI, SRCW)
C
C 2.a.v.   Add weighted epsilon_ij to additional source terms
C
               CALL SRCEIJW (IEPSIJ, NPTS, Q, PROPS, SN, EPSC, YNI,SRCW)
            ENDIF
         ENDIF
  290 CONTINUE
C
C 3. Weight additional source terms by total inverse distance and add
C    to residual
C
      IF (DOPLAN) THEN
         DO 320 K = 2, KDIM
            DO 310 J = 2, JDIM
               DENOMI    = 1.E0 / (YNITOT(J,K) + RSMALL)
               SRC(J,K, 6) = SRC(J,K, 6) + SRCW(J,K,1) * DENOMI
               SRC(J,K, 7) = SRC(J,K, 7) + SRCW(J,K,2) * DENOMI
               SRC(J,K, 8) = SRC(J,K, 8) + SRCW(J,K,3) * DENOMI
               SRC(J,K, 9) = SRC(J,K, 9) + SRCW(J,K,4) * DENOMI
               SRC(J,K,10) = SRC(J,K,10) + SRCW(J,K,5) * DENOMI
               SRC(J,K,11) = SRC(J,K,11) + SRCW(J,K,6) * DENOMI
  310       CONTINUE
  320    CONTINUE
      ENDIF
C
C Finished with wall normal dependent Reynolds Stress source terms
      RETURN
 1000 FORMAT (' ','ERROR - RUN ABORTING',
     1       /' ','Incorrect direction specified in routine SRCRSW = ',
     2            I10)
      END
      SUBROUTINE SRCEIJ (IEPSIJ, NPTS, Q, PROPS, DQDX, DQDY, DQDZ,
     1                   EPSC, DEL2K, SRC)
C
C Routine to calculate the source terms for the dissipation and epsilon
C equation in the Reynolds stress turbulence model.
C
C This routine is organized into the following sections:
C      1. Isotropic distribution (For isotropic models and the isotropic
C         portion of Lai-So model with the near wall portions in SRCEIJW)
C      2. Fu-Launder-Tselepidakis Model
C      3. Gatski-Speziale Algebraic Anisotropic Dissipation Rate Model
C      4. So et al. 1995 model (Additional near wall in the diffusion terms)
C
C IEPSIJ         : Model for epsilon_ij
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C DQDX,DQDY,DQDZ : Derivatives of Q at cell centers
C EPSC           : Compressible dissipation
C DEL2K          : Laplacian of turbulent kinetic energy
C SRC            : Source terms at the cell centers
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
      DIMENSION DQDX  (NPTS,NQ),
     1          DQDY  (NPTS,NQ),
     2          DQDZ  (NPTS,NQ),
     3          EPSC  (NPTS),
     4          DEL2K (NPTS),
     5          SRC   (NPTS,NF)
C
C One-Third
C Two-Thirds
C
      T13 = 1.E0 / 3.E0
      T23 = 2.E0 / 3.E0
C
C Add the source terms for the dissipation and the epsilon equation to SRC
C
C 1. Isotropic (High Reynolds Number Model)
C    Isotropic portion of Lai-So model (SN (wall normal) dependent portion
C    of Lai-So model is in SRCEIJW.
C    NASA Contractor Report 4369 modifications from Thomas Sommer
C
      IF (IEPSIJ .EQ. IEISO .OR. IEPSIJ .EQ. IELAIS) THEN
         DO 100 I = 1, NPTS
C
            RHO    = Q(I,1)
            EPSLN  = Q(I,12)
C
C Dissipation = Solenoidal dissipation + compressible dissipation
C
            DISS   = T23 * RHO * (EPSLN + EPSC(I))
C
C Calculate Source Term
C
            SRC(I, 6) = SRC(I, 6) - DISS
            SRC(I, 7) = SRC(I, 7) - DISS
            SRC(I, 8) = SRC(I, 8) - DISS
  100    CONTINUE
C
C 2. Fu-Launder-Tselepidakis Model
C
      ELSE IF (IEPSIJ .EQ. IEFLT) THEN
         DO 200 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU    = PROPS(I,1)
            RMUT   = PROPS(I,2)
C
C FLT variables
C
            AXX    = TAUXX / TKE - T23
            AYY    = TAUYY / TKE - T23
            AZZ    = TAUZZ / TKE - T23
            AXY    = TAUXY / TKE
            AXZ    = TAUXZ / TKE
            AYZ    = TAUYZ / TKE
C
C A_2 = a_ik a_ki
C
            A2     =       AXX*AXX + AYY*AYY + AZZ*AZZ
     1             + 2.E0*(AXY*AXY + AXZ*AXZ + AYZ*AYZ)
C
C A_3 = a_ik a_kl a_li
C
            A3     =      AXX*AXX*AXX + AYY*AYY*AYY + AZZ*AZZ*AZZ
     1             + 3.E0*AXY*AXY*(AXX + AYY)
     2             + 3.E0*AXZ*AXZ*(AXX + AZZ)
     3             + 3.E0*AYZ*AYZ*(AYY + AZZ)
     4             + 6.E0*AXY*AXZ*AYZ
C
C A   =  1 - 9(A_2 - A_3)/8
C     => 0 in 2D limit
C     => 1 in isotropic turbulence
C
            ASQRT  = SQRT (1.E0 - 1.125E0*(A2 - A3))
C
C Dissipation
C
            DISS   = RHO  * (EPSLN + EPSC(I))
            DISSXX = DISS * (TAUXX*(1.E0-ASQRT)/TKE + T23*ASQRT)
            DISSYY = DISS * (TAUYY*(1.E0-ASQRT)/TKE + T23*ASQRT)
            DISSZZ = DISS * (TAUZZ*(1.E0-ASQRT)/TKE + T23*ASQRT)
            DISSXY = DISS * (TAUXY*(1.E0-ASQRT)/TKE)
            DISSXZ = DISS * (TAUXZ*(1.E0-ASQRT)/TKE)
            DISSYZ = DISS * (TAUYZ*(1.E0-ASQRT)/TKE)
C
C Calculate Source Term
C
            SRC(I, 6) = SRC(I, 6) - DISSXX
            SRC(I, 7) = SRC(I, 7) - DISSYY
            SRC(I, 8) = SRC(I, 8) - DISSZZ
            SRC(I, 9) = SRC(I, 9) - DISSXY
            SRC(I,10) = SRC(I,10) - DISSXZ
            SRC(I,11) = SRC(I,11) - DISSYZ
  200    CONTINUE
C
C 3. Gatski-Speziale Algebraic Anisotropic Dissipation Rate Model
C
      ELSE IF (IEPSIJ .EQ. IEADGS) THEN
         CE5    = 5.8E0
         AL3    = 0.6E0
         CALFA  = 0.75E0 * (14.E0*AL3/11.E0 - 16.E0/33.E0)
         DO 300 I = 1, NPTS
C
            RHO       = Q(I, 1)
            P         = Q(I, 5)
            TAUXX     = Q(I, 6)
            TAUYY     = Q(I, 7)
            TAUZZ     = Q(I, 8)
            TAUXY     = Q(I, 9)
            TAUXZ     = Q(I,10)
            TAUYZ     = Q(I,11)
            EPSLN     = Q(I,12)
C
            TKE       = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
C Production term:
C    PROD = TAUXX*DUDX + TAUYY*DVDY + TAUZZ*DWDZ +
C           TAUXY*(DUDY+DVDX) + TAUXZ*(DUDZ+DWDX) + TAUYZ*(DVDZ+DWDY)
C    note: TAU_ij is defined as -rho tau_ij
C
            PROD      = - RHO * (  TAUXX * DQDX(I,2)
     1                           + TAUYY * DQDY(I,3)
     2                           + TAUZZ * DQDZ(I,4)
     3                           + TAUXY * (DQDY(I,2) + DQDX(I,3))
     4                           + TAUXZ * (DQDZ(I,2) + DQDX(I,4))
     5                           + TAUYZ * (DQDZ(I,3) + DQDY(I,4)) )
C
            IF (POSPRD) PROD = ABS (PROD)
C
C Limit production term for robustness:
C
            TSTDIS    = PRDLIM * RHO * EPSLN
            PROD      = MIN (PROD, TSTDIS)
C
C     Constants based on SSG pressure-strain
C
            POVERE    = PROD / (RHO*EPSLN)
C
            TIMSCL    = TKE / EPSLN
C
C     S_ij
C
            SXX       = DQDX(I,2)
            SYY       = DQDY(I,3)
            SZZ       = DQDZ(I,4)
            SXY       = 0.5E0 * (DQDY(I,2) + DQDX(I,3))
            SXZ       = 0.5E0 * (DQDZ(I,2) + DQDX(I,4))
            SYZ       = 0.5E0 * (DQDZ(I,3) + DQDY(I,4))
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
            SKK       = (SXX + SYY + SZZ) / 3.E0
C
C     S_kl * S_lk / 3
C
            SKLSLK    =  ( SXX*SXX + SYY*SYY + SZZ*SZZ
     1             + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ) ) / 3.E0
C
C     W_ij
C
            WYX       = 0.5E0 * (DQDX(I,3) - DQDY(I,2))
            WZX       = 0.5E0 * (DQDX(I,4) - DQDZ(I,2))
            WZY       = 0.5E0 * (DQDY(I,4) - DQDZ(I,3))
            WXY       = 0.5E0 * (DQDY(I,2) - DQDX(I,3))
            WXZ       = 0.5E0 * (DQDZ(I,2) - DQDX(I,4))
            WYZ       = 0.5E0 * (DQDZ(I,3) - DQDY(I,4))
C
            ETASQ     =      TIMSCL * TIMSCL *
     1                      ( SXX*SXX + SYY*SYY + SZZ*SZZ
     2                + 2.E0*(SXY*SXY + SXZ*SXZ + SYZ*SYZ) )
            ZETSQ     =      TIMSCL * TIMSCL *
     1                  2.E0*(WXY*WXY + WXZ*WXZ + WYZ*WYZ)
C
            DENOM     = CE5 + POVERE - 1.E0
C
            B1        = ( 7.E0 * AL3 + 1.E0) / (11.E0 * DENOM)
            B2        = (15.E0 * AL3 - 1.E0) / (11.E0 * DENOM)
C
            CMUEPS    = 1.E0 / ( 15.E0 * DENOM *
     1                     (1.E0 + 2.E0*B1*B1*ZETSQ - T23*B2*B2*ETASQ) )
C
            B1KESQ    = B1 * TIMSCL * TIMSCL
            B2KESQ    = B2 * TIMSCL * TIMSCL
C
C Scaled Dissipation Anisotropy Tensor
C
            DXX    = - 2.E0 * CMUEPS * ( (SXX-SKK) * TIMSCL
     1                  +      B1KESQ*(        SXY*WYX+SXZ*WZX)
     2                  + 2.E0*B2KESQ*(SXX*SXX+SXY*SXY+SXZ*SXZ-SKLSLK) )
            DYY    = - 2.E0 * CMUEPS * ( (SYY-SKK) * TIMSCL
     1                  +      B1KESQ*(SXY*WXY        +SYZ*WZY)
     2                  + 2.E0*B2KESQ*(SXY*SXY+SYY*SYY+SYZ*SYZ-SKLSLK) )
            DZZ    = - 2.E0 * CMUEPS * ( (SZZ-SKK) * TIMSCL
     1                  +      B1KESQ*(SXZ*WXZ+SYZ*WYZ        )
     2                  + 2.E0*B2KESQ*(SXZ*SXZ+SYZ*SYZ+SZZ*SZZ-SKLSLK) )
            DXY    = - 2.E0 * CMUEPS * (  SXY * TIMSCL
     1                  +      B1KESQ*(SXX*WXY        +SXZ*WZY
     2                                        +SYY*WYX+SXZ*WZX)
     3                  + 2.E0*B2KESQ*(SXX*SXY+SXY*SYY+SXZ*SYZ) )
            DXZ    = - 2.E0 * CMUEPS * (  SXZ * TIMSCL
     1                  +      B1KESQ*(SXX*WXZ+SXY*WYZ
     2                                        +SYZ*WYX+SZZ*WZX)
     3                  + 2.E0*B2KESQ*(SXX*SXZ+SXY*SYZ+SXZ*SZZ) )
            DYZ    = - 2.E0 * CMUEPS * (  SYZ * TIMSCL
     1                  +      B1KESQ*(SXY*WXZ+SYY*WYZ
     2                                +SXZ*WXY        +SZZ*WZY)
     3                  + 2.E0*B2KESQ*(SXY*SXZ+SYY*SYZ+SYZ*SZZ) )
C
C Eps_ij
C
            DISSXX    = 2.E0 * RHO * EPSLN * (DXX + T13)
            DISSYY    = 2.E0 * RHO * EPSLN * (DYY + T13)
            DISSZZ    = 2.E0 * RHO * EPSLN * (DZZ + T13)
            DISSXY    = 2.E0 * RHO * EPSLN * (DXY)
            DISSXZ    = 2.E0 * RHO * EPSLN * (DXZ)
            DISSYZ    = 2.E0 * RHO * EPSLN * (DYZ)
C
C Source term in dissipation transport equation
C           R = - 2 (1 + alpha) rho epsilon d_ij S_ij
C
            REPSLN    = - 2.E0 * (1.E0 + CALFA) * RHO * EPSLN *
     1                            ( DXX*SXX + DYY*SYY + DZZ*SZZ
     2                      + 2.E0*(DXY*SXY + DXZ*SXZ + DYZ*SYZ) )
C
C Calculate Source Term
C
            SRC(I, 6) = SRC(I, 6) - DISSXX
            SRC(I, 7) = SRC(I, 7) - DISSYY
            SRC(I, 8) = SRC(I, 8) - DISSZZ
            SRC(I, 9) = SRC(I, 9) - DISSXY
            SRC(I,10) = SRC(I,10) - DISSXZ
            SRC(I,11) = SRC(I,11) - DISSYZ
            SRC(I,12) = SRC(I,12) + REPSLN
  300    CONTINUE
C
C 4.  So et al. 1995 model (Additional near wall in the diffusion terms)
C
      ELSE IF (IEPSIJ .EQ. IESO95) THEN
         DO 400 I = 1, NPTS
C
            RHO       = Q(I, 1)
            TAUXX     = Q(I, 6)
            TAUYY     = Q(I, 7)
            TAUZZ     = Q(I, 8)
            TAUXY     = Q(I, 9)
            TAUXZ     = Q(I,10)
            TAUYZ     = Q(I,11)
            EPSLN     = Q(I,12)
C
            TKE       = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU       = PROPS(I,1)
            YPLUS     = PROPS(I,3)
C
C Dissipation = Solenoidal dissipation + compressible dissipation
C
            DISS      = T23 * RHO * (EPSLN + EPSC(I))
C
C Epsilon_ij = Isotropic + Near Wall Correction
C
            RET       = RHO * TKE * TKE / (EPSLN * RMU) * RE / FSMACH
            FW2       = EXP( -(RET /  40.E0)**2 )
C
            TERM      = FW2 * RHO * (EPSLN + EPSC(I)) / (TKE + RSMASQ)
            EPSXX     = DISS + TERM * (TAUXX - T23*TKE)
            EPSYY     = DISS + TERM * (TAUYY - T23*TKE)
            EPSZZ     = DISS + TERM * (TAUZZ - T23*TKE)
            EPSXY     =        TERM *  TAUXY
            EPSXZ     =        TERM *  TAUXZ
            EPSYZ     =        TERM *  TAUYZ
C
C Calculate Source Term
C
            SRC(I, 6) = SRC(I, 6) - EPSXX
            SRC(I, 7) = SRC(I, 7) - EPSYY
            SRC(I, 8) = SRC(I, 8) - EPSZZ
            SRC(I, 9) = SRC(I, 9) - EPSXY
            SRC(I,10) = SRC(I,10) - EPSXZ
            SRC(I,11) = SRC(I,11) - EPSYZ
  400    CONTINUE
C
C Error
C
      ELSE
         WRITE (IOUT,1000) IEPSIJ
         STOP
      ENDIF
C
C Finished with dissipation source terms
      RETURN
 1000 FORMAT (' ','Invalid epsilon_ij model ',I5,' in SRCEIJ.',
     1       /' ','RUN ABORTING')
      END
      SUBROUTINE SRCEIJW (IEPSIJ, NPTS, Q, PROPS, SN, EPSC, YNI, SRCW)
C
C Routine to calculate the wall normal dependent source terms for the
C dissipation and epsilon equation in the Reynolds stress turbulence model.
C
C This routine is organized to calculate wall normal dependent source terms
C for epsilon_ij in the following sections:
C         Model                                        Wall Terms (YES/NO)
C      --------------------------------------------------------------------
C      0. Isotropic (High Reynolds Number Model)                    No
C      1. Lai-So model                                              YES
C      2. Fu-Launder-Tselepidakis Model                             No
C      3. Gatski-Speziale Algebraic Anisotropic Dissipation Rate    No
C
C IEPSIJ         : Model for epsilon_ij
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C                  PROPS(4) = YNORML
C SN             : Wall normals
C EPSC           : Compressible dissipation
C YNI            : Inverse distance to wall
C SRCW           : Wall normal dependent terms for epsilon_ij tensor
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP),
     2          SN    (NPTS,3)
C
      DIMENSION EPSC  (NPTS),
     1          YNI   (NPTS),
     2          SRCW  (NPTS,6)
C
C One-Third
C Two-Thirds
C
      T13 = 1.E0 / 3.E0
      T23 = 2.E0 / 3.E0
C
C Add the source terms for the dissipation and the epsilon equation to SRC
C
C 1. Lai-So model
C    NASA Contractor Report 4369 modifications from Thomas Sommer
C
      IF (IEPSIJ .EQ. IELAIS) THEN
         DO 100 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU    = PROPS(I,1)
            YPLUS  = PROPS(I,3)
C
C Damping
C
            RET    = RHO * TKE * TKE / (RMU * EPSLN) * RE / FSMACH
            FW1    = EXP( -(RET / 150.E0)**2 )
            IF (YPLUS .GT. 250.E0) FW1 = 0.E0
C
C Dissipation
C NOTE: PROBABLY ALSO NEED THE COMPRESSIBILITY CORRECTION MULTIPLYING EPSLN
C       IN THE FW1 TERM
C
            DISS   = T23 * RHO * (EPSLN + EPSC(I))
            TKLNKL =   TAUXX * SN(I,1) * SN(I,1)
     1               + TAUYY * SN(I,2) * SN(I,2)
     2               + TAUZZ * SN(I,3) * SN(I,3)
     3               + 2.E0 * TAUXY * SN(I,1) * SN(I,2)
     4               + 2.E0 * TAUXZ * SN(I,1) * SN(I,3)
     5               + 2.E0 * TAUYZ * SN(I,2) * SN(I,3)
            DENOMI = 1.E0 / (1.E0 + 1.5E0 * TKLNKL / TKE)
            DISSXX = - FW1 * DISS +
     1               FW1*RHO*EPSLN/TKE*DENOMI * ( TAUXX
     2+TAUXX*SN(I,1)*SN(I,1)+TAUXY*SN(I,2)*SN(I,1)+TAUXZ*SN(I,3)*SN(I,1)
     3+TAUXX*SN(I,1)*SN(I,1)+TAUXY*SN(I,2)*SN(I,1)+TAUXZ*SN(I,3)*SN(I,1)
     4+TKLNKL*SN(I,1)*SN(I,1) )
            DISSYY = - FW1 * DISS +
     1               FW1*RHO*EPSLN/TKE*DENOMI * ( TAUYY
     2+TAUXY*SN(I,1)*SN(I,2)+TAUYY*SN(I,2)*SN(I,2)+TAUYZ*SN(I,3)*SN(I,2)
     3+TAUXY*SN(I,1)*SN(I,2)+TAUYY*SN(I,2)*SN(I,2)+TAUYZ*SN(I,3)*SN(I,2)
     4+TKLNKL*SN(I,2)*SN(I,2) )
            DISSZZ = - FW1 * DISS +
     1               FW1*RHO*EPSLN/TKE*DENOMI * ( TAUZZ
     2+TAUXZ*SN(I,1)*SN(I,3)+TAUYZ*SN(I,2)*SN(I,3)+TAUZZ*SN(I,3)*SN(I,3)
     3+TAUXZ*SN(I,1)*SN(I,3)+TAUYZ*SN(I,2)*SN(I,3)+TAUZZ*SN(I,3)*SN(I,3)
     4+TKLNKL*SN(I,3)*SN(I,3) )
            DISSXY =
     1               FW1*RHO*EPSLN/TKE*DENOMI * ( TAUXY
     2+TAUXX*SN(I,1)*SN(I,2)+TAUXY*SN(I,2)*SN(I,2)+TAUXZ*SN(I,3)*SN(I,2)
     3+TAUXY*SN(I,1)*SN(I,1)+TAUYY*SN(I,2)*SN(I,1)+TAUYZ*SN(I,3)*SN(I,1)
     4+TKLNKL*SN(I,1)*SN(I,2) )
            DISSXZ =
     1               FW1*RHO*EPSLN/TKE*DENOMI * ( TAUXZ
     2+TAUXX*SN(I,1)*SN(I,3)+TAUXY*SN(I,2)*SN(I,3)+TAUXZ*SN(I,3)*SN(I,3)
     3+TAUXZ*SN(I,1)*SN(I,1)+TAUYZ*SN(I,2)*SN(I,1)+TAUZZ*SN(I,3)*SN(I,1)
     4+TKLNKL*SN(I,1)*SN(I,3) )
            DISSYZ =
     1               FW1*RHO*EPSLN/TKE*DENOMI * ( TAUYZ
     2+TAUXY*SN(I,1)*SN(I,3)+TAUYY*SN(I,2)*SN(I,3)+TAUYZ*SN(I,3)*SN(I,3)
     3+TAUXZ*SN(I,1)*SN(I,2)+TAUYZ*SN(I,2)*SN(I,2)+TAUZZ*SN(I,3)*SN(I,2)
     4+TKLNKL*SN(I,2)*SN(I,3) )
C
C Calculate Source Term
C
            SRCW(I,1) = SRCW(I,1) - YNI(I) * DISSXX
            SRCW(I,2) = SRCW(I,2) - YNI(I) * DISSYY
            SRCW(I,3) = SRCW(I,3) - YNI(I) * DISSZZ
            SRCW(I,4) = SRCW(I,4) - YNI(I) * DISSXY
            SRCW(I,5) = SRCW(I,5) - YNI(I) * DISSXZ
            SRCW(I,6) = SRCW(I,6) - YNI(I) * DISSYZ
  100    CONTINUE
C
      ENDIF
C
C Finished with wall surface normal dependent dissipation source terms
      RETURN
      END
      SUBROUTINE PSTRAN (IPSMDL, NPTS, Q, PROPS, SIJ, WIJ, PIIJ)
C
C Routine to calculate the Pressure-Strain Correlation for a Reynolds stress
C turbulence model.
C
C This routine is organized into the following sections:
C      1. Gison-Launder Pressure-Strain Correlation
C         Launder-Reece-Rodi "Basic Model" Pressure-Strain Correlation.
C      2. Launder-Reece-Rodi Pressure Strain Correlation
C      3. Lai-So Pressure Strain Correlation
C      4. Speziale-Sarkar-Gatski Pressure Strain Correlation
C      5. Fu-Launder-Tselepidakis (FLT) Pressure Strain Correlation
C      6. So et al. 1995 SSG-based near-wall Pressure Strain Correlation
C
C IPSMDL         : Pressure-strain model
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C                  PROPS(4) = YNORML
C SIJ            : Symmetric tensor du_i/dx_j + du_j/dx_i
C WIJ            : Anti-Symmetric tensor du_i/dx_j - du_j/dx_i
C PIIJ           : Pressure Strain Correlation
C                  On entry to this routine, PIIJ contains b_ij
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP)
C
C     +-------------+---------------+---------------+
C     +     SIJ     +       WIJ     +      PIIJ     +
C     + (i,j)  sub  +  (i,j)   sub  +  (i,j)   sub  +
C     +-------------+---------------+---------------+
C     +  x,x    1   +   y,x     1   +   x,x     1   +
C     +  y,y    2   +   z,x     2   +   y,y     2   +
C     +  z,z    3   +   z,y     3   +   z,z     3   +
C     +  x,y    4   +   x,y     4   +   x,y     4   +
C     +  x,z    5   +   x,z     5   +   x,z     5   +
C     +  y,z    6   +   y,z     6   +   y,z     6   +
C     +-------------+---------------+---------------+
C
      DIMENSION SIJ   (NPTS,6),
     1          WIJ   (NPTS,6),
     2          PIIJ  (NPTS,6)
C
C     One-Thirds
C     Two-Thirds
C
      T13 = 1.E0 / 3.E0
      T23 = 2.E0 / 3.E0
C
C     Calculate Pressure-Strain Correlation
C
      IF (IPSMDL .EQ. IPGL) THEN
C
C 1. Gison-Launder Pressure-Strain Correlation
C    Launder-Reece-Rodi "Basic Model" Pressure-Strain Correlation.
C    The form for this model is from Sarkar&Balakrishnan, ICASE 90-18
C
C     Coefficients
C
         CA = PSC2
         CB = PSC2
         CC = T23 * PSC2
         DO 100 I = 1, NPTS
C
            RHO   = Q(I,1)
            P     = Q(I,5)
            TAUXX = Q(I,6)
            TAUYY = Q(I,7)
            TAUZZ = Q(I,8)
            TAUXY = Q(I,9)
            TAUXZ = Q(I,10)
            TAUYZ = Q(I,11)
            EPSLN = Q(I,12)
C
            TKE   = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
C     Anisotropy tensor
C
            BXX    = PIIJ(I,1)
            BYY    = PIIJ(I,2)
            BZZ    = PIIJ(I,3)
            BXY    = PIIJ(I,4)
            BXZ    = PIIJ(I,5)
            BYZ    = PIIJ(I,6)
C
            SXX    = SIJ(I,1)
            SYY    = SIJ(I,2)
            SZZ    = SIJ(I,3)
            SXY    = SIJ(I,4)
            SXZ    = SIJ(I,5)
            SYZ    = SIJ(I,6)
C
            WYX    = WIJ(I,1)
            WZX    = WIJ(I,2)
            WZY    = WIJ(I,3)
            WXY    = WIJ(I,4)
            WXZ    = WIJ(I,5)
            WYZ    = WIJ(I,6)
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
            SKK    = (SXX + SYY + SZZ) / 3.E0
C
C     b_lk * S_lk
C
            BLKSLK =       BXX*SXX + BYY*SYY + BZZ*SZZ
     1             + 2.E0*(BXY*SXY + BXZ*SXZ + BYZ*SYZ)
C
C     PI_ij = Phi*_ij,1 + Phi_ij,2
C
            PIIJ(I,1) = - PSC1 * RHO * EPSLN * BXX
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXX*SXX + BXY*SXY + BXZ*SXZ) - T23*BLKSLK)
     3   + CB * (2.E0*(          BXY*WXY + BXZ*WXZ))
     4   + CC * (SXX - SKK) )
C
            PIIJ(I,2) = - PSC1 * RHO * EPSLN * BYY
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXY*SXY + BYY*SYY + BYZ*SYZ) - T23*BLKSLK)
     3   + CB * (2.E0*(BXY*WYX           + BYZ*WYZ))
     4   + CC * (SYY - SKK) )
C
            PIIJ(I,3) = - PSC1 * RHO * EPSLN * BZZ
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXZ*SXZ + BYZ*SYZ + BZZ*SZZ) - T23*BLKSLK)
     3   + CB * (2.E0*(BXZ*WZX + BYZ*WZY          ))
     4   + CC * (SZZ - SKK) )
C
            PIIJ(I,4) = - PSC1 * RHO * EPSLN * BXY
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXX*SXY + BXY*SYY + BXZ*SYZ + BXY*SXX + BYY*SXY + BYZ*SXZ)
     3   +CB*(BXX*WYX           + BXZ*WYZ           + BYY*WXY + BYZ*WXZ)
     4   +CC*(SXY) )
C
            PIIJ(I,5) = - PSC1 * RHO * EPSLN * BXZ
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXX*SXZ + BXY*SYZ + BXZ*SZZ + BXZ*SXX + BYZ*SXY + BZZ*SXZ)
     3   +CB*(BXX*WZX + BXY*WZY                     + BYZ*WXY + BZZ*WXZ)
     4   +CC*(SXZ) )
C
            PIIJ(I,6) = - PSC1 * RHO * EPSLN * BYZ
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXY*SXZ + BYY*SYZ + BYZ*SZZ + BXZ*SXY + BYZ*SYY + BZZ*SYZ)
     3   +CB*(BXY*WZX + BYY*WZY           + BXZ*WYX           + BZZ*WYZ)
     4   +CC*(SYZ) )
C
  100    CONTINUE
C
C 2. Launder-Reece-Rodi Pressure Strain Correlation
C    Cphi are coefficients casting the LRR form of the model into b,S,W.
C    Use PSCW = 1.e0 to turn wall reflection term ON,
C        PSCW = 0.e0 to turn wall reflection term OFF
C
      ELSE IF (IPSMDL .EQ. IPLRR1) THEN
         CPHI2A = ( 9.E0*PSC2 + 6.E0) / 11.E0
         CPHI2B = (10.E0 - 7.E0*PSC2) / 11.E0
         CPHI2C = 0.4E0
         DO 200 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            YNORML = ABS (PROPS(I,4))
C
C     Pressure Reflection term
C
            RLEN   = PSCW * TKE * SQRT(TKE) / (EPSLN * YNORML)
C
C     Anisotropy tensor
C
            BXX    = PIIJ(I,1)
            BYY    = PIIJ(I,2)
            BZZ    = PIIJ(I,3)
            BXY    = PIIJ(I,4)
            BXZ    = PIIJ(I,5)
            BYZ    = PIIJ(I,6)
C
            SXX    = SIJ(I,1)
            SYY    = SIJ(I,2)
            SZZ    = SIJ(I,3)
            SXY    = SIJ(I,4)
            SXZ    = SIJ(I,5)
            SYZ    = SIJ(I,6)
C
            WYX    = WIJ(I,1)
            WZX    = WIJ(I,2)
            WZY    = WIJ(I,3)
            WXY    = WIJ(I,4)
            WXZ    = WIJ(I,5)
            WYZ    = WIJ(I,6)
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
            SKK    = (SXX + SYY + SZZ) / 3.E0
C
C     b_lk * S_lk
C
            BLKSLK =       BXX*SXX + BYY*SYY + BZZ*SZZ
     1             + 2.E0*(BXY*SXY + BXZ*SXZ + BYZ*SYZ)
C
C     Coefficients
C
            C1STAR = PSC1 - 2.E0 * 0.125E0 * RLEN
C
            CA     = CPHI2A
            CB     = CPHI2B - 2.E0 * 0.015E0 * RLEN
            CC     = CPHI2C
C
C     PI_ij = Phi_ij,1 + Phi_ij,2
C
            PIIJ(I,1) = - C1STAR * RHO * EPSLN * BXX
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXX*SXX + BXY*SXY + BXZ*SXZ) - T23*BLKSLK)
     3   + CB * (2.E0*(          BXY*WXY + BXZ*WXZ))
     4   + CC * (SXX - SKK) )
C
            PIIJ(I,2) = - C1STAR * RHO * EPSLN * BYY
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXY*SXY + BYY*SYY + BYZ*SYZ) - T23*BLKSLK)
     3   + CB * (2.E0*(BXY*WYX           + BYZ*WYZ))
     4   + CC * (SYY - SKK) )
C
            PIIJ(I,3) = - C1STAR * RHO * EPSLN * BZZ
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXZ*SXZ + BYZ*SYZ + BZZ*SZZ) - T23*BLKSLK)
     3   + CB * (2.E0*(BXZ*WZX + BYZ*WZY          ))
     4   + CC * (SZZ - SKK) )
C
            PIIJ(I,4) = - C1STAR * RHO * EPSLN * BXY
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXX*SXY + BXY*SYY + BXZ*SYZ + BXY*SXX + BYY*SXY + BYZ*SXZ)
     3   +CB*(BXX*WYX           + BXZ*WYZ           + BYY*WXY + BYZ*WXZ)
     4   +CC*(SXY) )
C
            PIIJ(I,5) = - C1STAR * RHO * EPSLN * BXZ
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXX*SXZ + BXY*SYZ + BXZ*SZZ + BXZ*SXX + BYZ*SXY + BZZ*SXZ)
     3   +CB*(BXX*WZX + BXY*WZY                     + BYZ*WXY + BZZ*WXZ)
     4   +CC*(SXZ) )
C
            PIIJ(I,6) = - C1STAR * RHO * EPSLN * BYZ
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXY*SXZ + BYY*SYZ + BYZ*SZZ + BXZ*SXY + BYZ*SYY + BZZ*SYZ)
     3   +CB*(BXY*WZX + BYY*WZY           + BXZ*WYX           + BZZ*WYZ)
     4   +CC*(SYZ) )
C
  200    CONTINUE
C
C 3. Lai-So Pressure Strain Correlation
C    NASA Contractor Report 4369 (Based on LRR1)
C    Corrected form based on Zhang, So, Gatski, Speziale in the
C    Near-Wall Turbulent Flows book later corrected from private communications
C    with Ron So.  Note that this is not strictly a pressure-strain model
C    but rather a model of pressure-strain and pressure-diffusion so that the
C    trace of the model is Non-Zero.
C    Modified based on private communication with Hou-Shun Zhang to include
C    the subtraction of the trace term from the S_ij term in the near-wall.
C
      ELSE IF (IPSMDL .EQ. IPLS) THEN
         CPHI2A = ( 9.E0*PSC2 + 6.E0) / 11.E0
         CPHI2B = (10.E0 - 7.E0*PSC2) / 11.E0
         CPHI2C = 0.4E0
         DO 300 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU    = PROPS(I,1)
            YPLUS  = PROPS(I,3)
            YNORML = ABS (PROPS(I,4))
C
C     Anisotropy tensor
C
            BXX    = PIIJ(I,1)
            BYY    = PIIJ(I,2)
            BZZ    = PIIJ(I,3)
            BXY    = PIIJ(I,4)
            BXZ    = PIIJ(I,5)
            BYZ    = PIIJ(I,6)
C
            SXX    = SIJ(I,1)
            SYY    = SIJ(I,2)
            SZZ    = SIJ(I,3)
            SXY    = SIJ(I,4)
            SXZ    = SIJ(I,5)
            SYZ    = SIJ(I,6)
C
            WYX    = WIJ(I,1)
            WZX    = WIJ(I,2)
            WZY    = WIJ(I,3)
            WXY    = WIJ(I,4)
            WXZ    = WIJ(I,5)
            WYZ    = WIJ(I,6)
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
            SKK    = (SXX + SYY + SZZ) / 3.E0
C
C     b_lk * S_lk
C
            BLKSLK =       BXX*SXX + BYY*SYY + BZZ*SZZ
     1             + 2.E0*(BXY*SXY + BXZ*SXZ + BYZ*SYZ)
C
C     Wall damping
C
            RET    = RHO * TKE * TKE / (RMU * EPSLN) * RE / FSMACH
            FW1    = EXP( -(RET / 150.E0)**2 )
            IF (YPLUS .GT. 250.E0) FW1 = 0.E0
            C1STAR = PSC1 * (1.E0 - FW1)
C
C     Coefficients
C
            CA     = CPHI2A - (PSALFA + PSBETA)*FW1
            CB     = CPHI2B - (PSALFA - PSBETA)*FW1
            CC     = CPHI2C - (T23*(PSALFA + PSBETA) - PSGAMA)*FW1
C
            CWALL  = 2.E0*PSCW*RHO*TKE*TKE*SQRT(TKE) / (EPSLN*YNORML)
C
C     PI_ij = Phi_ij,1 + Phi_ij,2 + Phi_ij,w + Phi_ij,R
C     Note: SN (wall normal) dependent portion of Phi_ij,w is now in PSTRANW
C
            PIIJ(I,1) = - C1STAR * RHO * EPSLN * BXX
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXX*SXX + BXY*SXY + BXZ*SXZ) - T23*BLKSLK)
     3   + CB * (2.E0*(          BXY*WXY + BXZ*WXZ))
     4   + CC * (SXX - SKK) )
     5 + CWALL * (SXX - SKK)
C
            PIIJ(I,2) = - C1STAR * RHO * EPSLN * BYY
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXY*SXY + BYY*SYY + BYZ*SYZ) - T23*BLKSLK)
     3   + CB * (2.E0*(BXY*WYX           + BYZ*WYZ))
     4   + CC * (SYY - SKK) )
     5 + CWALL * (SYY - SKK)
C
            PIIJ(I,3) = - C1STAR * RHO * EPSLN * BZZ
     1 + 2.E0 * RHO * TKE *
     2   ( CA * (2.E0*(BXZ*SXZ + BYZ*SYZ + BZZ*SZZ) - T23*BLKSLK)
     3   + CB * (2.E0*(BXZ*WZX + BYZ*WZY          ))
     4   + CC * (SZZ - SKK) )
     5 + CWALL * (SZZ - SKK)
C
            PIIJ(I,4) = - C1STAR * RHO * EPSLN * BXY
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXX*SXY + BXY*SYY + BXZ*SYZ + BXY*SXX + BYY*SXY + BYZ*SXZ)
     3   +CB*(BXX*WYX           + BXZ*WYZ           + BYY*WXY + BYZ*WXZ)
     4   +CC*(SXY) )
     5 + CWALL * SXY
C
            PIIJ(I,5) = - C1STAR * RHO * EPSLN * BXZ
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXX*SXZ + BXY*SYZ + BXZ*SZZ + BXZ*SXX + BYZ*SXY + BZZ*SXZ)
     3   +CB*(BXX*WZX + BXY*WZY                     + BYZ*WXY + BZZ*WXZ)
     4   +CC*(SXZ) )
     5 + CWALL * SXZ
C
            PIIJ(I,6) = - C1STAR * RHO * EPSLN * BYZ
     1 + 2.E0 * RHO * TKE *
     2   (CA*(BXY*SXZ + BYY*SYZ + BYZ*SZZ + BXZ*SXY + BYZ*SYY + BZZ*SYZ)
     3   +CB*(BXY*WZX + BYY*WZY           + BXZ*WYX           + BZZ*WYZ)
     4   +CC*(SYZ) )
     5 + CWALL * SYZ
C
  300    CONTINUE
C
C 4. Speziale-Sarkar-Gatski Pressure Strain Correlation
C
      ELSE IF (IPSMDL .EQ. IPSSG) THEN
         CA0 =   3.40E0
         CA1 =   4.20E0
         CA3 = - 1.80E0
         CA4 =   1.25E0
         CA5 =   0.40E0
         DO 400 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            YNORML = ABS (PROPS(I,4))
C
C     Anisotropy tensor
C
            BXX    = PIIJ(I,1)
            BYY    = PIIJ(I,2)
            BZZ    = PIIJ(I,3)
            BXY    = PIIJ(I,4)
            BXZ    = PIIJ(I,5)
            BYZ    = PIIJ(I,6)
C
            SXX    = SIJ(I,1)
            SYY    = SIJ(I,2)
            SZZ    = SIJ(I,3)
            SXY    = SIJ(I,4)
            SXZ    = SIJ(I,5)
            SYZ    = SIJ(I,6)
C
            WYX    = WIJ(I,1)
            WZX    = WIJ(I,2)
            WZY    = WIJ(I,3)
            WXY    = WIJ(I,4)
            WXZ    = WIJ(I,5)
            WYZ    = WIJ(I,6)
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
            SKK    = (SXX + SYY + SZZ) / 3.E0
C
C     b_lk * S_lk
C
            BLKSLK =       BXX*SXX + BYY*SYY + BZZ*SZZ
     1             + 2.E0*(BXY*SXY + BXZ*SXZ + BYZ*SYZ)
C
C     II = b_mn b_nm
C
            BMNBMN =       BXX*BXX + BYY*BYY + BZZ*BZZ
     1             + 2.E0*(BXY*BXY + BXZ*BXZ + BYZ*BYZ)
C
C     Coefficient for SSG
C
            CA2    =   0.80E0 - 1.3E0 * SQRT(BMNBMN)
C
C     P_k => Production of turbulent kinetic energy
C
            PK     =   - ( TAUXX*SXX + TAUYY*SYY + TAUZZ*SZZ
     1             + 2.E0*(TAUXY*SXY + TAUXZ*SXZ + TAUYZ*SYZ) )
C
C     PI_ij = Phi_ij,1 + Phi_ij,2
C
            PIIJ(I,1) = - CA0 * RHO * EPSLN * BXX
     1 + CA1 * RHO * EPSLN * (BXX*BXX + BXY*BXY + BXZ*BXZ - T13*BMNBMN)
     2 + RHO * TKE *
     3  ( CA4 * (2.E0*(BXX*SXX + BXY*SXY + BXZ*SXZ) - T23*BLKSLK)
     4  + CA5 * (2.E0*(          BXY*WXY + BXZ*WXZ))
     5  + CA2 * (SXX - SKK) )
     6 + CA3 * RHO * PK * BXX
C
            PIIJ(I,2) = - CA0 * RHO * EPSLN * BYY
     1 + CA1 * RHO * EPSLN * (BXY*BXY + BYY*BYY + BYZ*BYZ - T13*BMNBMN)
     2 + RHO * TKE *
     3  ( CA4 * (2.E0*(BXY*SXY + BYY*SYY + BYZ*SYZ) - T23*BLKSLK)
     4  + CA5 * (2.E0*(BXY*WYX           + BYZ*WYZ))
     5  + CA2 * (SYY - SKK) )
     6 + CA3 * RHO * PK * BYY
C
            PIIJ(I,3) = - CA0 * RHO * EPSLN * BZZ
     1 + CA1 * RHO * EPSLN * (BXZ*BXZ + BYZ*BYZ + BZZ*BZZ - T13*BMNBMN)
     2 + RHO * TKE *
     3  ( CA4 * (2.E0*(BXZ*SXZ + BYZ*SYZ + BZZ*SZZ) - T23*BLKSLK)
     4  + CA5 * (2.E0*(BXZ*WZX + BYZ*WZY          ))
     5  + CA2 * (SZZ - SKK) )
     6 + CA3 * RHO * PK * BZZ
C
            PIIJ(I,4) = - CA0 * RHO * EPSLN * BXY
     1 + CA1 * RHO * EPSLN * (BXX*BXY + BXY*BYY + BXZ*BYZ)
     2 + RHO * TKE *
     3  (CA4*(BXX*SXY + BXY*SYY + BXZ*SYZ + BXY*SXX + BYY*SXY + BYZ*SXZ)
     4  +CA5*(BXX*WYX           + BXZ*WYZ           + BYY*WXY + BYZ*WXZ)
     5  +CA2*(SXY) )
     6 + CA3 * RHO * PK * BXY
C
            PIIJ(I,5) = - CA0 * RHO * EPSLN * BXZ
     1 + CA1 * RHO * EPSLN * (BXX*BXZ + BXY*BYZ + BXZ*BZZ)
     2 + RHO * TKE *
     3  (CA4*(BXX*SXZ + BXY*SYZ + BXZ*SZZ + BXZ*SXX + BYZ*SXY + BZZ*SXZ)
     4  +CA5*(BXX*WZX + BXY*WZY                     + BYZ*WXY + BZZ*WXZ)
     5  +CA2*(SXZ) )
     6 + CA3 * RHO * PK * BXZ
C
            PIIJ(I,6) = - CA0 * RHO * EPSLN * BYZ
     1 + CA1 * RHO * EPSLN * (BXY*BXZ + BYY*BYZ + BYZ*BZZ)
     2 + RHO * TKE *
     3  (CA4*(BXY*SXZ + BYY*SYZ + BYZ*SZZ + BXZ*SXY + BYZ*SYY + BZZ*SYZ)
     4  +CA5*(BXY*WZX + BYY*WZY           + BXZ*WYX           + BZZ*WYZ)
     5  +CA2*(SYZ) )
     6 + CA3 * RHO * PK * BYZ
C
  400    CONTINUE
C
C 5. Fu-Launder-Tselepidakis (FLT) Pressure Strain Correlation
C
      ELSE IF (IPSMDL .EQ. IPFLT) THEN
         CA2 =   0.80E0
         CA3 =   1.20E0
         CA4 =   1.20E0
         CA5 =   1.73E0
         CA6 =   0.80E0
         CA7 =   0.80E0
         CA8 =  11.20E0
         DO 500 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
C     Anisotropy tensor
C
            BXX    = PIIJ(I,1)
            BYY    = PIIJ(I,2)
            BZZ    = PIIJ(I,3)
            BXY    = PIIJ(I,4)
            BXZ    = PIIJ(I,5)
            BYZ    = PIIJ(I,6)
C
            SXX    = SIJ(I,1)
            SYY    = SIJ(I,2)
            SZZ    = SIJ(I,3)
            SXY    = SIJ(I,4)
            SXZ    = SIJ(I,5)
            SYZ    = SIJ(I,6)
C
            WYX    = WIJ(I,1)
            WZX    = WIJ(I,2)
            WZY    = WIJ(I,3)
            WXY    = WIJ(I,4)
            WXZ    = WIJ(I,5)
            WYZ    = WIJ(I,6)
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
            SKK    = (SXX + SYY + SZZ) / 3.E0
C
C     b_lk * S_lk
C
            BLKSLK =       BXX*SXX + BYY*SYY + BZZ*SZZ
     1             + 2.E0*(BXY*SXY + BXZ*SXZ + BYZ*SYZ)
C
C     II = b_mn b_nm
C
            BMNBMN =       BXX*BXX + BYY*BYY + BZZ*BZZ
     1             + 2.E0*(BXY*BXY + BXZ*BXZ + BYZ*BYZ)
C
C     III = b_lm b_mn b_nl
C
            BIII   =      BXX*BXX*BXX + BYY*BYY*BYY + BZZ*BZZ*BZZ
     1             + 3.E0*BXY*BXY*(BXX + BYY)
     2             + 3.E0*BXZ*BXZ*(BXX + BZZ)
     3             + 3.E0*BYZ*BYZ*(BYY + BZZ)
     4             + 6.E0*BXY*BXZ*BYZ
C
C     Coefficients for FLT
C
            FSQRT  =   SQRT (1.E0 - 4.5E0*BMNBMN + 9.E0*BIII)
            CA0    =   60.E0 * BMNBMN * FSQRT
            CA1    = - 72.E0 * BMNBMN * FSQRT
C
C     P_k => Production of turbulent kinetic energy
C
            PK     =   - ( TAUXX*SXX + TAUYY*SYY + TAUZZ*SZZ
     1             + 2.E0*(TAUXY*SXY + TAUXZ*SXZ + TAUYZ*SYZ) )
C
            BW11   =   2.E0 * (BXY*WXY + BXZ*WXZ)
            BW22   =   2.E0 * (BYZ*WYZ - BXY*WXY)
            BW33   = - 2.E0 * (BXZ*WXZ + BYZ*WYZ)
            BW12   = (BYY-BXX)*WXY + BXZ*WYZ + BYZ*WXZ
            BW13   = (BZZ-BXX)*WXZ - BXY*WYZ + BYZ*WXY
            BW23   = (BZZ-BYY)*WYZ - BXY*WXZ - BXZ*WXY
C
C     PI_ij = Phi_ij,1 + Phi_ij,2
C
            PIIJ(I,1) = - CA0 * RHO * EPSLN * BXX
     1 + CA1 * RHO * EPSLN * (BXX*BXX + BXY*BXY + BXZ*BXZ - T13*BMNBMN)
     2 + CA2 * RHO * TKE * (SXX - SKK)
     3 + CA3 * RHO * PK  * BXX
     4 + RHO * TKE *
     5  ( CA4 * (2.E0*(BXX*SXX + BXY*SXY + BXZ*SXZ) - T23*BLKSLK)
     6  + CA5 * (2.E0*(          BXY*WXY + BXZ*WXZ))
     7  + CA6 * ( BXX*2.E0*(BXX*SXX)
     8          + BYY*2.E0*(BXY*SXY)
     9          + BZZ*2.E0*(BXZ*SXZ)
     A          + BXY*2.E0*(BXX*SXY + BXY*SXX)
     B          + BXZ*2.E0*(BXX*SXZ + BXZ*SXX)
     C          + BYZ*2.E0*(BXY*SXZ + BXZ*SXY)
     D          - 2.E0 * (SXX*BXX*BXX + SYY*BXY*BXY + SZZ*BXZ*BXZ
     E                    + SXY*2.E0*(BXY*BXX)
     F                    + SXZ*2.E0*(BXZ*BXX)
     G                    + SYZ*2.E0*(BXZ*BXY)) )
     H  + CA7 * (
     I          + BYY*2.E0*(BXY*WXY)
     J          + BZZ*2.E0*(BXZ*WXZ)
     K          + BXY*2.E0*(BXX*WXY          )
     L          + BXZ*2.E0*(BXX*WXZ          )
     M          + BYZ*2.E0*(BXY*WXZ + BXZ*WXY) )
     N  + CA8 * ( BMNBMN
     O          *2.E0*(          BXY*WXY + BXZ*WXZ)
     P          +3.E0*( BW11*BXX*BXX + BW22*BXY*BXY + BW33*BXZ*BXZ
     Q                + BW12*(2.E0*BXX*BXY) + BW13*(2.E0*BXX*BXZ)
     R                + BW23*(2.E0*BXY*BXZ) ) )
     S  )
C
            PIIJ(I,2) = - CA0 * RHO * EPSLN * BYY
     1 + CA1 * RHO * EPSLN * (BXY*BXY + BYY*BYY + BYZ*BYZ - T13*BMNBMN)
     2 + CA2 * RHO * TKE * (SYY - SKK)
     3 + CA3 * RHO * PK  * BYY
     4 + RHO * TKE *
     5  ( CA4 * (2.E0*(BXY*SXY + BYY*SYY + BYZ*SYZ) - T23*BLKSLK)
     6  + CA5 * (2.E0*(BXY*WYX           + BYZ*WYZ))
     7  + CA6 * ( BXX*2.E0*(BXY*SXY)
     8          + BYY*2.E0*(BYY*SYY)
     9          + BZZ*2.E0*(BYZ*SYZ)
     A          + BXY*2.E0*(BXY*SYY + BYY*SXY)
     B          + BXZ*2.E0*(BXY*SYZ + BYZ*SXY)
     C          + BYZ*2.E0*(BYY*SYZ + BYZ*SYY)
     D          - 2.E0 * (SXX*BXY*BXY + SYY*BYY*BYY + SZZ*BYZ*BYZ
     E                    + SXY*2.E0*(BXY*BYY)
     F                    + SXZ*2.E0*(BXY*BYZ)
     G                    + SYZ*2.E0*(BYY*BYZ)) )
     H  + CA7 * ( BXX*2.E0*(BXY*WYX)
     I
     J          + BZZ*2.E0*(BYZ*WYZ)
     K          + BXY*2.E0*(          BYY*WYX)
     L          + BXZ*2.E0*(BXY*WYZ + BYZ*WYX)
     M          + BYZ*2.E0*(BYY*WYZ          ) )
     N  + CA8 * ( BMNBMN
     O          *2.E0*(BXY*WYX           + BYZ*WYZ)
     P          +3.E0*( BW11*BXY*BXY + BW22*BYY*BYY + BW33*BYZ*BYZ
     Q                + BW12*(2.E0*BXY*BYY) + BW13*(2.E0*BXY*BYZ)
     R                + BW23*(2.E0*BYY*BYZ) ) )
     S  )
C
            PIIJ(I,3) = - CA0 * RHO * EPSLN * BZZ
     1 + CA1 * RHO * EPSLN * (BXZ*BXZ + BYZ*BYZ + BZZ*BZZ - T13*BMNBMN)
     2 + CA2 * RHO * TKE * (SZZ - SKK)
     3 + CA3 * RHO * PK  * BZZ
     4 + RHO * TKE *
     5  ( CA4 * (2.E0*(BXZ*SXZ + BYZ*SYZ + BZZ*SZZ) - T23*BLKSLK)
     6  + CA5 * (2.E0*(BXZ*WXZ + BYZ*WZY          ))
     7  + CA6 * ( BXX*2.E0*(BXZ*SXZ)
     8          + BYY*2.E0*(BYZ*SYZ)
     9          + BZZ*2.E0*(BZZ*SZZ)
     A          + BXY*2.E0*(BXZ*SYZ + BYZ*SXZ)
     B          + BXZ*2.E0*(BXZ*SZZ + BZZ*SXZ)
     C          + BYZ*2.E0*(BYZ*SZZ + BZZ*SYZ)
     D          - 2.E0 * (SXX*BXZ*BXZ + SYY*BYZ*BYZ + SZZ*BZZ*BZZ
     E                    + SXY*2.E0*(BXZ*BYZ)
     F                    + SXZ*2.E0*(BXZ*BZZ)
     G                    + SYZ*2.E0*(BYZ*BZZ)) )
     H  + CA7 * ( BXX*2.E0*(BXZ*WZX)
     I          + BYY*2.E0*(BYZ*WZY)
     J
     K          + BXY*2.E0*(BXZ*WZY + BYZ*WZX)
     L          + BXZ*2.E0*(          BZZ*WZX)
     M          + BYZ*2.E0*(          BZZ*WZY) )
     N  + CA8 * ( BMNBMN
     O          *2.E0*(BXZ*WZX + BYZ*WZY          )
     P          +3.E0*( BW11*BXZ*BXZ + BW22*BYZ*BYZ + BW33*BZZ*BZZ
     Q                + BW12*(2.E0*BXZ*BYZ) + BW13*(2.E0*BXZ*BZZ)
     R                + BW23*(2.E0*BYZ*BZZ) ) )
     S  )
C
            PIIJ(I,4) = - CA0 * RHO * EPSLN * BXY
     1 + CA1 * RHO * EPSLN * (BXX*BXY + BXY*BYY + BXZ*BYZ)
     2 + CA2 * RHO * TKE * SXY
     3 + CA3 * RHO * PK  * BXY
     4 + RHO * TKE *
     5  (CA4*(BXX*SXY + BXY*SYY + BXZ*SYZ + BXY*SXX + BYY*SXY + BYZ*SXZ)
     6  +CA5*(BXX*WYX           + BXZ*WYZ           + BYY*WXY + BYZ*WXZ)
     7  + CA6 * ( BXX*(BXX*SXY + BXY*SXX)
     8          + BYY*(BXY*SYY + BYY*SXY)
     9          + BZZ*(BXZ*SYZ + BYZ*SXZ)
     A          + BXY*(BXX*SYY + BXY*SXY + BXY*SXY + BYY*SXX)
     B          + BXZ*(BXX*SYZ + BXZ*SXY + BXY*SXZ + BYZ*SXX)
     C          + BYZ*(BXY*SYZ + BXZ*SYY + BYY*SXZ + BYZ*SXY)
     D          - 2.E0 * (SXX*BXY*BXX + SYY*BYY*BXY + SZZ*BYZ*BXZ
     E                    + SXY*(BYY*BXX+BXY*BXY)
     F                    + SXZ*(BYZ*BXX+BXY*BXZ)
     G                    + SYZ*(BYZ*BXY+BYY*BXZ)) )
     H  + CA7 * ( BXX*(BXX*WYX          )
     I          + BYY*(          BYY*WXY)
     J          + BZZ*(BXZ*WYZ + BYZ*WXZ)
     K          + BXY*(          BXY*WYX + BXY*WXY          )
     L          + BXZ*(BXX*WYZ + BXZ*WYX + BXY*WXZ          )
     M          + BYZ*(BXY*WYZ +           BYY*WXZ + BYZ*WXY) )
     N  + CA8 * ( BMNBMN
     O      *(BXX*WYX           + BXZ*WYZ           + BYY*WXY + BYZ*WXZ)
     P          +3.E0*( BW11*BXX*BXY + BW22*BXY*BYY + BW33*BXZ*BYZ
     Q                + BW12*(BXX*BYY+BXY*BXY) + BW13*(BXX*BYZ+BXZ*BXY)
     R                + BW23*(BXY*BYZ+BXZ*BYY) ) )
     S  )
C
            PIIJ(I,5) = - CA0 * RHO * EPSLN * BXZ
     1 + CA1 * RHO * EPSLN * (BXX*BXZ + BXY*BYZ + BXZ*BZZ)
     2 + CA2 * RHO * TKE * SXZ
     3 + CA3 * RHO * PK  * BXZ
     4 + RHO * TKE *
     5  (CA4*(BXX*SXZ + BXY*SYZ + BXZ*SZZ + BXZ*SXX + BYZ*SXY + BZZ*SXZ)
     6  +CA5*(BXX*WZX + BXY*WZY                     + BYZ*WXY + BZZ*WXZ)
     7  + CA6 * ( BXX*(BXX*SXZ + BXZ*SXX)
     8          + BYY*(BXY*SYZ + BYZ*SXY)
     9          + BZZ*(BXZ*SZZ + BZZ*SXZ)
     A          + BXY*(BXX*SYZ + BXY*SXZ + BXZ*SXY + BYZ*SXX)
     B          + BXZ*(BXX*SZZ + BXZ*SXZ + BXZ*SXZ + BZZ*SXX)
     C          + BYZ*(BXY*SZZ + BXZ*SYZ + BYZ*SXZ + BZZ*SXY)
     D          - 2.E0 * (SXX*BXZ*BXX + SYY*BYZ*BXY + SZZ*BZZ*BXZ
     E                    + SXY*(BYZ*BXX+BXZ*BXY)
     F                    + SXZ*(BZZ*BXX+BXZ*BXZ)
     G                    + SYZ*(BZZ*BXY+BYZ*BXZ)) )
     H  + CA7 * ( BXX*(BXX*WZX          )
     I          + BYY*(BXY*WZY + BYZ*WXY)
     J          + BZZ*(          BZZ*WXZ)
     K          + BXY*(BXX*WZY + BXY*WZX + BXZ*WXY          )
     L          + BXZ*(          BXZ*WZX + BXZ*WXZ          )
     M          + BYZ*(          BXZ*WZY + BYZ*WXZ + BZZ*WXY) )
     N  + CA8 * ( BMNBMN
     O      *(BXX*WZX + BXY*WZY                     + BYZ*WXY + BZZ*WXZ)
     P          +3.E0*( BW11*BXX*BXZ + BW22*BXY*BYZ + BW33*BXZ*BZZ
     Q                + BW12*(BXX*BYZ+BXY*BXZ) + BW13*(BXX*BZZ+BXZ*BXZ)
     R                + BW23*(BXY*BZZ+BXZ*BYZ) ) )
     S  )
C
            PIIJ(I,6) = - CA0 * RHO * EPSLN * BYZ
     1 + CA1 * RHO * EPSLN * (BXY*BXZ + BYY*BYZ + BYZ*BZZ)
     2 + CA2 * RHO * TKE * SYZ
     3 + CA3 * RHO * PK  * BYZ
     4 + RHO * TKE *
     5  (CA4*(BXY*SXZ + BYY*SYZ + BYZ*SZZ + BXZ*SXY + BYZ*SYY + BZZ*SYZ)
     6  +CA5*(BXY*WZX + BYY*WZY           + BXZ*WYX           + BZZ*WYZ)
     7  + CA6 * ( BXX*(BXY*SXZ + BXZ*SXY)
     8          + BYY*(BYY*SYZ + BYZ*SYY)
     9          + BZZ*(BYZ*SZZ + BZZ*SYZ)
     A          + BXY*(BXY*SYZ + BYY*SXZ + BXZ*SYY + BYZ*SXY)
     B          + BXZ*(BXY*SZZ + BYZ*SXZ + BXZ*SYZ + BZZ*SXY)
     C          + BYZ*(BYY*SZZ + BYZ*SYZ + BYZ*SYZ + BZZ*SYY)
     D          - 2.E0 * (SXX*BXZ*BXY + SYY*BYZ*BYY + SZZ*BZZ*BYZ
     E                    + SXY*(BYZ*BXY+BXZ*BYY)
     F                    + SXZ*(BZZ*BXY+BXZ*BYZ)
     G                    + SYZ*(BZZ*BYY+BYZ*BYZ)) )
     H  + CA7 * ( BXX*(BXY*WZX + BXZ*WYX)
     I          + BYY*(BYY*WZY          )
     J          + BZZ*(          BZZ*WYZ)
     K          + BXY*(BXY*WZY + BYY*WZX +           BYZ*WYX)
     L          + BXZ*(          BYZ*WZX + BXZ*WYZ + BZZ*WYX)
     M          + BYZ*(          BYZ*WZY + BYZ*WYZ          ) )
     N  + CA8 * ( BMNBMN
     O      *(BXY*WZX + BYY*WZY           + BXZ*WYX           + BZZ*WYZ)
     P          +3.E0*( BW11*BXY*BXZ + BW22*BYY*BYZ + BW33*BYZ*BZZ
     Q                + BW12*(BXY*BYZ+BYY*BXZ) + BW13*(BXY*BZZ+BYZ*BXZ)
     R                + BW23*(BYY*BZZ+BYZ*BYZ) ) )
     S  )
C
  500    CONTINUE
C
C 6. So et al. 1995 SSG-based near-wall Pressure Strain Correlation
C
      ELSE IF (IPSMDL .EQ. IPSO95) THEN
         CA0HR =   3.40E0
         CA1HR =   4.20E0
         CA3HR = - 1.80E0
         CA4HR =   1.25E0
         CA5HR =   0.40E0
         DO 600 I = 1, NPTS
C
            RHO    = Q(I,1)
            P      = Q(I,5)
            TAUXX  = Q(I,6)
            TAUYY  = Q(I,7)
            TAUZZ  = Q(I,8)
            TAUXY  = Q(I,9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU    = PROPS(I,1)
            YPLUS  = PROPS(I,3)
C
C     Anisotropy tensor
C
            BXX    = PIIJ(I,1)
            BYY    = PIIJ(I,2)
            BZZ    = PIIJ(I,3)
            BXY    = PIIJ(I,4)
            BXZ    = PIIJ(I,5)
            BYZ    = PIIJ(I,6)
C
            SXX    = SIJ(I,1)
            SYY    = SIJ(I,2)
            SZZ    = SIJ(I,3)
            SXY    = SIJ(I,4)
            SXZ    = SIJ(I,5)
            SYZ    = SIJ(I,6)
C
            WYX    = WIJ(I,1)
            WZX    = WIJ(I,2)
            WZY    = WIJ(I,3)
            WXY    = WIJ(I,4)
            WXZ    = WIJ(I,5)
            WYZ    = WIJ(I,6)
C
C     S_kk = (S_xx + S_yy + S_zz) / 3
C
            SKK    = (SXX + SYY + SZZ) / 3.E0
C
C     b_lk * S_lk
C
            BLKSLK =       BXX*SXX + BYY*SYY + BZZ*SZZ
     1             + 2.E0*(BXY*SXY + BXZ*SXZ + BYZ*SYZ)
C
C     II  = b_mn b_nm
C
            BMNBMN =       BXX*BXX + BYY*BYY + BZZ*BZZ
     1             + 2.E0*(BXY*BXY + BXZ*BXZ + BYZ*BYZ)
C
C     III = b_ij b_jk b_ki
C
            BIII   = BXX*BXX*BXX + BXX*BXY*BXY + BXX*BXZ*BXZ
     1             + BXY*BXY*BXX + BXY*BYY*BXY + BXY*BYZ*BXZ
     2             + BXZ*BXZ*BXX + BXZ*BYZ*BXY + BXZ*BZZ*BXZ
     3             + BXY*BXX*BXY + BXY*BXY*BYY + BXY*BXZ*BYZ
     4             + BYY*BXY*BXY + BYY*BYY*BYY + BYY*BYZ*BYZ
     5             + BYZ*BXZ*BXY + BYZ*BYZ*BYY + BYZ*BZZ*BYZ
     6             + BXZ*BXX*BXZ + BXZ*BXY*BYZ + BXZ*BXZ*BZZ
     7             + BYZ*BXY*BXZ + BYZ*BYY*BYZ + BYZ*BYZ*BZZ
     8             + BZZ*BXZ*BXZ + BZZ*BYZ*BYZ + BZZ*BZZ*BZZ
C
C     Coefficient for SSG
C
            CA2HR  =   0.80E0 - 1.3E0 * SQRT(BMNBMN)
C
C     Near-Wall damping
C
C-          AFLAT  = 1.E0 - 4.5E0*(BMNBMN - 2.E0*BIII)
            RET    = RHO * TKE * TKE / (RMU * EPSLN) * RE / FSMACH
C-          FW1    = EXP (-(AFLAT * RET / 57)**3)
            FW1    = EXP (-(RET / 175)**2)
C
C     Near-Wall coefficients from So et al. 1995
C
            CA0    = CA0HR - FW1 * CA0HR
            CA1    = CA1HR - FW1 * CA1HR
            CA2    = CA2HR - FW1 * 2.E0*(T23*(PSALFA+PSBETA)-PSGAMA)
            CA3    = CA3HR - FW1 * CA3HR
            CA4    = CA4HR - FW1 * 2.E0*(PSALFA+PSBETA)
            CA5    = CA5HR - FW1 * 2.E0*(PSALFA-PSBETA)
C
C     P_k => Production of turbulent kinetic energy
C
            PK     =   - ( TAUXX*SXX + TAUYY*SYY + TAUZZ*SZZ
     1             + 2.E0*(TAUXY*SXY + TAUXZ*SXZ + TAUYZ*SYZ) )
C
C     PI_ij = Phi_ij,1 + Phi_ij,2
C
            PIIJ(I,1) = - CA0 * RHO * EPSLN * BXX
     1 + CA1 * RHO * EPSLN * (BXX*BXX + BXY*BXY + BXZ*BXZ - T13*BMNBMN)
     2 + RHO * TKE *
     3  ( CA4 * (2.E0*(BXX*SXX + BXY*SXY + BXZ*SXZ) - T23*BLKSLK)
     4  + CA5 * (2.E0*(          BXY*WXY + BXZ*WXZ))
     5  + CA2 * (SXX - SKK) )
     6 + CA3 * RHO * PK * BXX
C
            PIIJ(I,2) = - CA0 * RHO * EPSLN * BYY
     1 + CA1 * RHO * EPSLN * (BXY*BXY + BYY*BYY + BYZ*BYZ - T13*BMNBMN)
     2 + RHO * TKE *
     3  ( CA4 * (2.E0*(BXY*SXY + BYY*SYY + BYZ*SYZ) - T23*BLKSLK)
     4  + CA5 * (2.E0*(BXY*WYX           + BYZ*WYZ))
     5  + CA2 * (SYY - SKK) )
     6 + CA3 * RHO * PK * BYY
C
            PIIJ(I,3) = - CA0 * RHO * EPSLN * BZZ
     1 + CA1 * RHO * EPSLN * (BXZ*BXZ + BYZ*BYZ + BZZ*BZZ - T13*BMNBMN)
     2 + RHO * TKE *
     3  ( CA4 * (2.E0*(BXZ*SXZ + BYZ*SYZ + BZZ*SZZ) - T23*BLKSLK)
     4  + CA5 * (2.E0*(BXZ*WZX + BYZ*WZY          ))
     5  + CA2 * (SZZ - SKK) )
     6 + CA3 * RHO * PK * BZZ
C
            PIIJ(I,4) = - CA0 * RHO * EPSLN * BXY
     1 + CA1 * RHO * EPSLN * (BXX*BXY + BXY*BYY + BXZ*BYZ)
     2 + RHO * TKE *
     3  (CA4*(BXX*SXY + BXY*SYY + BXZ*SYZ + BXY*SXX + BYY*SXY + BYZ*SXZ)
     4  +CA5*(BXX*WYX           + BXZ*WYZ           + BYY*WXY + BYZ*WXZ)
     5  +CA2*(SXY) )
     6 + CA3 * RHO * PK * BXY
C
            PIIJ(I,5) = - CA0 * RHO * EPSLN * BXZ
     1 + CA1 * RHO * EPSLN * (BXX*BXZ + BXY*BYZ + BXZ*BZZ)
     2 + RHO * TKE *
     3  (CA4*(BXX*SXZ + BXY*SYZ + BXZ*SZZ + BXZ*SXX + BYZ*SXY + BZZ*SXZ)
     4  +CA5*(BXX*WZX + BXY*WZY                     + BYZ*WXY + BZZ*WXZ)
     5  +CA2*(SXZ) )
     6 + CA3 * RHO * PK * BXZ
C
            PIIJ(I,6) = - CA0 * RHO * EPSLN * BYZ
     1 + CA1 * RHO * EPSLN * (BXY*BXZ + BYY*BYZ + BYZ*BZZ)
     2 + RHO * TKE *
     3  (CA4*(BXY*SXZ + BYY*SYZ + BYZ*SZZ + BXZ*SXY + BYZ*SYY + BZZ*SYZ)
     4  +CA5*(BXY*WZX + BYY*WZY           + BXZ*WYX           + BZZ*WYZ)
     5  +CA2*(SYZ) )
     6 + CA3 * RHO * PK * BYZ
C
  600    CONTINUE
C
C     Error
C
      ELSE
         WRITE (IOUT,1000) IPSMDL
         STOP
      ENDIF
C
C     Finished calculating pressure-strain correlation
      RETURN
 1000 FORMAT (' ','ERROR - RUN ABORTING',
     1       /' ','Incorrect Pressure-Strain Correlation ',
     2            'Specified in routine PSTRAN = ',I10)
      END
      SUBROUTINE PSTRANW (IPSMDL, NPTS, Q, PROPS, SN, YNI, SRCW)
C
C Routine to calculate the wall surface normal dependent Pressure-Strain
C Correlation terms for a Reynolds stress turbulence model.
C
C This routine is organized to calculate wall normal dependent source terms
C for the Pressure-Strain in the following sections:
C         Model                                        Wall Terms (YES/NO)
C      --------------------------------------------------------------------
C      0. Isotropic (High Reynolds Number Model)                    No
C      1. Gison-Launder Pressure-Strain                             No
C         (Launder-Reece-Rodi "Basic Model" Pressure-Strain)
C      2. Launder-Reece-Rodi Pressure Strain                        No
C      3. Lai-So Pressure Strain                                    YES
C      4. Speziale-Sarkar-Gatski Pressure Strain                    No
C      5. Fu-Launder-Tselepidakis (FLT) Pressure Strain             No
C      6. So et al. 1995 Pressure Strain                            No
C
C IPSMDL         : Pressure-strain model
C NPTS           : Number of points to calculate source terms at
C Q              : Primitive variables at cell centers
C PROPS          : Properties stored at cell centers
C                  PROPS(1) = RMU   molecular viscosity
C                  PROPS(2) = RMUT  turbulent eddy viscosity
C                  PROPS(3) = YPLUS Y+
C                  PROPS(4) = YNORML
C SN             : Wall normals
C YNI            : Inverse distance to wall
C SRCW           : Wall normal dependent terms for Pressure-Strain
C
      include 'common.inc'
C
      DIMENSION Q     (NPTS,NQ),
     1          PROPS (NPTS,NP),
     2          SN    (NPTS,3),
     3          YNI   (NPTS)
C
      DIMENSION SRCW  (NPTS,6)
C
C     One-Thirds
C     Two-Thirds
C
      T13 = 1.E0 / 3.E0
      T23 = 2.E0 / 3.E0
C
C Calculate wall normal dependent Pressure-Strain Correlation
C
C 3. Lai-So Pressure Strain Correlation
C    NASA Contractor Report 4369 (Based on LRR1)
C    Corrected form based on Zhang, So, Gatski, Speziale in the
C    Near-Wall Turbulent Flows book later corrected from private communications
C    with Ron So.  Note that this is not strictly a pressure-strain model
C    but rather a model of pressure-strain and pressure-diffusion so that the
C    trace of the model is Non-Zero.
C    Modified based on private communication with Hou-Shun Zhang to include
C    the subtraction of the trace term from the S_ij term in the near-wall.
C
      IF (IPSMDL .EQ. IPLS) THEN
         DO 300 I = 1, NPTS
C
            RHO    = Q(I, 1)
            P      = Q(I, 5)
            TAUXX  = Q(I, 6)
            TAUYY  = Q(I, 7)
            TAUZZ  = Q(I, 8)
            TAUXY  = Q(I, 9)
            TAUXZ  = Q(I,10)
            TAUYZ  = Q(I,11)
            EPSLN  = Q(I,12)
C
            TKE    = 0.5E0 * (TAUXX + TAUYY + TAUZZ)
C
            RMU    = PROPS(I,1)
            YPLUS  = PROPS(I,3)
C
C     Wall damping
C
            RET    = RHO * TKE * TKE / (RMU * EPSLN) * RE / FSMACH
            FW1    = EXP( -(RET / 150.E0)**2 )
            IF (YPLUS .GT. 250.E0) FW1 = 0.E0
C
C     SRCW_ij = SRCW_ij + Phi_ij,w
C
            SRCW(I,1) = SRCW(I,1) - YNI(I) * FW1 * RHO * EPSLN / TKE * (
     1TAUXX*SN(I,1)*SN(I,1)+TAUXY*SN(I,2)*SN(I,1)+TAUXZ*SN(I,3)*SN(I,1)+
     2TAUXX*SN(I,1)*SN(I,1)+TAUXY*SN(I,2)*SN(I,1)+TAUXZ*SN(I,3)*SN(I,1))
C
            SRCW(I,2) = SRCW(I,2) - YNI(I) * FW1 * RHO * EPSLN / TKE * (
     1TAUXY*SN(I,1)*SN(I,2)+TAUYY*SN(I,2)*SN(I,2)+TAUYZ*SN(I,3)*SN(I,2)+
     2TAUXY*SN(I,1)*SN(I,2)+TAUYY*SN(I,2)*SN(I,2)+TAUYZ*SN(I,3)*SN(I,2))
C
            SRCW(I,3) = SRCW(I,3) - YNI(I) * FW1 * RHO * EPSLN / TKE * (
     1TAUXZ*SN(I,1)*SN(I,3)+TAUYZ*SN(I,2)*SN(I,3)+TAUZZ*SN(I,3)*SN(I,3)+
     2TAUXZ*SN(I,1)*SN(I,3)+TAUYZ*SN(I,2)*SN(I,3)+TAUZZ*SN(I,3)*SN(I,3))
C
            SRCW(I,4) = SRCW(I,4) - YNI(I) * FW1 * RHO * EPSLN / TKE * (
     1TAUXX*SN(I,1)*SN(I,2)+TAUXY*SN(I,2)*SN(I,2)+TAUXZ*SN(I,3)*SN(I,2)+
     2TAUXY*SN(I,1)*SN(I,1)+TAUYY*SN(I,2)*SN(I,1)+TAUYZ*SN(I,3)*SN(I,1))
C
            SRCW(I,5) = SRCW(I,5) - YNI(I) * FW1 * RHO * EPSLN / TKE * (
     1TAUXX*SN(I,1)*SN(I,3)+TAUXY*SN(I,2)*SN(I,3)+TAUXZ*SN(I,3)*SN(I,3)+
     2TAUXZ*SN(I,1)*SN(I,1)+TAUYZ*SN(I,2)*SN(I,1)+TAUZZ*SN(I,3)*SN(I,1))
C
            SRCW(I,6) = SRCW(I,6) - YNI(I) * FW1 * RHO * EPSLN / TKE * (
     1TAUXY*SN(I,1)*SN(I,3)+TAUYY*SN(I,2)*SN(I,3)+TAUYZ*SN(I,3)*SN(I,3)+
     2TAUXZ*SN(I,1)*SN(I,2)+TAUYZ*SN(I,2)*SN(I,2)+TAUZZ*SN(I,3)*SN(I,2))
C
  300    CONTINUE
C
      ENDIF
C
C Finished calculating wall surface normal dependent pressure-strain terms
      RETURN
      END
      SUBROUTINE RSDFEW (IEPSIJ, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ,
     1                   S, TAU, F)
C
C Routine to calculate the wall correction to the epsilon_ij tensor that
C depends on the diffusion term.  Modeled forms are:
C      1. So et al. (1995) model
C
C The flow variables, properties and derivatives of the flow variables are
C provided to this routine from which it calculates the diffusive contribution
C to epsilon_wall_ij.
C
C This routine is organized as follows:
C      1. Calculate epsilon_wall_ij
C         a. So et al. (1995)
C
C IEPSIJ         : Epsilon_wall_ij model
C NPTS           : Number of interfaces to calculate viscous fluxes
C QI             : Primitive variables at interfaces
C PROPSI         : Properties at the interfaces
C                  PROPSI(1) = RMU
C                  PROPSI(2) = RMUT
C                  PROPSI(3) = Y+
C                  PROPSI(4) = YNORML
C DQDX           : X-Derivative of primitive variables at the interface
C DQDY           : Y-Derivative of primitive variables at the interface
C DQDZ           : Z-Derivative of primitive variables at the interface
C S              : Metrics
C TAU            : Reynold's stresses
C F              : Viscous fluxes at cell interfaces
C
      include 'common.inc'
C
      DIMENSION QI    (NPTS,NQ),
     1          PROPSI(NPTS,NP),
     2          DQDX  (NPTS,NQ),
     3          DQDY  (NPTS,NQ),
     4          DQDZ  (NPTS,NQ),
     5          S     (NPTS,3),
     6          TAU   (NPTS,6),
     7          F     (NPTS,NF)
C
C     Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
C 1.   Calculate epsilon_wall_ij from So et al. 1995
C
      IF (IEPSIJ .EQ. IESO95) THEN
         DO 100 I = 1, NPTS
C
            RMU    = PROPSI(I,1)
C
C     VRS : Coefficient for diffusion term for epsilon_wall_ij
C           Multiply by 1/2 as the diffusion term for the wall correction
C           to epsilon_ij has a 1/2 in front.
C
            VRS    = 0.5E0 * RMU * FSMACH / RE
C
C     d(K)/d(x_k) : 1/2 here since k = 1/2 Tau_ii
C
            DKDXK  = 0.5E0 * T23 *
     1               ( S(I,1) * (DQDX(I,6) + DQDX(I,7) + DQDX(I,8))
     2               + S(I,2) * (DQDY(I,6) + DQDY(I,7) + DQDY(I,8))
     3               + S(I,3) * (DQDZ(I,6) + DQDZ(I,7) + DQDZ(I,8)) )
C
C      Calculate F(molecular diffusion)
C
            F(I, 6) = F(I, 6)
     1              + VRS * ( S(I,1)*DQDX(I, 6) + S(I,2)*DQDY(I, 6)
     2                      + S(I,3)*DQDZ(I, 6) - DKDXK )
            F(I, 7) = F(I, 7)
     1              + VRS * ( S(I,1)*DQDX(I, 7) + S(I,2)*DQDY(I, 7)
     2                      + S(I,3)*DQDZ(I, 7) - DKDXK )
            F(I, 8) = F(I, 8)
     1              + VRS * ( S(I,1)*DQDX(I, 8) + S(I,2)*DQDY(I, 8)
     2                      + S(I,3)*DQDZ(I, 8) - DKDXK )
            F(I, 9) = F(I, 9)
     1              + VRS * ( S(I,1)*DQDX(I, 9) + S(I,2)*DQDY(I, 9)
     2                      + S(I,3)*DQDZ(I, 9) )
            F(I,10) = F(I,10)
     1              + VRS * ( S(I,1)*DQDX(I,10) + S(I,2)*DQDY(I,10)
     2                      + S(I,3)*DQDZ(I,10) )
            F(I,11) = F(I,11)
     1              + VRS * ( S(I,1)*DQDX(I,11) + S(I,2)*DQDY(I,11)
     2                      + S(I,3)*DQDZ(I,11) )
  100    CONTINUE
C
C Error - Output error message and stop
C
      ELSE
         WRITE (IOUT,1000) IEPSIJ
         STOP
      ENDIF
C
C Finished with epsilon_wall_ij
      RETURN
 1000 FORMAT (' ','ERROR - RUN ABORTING',
     1       /' ','Invalid Epsilon_wall_ij in routine ',
     2            'RSDFEW  = ',I10)
      END
      SUBROUTINE RSMDIF (IDMMDL, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ,
     1                   S, TAU, F)
C
C Routine to calculate the Reynolds Stress equations' Molecular Diffusion.
C
C The flow variables, properties and derivatives of the flow variables are
C provided to this routine from which it calculates the viscous fluxes.
C
C This routine is organized as follows:
C      1. Calculate Molecular Diffusion for Reynolds Stresses
C         a. Simple form              => Ron So
C         b. Complex form             => Charles Speziale
C
C IDMMDL         : Reynolds stress Molecular diffusion model
C NPTS           : Number of interfaces to calculate viscous fluxes
C QI             : Primitive variables at interfaces
C PROPSI         : Properties at the interfaces
C                  PROPSI(1) = RMU
C                  PROPSI(2) = RMUT
C                  PROPSI(3) = Y+
C                  PROPSI(4) = YNORML
C DQDX           : X-Derivative of primitive variables at the interface
C DQDY           : Y-Derivative of primitive variables at the interface
C DQDZ           : Z-Derivative of primitive variables at the interface
C S              : Metrics
C TAU            : Reynold's stresses
C F              : Viscous fluxes at cell interfaces
C
      include 'common.inc'
C
      DIMENSION QI    (NPTS,NQ),
     1          PROPSI(NPTS,NP),
     2          DQDX  (NPTS,NQ),
     3          DQDY  (NPTS,NQ),
     4          DQDZ  (NPTS,NQ),
     5          S     (NPTS,3),
     6          TAU   (NPTS,6),
     7          F     (NPTS,NF)
C
C     Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
C 1.   Calculate Molecular Diffusion
C
C 1-a. Simple form (So et al.)
C
      IF (IDMMDL .EQ. IDMSO) THEN
         DO 100 I = 1, NPTS
C
            RMU    = PROPSI(I,1)
C
C     VRS : Coefficient for molecular diffusion in Tau_ij
C
            VRS    = RMU * FSMACH / RE
C
C      Calculate F(molecular diffusion)
C
           F(I,6) = F(I, 6)
     1            + VRS * ( S(I,1)*DQDX(I, 6) + S(I,2)*DQDY(I, 6)
     2                    + S(I,3)*DQDZ(I, 6) )
           F(I,7) = F(I, 7)
     1            + VRS * ( S(I,1)*DQDX(I, 7) + S(I,2)*DQDY(I, 7)
     2                    + S(I,3)*DQDZ(I, 7) )
           F(I,8) = F(I, 8)
     1            + VRS * ( S(I,1)*DQDX(I, 8) + S(I,2)*DQDY(I, 8)
     2                    + S(I,3)*DQDZ(I, 8) )
           F(I,9) = F(I, 9)
     1            + VRS * ( S(I,1)*DQDX(I, 9) + S(I,2)*DQDY(I, 9)
     2                    + S(I,3)*DQDZ(I, 9) )
           F(I,10)= F(I,10)
     1            + VRS * ( S(I,1)*DQDX(I,10) + S(I,2)*DQDY(I,10)
     2                    + S(I,3)*DQDZ(I,10) )
           F(I,11)= F(I,11)
     1            + VRS * ( S(I,1)*DQDX(I,11) + S(I,2)*DQDY(I,11)
     2                    + S(I,3)*DQDZ(I,11) )
  100    CONTINUE
C
C 1-b. Complex form (Speziale)
C
      ELSE IF (IDMMDL .EQ. IDMSPZ) THEN
         DO 200 I = 1, NPTS
C
            RMU    = PROPSI(I,1)
C
C      VRS : Coefficient for molecular diffusion in Tau_ij
C
            VRS    = RMU * FSMACH / RE
C
C      Calculate F(molecular diffusion)
C
           F(I,6) = F(I, 6)
     1            + VRS * ( S(I,1)*(DQDX(I, 6)+DQDX(I, 6)+DQDX(I, 6))
     2                    + S(I,2)*(DQDY(I, 6)+DQDX(I, 9)+DQDX(I, 9))
     3                    + S(I,3)*(DQDZ(I, 6)+DQDX(I,10)+DQDX(I,10)) )
           F(I,7) = F(I, 7)
     1            + VRS * ( S(I,1)*(DQDX(I, 7)+DQDY(I, 9)+DQDY(I, 9))
     2                    + S(I,2)*(DQDY(I, 7)+DQDY(I, 7)+DQDY(I, 7))
     3                    + S(I,3)*(DQDZ(I, 7)+DQDY(I,11)+DQDY(I,11)) )
           F(I,8) = F(I, 8)
     1            + VRS * ( S(I,1)*(DQDX(I, 8)+DQDZ(I,10)+DQDZ(I,10))
     2                    + S(I,2)*(DQDY(I, 8)+DQDZ(I,11)+DQDZ(I,11))
     3                    + S(I,3)*(DQDZ(I, 8)+DQDZ(I, 8)+DQDZ(I, 8)) )
           F(I,9) = F(I, 9)
     1            + VRS * ( S(I,1)*(DQDX(I, 9)+DQDY(I, 6)+DQDX(I, 9))
     2                    + S(I,2)*(DQDY(I, 9)+DQDY(I, 9)+DQDX(I, 7))
     3                    + S(I,3)*(DQDZ(I, 9)+DQDY(I,10)+DQDX(I,11)) )
           F(I,10)= F(I,10)
     1            + VRS * ( S(I,1)*(DQDX(I,10)+DQDZ(I, 6)+DQDX(I,10))
     2                    + S(I,2)*(DQDY(I,10)+DQDZ(I, 9)+DQDX(I,11))
     3                    + S(I,3)*(DQDZ(I,10)+DQDZ(I,10)+DQDX(I, 8)) )
           F(I,11)= F(I,11)
     1            + VRS * ( S(I,1)*(DQDX(I,11)+DQDZ(I, 9)+DQDY(I,10))
     2                    + S(I,2)*(DQDY(I,11)+DQDZ(I, 7)+DQDY(I,11))
     3                    + S(I,3)*(DQDZ(I,11)+DQDZ(I,11)+DQDY(I, 8)) )
  200    CONTINUE
C
C Error - Output error message and stop
C
      ELSE
         WRITE (IOUT,1000) IDMMDL
         STOP
      ENDIF
C
C Finished with Molecular Diffusion Terms
      RETURN
 1000 FORMAT (' ','ERROR - RUN ABORTING',
     1       /' ','Invalid Molecular diffusion model in routine ',
     2            'RSMDIF  = ',I10)
      END
      SUBROUTINE RSTDIF (IDTMDL, NPTS, QI, PROPSI, DQDX, DQDY, DQDZ,
     1                   S, TAU, F)
C
C Routine to calculate the Reynolds Stress equations' TURBULENT Diffusion.
C
C The flow variables, properties and derivatives of the flow variables are
C provided to this routine from which it calculates the viscous fluxes.
C
C This routine is organized as follows:
C      1. Calculate TURBULENT Diffusion for Reynolds Stresses
C         a. DH         => Daly and Harlow
C         b. HL72       => Hanjalic and Launder (1972)
C         c. MH73       => Mellor and Herring (1973)
C
C IDTMDL         : Reynolds stress Turbulent diffusion model
C NPTS           : Number of interfaces to calculate viscous fluxes
C QI             : Primitive variables at interfaces
C PROPSI         : Properties at the interfaces
C                  PROPSI(1) = RMU
C                  PROPSI(2) = RMUT
C                  PROPSI(3) = Y+
C                  PROPSI(4) = YNORML
C DQDX           : X-Derivative of primitive variables at the interface
C DQDY           : Y-Derivative of primitive variables at the interface
C DQDZ           : Z-Derivative of primitive variables at the interface
C S              : Metrics
C TAU            : Reynold's stresses
C F              : Viscous fluxes at cell interfaces
C
      include 'common.inc'
C
      DIMENSION QI    (NPTS,NQ),
     1          PROPSI(NPTS,NP),
     2          DQDX  (NPTS,NQ),
     3          DQDY  (NPTS,NQ),
     4          DQDZ  (NPTS,NQ),
     5          S     (NPTS,3),
     6          TAU   (NPTS,6),
     7          F     (NPTS,NF)
C
C     Two-Thirds
C
      T23 = 2.E0 / 3.E0
C
C 1.   Calculate Turbulent Diffusion
C
C 1-a. Daly-Harlow
C
      IF (IDTMDL .EQ. IDTDH) THEN
         DO 100 I = 1, NPTS
C
            RHO    = QI(I,1)
            TKE    = 0.5E0 * (QI(I,6) + QI(I,7) + QI(I,8))
            EPSLN  = QI(I,12)
C
C      VDT : Coefficient for turbulent diffusion (DT_ij) in Tau_ij
C
            VDT    = CSUBS * RHO * TKE / EPSLN
C
C      Calculate F(Turbulent diffusion)
C
           F(I, 6) = F(I, 6) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 6)+QI(I, 9)*DQDY(I, 6)+QI(I,10)*DQDZ(I, 6))
     3 + S(I,2)*
     4   (QI(I, 9)*DQDX(I, 6)+QI(I, 7)*DQDY(I, 6)+QI(I,11)*DQDZ(I, 6))
     5 + S(I,3)*
     6   (QI(I,10)*DQDX(I, 6)+QI(I,11)*DQDY(I, 6)+QI(I, 8)*DQDZ(I, 6)) )
C
           F(I, 7) = F(I, 7) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 7)+QI(I, 9)*DQDY(I, 7)+QI(I,10)*DQDZ(I, 7))
     3 + S(I,2)*
     4   (QI(I, 9)*DQDX(I, 7)+QI(I, 7)*DQDY(I, 7)+QI(I,11)*DQDZ(I, 7))
     5 + S(I,3)*
     6   (QI(I,10)*DQDX(I, 7)+QI(I,11)*DQDY(I, 7)+QI(I, 8)*DQDZ(I, 7)) )
C
           F(I, 8) = F(I, 8) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 8)+QI(I, 9)*DQDY(I, 8)+QI(I,10)*DQDZ(I, 8))
     3 + S(I,2)*
     4   (QI(I, 9)*DQDX(I, 8)+QI(I, 7)*DQDY(I, 8)+QI(I,11)*DQDZ(I, 8))
     5 + S(I,3)*
     6   (QI(I,10)*DQDX(I, 8)+QI(I,11)*DQDY(I, 8)+QI(I, 8)*DQDZ(I, 8)) )
C
           F(I, 9) = F(I, 9) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 9)+QI(I, 9)*DQDY(I, 9)+QI(I,10)*DQDZ(I, 9))
     3 + S(I,2)*
     4   (QI(I, 9)*DQDX(I, 9)+QI(I, 7)*DQDY(I, 9)+QI(I,11)*DQDZ(I, 9))
     5 + S(I,3)*
     6   (QI(I,10)*DQDX(I, 9)+QI(I,11)*DQDY(I, 9)+QI(I, 8)*DQDZ(I, 9)) )
C
           F(I,10) = F(I,10) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I,10)+QI(I, 9)*DQDY(I,10)+QI(I,10)*DQDZ(I,10))
     3 + S(I,2)*
     4   (QI(I, 9)*DQDX(I,10)+QI(I, 7)*DQDY(I,10)+QI(I,11)*DQDZ(I,10))
     5 + S(I,3)*
     6   (QI(I,10)*DQDX(I,10)+QI(I,11)*DQDY(I,10)+QI(I, 8)*DQDZ(I,10)) )
C
           F(I,11) = F(I,11) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I,11)+QI(I, 9)*DQDY(I,11)+QI(I,10)*DQDZ(I,11))
     3 + S(I,2)*
     4   (QI(I, 9)*DQDX(I,11)+QI(I, 7)*DQDY(I,11)+QI(I,11)*DQDZ(I,11))
     5 + S(I,3)*
     6   (QI(I,10)*DQDX(I,11)+QI(I,11)*DQDY(I,11)+QI(I, 8)*DQDZ(I,11)) )
  100    CONTINUE
C
C 1-b. HL72 - Hanjalic and Launder (1972)
C
      ELSE IF (IDTMDL .EQ. IDTHL) THEN
         DO 200 I = 1, NPTS
C
            RHO    = QI(I,1)
            TKE    = 0.5E0 * (QI(I,6) + QI(I,7) + QI(I,8))
            EPSLN  = QI(I,12)
C
C      VDT : Coefficient for turbulent diffusion (DT_ij) in Tau_ij
C
            VDT    = CSUBS * RHO * TKE / EPSLN
C
C      Calculate F(Turbulent diffusion)
C
           F(I,6) = F(I, 6) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 6)+QI(I, 9)*DQDY(I, 6)+QI(I,10)*DQDZ(I, 6)+
     3    QI(I, 6)*DQDX(I, 6)+QI(I, 9)*DQDY(I, 6)+QI(I,10)*DQDZ(I, 6)+
     4    QI(I, 6)*DQDX(I, 6)+QI(I, 9)*DQDY(I, 6)+QI(I,10)*DQDZ(I, 6))
     5 + S(I,2)*
     6   (QI(I, 9)*DQDX(I, 6)+QI(I, 7)*DQDY(I, 6)+QI(I,11)*DQDZ(I, 6)+
     7    QI(I, 6)*DQDX(I, 9)+QI(I, 9)*DQDY(I, 9)+QI(I,10)*DQDZ(I, 9)+
     8    QI(I, 6)*DQDX(I, 9)+QI(I, 9)*DQDY(I, 9)+QI(I,10)*DQDZ(I, 9))
     9 + S(I,3)*
     A   (QI(I,10)*DQDX(I, 6)+QI(I,11)*DQDY(I, 6)+QI(I, 8)*DQDZ(I, 6)+
     B    QI(I, 6)*DQDX(I,10)+QI(I, 9)*DQDY(I,10)+QI(I,10)*DQDZ(I,10)+
     C    QI(I, 6)*DQDX(I,10)+QI(I, 9)*DQDY(I,10)+QI(I,10)*DQDZ(I,10)) )
C
           F(I,7) = F(I, 7) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 7)+QI(I, 9)*DQDY(I, 7)+QI(I,10)*DQDZ(I, 7)+
     3    QI(I, 9)*DQDX(I, 9)+QI(I, 7)*DQDY(I, 9)+QI(I,11)*DQDZ(I, 9)+
     4    QI(I, 9)*DQDX(I, 9)+QI(I, 7)*DQDY(I, 9)+QI(I,11)*DQDZ(I, 9))
     5 + S(I,2)*
     6   (QI(I, 9)*DQDX(I, 7)+QI(I, 7)*DQDY(I, 7)+QI(I,11)*DQDZ(I, 7)+
     7    QI(I, 9)*DQDX(I, 7)+QI(I, 7)*DQDY(I, 7)+QI(I,11)*DQDZ(I, 7)+
     8    QI(I, 9)*DQDX(I, 7)+QI(I, 7)*DQDY(I, 7)+QI(I,11)*DQDZ(I, 7))
     9 + S(I,3)*
     A   (QI(I,10)*DQDX(I, 7)+QI(I,11)*DQDY(I, 7)+QI(I, 8)*DQDZ(I, 7)+
     B    QI(I, 9)*DQDX(I,11)+QI(I, 7)*DQDY(I,11)+QI(I,11)*DQDZ(I,11)+
     C    QI(I, 9)*DQDX(I,11)+QI(I, 7)*DQDY(I,11)+QI(I,11)*DQDZ(I,11)) )
C
           F(I,8) = F(I, 8) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 8)+QI(I, 9)*DQDY(I, 8)+QI(I,10)*DQDZ(I, 8)+
     3    QI(I,10)*DQDX(I,10)+QI(I,11)*DQDY(I,10)+QI(I, 8)*DQDZ(I,10)+
     4    QI(I,10)*DQDX(I,10)+QI(I,11)*DQDY(I,10)+QI(I, 8)*DQDZ(I,10))
     5 + S(I,2)*
     6   (QI(I, 9)*DQDX(I, 8)+QI(I, 7)*DQDY(I, 8)+QI(I,11)*DQDZ(I, 8)+
     7    QI(I,10)*DQDX(I,11)+QI(I,11)*DQDY(I,11)+QI(I, 8)*DQDZ(I,11)+
     8    QI(I,10)*DQDX(I,11)+QI(I,11)*DQDY(I,11)+QI(I, 8)*DQDZ(I,11))
     9 + S(I,3)*
     A   (QI(I,10)*DQDX(I, 8)+QI(I,11)*DQDY(I, 8)+QI(I, 8)*DQDZ(I, 8)+
     B    QI(I,10)*DQDX(I, 8)+QI(I,11)*DQDY(I, 8)+QI(I, 8)*DQDZ(I, 8)+
     C    QI(I,10)*DQDX(I, 8)+QI(I,11)*DQDY(I, 8)+QI(I, 8)*DQDZ(I, 8)) )
C
           F(I,9) = F(I, 9) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I, 9)+QI(I, 9)*DQDY(I, 9)+QI(I,10)*DQDZ(I, 9)+
     3    QI(I, 9)*DQDX(I, 6)+QI(I, 7)*DQDY(I, 6)+QI(I,11)*DQDZ(I, 6)+
     4    QI(I, 6)*DQDX(I, 9)+QI(I, 9)*DQDY(I, 9)+QI(I,10)*DQDZ(I, 9))
     5 + S(I,2)*
     6   (QI(I, 9)*DQDX(I, 9)+QI(I, 7)*DQDY(I, 9)+QI(I,11)*DQDZ(I, 9)+
     7    QI(I, 9)*DQDX(I, 9)+QI(I, 7)*DQDY(I, 9)+QI(I,11)*DQDZ(I, 9)+
     8    QI(I, 6)*DQDX(I, 7)+QI(I, 9)*DQDY(I, 7)+QI(I,10)*DQDZ(I, 7))
     9 + S(I,3)*
     A   (QI(I,10)*DQDX(I, 9)+QI(I,11)*DQDY(I, 9)+QI(I, 8)*DQDZ(I, 9)+
     B    QI(I, 9)*DQDX(I,10)+QI(I, 7)*DQDY(I,10)+QI(I,11)*DQDZ(I,10)+
     C    QI(I, 6)*DQDX(I,11)+QI(I, 9)*DQDY(I,11)+QI(I,10)*DQDZ(I,11)) )
C
           F(I,10)= F(I,10) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I,10)+QI(I, 9)*DQDY(I,10)+QI(I,10)*DQDZ(I,10)+
     3    QI(I,10)*DQDX(I, 6)+QI(I,11)*DQDY(I, 6)+QI(I, 8)*DQDZ(I, 6)+
     4    QI(I, 6)*DQDX(I,10)+QI(I, 9)*DQDY(I,10)+QI(I,10)*DQDZ(I,10))
     5 + S(I,2)*
     6   (QI(I, 9)*DQDX(I,10)+QI(I, 7)*DQDY(I,10)+QI(I,11)*DQDZ(I,10)+
     7    QI(I,10)*DQDX(I, 9)+QI(I,11)*DQDY(I, 9)+QI(I, 8)*DQDZ(I, 9)+
     8    QI(I, 6)*DQDX(I,11)+QI(I, 9)*DQDY(I,11)+QI(I,10)*DQDZ(I,11))
     9 + S(I,3)*
     A   (QI(I,10)*DQDX(I,10)+QI(I,11)*DQDY(I,10)+QI(I, 8)*DQDZ(I,10)+
     B    QI(I,10)*DQDX(I,10)+QI(I,11)*DQDY(I,10)+QI(I, 8)*DQDZ(I,10)+
     C    QI(I, 6)*DQDX(I, 8)+QI(I, 9)*DQDY(I, 8)+QI(I,10)*DQDZ(I, 8)) )
C
           F(I,11)= F(I,11) + VDT *
     1 ( S(I,1)*
     2   (QI(I, 6)*DQDX(I,11)+QI(I, 9)*DQDY(I,11)+QI(I,10)*DQDZ(I,11)+
     3    QI(I,10)*DQDX(I, 9)+QI(I,11)*DQDY(I, 9)+QI(I, 8)*DQDZ(I, 9)+
     4    QI(I, 9)*DQDX(I,10)+QI(I, 7)*DQDY(I,10)+QI(I,11)*DQDZ(I,10))
     5 + S(I,2)*
     6   (QI(I, 9)*DQDX(I,11)+QI(I, 7)*DQDY(I,11)+QI(I,11)*DQDZ(I,11)+
     7    QI(I,10)*DQDX(I, 7)+QI(I,11)*DQDY(I, 7)+QI(I, 8)*DQDZ(I, 7)+
     8    QI(I, 9)*DQDX(I,11)+QI(I, 7)*DQDY(I,11)+QI(I,11)*DQDZ(I,11))
     9 + S(I,3)*
     A   (QI(I,10)*DQDX(I,11)+QI(I,11)*DQDY(I,11)+QI(I, 8)*DQDZ(I,11)+
     B    QI(I,10)*DQDX(I,11)+QI(I,11)*DQDY(I,11)+QI(I, 8)*DQDZ(I,11)+
     C    QI(I, 9)*DQDX(I, 8)+QI(I, 7)*DQDY(I, 8)+QI(I,11)*DQDZ(I, 8)) )
  200    CONTINUE
C
C 1-c. Mellor and Herring (AIAA Journal, 1973, Vol. 11, pp. 590-599)
C      also recommended by Speziale as 'Isotropized' form
C
      ELSE IF (IDTMDL .EQ. IDTMH) THEN
         DO 300 I = 1, NPTS
C
            RHO    = QI(I,1)
            TKE    = 0.5E0 * (QI(I,6) + QI(I,7) + QI(I,8))
            EPSLN  = QI(I,12)
C
C      VRS : Coefficient for turbulent diffusion in Tau_ij
C
            VRS    = CSUBS * RHO * TKE * TKE / EPSLN
C
C      Calculate F(Turbulent diffusion)
C
           F(I,6) = F(I, 6)
     1            + VRS * ( S(I,1)*(DQDX(I, 6)+DQDX(I, 6)+DQDX(I, 6))
     2                    + S(I,2)*(DQDY(I, 6)+DQDX(I, 9)+DQDX(I, 9))
     3                    + S(I,3)*(DQDZ(I, 6)+DQDX(I,10)+DQDX(I,10)) )
           F(I,7) = F(I, 7)
     1            + VRS * ( S(I,1)*(DQDX(I, 7)+DQDY(I, 9)+DQDY(I, 9))
     2                    + S(I,2)*(DQDY(I, 7)+DQDY(I, 7)+DQDY(I, 7))
     3                    + S(I,3)*(DQDZ(I, 7)+DQDY(I,11)+DQDY(I,11)) )
           F(I,8) = F(I, 8)
     1            + VRS * ( S(I,1)*(DQDX(I, 8)+DQDZ(I,10)+DQDZ(I,10))
     2                    + S(I,2)*(DQDY(I, 8)+DQDZ(I,11)+DQDZ(I,11))
     3                    + S(I,3)*(DQDZ(I, 8)+DQDZ(I, 8)+DQDZ(I, 8)) )
           F(I,9) = F(I, 9)
     1            + VRS * ( S(I,1)*(DQDX(I, 9)+DQDY(I, 6)+DQDX(I, 9))
     2                    + S(I,2)*(DQDY(I, 9)+DQDY(I, 9)+DQDX(I, 7))
     3                    + S(I,3)*(DQDZ(I, 9)+DQDY(I,10)+DQDX(I,11)) )
           F(I,10)= F(I,10)
     1            + VRS * ( S(I,1)*(DQDX(I,10)+DQDZ(I, 6)+DQDX(I,10))
     2                    + S(I,2)*(DQDY(I,10)+DQDZ(I, 9)+DQDX(I,11))
     3                    + S(I,3)*(DQDZ(I,10)+DQDZ(I,10)+DQDX(I, 8)) )
           F(I,11)= F(I,11)
     1            + VRS * ( S(I,1)*(DQDX(I,11)+DQDZ(I, 9)+DQDY(I,10))
     2                    + S(I,2)*(DQDY(I,11)+DQDZ(I, 7)+DQDY(I,11))
     3                    + S(I,3)*(DQDZ(I,11)+DQDZ(I,11)+DQDY(I, 8)) )
  300    CONTINUE
C
C Error - Output error message and stop
C
      ELSE
         WRITE (IOUT,1000) IDTMDL
         STOP
      ENDIF
C
C Finished with Turbulent Diffusion Terms
      RETURN
 1000 FORMAT (' ','ERROR - RUN ABORTING',
     1       /' ','Invalid Turbulent diffusion model in routine ',
     2            'RSTDIF  = ',I10)
      END
      SUBROUTINE REALIZ (ITURB, IDIM, JDIM, KDIM, IPSTRT, IPEND, Q,
     1                   NRELIZ)
C
C Routine to apply realizability to the Reynolds stresses based on
C Schwartz's inequality (see Lumley and Panofsky, The Structure of
C Atmospheric Turbulence).
C
C This routine is organized as follows
C     1. Schwartz's inequality for Tau_xy
C        a. Calculate magnitude of shear stress from Schwartz's inequality
C        b. Replace magnitude of shear stress if it exceeds above value
C        c. Output statistics
C     2. If 3D calculation then, Schwartz's inequality for Tau_xz and Tau_yz
C        a. Calculate magnitude of shear stress from Schwartz's inequality
C        b. Replace magnitude of shear stress if it exceeds above value
C        c. Output statistics
C
C ITURB          : Turbulence model
C IDIM,JDIM,KDIM : Dimensions of current block
C IPSTRT         : I Plane (cell center) to start calculations at
C                  (Minimum Value: 2)
C IPEND          : I Plane (cell center) to end caclulations at
C                  (Maximum Value: IDIM)
C Q              : Primitive variables at cell centers
C NRELIZ         : Number of times violate realizability
C
      include 'common.inc'
C
      DIMENSION Q     (0:JDIM+2,0:KDIM+2,0:IDIM+2,NQ)
C
      DIMENSION NRELIZ(NQ)
C
C 1.   Schwartz's inequality for Tau_xy
C 1-a. Calculate magnitude of shear stress from Schwartz's inequality
C 1-b. Replace magnitude of shear stress if it exceeds above value
C
      DO 130 I = IPSTRT, IPEND
         DO 120 K = 2, KDIM
            DO 110 J = 2, JDIM
               TESTXY = SQRT (Q(J,K,I,6) * Q(J,K,I,7))
               IF (ABS(Q(J,K,I,9)) .GT. TESTXY) THEN
                  NRELIZ( 9) = NRELIZ( 9) + 1
                  Q(J,K,I,9) = SIGN (TESTXY, Q(J,K,I,9))
               ENDIF
  110       CONTINUE
  120    CONTINUE
  130 CONTINUE
C
C 2.   If 3D calculation then, Schwartz's inequality for Tau_xz and Tau_yz
C 2-a. Calculate magnitude of shear stress from Schwartz's inequality
C 2-b. Replace magnitude of shear stress if it exceeds above value
C
      IF (THREED) THEN
         DO 230 I = IPSTRT, IPEND
            DO 220 K = 2, KDIM
               DO 210 J = 2, JDIM
                  TESTXZ = SQRT (Q(J,K,I,6) * Q(J,K,I,8))
                  IF (ABS(Q(J,K,I,10)) .GT. TESTXZ) THEN
                     NRELIZ(10)  = NRELIZ(10) + 1
                     Q(J,K,I,10) = SIGN (TESTXZ, Q(J,K,I,10))
                  ENDIF
C
                  TESTYZ = SQRT (Q(J,K,I,7) * Q(J,K,I,8))
                  IF (ABS(Q(J,K,I,11)) .GT. TESTYZ) THEN
                     NRELIZ(11)  = NRELIZ(11) + 1
                     Q(J,K,I,11) = SIGN (TESTYZ, Q(J,K,I,11))
                  ENDIF
  210          CONTINUE
  220       CONTINUE
  230    CONTINUE
      ENDIF
C
C Finished with Realizability constraints
      RETURN
      END
